var xT = Object.defineProperty;
var CT = (t, e, r) => (e in t ? xT(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (t[e] = r));
var ko = (t, e, r) => (CT(t, typeof e != 'symbol' ? e + '' : e, r), r);
(function () {
  const e = document.createElement('link').relList;
  if (e && e.supports && e.supports('modulepreload')) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === 'childList')
        for (const o of s.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && n(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function r(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : i.crossOrigin === 'anonymous'
        ? (s.credentials = 'omit')
        : (s.credentials = 'same-origin'),
      s
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = r(i);
    fetch(i.href, s);
  }
})();
var dg =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {};
function mg(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t;
}
var XC = { exports: {} };
(function (t, e) {
  (function (r, n) {
    t.exports = n();
  })(dg, function () {
    var r = 1e3,
      n = 6e4,
      i = 36e5,
      s = 'millisecond',
      o = 'second',
      l = 'minute',
      c = 'hour',
      p = 'day',
      f = 'week',
      m = 'month',
      g = 'quarter',
      x = 'year',
      b = 'date',
      F = 'Invalid Date',
      E = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      w = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      I = {
        name: 'en',
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        ordinal: function (re) {
          var ie = ['th', 'st', 'nd', 'rd'],
            Q = re % 100;
          return '[' + re + (ie[(Q - 20) % 10] || ie[Q] || ie[0]) + ']';
        },
      },
      T = function (re, ie, Q) {
        var ce = String(re);
        return !ce || ce.length >= ie ? re : '' + Array(ie + 1 - ce.length).join(Q) + re;
      },
      j = {
        s: T,
        z: function (re) {
          var ie = -re.utcOffset(),
            Q = Math.abs(ie),
            ce = Math.floor(Q / 60),
            G = Q % 60;
          return (ie <= 0 ? '+' : '-') + T(ce, 2, '0') + ':' + T(G, 2, '0');
        },
        m: function re(ie, Q) {
          if (ie.date() < Q.date()) return -re(Q, ie);
          var ce = 12 * (Q.year() - ie.year()) + (Q.month() - ie.month()),
            G = ie.clone().add(ce, m),
            ge = Q - G < 0,
            we = ie.clone().add(ce + (ge ? -1 : 1), m);
          return +(-(ce + (Q - G) / (ge ? G - we : we - G)) || 0);
        },
        a: function (re) {
          return re < 0 ? Math.ceil(re) || 0 : Math.floor(re);
        },
        p: function (re) {
          return (
            { M: m, y: x, w: f, d: p, D: b, h: c, m: l, s: o, ms: s, Q: g }[re] ||
            String(re || '')
              .toLowerCase()
              .replace(/s$/, '')
          );
        },
        u: function (re) {
          return re === void 0;
        },
      },
      $ = 'en',
      L = {};
    L[$] = I;
    var se = '$isDayjsObject',
      Y = function (re) {
        return re instanceof xe || !(!re || !re[se]);
      },
      W = function re(ie, Q, ce) {
        var G;
        if (!ie) return $;
        if (typeof ie == 'string') {
          var ge = ie.toLowerCase();
          L[ge] && (G = ge), Q && ((L[ge] = Q), (G = ge));
          var we = ie.split('-');
          if (!G && we.length > 1) return re(we[0]);
        } else {
          var je = ie.name;
          (L[je] = ie), (G = je);
        }
        return !ce && G && ($ = G), G || (!ce && $);
      },
      X = function (re, ie) {
        if (Y(re)) return re.clone();
        var Q = typeof ie == 'object' ? ie : {};
        return (Q.date = re), (Q.args = arguments), new xe(Q);
      },
      q = j;
    (q.l = W),
      (q.i = Y),
      (q.w = function (re, ie) {
        return X(re, { locale: ie.$L, utc: ie.$u, x: ie.$x, $offset: ie.$offset });
      });
    var xe = (function () {
        function re(Q) {
          (this.$L = W(Q.locale, null, !0)), this.parse(Q), (this.$x = this.$x || Q.x || {}), (this[se] = !0);
        }
        var ie = re.prototype;
        return (
          (ie.parse = function (Q) {
            (this.$d = (function (ce) {
              var G = ce.date,
                ge = ce.utc;
              if (G === null) return new Date(NaN);
              if (q.u(G)) return new Date();
              if (G instanceof Date) return new Date(G);
              if (typeof G == 'string' && !/Z$/i.test(G)) {
                var we = G.match(E);
                if (we) {
                  var je = we[2] - 1 || 0,
                    Qe = (we[7] || '0').substring(0, 3);
                  return ge
                    ? new Date(Date.UTC(we[1], je, we[3] || 1, we[4] || 0, we[5] || 0, we[6] || 0, Qe))
                    : new Date(we[1], je, we[3] || 1, we[4] || 0, we[5] || 0, we[6] || 0, Qe);
                }
              }
              return new Date(G);
            })(Q)),
              this.init();
          }),
          (ie.init = function () {
            var Q = this.$d;
            (this.$y = Q.getFullYear()),
              (this.$M = Q.getMonth()),
              (this.$D = Q.getDate()),
              (this.$W = Q.getDay()),
              (this.$H = Q.getHours()),
              (this.$m = Q.getMinutes()),
              (this.$s = Q.getSeconds()),
              (this.$ms = Q.getMilliseconds());
          }),
          (ie.$utils = function () {
            return q;
          }),
          (ie.isValid = function () {
            return this.$d.toString() !== F;
          }),
          (ie.isSame = function (Q, ce) {
            var G = X(Q);
            return this.startOf(ce) <= G && G <= this.endOf(ce);
          }),
          (ie.isAfter = function (Q, ce) {
            return X(Q) < this.startOf(ce);
          }),
          (ie.isBefore = function (Q, ce) {
            return this.endOf(ce) < X(Q);
          }),
          (ie.$g = function (Q, ce, G) {
            return q.u(Q) ? this[ce] : this.set(G, Q);
          }),
          (ie.unix = function () {
            return Math.floor(this.valueOf() / 1e3);
          }),
          (ie.valueOf = function () {
            return this.$d.getTime();
          }),
          (ie.startOf = function (Q, ce) {
            var G = this,
              ge = !!q.u(ce) || ce,
              we = q.p(Q),
              je = function (Te, fe) {
                var at = q.w(G.$u ? Date.UTC(G.$y, fe, Te) : new Date(G.$y, fe, Te), G);
                return ge ? at : at.endOf(p);
              },
              Qe = function (Te, fe) {
                return q.w(G.toDate()[Te].apply(G.toDate('s'), (ge ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(fe)), G);
              },
              ot = this.$W,
              pt = this.$M,
              gt = this.$D,
              yt = 'set' + (this.$u ? 'UTC' : '');
            switch (we) {
              case x:
                return ge ? je(1, 0) : je(31, 11);
              case m:
                return ge ? je(1, pt) : je(0, pt + 1);
              case f:
                var U = this.$locale().weekStart || 0,
                  he = (ot < U ? ot + 7 : ot) - U;
                return je(ge ? gt - he : gt + (6 - he), pt);
              case p:
              case b:
                return Qe(yt + 'Hours', 0);
              case c:
                return Qe(yt + 'Minutes', 1);
              case l:
                return Qe(yt + 'Seconds', 2);
              case o:
                return Qe(yt + 'Milliseconds', 3);
              default:
                return this.clone();
            }
          }),
          (ie.endOf = function (Q) {
            return this.startOf(Q, !1);
          }),
          (ie.$set = function (Q, ce) {
            var G,
              ge = q.p(Q),
              we = 'set' + (this.$u ? 'UTC' : ''),
              je = ((G = {}),
              (G[p] = we + 'Date'),
              (G[b] = we + 'Date'),
              (G[m] = we + 'Month'),
              (G[x] = we + 'FullYear'),
              (G[c] = we + 'Hours'),
              (G[l] = we + 'Minutes'),
              (G[o] = we + 'Seconds'),
              (G[s] = we + 'Milliseconds'),
              G)[ge],
              Qe = ge === p ? this.$D + (ce - this.$W) : ce;
            if (ge === m || ge === x) {
              var ot = this.clone().set(b, 1);
              ot.$d[je](Qe), ot.init(), (this.$d = ot.set(b, Math.min(this.$D, ot.daysInMonth())).$d);
            } else je && this.$d[je](Qe);
            return this.init(), this;
          }),
          (ie.set = function (Q, ce) {
            return this.clone().$set(Q, ce);
          }),
          (ie.get = function (Q) {
            return this[q.p(Q)]();
          }),
          (ie.add = function (Q, ce) {
            var G,
              ge = this;
            Q = Number(Q);
            var we = q.p(ce),
              je = function (pt) {
                var gt = X(ge);
                return q.w(gt.date(gt.date() + Math.round(pt * Q)), ge);
              };
            if (we === m) return this.set(m, this.$M + Q);
            if (we === x) return this.set(x, this.$y + Q);
            if (we === p) return je(1);
            if (we === f) return je(7);
            var Qe = ((G = {}), (G[l] = n), (G[c] = i), (G[o] = r), G)[we] || 1,
              ot = this.$d.getTime() + Q * Qe;
            return q.w(ot, this);
          }),
          (ie.subtract = function (Q, ce) {
            return this.add(-1 * Q, ce);
          }),
          (ie.format = function (Q) {
            var ce = this,
              G = this.$locale();
            if (!this.isValid()) return G.invalidDate || F;
            var ge = Q || 'YYYY-MM-DDTHH:mm:ssZ',
              we = q.z(this),
              je = this.$H,
              Qe = this.$m,
              ot = this.$M,
              pt = G.weekdays,
              gt = G.months,
              yt = G.meridiem,
              U = function (fe, at, M, V) {
                return (fe && (fe[at] || fe(ce, ge))) || M[at].slice(0, V);
              },
              he = function (fe) {
                return q.s(je % 12 || 12, fe, '0');
              },
              Te =
                yt ||
                function (fe, at, M) {
                  var V = fe < 12 ? 'AM' : 'PM';
                  return M ? V.toLowerCase() : V;
                };
            return ge.replace(w, function (fe, at) {
              return (
                at ||
                (function (M) {
                  switch (M) {
                    case 'YY':
                      return String(ce.$y).slice(-2);
                    case 'YYYY':
                      return q.s(ce.$y, 4, '0');
                    case 'M':
                      return ot + 1;
                    case 'MM':
                      return q.s(ot + 1, 2, '0');
                    case 'MMM':
                      return U(G.monthsShort, ot, gt, 3);
                    case 'MMMM':
                      return U(gt, ot);
                    case 'D':
                      return ce.$D;
                    case 'DD':
                      return q.s(ce.$D, 2, '0');
                    case 'd':
                      return String(ce.$W);
                    case 'dd':
                      return U(G.weekdaysMin, ce.$W, pt, 2);
                    case 'ddd':
                      return U(G.weekdaysShort, ce.$W, pt, 3);
                    case 'dddd':
                      return pt[ce.$W];
                    case 'H':
                      return String(je);
                    case 'HH':
                      return q.s(je, 2, '0');
                    case 'h':
                      return he(1);
                    case 'hh':
                      return he(2);
                    case 'a':
                      return Te(je, Qe, !0);
                    case 'A':
                      return Te(je, Qe, !1);
                    case 'm':
                      return String(Qe);
                    case 'mm':
                      return q.s(Qe, 2, '0');
                    case 's':
                      return String(ce.$s);
                    case 'ss':
                      return q.s(ce.$s, 2, '0');
                    case 'SSS':
                      return q.s(ce.$ms, 3, '0');
                    case 'Z':
                      return we;
                  }
                  return null;
                })(fe) ||
                we.replace(':', '')
              );
            });
          }),
          (ie.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }),
          (ie.diff = function (Q, ce, G) {
            var ge,
              we = this,
              je = q.p(ce),
              Qe = X(Q),
              ot = (Qe.utcOffset() - this.utcOffset()) * n,
              pt = this - Qe,
              gt = function () {
                return q.m(we, Qe);
              };
            switch (je) {
              case x:
                ge = gt() / 12;
                break;
              case m:
                ge = gt();
                break;
              case g:
                ge = gt() / 3;
                break;
              case f:
                ge = (pt - ot) / 6048e5;
                break;
              case p:
                ge = (pt - ot) / 864e5;
                break;
              case c:
                ge = pt / i;
                break;
              case l:
                ge = pt / n;
                break;
              case o:
                ge = pt / r;
                break;
              default:
                ge = pt;
            }
            return G ? ge : q.a(ge);
          }),
          (ie.daysInMonth = function () {
            return this.endOf(m).$D;
          }),
          (ie.$locale = function () {
            return L[this.$L];
          }),
          (ie.locale = function (Q, ce) {
            if (!Q) return this.$L;
            var G = this.clone(),
              ge = W(Q, ce, !0);
            return ge && (G.$L = ge), G;
          }),
          (ie.clone = function () {
            return q.w(this.$d, this);
          }),
          (ie.toDate = function () {
            return new Date(this.valueOf());
          }),
          (ie.toJSON = function () {
            return this.isValid() ? this.toISOString() : null;
          }),
          (ie.toISOString = function () {
            return this.$d.toISOString();
          }),
          (ie.toString = function () {
            return this.$d.toUTCString();
          }),
          re
        );
      })(),
      Re = xe.prototype;
    return (
      (X.prototype = Re),
      [
        ['$ms', s],
        ['$s', o],
        ['$m', l],
        ['$H', c],
        ['$W', p],
        ['$M', m],
        ['$y', x],
        ['$D', b],
      ].forEach(function (re) {
        Re[re[1]] = function (ie) {
          return this.$g(ie, re[0], re[1]);
        };
      }),
      (X.extend = function (re, ie) {
        return re.$i || (re(ie, xe, X), (re.$i = !0)), X;
      }),
      (X.locale = W),
      (X.isDayjs = Y),
      (X.unix = function (re) {
        return X(1e3 * re);
      }),
      (X.en = L[$]),
      (X.Ls = L),
      (X.p = {}),
      X
    );
  });
})(XC);
var GC = XC.exports;
const YC = mg(GC);
var bT = { exports: {} };
(function (t, e) {
  (function (r, n) {
    t.exports = n(GC);
  })(dg, function (r) {
    function n(o) {
      return o && typeof o == 'object' && 'default' in o ? o : { default: o };
    }
    var i = n(r),
      s = {
        name: 'zh-cn',
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        ordinal: function (o, l) {
          return l === 'W' ? o + '周' : o + '日';
        },
        weekStart: 1,
        yearStart: 4,
        formats: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY年M月D日',
          LLL: 'YYYY年M月D日Ah点mm分',
          LLLL: 'YYYY年M月D日ddddAh点mm分',
          l: 'YYYY/M/D',
          ll: 'YYYY年M月D日',
          lll: 'YYYY年M月D日 HH:mm',
          llll: 'YYYY年M月D日dddd HH:mm',
        },
        relativeTime: {
          future: '%s内',
          past: '%s前',
          s: '几秒',
          m: '1 分钟',
          mm: '%d 分钟',
          h: '1 小时',
          hh: '%d 小时',
          d: '1 天',
          dd: '%d 天',
          M: '1 个月',
          MM: '%d 个月',
          y: '1 年',
          yy: '%d 年',
        },
        meridiem: function (o, l) {
          var c = 100 * o + l;
          return c < 600
            ? '凌晨'
            : c < 900
            ? '早上'
            : c < 1100
            ? '上午'
            : c < 1300
            ? '中午'
            : c < 1800
            ? '下午'
            : '晚上';
        },
      };
    return i.default.locale(s, null, !0), s;
  });
})(bT);
var QC = { exports: {} };
(function (t, e) {
  (function (r, n) {
    t.exports = n();
  })(dg, function () {
    return function (r, n, i) {
      r = r || {};
      var s = n.prototype,
        o = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        };
      function l(p, f, m, g) {
        return s.fromToBase(p, f, m, g);
      }
      (i.en.relativeTime = o),
        (s.fromToBase = function (p, f, m, g, x) {
          for (
            var b,
              F,
              E,
              w = m.$locale().relativeTime || o,
              I = r.thresholds || [
                { l: 's', r: 44, d: 'second' },
                { l: 'm', r: 89 },
                { l: 'mm', r: 44, d: 'minute' },
                { l: 'h', r: 89 },
                { l: 'hh', r: 21, d: 'hour' },
                { l: 'd', r: 35 },
                { l: 'dd', r: 25, d: 'day' },
                { l: 'M', r: 45 },
                { l: 'MM', r: 10, d: 'month' },
                { l: 'y', r: 17 },
                { l: 'yy', d: 'year' },
              ],
              T = I.length,
              j = 0;
            j < T;
            j += 1
          ) {
            var $ = I[j];
            $.d && (b = g ? i(p).diff(m, $.d, !0) : m.diff(p, $.d, !0));
            var L = (r.rounding || Math.round)(Math.abs(b));
            if (((E = b > 0), L <= $.r || !$.r)) {
              L <= 1 && j > 0 && ($ = I[j - 1]);
              var se = w[$.l];
              x && (L = x('' + L)), (F = typeof se == 'string' ? se.replace('%d', L) : se(L, f, $.l, E));
              break;
            }
          }
          if (f) return F;
          var Y = E ? w.future : w.past;
          return typeof Y == 'function' ? Y(F) : Y.replace('%s', F);
        }),
        (s.to = function (p, f) {
          return l(p, f, this, !0);
        }),
        (s.from = function (p, f) {
          return l(p, f, this);
        });
      var c = function (p) {
        return p.$u ? i.utc() : i();
      };
      (s.toNow = function (p) {
        return this.to(c(this), p);
      }),
        (s.fromNow = function (p) {
          return this.from(c(this), p);
        });
    };
  });
})(QC);
var AT = QC.exports;
const ET = mg(AT);
function gg(t, e) {
  const r = Object.create(null),
    n = t.split(',');
  for (let i = 0; i < n.length; i++) r[n[i]] = !0;
  return e ? (i) => !!r[i.toLowerCase()] : (i) => !!r[i];
}
const Jt = {},
  Ha = [],
  oi = () => {},
  vT = () => !1,
  FT = /^on[^a-z]/,
  Xp = (t) => FT.test(t),
  yg = (t) => t.startsWith('onUpdate:'),
  mr = Object.assign,
  Dg = (t, e) => {
    const r = t.indexOf(e);
    r > -1 && t.splice(r, 1);
  },
  ST = Object.prototype.hasOwnProperty,
  Tt = (t, e) => ST.call(t, e),
  st = Array.isArray,
  Wa = (t) => Gp(t) === '[object Map]',
  ZC = (t) => Gp(t) === '[object Set]',
  ht = (t) => typeof t == 'function',
  pr = (t) => typeof t == 'string',
  xg = (t) => typeof t == 'symbol',
  Wt = (t) => t !== null && typeof t == 'object',
  eb = (t) => Wt(t) && ht(t.then) && ht(t.catch),
  tb = Object.prototype.toString,
  Gp = (t) => tb.call(t),
  wT = (t) => Gp(t).slice(8, -1),
  rb = (t) => Gp(t) === '[object Object]',
  Cg = (t) => pr(t) && t !== 'NaN' && t[0] !== '-' && '' + parseInt(t, 10) === t,
  Hh = gg(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted',
  ),
  Yp = (t) => {
    const e = Object.create(null);
    return (r) => e[r] || (e[r] = t(r));
  },
  TT = /-(\w)/g,
  $i = Yp((t) => t.replace(TT, (e, r) => (r ? r.toUpperCase() : ''))),
  kT = /\B([A-Z])/g,
  aa = Yp((t) => t.replace(kT, '-$1').toLowerCase()),
  Qp = Yp((t) => t.charAt(0).toUpperCase() + t.slice(1)),
  _d = Yp((t) => (t ? `on${Qp(t)}` : '')),
  Bu = (t, e) => !Object.is(t, e),
  Rd = (t, e) => {
    for (let r = 0; r < t.length; r++) t[r](e);
  },
  sp = (t, e, r) => {
    Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: r });
  },
  PT = (t) => {
    const e = parseFloat(t);
    return isNaN(e) ? t : e;
  },
  BT = (t) => {
    const e = pr(t) ? Number(t) : NaN;
    return isNaN(e) ? t : e;
  };
let xD;
const Om = () =>
  xD ||
  (xD =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
      ? self
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : {});
function Us(t) {
  if (st(t)) {
    const e = {};
    for (let r = 0; r < t.length; r++) {
      const n = t[r],
        i = pr(n) ? OT(n) : Us(n);
      if (i) for (const s in i) e[s] = i[s];
    }
    return e;
  } else {
    if (pr(t)) return t;
    if (Wt(t)) return t;
  }
}
const IT = /;(?![^(]*\))/g,
  NT = /:([^]+)/,
  MT = /\/\*[^]*?\*\//g;
function OT(t) {
  const e = {};
  return (
    t
      .replace(MT, '')
      .split(IT)
      .forEach((r) => {
        if (r) {
          const n = r.split(NT);
          n.length > 1 && (e[n[0].trim()] = n[1].trim());
        }
      }),
    e
  );
}
function Gt(t) {
  let e = '';
  if (pr(t)) e = t;
  else if (st(t))
    for (let r = 0; r < t.length; r++) {
      const n = Gt(t[r]);
      n && (e += n + ' ');
    }
  else if (Wt(t)) for (const r in t) t[r] && (e += r + ' ');
  return e.trim();
}
const LT = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  _T = gg(LT);
function nb(t) {
  return !!t || t === '';
}
const ai = (t) =>
    pr(t)
      ? t
      : t == null
      ? ''
      : st(t) || (Wt(t) && (t.toString === tb || !ht(t.toString)))
      ? JSON.stringify(t, ib, 2)
      : String(t),
  ib = (t, e) =>
    e && e.__v_isRef
      ? ib(t, e.value)
      : Wa(e)
      ? { [`Map(${e.size})`]: [...e.entries()].reduce((r, [n, i]) => ((r[`${n} =>`] = i), r), {}) }
      : ZC(e)
      ? { [`Set(${e.size})`]: [...e.values()] }
      : Wt(e) && !st(e) && !rb(e)
      ? String(e)
      : e;
let En;
class sb {
  constructor(e = !1) {
    (this.detached = e),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this.parent = En),
      !e && En && (this.index = (En.scopes || (En.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const r = En;
      try {
        return (En = this), e();
      } finally {
        En = r;
      }
    }
  }
  on() {
    En = this;
  }
  off() {
    En = this.parent;
  }
  stop(e) {
    if (this._active) {
      let r, n;
      for (r = 0, n = this.effects.length; r < n; r++) this.effects[r].stop();
      for (r = 0, n = this.cleanups.length; r < n; r++) this.cleanups[r]();
      if (this.scopes) for (r = 0, n = this.scopes.length; r < n; r++) this.scopes[r].stop(!0);
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && ((this.parent.scopes[this.index] = i), (i.index = this.index));
      }
      (this.parent = void 0), (this._active = !1);
    }
  }
}
function ob(t) {
  return new sb(t);
}
function RT(t, e = En) {
  e && e.active && e.effects.push(t);
}
function Zp() {
  return En;
}
function ab(t) {
  En && En.cleanups.push(t);
}
const bg = (t) => {
    const e = new Set(t);
    return (e.w = 0), (e.n = 0), e;
  },
  lb = (t) => (t.w & Zs) > 0,
  ub = (t) => (t.n & Zs) > 0,
  jT = ({ deps: t }) => {
    if (t.length) for (let e = 0; e < t.length; e++) t[e].w |= Zs;
  },
  $T = (t) => {
    const { deps: e } = t;
    if (e.length) {
      let r = 0;
      for (let n = 0; n < e.length; n++) {
        const i = e[n];
        lb(i) && !ub(i) ? i.delete(t) : (e[r++] = i), (i.w &= ~Zs), (i.n &= ~Zs);
      }
      e.length = r;
    }
  },
  op = new WeakMap();
let ou = 0,
  Zs = 1;
const Lm = 30;
let ni;
const Xo = Symbol(''),
  _m = Symbol('');
class Ag {
  constructor(e, r = null, n) {
    (this.fn = e), (this.scheduler = r), (this.active = !0), (this.deps = []), (this.parent = void 0), RT(this, n);
  }
  run() {
    if (!this.active) return this.fn();
    let e = ni,
      r = qs;
    for (; e; ) {
      if (e === this) return;
      e = e.parent;
    }
    try {
      return (this.parent = ni), (ni = this), (qs = !0), (Zs = 1 << ++ou), ou <= Lm ? jT(this) : CD(this), this.fn();
    } finally {
      ou <= Lm && $T(this),
        (Zs = 1 << --ou),
        (ni = this.parent),
        (qs = r),
        (this.parent = void 0),
        this.deferStop && this.stop();
    }
  }
  stop() {
    ni === this ? (this.deferStop = !0) : this.active && (CD(this), this.onStop && this.onStop(), (this.active = !1));
  }
}
function CD(t) {
  const { deps: e } = t;
  if (e.length) {
    for (let r = 0; r < e.length; r++) e[r].delete(t);
    e.length = 0;
  }
}
let qs = !0;
const cb = [];
function ml() {
  cb.push(qs), (qs = !1);
}
function gl() {
  const t = cb.pop();
  qs = t === void 0 ? !0 : t;
}
function yn(t, e, r) {
  if (qs && ni) {
    let n = op.get(t);
    n || op.set(t, (n = new Map()));
    let i = n.get(r);
    i || n.set(r, (i = bg())), hb(i);
  }
}
function hb(t, e) {
  let r = !1;
  ou <= Lm ? ub(t) || ((t.n |= Zs), (r = !lb(t))) : (r = !t.has(ni)), r && (t.add(ni), ni.deps.push(t));
}
function ss(t, e, r, n, i, s) {
  const o = op.get(t);
  if (!o) return;
  let l = [];
  if (e === 'clear') l = [...o.values()];
  else if (r === 'length' && st(t)) {
    const c = Number(n);
    o.forEach((p, f) => {
      (f === 'length' || f >= c) && l.push(p);
    });
  } else
    switch ((r !== void 0 && l.push(o.get(r)), e)) {
      case 'add':
        st(t) ? Cg(r) && l.push(o.get('length')) : (l.push(o.get(Xo)), Wa(t) && l.push(o.get(_m)));
        break;
      case 'delete':
        st(t) || (l.push(o.get(Xo)), Wa(t) && l.push(o.get(_m)));
        break;
      case 'set':
        Wa(t) && l.push(o.get(Xo));
        break;
    }
  if (l.length === 1) l[0] && Rm(l[0]);
  else {
    const c = [];
    for (const p of l) p && c.push(...p);
    Rm(bg(c));
  }
}
function Rm(t, e) {
  const r = st(t) ? t : [...t];
  for (const n of r) n.computed && bD(n);
  for (const n of r) n.computed || bD(n);
}
function bD(t, e) {
  (t !== ni || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run());
}
function VT(t, e) {
  var r;
  return (r = op.get(t)) == null ? void 0 : r.get(e);
}
const zT = gg('__proto__,__v_isRef,__isVue'),
  pb = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((t) => t !== 'arguments' && t !== 'caller')
      .map((t) => Symbol[t])
      .filter(xg),
  ),
  HT = Eg(),
  WT = Eg(!1, !0),
  UT = Eg(!0),
  AD = qT();
function qT() {
  const t = {};
  return (
    ['includes', 'indexOf', 'lastIndexOf'].forEach((e) => {
      t[e] = function (...r) {
        const n = bt(this);
        for (let s = 0, o = this.length; s < o; s++) yn(n, 'get', s + '');
        const i = n[e](...r);
        return i === -1 || i === !1 ? n[e](...r.map(bt)) : i;
      };
    }),
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => {
      t[e] = function (...r) {
        ml();
        const n = bt(this)[e].apply(this, r);
        return gl(), n;
      };
    }),
    t
  );
}
function KT(t) {
  const e = bt(this);
  return yn(e, 'has', t), e.hasOwnProperty(t);
}
function Eg(t = !1, e = !1) {
  return function (n, i, s) {
    if (i === '__v_isReactive') return !t;
    if (i === '__v_isReadonly') return t;
    if (i === '__v_isShallow') return e;
    if (i === '__v_raw' && s === (t ? (e ? uk : yb) : e ? gb : mb).get(n)) return n;
    const o = st(n);
    if (!t) {
      if (o && Tt(AD, i)) return Reflect.get(AD, i, s);
      if (i === 'hasOwnProperty') return KT;
    }
    const l = Reflect.get(n, i, s);
    return (xg(i) ? pb.has(i) : zT(i)) || (t || yn(n, 'get', i), e)
      ? l
      : tr(l)
      ? o && Cg(i)
        ? l
        : l.value
      : Wt(l)
      ? t
        ? ic(l)
        : yl(l)
      : l;
  };
}
const JT = fb(),
  XT = fb(!0);
function fb(t = !1) {
  return function (r, n, i, s) {
    let o = r[n];
    if (Za(o) && tr(o) && !tr(i)) return !1;
    if (!t && (!ap(i) && !Za(i) && ((o = bt(o)), (i = bt(i))), !st(r) && tr(o) && !tr(i))) return (o.value = i), !0;
    const l = st(r) && Cg(n) ? Number(n) < r.length : Tt(r, n),
      c = Reflect.set(r, n, i, s);
    return r === bt(s) && (l ? Bu(i, o) && ss(r, 'set', n, i) : ss(r, 'add', n, i)), c;
  };
}
function GT(t, e) {
  const r = Tt(t, e);
  t[e];
  const n = Reflect.deleteProperty(t, e);
  return n && r && ss(t, 'delete', e, void 0), n;
}
function YT(t, e) {
  const r = Reflect.has(t, e);
  return (!xg(e) || !pb.has(e)) && yn(t, 'has', e), r;
}
function QT(t) {
  return yn(t, 'iterate', st(t) ? 'length' : Xo), Reflect.ownKeys(t);
}
const db = { get: HT, set: JT, deleteProperty: GT, has: YT, ownKeys: QT },
  ZT = {
    get: UT,
    set(t, e) {
      return !0;
    },
    deleteProperty(t, e) {
      return !0;
    },
  },
  ek = mr({}, db, { get: WT, set: XT }),
  vg = (t) => t,
  ef = (t) => Reflect.getPrototypeOf(t);
function sh(t, e, r = !1, n = !1) {
  t = t.__v_raw;
  const i = bt(t),
    s = bt(e);
  r || (e !== s && yn(i, 'get', e), yn(i, 'get', s));
  const { has: o } = ef(i),
    l = n ? vg : r ? wg : Iu;
  if (o.call(i, e)) return l(t.get(e));
  if (o.call(i, s)) return l(t.get(s));
  t !== i && t.get(e);
}
function oh(t, e = !1) {
  const r = this.__v_raw,
    n = bt(r),
    i = bt(t);
  return e || (t !== i && yn(n, 'has', t), yn(n, 'has', i)), t === i ? r.has(t) : r.has(t) || r.has(i);
}
function ah(t, e = !1) {
  return (t = t.__v_raw), !e && yn(bt(t), 'iterate', Xo), Reflect.get(t, 'size', t);
}
function ED(t) {
  t = bt(t);
  const e = bt(this);
  return ef(e).has.call(e, t) || (e.add(t), ss(e, 'add', t, t)), this;
}
function vD(t, e) {
  e = bt(e);
  const r = bt(this),
    { has: n, get: i } = ef(r);
  let s = n.call(r, t);
  s || ((t = bt(t)), (s = n.call(r, t)));
  const o = i.call(r, t);
  return r.set(t, e), s ? Bu(e, o) && ss(r, 'set', t, e) : ss(r, 'add', t, e), this;
}
function FD(t) {
  const e = bt(this),
    { has: r, get: n } = ef(e);
  let i = r.call(e, t);
  i || ((t = bt(t)), (i = r.call(e, t))), n && n.call(e, t);
  const s = e.delete(t);
  return i && ss(e, 'delete', t, void 0), s;
}
function SD() {
  const t = bt(this),
    e = t.size !== 0,
    r = t.clear();
  return e && ss(t, 'clear', void 0, void 0), r;
}
function lh(t, e) {
  return function (n, i) {
    const s = this,
      o = s.__v_raw,
      l = bt(o),
      c = e ? vg : t ? wg : Iu;
    return !t && yn(l, 'iterate', Xo), o.forEach((p, f) => n.call(i, c(p), c(f), s));
  };
}
function uh(t, e, r) {
  return function (...n) {
    const i = this.__v_raw,
      s = bt(i),
      o = Wa(s),
      l = t === 'entries' || (t === Symbol.iterator && o),
      c = t === 'keys' && o,
      p = i[t](...n),
      f = r ? vg : e ? wg : Iu;
    return (
      !e && yn(s, 'iterate', c ? _m : Xo),
      {
        next() {
          const { value: m, done: g } = p.next();
          return g ? { value: m, done: g } : { value: l ? [f(m[0]), f(m[1])] : f(m), done: g };
        },
        [Symbol.iterator]() {
          return this;
        },
      }
    );
  };
}
function Ss(t) {
  return function (...e) {
    return t === 'delete' ? !1 : this;
  };
}
function tk() {
  const t = {
      get(s) {
        return sh(this, s);
      },
      get size() {
        return ah(this);
      },
      has: oh,
      add: ED,
      set: vD,
      delete: FD,
      clear: SD,
      forEach: lh(!1, !1),
    },
    e = {
      get(s) {
        return sh(this, s, !1, !0);
      },
      get size() {
        return ah(this);
      },
      has: oh,
      add: ED,
      set: vD,
      delete: FD,
      clear: SD,
      forEach: lh(!1, !0),
    },
    r = {
      get(s) {
        return sh(this, s, !0);
      },
      get size() {
        return ah(this, !0);
      },
      has(s) {
        return oh.call(this, s, !0);
      },
      add: Ss('add'),
      set: Ss('set'),
      delete: Ss('delete'),
      clear: Ss('clear'),
      forEach: lh(!0, !1),
    },
    n = {
      get(s) {
        return sh(this, s, !0, !0);
      },
      get size() {
        return ah(this, !0);
      },
      has(s) {
        return oh.call(this, s, !0);
      },
      add: Ss('add'),
      set: Ss('set'),
      delete: Ss('delete'),
      clear: Ss('clear'),
      forEach: lh(!0, !0),
    };
  return (
    ['keys', 'values', 'entries', Symbol.iterator].forEach((s) => {
      (t[s] = uh(s, !1, !1)), (r[s] = uh(s, !0, !1)), (e[s] = uh(s, !1, !0)), (n[s] = uh(s, !0, !0));
    }),
    [t, r, e, n]
  );
}
const [rk, nk, ik, sk] = tk();
function Fg(t, e) {
  const r = e ? (t ? sk : ik) : t ? nk : rk;
  return (n, i, s) =>
    i === '__v_isReactive'
      ? !t
      : i === '__v_isReadonly'
      ? t
      : i === '__v_raw'
      ? n
      : Reflect.get(Tt(r, i) && i in n ? r : n, i, s);
}
const ok = { get: Fg(!1, !1) },
  ak = { get: Fg(!1, !0) },
  lk = { get: Fg(!0, !1) },
  mb = new WeakMap(),
  gb = new WeakMap(),
  yb = new WeakMap(),
  uk = new WeakMap();
function ck(t) {
  switch (t) {
    case 'Object':
    case 'Array':
      return 1;
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2;
    default:
      return 0;
  }
}
function hk(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : ck(wT(t));
}
function yl(t) {
  return Za(t) ? t : Sg(t, !1, db, ok, mb);
}
function Db(t) {
  return Sg(t, !1, ek, ak, gb);
}
function ic(t) {
  return Sg(t, !0, ZT, lk, yb);
}
function Sg(t, e, r, n, i) {
  if (!Wt(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t;
  const s = i.get(t);
  if (s) return s;
  const o = hk(t);
  if (o === 0) return t;
  const l = new Proxy(t, o === 2 ? n : r);
  return i.set(t, l), l;
}
function ns(t) {
  return Za(t) ? ns(t.__v_raw) : !!(t && t.__v_isReactive);
}
function Za(t) {
  return !!(t && t.__v_isReadonly);
}
function ap(t) {
  return !!(t && t.__v_isShallow);
}
function xb(t) {
  return ns(t) || Za(t);
}
function bt(t) {
  const e = t && t.__v_raw;
  return e ? bt(e) : t;
}
function tf(t) {
  return sp(t, '__v_skip', !0), t;
}
const Iu = (t) => (Wt(t) ? yl(t) : t),
  wg = (t) => (Wt(t) ? ic(t) : t);
function Cb(t) {
  qs && ni && ((t = bt(t)), hb(t.dep || (t.dep = bg())));
}
function bb(t, e) {
  t = bt(t);
  const r = t.dep;
  r && Rm(r);
}
function tr(t) {
  return !!(t && t.__v_isRef === !0);
}
function tt(t) {
  return Ab(t, !1);
}
function Ua(t) {
  return Ab(t, !0);
}
function Ab(t, e) {
  return tr(t) ? t : new pk(t, e);
}
class pk {
  constructor(e, r) {
    (this.__v_isShallow = r),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._rawValue = r ? e : bt(e)),
      (this._value = r ? e : Iu(e));
  }
  get value() {
    return Cb(this), this._value;
  }
  set value(e) {
    const r = this.__v_isShallow || ap(e) || Za(e);
    (e = r ? e : bt(e)), Bu(e, this._rawValue) && ((this._rawValue = e), (this._value = r ? e : Iu(e)), bb(this));
  }
}
function te(t) {
  return tr(t) ? t.value : t;
}
const fk = {
  get: (t, e, r) => te(Reflect.get(t, e, r)),
  set: (t, e, r, n) => {
    const i = t[e];
    return tr(i) && !tr(r) ? ((i.value = r), !0) : Reflect.set(t, e, r, n);
  },
};
function Eb(t) {
  return ns(t) ? t : new Proxy(t, fk);
}
function dk(t) {
  const e = st(t) ? new Array(t.length) : {};
  for (const r in t) e[r] = vb(t, r);
  return e;
}
class mk {
  constructor(e, r, n) {
    (this._object = e), (this._key = r), (this._defaultValue = n), (this.__v_isRef = !0);
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return VT(bt(this._object), this._key);
  }
}
class gk {
  constructor(e) {
    (this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0);
  }
  get value() {
    return this._getter();
  }
}
function yk(t, e, r) {
  return tr(t) ? t : ht(t) ? new gk(t) : Wt(t) && arguments.length > 1 ? vb(t, e, r) : tt(t);
}
function vb(t, e, r) {
  const n = t[e];
  return tr(n) ? n : new mk(t, e, r);
}
class Dk {
  constructor(e, r, n, i) {
    (this._setter = r),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this.__v_isReadonly = !1),
      (this._dirty = !0),
      (this.effect = new Ag(e, () => {
        this._dirty || ((this._dirty = !0), bb(this));
      })),
      (this.effect.computed = this),
      (this.effect.active = this._cacheable = !i),
      (this.__v_isReadonly = n);
  }
  get value() {
    const e = bt(this);
    return Cb(e), (e._dirty || !e._cacheable) && ((e._dirty = !1), (e._value = e.effect.run())), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
function xk(t, e, r = !1) {
  let n, i;
  const s = ht(t);
  return s ? ((n = t), (i = oi)) : ((n = t.get), (i = t.set)), new Dk(n, i, s || !i, r);
}
function Ks(t, e, r, n) {
  let i;
  try {
    i = n ? t(...n) : t();
  } catch (s) {
    rf(s, e, r);
  }
  return i;
}
function jn(t, e, r, n) {
  if (ht(t)) {
    const s = Ks(t, e, r, n);
    return (
      s &&
        eb(s) &&
        s.catch((o) => {
          rf(o, e, r);
        }),
      s
    );
  }
  const i = [];
  for (let s = 0; s < t.length; s++) i.push(jn(t[s], e, r, n));
  return i;
}
function rf(t, e, r, n = !0) {
  const i = e ? e.vnode : null;
  if (e) {
    let s = e.parent;
    const o = e.proxy,
      l = r;
    for (; s; ) {
      const p = s.ec;
      if (p) {
        for (let f = 0; f < p.length; f++) if (p[f](t, o, l) === !1) return;
      }
      s = s.parent;
    }
    const c = e.appContext.config.errorHandler;
    if (c) {
      Ks(c, null, 10, [t, o, l]);
      return;
    }
  }
  Ck(t, r, i, n);
}
function Ck(t, e, r, n = !0) {
  console.error(t);
}
let Nu = !1,
  jm = !1;
const Jr = [];
let Pi = 0;
const qa = [];
let es = null,
  _o = 0;
const Fb = Promise.resolve();
let Tg = null;
function gi(t) {
  const e = Tg || Fb;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function bk(t) {
  let e = Pi + 1,
    r = Jr.length;
  for (; e < r; ) {
    const n = (e + r) >>> 1;
    Mu(Jr[n]) < t ? (e = n + 1) : (r = n);
  }
  return e;
}
function kg(t) {
  (!Jr.length || !Jr.includes(t, Nu && t.allowRecurse ? Pi + 1 : Pi)) &&
    (t.id == null ? Jr.push(t) : Jr.splice(bk(t.id), 0, t), Sb());
}
function Sb() {
  !Nu && !jm && ((jm = !0), (Tg = Fb.then(Tb)));
}
function Ak(t) {
  const e = Jr.indexOf(t);
  e > Pi && Jr.splice(e, 1);
}
function Ek(t) {
  st(t) ? qa.push(...t) : (!es || !es.includes(t, t.allowRecurse ? _o + 1 : _o)) && qa.push(t), Sb();
}
function wD(t, e = Nu ? Pi + 1 : 0) {
  for (; e < Jr.length; e++) {
    const r = Jr[e];
    r && r.pre && (Jr.splice(e, 1), e--, r());
  }
}
function wb(t) {
  if (qa.length) {
    const e = [...new Set(qa)];
    if (((qa.length = 0), es)) {
      es.push(...e);
      return;
    }
    for (es = e, es.sort((r, n) => Mu(r) - Mu(n)), _o = 0; _o < es.length; _o++) es[_o]();
    (es = null), (_o = 0);
  }
}
const Mu = (t) => (t.id == null ? 1 / 0 : t.id),
  vk = (t, e) => {
    const r = Mu(t) - Mu(e);
    if (r === 0) {
      if (t.pre && !e.pre) return -1;
      if (e.pre && !t.pre) return 1;
    }
    return r;
  };
function Tb(t) {
  (jm = !1), (Nu = !0), Jr.sort(vk);
  const e = oi;
  try {
    for (Pi = 0; Pi < Jr.length; Pi++) {
      const r = Jr[Pi];
      r && r.active !== !1 && Ks(r, null, 14);
    }
  } finally {
    (Pi = 0), (Jr.length = 0), wb(), (Nu = !1), (Tg = null), (Jr.length || qa.length) && Tb();
  }
}
function Fk(t, e, ...r) {
  if (t.isUnmounted) return;
  const n = t.vnode.props || Jt;
  let i = r;
  const s = e.startsWith('update:'),
    o = s && e.slice(7);
  if (o && o in n) {
    const f = `${o === 'modelValue' ? 'model' : o}Modifiers`,
      { number: m, trim: g } = n[f] || Jt;
    g && (i = r.map((x) => (pr(x) ? x.trim() : x))), m && (i = r.map(PT));
  }
  let l,
    c = n[(l = _d(e))] || n[(l = _d($i(e)))];
  !c && s && (c = n[(l = _d(aa(e)))]), c && jn(c, t, 6, i);
  const p = n[l + 'Once'];
  if (p) {
    if (!t.emitted) t.emitted = {};
    else if (t.emitted[l]) return;
    (t.emitted[l] = !0), jn(p, t, 6, i);
  }
}
function kb(t, e, r = !1) {
  const n = e.emitsCache,
    i = n.get(t);
  if (i !== void 0) return i;
  const s = t.emits;
  let o = {},
    l = !1;
  if (!ht(t)) {
    const c = (p) => {
      const f = kb(p, e, !0);
      f && ((l = !0), mr(o, f));
    };
    !r && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c);
  }
  return !s && !l
    ? (Wt(t) && n.set(t, null), null)
    : (st(s) ? s.forEach((c) => (o[c] = null)) : mr(o, s), Wt(t) && n.set(t, o), o);
}
function nf(t, e) {
  return !t || !Xp(e)
    ? !1
    : ((e = e.slice(2).replace(/Once$/, '')), Tt(t, e[0].toLowerCase() + e.slice(1)) || Tt(t, aa(e)) || Tt(t, e));
}
let Tr = null,
  sf = null;
function lp(t) {
  const e = Tr;
  return (Tr = t), (sf = (t && t.type.__scopeId) || null), e;
}
function sc(t) {
  sf = t;
}
function oc() {
  sf = null;
}
function Ke(t, e = Tr, r) {
  if (!e || t._n) return t;
  const n = (...i) => {
    n._d && jD(-1);
    const s = lp(e);
    let o;
    try {
      o = t(...i);
    } finally {
      lp(s), n._d && jD(1);
    }
    return o;
  };
  return (n._n = !0), (n._c = !0), (n._d = !0), n;
}
function jd(t) {
  const {
    type: e,
    vnode: r,
    proxy: n,
    withProxy: i,
    props: s,
    propsOptions: [o],
    slots: l,
    attrs: c,
    emit: p,
    render: f,
    renderCache: m,
    data: g,
    setupState: x,
    ctx: b,
    inheritAttrs: F,
  } = t;
  let E, w;
  const I = lp(t);
  try {
    if (r.shapeFlag & 4) {
      const j = i || n;
      (E = Ti(f.call(j, j, m, s, x, g, b))), (w = c);
    } else {
      const j = e;
      (E = Ti(j.length > 1 ? j(s, { attrs: c, slots: l, emit: p }) : j(s, null))), (w = e.props ? c : Sk(c));
    }
  } catch (j) {
    (yu.length = 0), rf(j, t, 1), (E = z($n));
  }
  let T = E;
  if (w && F !== !1) {
    const j = Object.keys(w),
      { shapeFlag: $ } = T;
    j.length && $ & 7 && (o && j.some(yg) && (w = wk(w, o)), (T = eo(T, w)));
  }
  return (
    r.dirs && ((T = eo(T)), (T.dirs = T.dirs ? T.dirs.concat(r.dirs) : r.dirs)),
    r.transition && (T.transition = r.transition),
    (E = T),
    lp(I),
    E
  );
}
const Sk = (t) => {
    let e;
    for (const r in t) (r === 'class' || r === 'style' || Xp(r)) && ((e || (e = {}))[r] = t[r]);
    return e;
  },
  wk = (t, e) => {
    const r = {};
    for (const n in t) (!yg(n) || !(n.slice(9) in e)) && (r[n] = t[n]);
    return r;
  };
function Tk(t, e, r) {
  const { props: n, children: i, component: s } = t,
    { props: o, children: l, patchFlag: c } = e,
    p = s.emitsOptions;
  if (e.dirs || e.transition) return !0;
  if (r && c >= 0) {
    if (c & 1024) return !0;
    if (c & 16) return n ? TD(n, o, p) : !!o;
    if (c & 8) {
      const f = e.dynamicProps;
      for (let m = 0; m < f.length; m++) {
        const g = f[m];
        if (o[g] !== n[g] && !nf(p, g)) return !0;
      }
    }
  } else return (i || l) && (!l || !l.$stable) ? !0 : n === o ? !1 : n ? (o ? TD(n, o, p) : !0) : !!o;
  return !1;
}
function TD(t, e, r) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length) return !0;
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    if (e[s] !== t[s] && !nf(r, s)) return !0;
  }
  return !1;
}
function kk({ vnode: t, parent: e }, r) {
  for (; e && e.subTree === t; ) ((t = e.vnode).el = r), (e = e.parent);
}
const Pk = (t) => t.__isSuspense;
function Bk(t, e) {
  e && e.pendingBranch ? (st(t) ? e.effects.push(...t) : e.effects.push(t)) : Ek(t);
}
function Ik(t, e) {
  return Pg(t, null, e);
}
const ch = {};
function Zt(t, e, r) {
  return Pg(t, e, r);
}
function Pg(t, e, { immediate: r, deep: n, flush: i, onTrack: s, onTrigger: o } = Jt) {
  var l;
  const c = Zp() === ((l = br) == null ? void 0 : l.scope) ? br : null;
  let p,
    f = !1,
    m = !1;
  if (
    (tr(t)
      ? ((p = () => t.value), (f = ap(t)))
      : ns(t)
      ? ((p = () => t), (n = !0))
      : st(t)
      ? ((m = !0),
        (f = t.some((j) => ns(j) || ap(j))),
        (p = () =>
          t.map((j) => {
            if (tr(j)) return j.value;
            if (ns(j)) return Ho(j);
            if (ht(j)) return Ks(j, c, 2);
          })))
      : ht(t)
      ? e
        ? (p = () => Ks(t, c, 2))
        : (p = () => {
            if (!(c && c.isUnmounted)) return g && g(), jn(t, c, 3, [x]);
          })
      : (p = oi),
    e && n)
  ) {
    const j = p;
    p = () => Ho(j());
  }
  let g,
    x = (j) => {
      g = I.onStop = () => {
        Ks(j, c, 4);
      };
    },
    b;
  if (_u)
    if (((x = oi), e ? r && jn(e, c, 3, [p(), m ? [] : void 0, x]) : p(), i === 'sync')) {
      const j = SP();
      b = j.__watcherHandles || (j.__watcherHandles = []);
    } else return oi;
  let F = m ? new Array(t.length).fill(ch) : ch;
  const E = () => {
    if (I.active)
      if (e) {
        const j = I.run();
        (n || f || (m ? j.some(($, L) => Bu($, F[L])) : Bu(j, F))) &&
          (g && g(), jn(e, c, 3, [j, F === ch ? void 0 : m && F[0] === ch ? [] : F, x]), (F = j));
      } else I.run();
  };
  E.allowRecurse = !!e;
  let w;
  i === 'sync'
    ? (w = E)
    : i === 'post'
    ? (w = () => fn(E, c && c.suspense))
    : ((E.pre = !0), c && (E.id = c.uid), (w = () => kg(E)));
  const I = new Ag(p, w);
  e ? (r ? E() : (F = I.run())) : i === 'post' ? fn(I.run.bind(I), c && c.suspense) : I.run();
  const T = () => {
    I.stop(), c && c.scope && Dg(c.scope.effects, I);
  };
  return b && b.push(T), T;
}
function Nk(t, e, r) {
  const n = this.proxy,
    i = pr(t) ? (t.includes('.') ? Pb(n, t) : () => n[t]) : t.bind(n, n);
  let s;
  ht(e) ? (s = e) : ((s = e.handler), (r = e));
  const o = br;
  el(this);
  const l = Pg(i, s.bind(n), r);
  return o ? el(o) : Go(), l;
}
function Pb(t, e) {
  const r = e.split('.');
  return () => {
    let n = t;
    for (let i = 0; i < r.length && n; i++) n = n[r[i]];
    return n;
  };
}
function Ho(t, e) {
  if (!Wt(t) || t.__v_skip || ((e = e || new Set()), e.has(t))) return t;
  if ((e.add(t), tr(t))) Ho(t.value, e);
  else if (st(t)) for (let r = 0; r < t.length; r++) Ho(t[r], e);
  else if (ZC(t) || Wa(t))
    t.forEach((r) => {
      Ho(r, e);
    });
  else if (rb(t)) for (const r in t) Ho(t[r], e);
  return t;
}
function Bb(t, e) {
  const r = Tr;
  if (r === null) return t;
  const n = hf(r) || r.proxy,
    i = t.dirs || (t.dirs = []);
  for (let s = 0; s < e.length; s++) {
    let [o, l, c, p = Jt] = e[s];
    o &&
      (ht(o) && (o = { mounted: o, updated: o }),
      o.deep && Ho(l),
      i.push({ dir: o, instance: n, value: l, oldValue: void 0, arg: c, modifiers: p }));
  }
  return t;
}
function Po(t, e, r, n) {
  const i = t.dirs,
    s = e && e.dirs;
  for (let o = 0; o < i.length; o++) {
    const l = i[o];
    s && (l.oldValue = s[o].value);
    let c = l.dir[n];
    c && (ml(), jn(c, r, 8, [t.el, l, t, e]), gl());
  }
}
function Mk() {
  const t = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() };
  return (
    Dl(() => {
      t.isMounted = !0;
    }),
    Bg(() => {
      t.isUnmounting = !0;
    }),
    t
  );
}
const Ln = [Function, Array],
  Ib = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Ln,
    onEnter: Ln,
    onAfterEnter: Ln,
    onEnterCancelled: Ln,
    onBeforeLeave: Ln,
    onLeave: Ln,
    onAfterLeave: Ln,
    onLeaveCancelled: Ln,
    onBeforeAppear: Ln,
    onAppear: Ln,
    onAfterAppear: Ln,
    onAppearCancelled: Ln,
  },
  Ok = {
    name: 'BaseTransition',
    props: Ib,
    setup(t, { slots: e }) {
      const r = cf(),
        n = Mk();
      let i;
      return () => {
        const s = e.default && Mb(e.default(), !0);
        if (!s || !s.length) return;
        let o = s[0];
        if (s.length > 1) {
          for (const F of s)
            if (F.type !== $n) {
              o = F;
              break;
            }
        }
        const l = bt(t),
          { mode: c } = l;
        if (n.isLeaving) return $d(o);
        const p = kD(o);
        if (!p) return $d(o);
        const f = $m(p, l, n, r);
        Vm(p, f);
        const m = r.subTree,
          g = m && kD(m);
        let x = !1;
        const { getTransitionKey: b } = p.type;
        if (b) {
          const F = b();
          i === void 0 ? (i = F) : F !== i && ((i = F), (x = !0));
        }
        if (g && g.type !== $n && (!Ro(p, g) || x)) {
          const F = $m(g, l, n, r);
          if ((Vm(g, F), c === 'out-in'))
            return (
              (n.isLeaving = !0),
              (F.afterLeave = () => {
                (n.isLeaving = !1), r.update.active !== !1 && r.update();
              }),
              $d(o)
            );
          c === 'in-out' &&
            p.type !== $n &&
            (F.delayLeave = (E, w, I) => {
              const T = Nb(n, g);
              (T[String(g.key)] = g),
                (E._leaveCb = () => {
                  w(), (E._leaveCb = void 0), delete f.delayedLeave;
                }),
                (f.delayedLeave = I);
            });
        }
        return o;
      };
    },
  },
  Lk = Ok;
function Nb(t, e) {
  const { leavingVNodes: r } = t;
  let n = r.get(e.type);
  return n || ((n = Object.create(null)), r.set(e.type, n)), n;
}
function $m(t, e, r, n) {
  const {
      appear: i,
      mode: s,
      persisted: o = !1,
      onBeforeEnter: l,
      onEnter: c,
      onAfterEnter: p,
      onEnterCancelled: f,
      onBeforeLeave: m,
      onLeave: g,
      onAfterLeave: x,
      onLeaveCancelled: b,
      onBeforeAppear: F,
      onAppear: E,
      onAfterAppear: w,
      onAppearCancelled: I,
    } = e,
    T = String(t.key),
    j = Nb(r, t),
    $ = (Y, W) => {
      Y && jn(Y, n, 9, W);
    },
    L = (Y, W) => {
      const X = W[1];
      $(Y, W), st(Y) ? Y.every((q) => q.length <= 1) && X() : Y.length <= 1 && X();
    },
    se = {
      mode: s,
      persisted: o,
      beforeEnter(Y) {
        let W = l;
        if (!r.isMounted)
          if (i) W = F || l;
          else return;
        Y._leaveCb && Y._leaveCb(!0);
        const X = j[T];
        X && Ro(t, X) && X.el._leaveCb && X.el._leaveCb(), $(W, [Y]);
      },
      enter(Y) {
        let W = c,
          X = p,
          q = f;
        if (!r.isMounted)
          if (i) (W = E || c), (X = w || p), (q = I || f);
          else return;
        let xe = !1;
        const Re = (Y._enterCb = (re) => {
          xe || ((xe = !0), re ? $(q, [Y]) : $(X, [Y]), se.delayedLeave && se.delayedLeave(), (Y._enterCb = void 0));
        });
        W ? L(W, [Y, Re]) : Re();
      },
      leave(Y, W) {
        const X = String(t.key);
        if ((Y._enterCb && Y._enterCb(!0), r.isUnmounting)) return W();
        $(m, [Y]);
        let q = !1;
        const xe = (Y._leaveCb = (Re) => {
          q || ((q = !0), W(), Re ? $(b, [Y]) : $(x, [Y]), (Y._leaveCb = void 0), j[X] === t && delete j[X]);
        });
        (j[X] = t), g ? L(g, [Y, xe]) : xe();
      },
      clone(Y) {
        return $m(Y, e, r, n);
      },
    };
  return se;
}
function $d(t) {
  if (of(t)) return (t = eo(t)), (t.children = null), t;
}
function kD(t) {
  return of(t) ? (t.children ? t.children[0] : void 0) : t;
}
function Vm(t, e) {
  t.shapeFlag & 6 && t.component
    ? Vm(t.component.subTree, e)
    : t.shapeFlag & 128
    ? ((t.ssContent.transition = e.clone(t.ssContent)), (t.ssFallback.transition = e.clone(t.ssFallback)))
    : (t.transition = e);
}
function Mb(t, e = !1, r) {
  let n = [],
    i = 0;
  for (let s = 0; s < t.length; s++) {
    let o = t[s];
    const l = r == null ? o.key : String(r) + String(o.key != null ? o.key : s);
    o.type === $t
      ? (o.patchFlag & 128 && i++, (n = n.concat(Mb(o.children, e, l))))
      : (e || o.type !== $n) && n.push(l != null ? eo(o, { key: l }) : o);
  }
  if (i > 1) for (let s = 0; s < n.length; s++) n[s].patchFlag = -2;
  return n;
}
function St(t, e) {
  return ht(t) ? (() => mr({ name: t.name }, e, { setup: t }))() : t;
}
const mu = (t) => !!t.type.__asyncLoader,
  of = (t) => t.type.__isKeepAlive;
function _k(t, e) {
  Ob(t, 'a', e);
}
function Rk(t, e) {
  Ob(t, 'da', e);
}
function Ob(t, e, r = br) {
  const n =
    t.__wdc ||
    (t.__wdc = () => {
      let i = r;
      for (; i; ) {
        if (i.isDeactivated) return;
        i = i.parent;
      }
      return t();
    });
  if ((af(e, n, r), r)) {
    let i = r.parent;
    for (; i && i.parent; ) of(i.parent.vnode) && jk(n, e, r, i), (i = i.parent);
  }
}
function jk(t, e, r, n) {
  const i = af(e, t, n, !0);
  Ig(() => {
    Dg(n[e], i);
  }, r);
}
function af(t, e, r = br, n = !1) {
  if (r) {
    const i = r[t] || (r[t] = []),
      s =
        e.__weh ||
        (e.__weh = (...o) => {
          if (r.isUnmounted) return;
          ml(), el(r);
          const l = jn(e, r, t, o);
          return Go(), gl(), l;
        });
    return n ? i.unshift(s) : i.push(s), s;
  }
}
const fs =
    (t) =>
    (e, r = br) =>
      (!_u || t === 'sp') && af(t, (...n) => e(...n), r),
  $k = fs('bm'),
  Dl = fs('m'),
  Vk = fs('bu'),
  zk = fs('u'),
  Bg = fs('bum'),
  Ig = fs('um'),
  Hk = fs('sp'),
  Wk = fs('rtg'),
  Uk = fs('rtc');
function qk(t, e = br) {
  af('ec', t, e);
}
const Lb = 'components',
  _b = Symbol.for('v-ndc');
function Rb(t) {
  return pr(t) ? Kk(Lb, t, !1) || t : t || _b;
}
function Kk(t, e, r = !0, n = !1) {
  const i = Tr || br;
  if (i) {
    const s = i.type;
    if (t === Lb) {
      const l = EP(s, !1);
      if (l && (l === e || l === $i(e) || l === Qp($i(e)))) return s;
    }
    const o = PD(i[t] || s[t], e) || PD(i.appContext[t], e);
    return !o && n ? s : o;
  }
}
function PD(t, e) {
  return t && (t[e] || t[$i(e)] || t[Qp($i(e))]);
}
function Zo(t, e, r, n) {
  let i;
  const s = r && r[n];
  if (st(t) || pr(t)) {
    i = new Array(t.length);
    for (let o = 0, l = t.length; o < l; o++) i[o] = e(t[o], o, void 0, s && s[o]);
  } else if (typeof t == 'number') {
    i = new Array(t);
    for (let o = 0; o < t; o++) i[o] = e(o + 1, o, void 0, s && s[o]);
  } else if (Wt(t))
    if (t[Symbol.iterator]) i = Array.from(t, (o, l) => e(o, l, void 0, s && s[l]));
    else {
      const o = Object.keys(t);
      i = new Array(o.length);
      for (let l = 0, c = o.length; l < c; l++) {
        const p = o[l];
        i[l] = e(t[p], p, l, s && s[l]);
      }
    }
  else i = [];
  return r && (r[n] = i), i;
}
function li(t, e, r = {}, n, i) {
  if (Tr.isCE || (Tr.parent && mu(Tr.parent) && Tr.parent.isCE))
    return e !== 'default' && (r.name = e), z('slot', r, n && n());
  let s = t[e];
  s && s._c && (s._d = !1), Ne();
  const o = s && jb(s(r)),
    l = nr($t, { key: r.key || (o && o.key) || `_${e}` }, o || (n ? n() : []), o && t._ === 1 ? 64 : -2);
  return !i && l.scopeId && (l.slotScopeIds = [l.scopeId + '-s']), s && s._c && (s._d = !0), l;
}
function jb(t) {
  return t.some((e) => (cp(e) ? !(e.type === $n || (e.type === $t && !jb(e.children))) : !0)) ? t : null;
}
const zm = (t) => (t ? (Yb(t) ? hf(t) || t.proxy : zm(t.parent)) : null),
  gu = mr(Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => t.props,
    $attrs: (t) => t.attrs,
    $slots: (t) => t.slots,
    $refs: (t) => t.refs,
    $parent: (t) => zm(t.parent),
    $root: (t) => zm(t.root),
    $emit: (t) => t.emit,
    $options: (t) => Ng(t),
    $forceUpdate: (t) => t.f || (t.f = () => kg(t.update)),
    $nextTick: (t) => t.n || (t.n = gi.bind(t.proxy)),
    $watch: (t) => Nk.bind(t),
  }),
  Vd = (t, e) => t !== Jt && !t.__isScriptSetup && Tt(t, e),
  Jk = {
    get({ _: t }, e) {
      const { ctx: r, setupState: n, data: i, props: s, accessCache: o, type: l, appContext: c } = t;
      let p;
      if (e[0] !== '$') {
        const x = o[e];
        if (x !== void 0)
          switch (x) {
            case 1:
              return n[e];
            case 2:
              return i[e];
            case 4:
              return r[e];
            case 3:
              return s[e];
          }
        else {
          if (Vd(n, e)) return (o[e] = 1), n[e];
          if (i !== Jt && Tt(i, e)) return (o[e] = 2), i[e];
          if ((p = t.propsOptions[0]) && Tt(p, e)) return (o[e] = 3), s[e];
          if (r !== Jt && Tt(r, e)) return (o[e] = 4), r[e];
          Hm && (o[e] = 0);
        }
      }
      const f = gu[e];
      let m, g;
      if (f) return e === '$attrs' && yn(t, 'get', e), f(t);
      if ((m = l.__cssModules) && (m = m[e])) return m;
      if (r !== Jt && Tt(r, e)) return (o[e] = 4), r[e];
      if (((g = c.config.globalProperties), Tt(g, e))) return g[e];
    },
    set({ _: t }, e, r) {
      const { data: n, setupState: i, ctx: s } = t;
      return Vd(i, e)
        ? ((i[e] = r), !0)
        : n !== Jt && Tt(n, e)
        ? ((n[e] = r), !0)
        : Tt(t.props, e) || (e[0] === '$' && e.slice(1) in t)
        ? !1
        : ((s[e] = r), !0);
    },
    has({ _: { data: t, setupState: e, accessCache: r, ctx: n, appContext: i, propsOptions: s } }, o) {
      let l;
      return (
        !!r[o] ||
        (t !== Jt && Tt(t, o)) ||
        Vd(e, o) ||
        ((l = s[0]) && Tt(l, o)) ||
        Tt(n, o) ||
        Tt(gu, o) ||
        Tt(i.config.globalProperties, o)
      );
    },
    defineProperty(t, e, r) {
      return (
        r.get != null ? (t._.accessCache[e] = 0) : Tt(r, 'value') && this.set(t, e, r.value, null),
        Reflect.defineProperty(t, e, r)
      );
    },
  };
function $b() {
  return Xk().slots;
}
function Xk() {
  const t = cf();
  return t.setupContext || (t.setupContext = Zb(t));
}
function BD(t) {
  return st(t) ? t.reduce((e, r) => ((e[r] = null), e), {}) : t;
}
let Hm = !0;
function Gk(t) {
  const e = Ng(t),
    r = t.proxy,
    n = t.ctx;
  (Hm = !1), e.beforeCreate && ID(e.beforeCreate, t, 'bc');
  const {
    data: i,
    computed: s,
    methods: o,
    watch: l,
    provide: c,
    inject: p,
    created: f,
    beforeMount: m,
    mounted: g,
    beforeUpdate: x,
    updated: b,
    activated: F,
    deactivated: E,
    beforeDestroy: w,
    beforeUnmount: I,
    destroyed: T,
    unmounted: j,
    render: $,
    renderTracked: L,
    renderTriggered: se,
    errorCaptured: Y,
    serverPrefetch: W,
    expose: X,
    inheritAttrs: q,
    components: xe,
    directives: Re,
    filters: re,
  } = e;
  if ((p && Yk(p, n, null), o))
    for (const ce in o) {
      const G = o[ce];
      ht(G) && (n[ce] = G.bind(r));
    }
  if (i) {
    const ce = i.call(r, r);
    Wt(ce) && (t.data = yl(ce));
  }
  if (((Hm = !0), s))
    for (const ce in s) {
      const G = s[ce],
        ge = ht(G) ? G.bind(r, r) : ht(G.get) ? G.get.bind(r, r) : oi,
        we = !ht(G) && ht(G.set) ? G.set.bind(r) : oi,
        je = nt({ get: ge, set: we });
      Object.defineProperty(n, ce, {
        enumerable: !0,
        configurable: !0,
        get: () => je.value,
        set: (Qe) => (je.value = Qe),
      });
    }
  if (l) for (const ce in l) Vb(l[ce], n, r, ce);
  if (c) {
    const ce = ht(c) ? c.call(r) : c;
    Reflect.ownKeys(ce).forEach((G) => {
      Wh(G, ce[G]);
    });
  }
  f && ID(f, t, 'c');
  function Q(ce, G) {
    st(G) ? G.forEach((ge) => ce(ge.bind(r))) : G && ce(G.bind(r));
  }
  if (
    (Q($k, m),
    Q(Dl, g),
    Q(Vk, x),
    Q(zk, b),
    Q(_k, F),
    Q(Rk, E),
    Q(qk, Y),
    Q(Uk, L),
    Q(Wk, se),
    Q(Bg, I),
    Q(Ig, j),
    Q(Hk, W),
    st(X))
  )
    if (X.length) {
      const ce = t.exposed || (t.exposed = {});
      X.forEach((G) => {
        Object.defineProperty(ce, G, { get: () => r[G], set: (ge) => (r[G] = ge) });
      });
    } else t.exposed || (t.exposed = {});
  $ && t.render === oi && (t.render = $),
    q != null && (t.inheritAttrs = q),
    xe && (t.components = xe),
    Re && (t.directives = Re);
}
function Yk(t, e, r = oi) {
  st(t) && (t = Wm(t));
  for (const n in t) {
    const i = t[n];
    let s;
    Wt(i) ? ('default' in i ? (s = kn(i.from || n, i.default, !0)) : (s = kn(i.from || n))) : (s = kn(i)),
      tr(s)
        ? Object.defineProperty(e, n, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: (o) => (s.value = o),
          })
        : (e[n] = s);
  }
}
function ID(t, e, r) {
  jn(st(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy), e, r);
}
function Vb(t, e, r, n) {
  const i = n.includes('.') ? Pb(r, n) : () => r[n];
  if (pr(t)) {
    const s = e[t];
    ht(s) && Zt(i, s);
  } else if (ht(t)) Zt(i, t.bind(r));
  else if (Wt(t))
    if (st(t)) t.forEach((s) => Vb(s, e, r, n));
    else {
      const s = ht(t.handler) ? t.handler.bind(r) : e[t.handler];
      ht(s) && Zt(i, s, t);
    }
}
function Ng(t) {
  const e = t.type,
    { mixins: r, extends: n } = e,
    {
      mixins: i,
      optionsCache: s,
      config: { optionMergeStrategies: o },
    } = t.appContext,
    l = s.get(e);
  let c;
  return (
    l
      ? (c = l)
      : !i.length && !r && !n
      ? (c = e)
      : ((c = {}), i.length && i.forEach((p) => up(c, p, o, !0)), up(c, e, o)),
    Wt(e) && s.set(e, c),
    c
  );
}
function up(t, e, r, n = !1) {
  const { mixins: i, extends: s } = e;
  s && up(t, s, r, !0), i && i.forEach((o) => up(t, o, r, !0));
  for (const o in e)
    if (!(n && o === 'expose')) {
      const l = Qk[o] || (r && r[o]);
      t[o] = l ? l(t[o], e[o]) : e[o];
    }
  return t;
}
const Qk = {
  data: ND,
  props: MD,
  emits: MD,
  methods: au,
  computed: au,
  beforeCreate: tn,
  created: tn,
  beforeMount: tn,
  mounted: tn,
  beforeUpdate: tn,
  updated: tn,
  beforeDestroy: tn,
  beforeUnmount: tn,
  destroyed: tn,
  unmounted: tn,
  activated: tn,
  deactivated: tn,
  errorCaptured: tn,
  serverPrefetch: tn,
  components: au,
  directives: au,
  watch: eP,
  provide: ND,
  inject: Zk,
};
function ND(t, e) {
  return e
    ? t
      ? function () {
          return mr(ht(t) ? t.call(this, this) : t, ht(e) ? e.call(this, this) : e);
        }
      : e
    : t;
}
function Zk(t, e) {
  return au(Wm(t), Wm(e));
}
function Wm(t) {
  if (st(t)) {
    const e = {};
    for (let r = 0; r < t.length; r++) e[t[r]] = t[r];
    return e;
  }
  return t;
}
function tn(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function au(t, e) {
  return t ? mr(Object.create(null), t, e) : e;
}
function MD(t, e) {
  return t ? (st(t) && st(e) ? [...new Set([...t, ...e])] : mr(Object.create(null), BD(t), BD(e ?? {}))) : e;
}
function eP(t, e) {
  if (!t) return e;
  if (!e) return t;
  const r = mr(Object.create(null), t);
  for (const n in e) r[n] = tn(t[n], e[n]);
  return r;
}
function zb() {
  return {
    app: null,
    config: {
      isNativeTag: vT,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap(),
  };
}
let tP = 0;
function rP(t, e) {
  return function (n, i = null) {
    ht(n) || (n = mr({}, n)), i != null && !Wt(i) && (i = null);
    const s = zb(),
      o = new Set();
    let l = !1;
    const c = (s.app = {
      _uid: tP++,
      _component: n,
      _props: i,
      _container: null,
      _context: s,
      _instance: null,
      version: wP,
      get config() {
        return s.config;
      },
      set config(p) {},
      use(p, ...f) {
        return o.has(p) || (p && ht(p.install) ? (o.add(p), p.install(c, ...f)) : ht(p) && (o.add(p), p(c, ...f))), c;
      },
      mixin(p) {
        return s.mixins.includes(p) || s.mixins.push(p), c;
      },
      component(p, f) {
        return f ? ((s.components[p] = f), c) : s.components[p];
      },
      directive(p, f) {
        return f ? ((s.directives[p] = f), c) : s.directives[p];
      },
      mount(p, f, m) {
        if (!l) {
          const g = z(n, i);
          return (
            (g.appContext = s),
            f && e ? e(g, p) : t(g, p, m),
            (l = !0),
            (c._container = p),
            (p.__vue_app__ = c),
            hf(g.component) || g.component.proxy
          );
        }
      },
      unmount() {
        l && (t(null, c._container), delete c._container.__vue_app__);
      },
      provide(p, f) {
        return (s.provides[p] = f), c;
      },
      runWithContext(p) {
        Ou = c;
        try {
          return p();
        } finally {
          Ou = null;
        }
      },
    });
    return c;
  };
}
let Ou = null;
function Wh(t, e) {
  if (br) {
    let r = br.provides;
    const n = br.parent && br.parent.provides;
    n === r && (r = br.provides = Object.create(n)), (r[t] = e);
  }
}
function kn(t, e, r = !1) {
  const n = br || Tr;
  if (n || Ou) {
    const i = n
      ? n.parent == null
        ? n.vnode.appContext && n.vnode.appContext.provides
        : n.parent.provides
      : Ou._context.provides;
    if (i && t in i) return i[t];
    if (arguments.length > 1) return r && ht(e) ? e.call(n && n.proxy) : e;
  }
}
function nP() {
  return !!(br || Tr || Ou);
}
function iP(t, e, r, n = !1) {
  const i = {},
    s = {};
  sp(s, uf, 1), (t.propsDefaults = Object.create(null)), Hb(t, e, i, s);
  for (const o in t.propsOptions[0]) o in i || (i[o] = void 0);
  r ? (t.props = n ? i : Db(i)) : t.type.props ? (t.props = i) : (t.props = s), (t.attrs = s);
}
function sP(t, e, r, n) {
  const {
      props: i,
      attrs: s,
      vnode: { patchFlag: o },
    } = t,
    l = bt(i),
    [c] = t.propsOptions;
  let p = !1;
  if ((n || o > 0) && !(o & 16)) {
    if (o & 8) {
      const f = t.vnode.dynamicProps;
      for (let m = 0; m < f.length; m++) {
        let g = f[m];
        if (nf(t.emitsOptions, g)) continue;
        const x = e[g];
        if (c)
          if (Tt(s, g)) x !== s[g] && ((s[g] = x), (p = !0));
          else {
            const b = $i(g);
            i[b] = Um(c, l, b, x, t, !1);
          }
        else x !== s[g] && ((s[g] = x), (p = !0));
      }
    }
  } else {
    Hb(t, e, i, s) && (p = !0);
    let f;
    for (const m in l)
      (!e || (!Tt(e, m) && ((f = aa(m)) === m || !Tt(e, f)))) &&
        (c ? r && (r[m] !== void 0 || r[f] !== void 0) && (i[m] = Um(c, l, m, void 0, t, !0)) : delete i[m]);
    if (s !== l) for (const m in s) (!e || !Tt(e, m)) && (delete s[m], (p = !0));
  }
  p && ss(t, 'set', '$attrs');
}
function Hb(t, e, r, n) {
  const [i, s] = t.propsOptions;
  let o = !1,
    l;
  if (e)
    for (let c in e) {
      if (Hh(c)) continue;
      const p = e[c];
      let f;
      i && Tt(i, (f = $i(c)))
        ? !s || !s.includes(f)
          ? (r[f] = p)
          : ((l || (l = {}))[f] = p)
        : nf(t.emitsOptions, c) || ((!(c in n) || p !== n[c]) && ((n[c] = p), (o = !0)));
    }
  if (s) {
    const c = bt(r),
      p = l || Jt;
    for (let f = 0; f < s.length; f++) {
      const m = s[f];
      r[m] = Um(i, c, m, p[m], t, !Tt(p, m));
    }
  }
  return o;
}
function Um(t, e, r, n, i, s) {
  const o = t[r];
  if (o != null) {
    const l = Tt(o, 'default');
    if (l && n === void 0) {
      const c = o.default;
      if (o.type !== Function && !o.skipFactory && ht(c)) {
        const { propsDefaults: p } = i;
        r in p ? (n = p[r]) : (el(i), (n = p[r] = c.call(null, e)), Go());
      } else n = c;
    }
    o[0] && (s && !l ? (n = !1) : o[1] && (n === '' || n === aa(r)) && (n = !0));
  }
  return n;
}
function Wb(t, e, r = !1) {
  const n = e.propsCache,
    i = n.get(t);
  if (i) return i;
  const s = t.props,
    o = {},
    l = [];
  let c = !1;
  if (!ht(t)) {
    const f = (m) => {
      c = !0;
      const [g, x] = Wb(m, e, !0);
      mr(o, g), x && l.push(...x);
    };
    !r && e.mixins.length && e.mixins.forEach(f), t.extends && f(t.extends), t.mixins && t.mixins.forEach(f);
  }
  if (!s && !c) return Wt(t) && n.set(t, Ha), Ha;
  if (st(s))
    for (let f = 0; f < s.length; f++) {
      const m = $i(s[f]);
      OD(m) && (o[m] = Jt);
    }
  else if (s)
    for (const f in s) {
      const m = $i(f);
      if (OD(m)) {
        const g = s[f],
          x = (o[m] = st(g) || ht(g) ? { type: g } : mr({}, g));
        if (x) {
          const b = RD(Boolean, x.type),
            F = RD(String, x.type);
          (x[0] = b > -1), (x[1] = F < 0 || b < F), (b > -1 || Tt(x, 'default')) && l.push(m);
        }
      }
    }
  const p = [o, l];
  return Wt(t) && n.set(t, p), p;
}
function OD(t) {
  return t[0] !== '$';
}
function LD(t) {
  const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : t === null ? 'null' : '';
}
function _D(t, e) {
  return LD(t) === LD(e);
}
function RD(t, e) {
  return st(e) ? e.findIndex((r) => _D(r, t)) : ht(e) && _D(e, t) ? 0 : -1;
}
const Ub = (t) => t[0] === '_' || t === '$stable',
  Mg = (t) => (st(t) ? t.map(Ti) : [Ti(t)]),
  oP = (t, e, r) => {
    if (e._n) return e;
    const n = Ke((...i) => Mg(e(...i)), r);
    return (n._c = !1), n;
  },
  qb = (t, e, r) => {
    const n = t._ctx;
    for (const i in t) {
      if (Ub(i)) continue;
      const s = t[i];
      if (ht(s)) e[i] = oP(i, s, n);
      else if (s != null) {
        const o = Mg(s);
        e[i] = () => o;
      }
    }
  },
  Kb = (t, e) => {
    const r = Mg(e);
    t.slots.default = () => r;
  },
  aP = (t, e) => {
    if (t.vnode.shapeFlag & 32) {
      const r = e._;
      r ? ((t.slots = bt(e)), sp(e, '_', r)) : qb(e, (t.slots = {}));
    } else (t.slots = {}), e && Kb(t, e);
    sp(t.slots, uf, 1);
  },
  lP = (t, e, r) => {
    const { vnode: n, slots: i } = t;
    let s = !0,
      o = Jt;
    if (n.shapeFlag & 32) {
      const l = e._;
      l ? (r && l === 1 ? (s = !1) : (mr(i, e), !r && l === 1 && delete i._)) : ((s = !e.$stable), qb(e, i)), (o = e);
    } else e && (Kb(t, e), (o = { default: 1 }));
    if (s) for (const l in i) !Ub(l) && !(l in o) && delete i[l];
  };
function qm(t, e, r, n, i = !1) {
  if (st(t)) {
    t.forEach((g, x) => qm(g, e && (st(e) ? e[x] : e), r, n, i));
    return;
  }
  if (mu(n) && !i) return;
  const s = n.shapeFlag & 4 ? hf(n.component) || n.component.proxy : n.el,
    o = i ? null : s,
    { i: l, r: c } = t,
    p = e && e.r,
    f = l.refs === Jt ? (l.refs = {}) : l.refs,
    m = l.setupState;
  if ((p != null && p !== c && (pr(p) ? ((f[p] = null), Tt(m, p) && (m[p] = null)) : tr(p) && (p.value = null)), ht(c)))
    Ks(c, l, 12, [o, f]);
  else {
    const g = pr(c),
      x = tr(c);
    if (g || x) {
      const b = () => {
        if (t.f) {
          const F = g ? (Tt(m, c) ? m[c] : f[c]) : c.value;
          i
            ? st(F) && Dg(F, s)
            : st(F)
            ? F.includes(s) || F.push(s)
            : g
            ? ((f[c] = [s]), Tt(m, c) && (m[c] = f[c]))
            : ((c.value = [s]), t.k && (f[t.k] = c.value));
        } else g ? ((f[c] = o), Tt(m, c) && (m[c] = o)) : x && ((c.value = o), t.k && (f[t.k] = o));
      };
      o ? ((b.id = -1), fn(b, r)) : b();
    }
  }
}
const fn = Bk;
function uP(t) {
  return cP(t);
}
function cP(t, e) {
  const r = Om();
  r.__VUE__ = !0;
  const {
      insert: n,
      remove: i,
      patchProp: s,
      createElement: o,
      createText: l,
      createComment: c,
      setText: p,
      setElementText: f,
      parentNode: m,
      nextSibling: g,
      setScopeId: x = oi,
      insertStaticContent: b,
    } = t,
    F = (M, V, J, ae = null, de = null, ye = null, Le = !1, Fe = null, ke = !!V.dynamicChildren) => {
      if (M === V) return;
      M && !Ro(M, V) && ((ae = U(M)), Qe(M, de, ye, !0), (M = null)),
        V.patchFlag === -2 && ((ke = !1), (V.dynamicChildren = null));
      const { type: De, ref: Ge, shapeFlag: He } = V;
      switch (De) {
        case lf:
          E(M, V, J, ae);
          break;
        case $n:
          w(M, V, J, ae);
          break;
        case zd:
          M == null && I(V, J, ae, Le);
          break;
        case $t:
          xe(M, V, J, ae, de, ye, Le, Fe, ke);
          break;
        default:
          He & 1
            ? $(M, V, J, ae, de, ye, Le, Fe, ke)
            : He & 6
            ? Re(M, V, J, ae, de, ye, Le, Fe, ke)
            : (He & 64 || He & 128) && De.process(M, V, J, ae, de, ye, Le, Fe, ke, Te);
      }
      Ge != null && de && qm(Ge, M && M.ref, ye, V || M, !V);
    },
    E = (M, V, J, ae) => {
      if (M == null) n((V.el = l(V.children)), J, ae);
      else {
        const de = (V.el = M.el);
        V.children !== M.children && p(de, V.children);
      }
    },
    w = (M, V, J, ae) => {
      M == null ? n((V.el = c(V.children || '')), J, ae) : (V.el = M.el);
    },
    I = (M, V, J, ae) => {
      [M.el, M.anchor] = b(M.children, V, J, ae, M.el, M.anchor);
    },
    T = ({ el: M, anchor: V }, J, ae) => {
      let de;
      for (; M && M !== V; ) (de = g(M)), n(M, J, ae), (M = de);
      n(V, J, ae);
    },
    j = ({ el: M, anchor: V }) => {
      let J;
      for (; M && M !== V; ) (J = g(M)), i(M), (M = J);
      i(V);
    },
    $ = (M, V, J, ae, de, ye, Le, Fe, ke) => {
      (Le = Le || V.type === 'svg'), M == null ? L(V, J, ae, de, ye, Le, Fe, ke) : W(M, V, de, ye, Le, Fe, ke);
    },
    L = (M, V, J, ae, de, ye, Le, Fe) => {
      let ke, De;
      const { type: Ge, props: He, shapeFlag: Ze, transition: et, dirs: lt } = M;
      if (
        ((ke = M.el = o(M.type, ye, He && He.is, He)),
        Ze & 8 ? f(ke, M.children) : Ze & 16 && Y(M.children, ke, null, ae, de, ye && Ge !== 'foreignObject', Le, Fe),
        lt && Po(M, null, ae, 'created'),
        se(ke, M, M.scopeId, Le, ae),
        He)
      ) {
        for (const Et in He) Et !== 'value' && !Hh(Et) && s(ke, Et, null, He[Et], ye, M.children, ae, de, yt);
        'value' in He && s(ke, 'value', null, He.value), (De = He.onVnodeBeforeMount) && Ai(De, ae, M);
      }
      lt && Po(M, null, ae, 'beforeMount');
      const Mt = (!de || (de && !de.pendingBranch)) && et && !et.persisted;
      Mt && et.beforeEnter(ke),
        n(ke, V, J),
        ((De = He && He.onVnodeMounted) || Mt || lt) &&
          fn(() => {
            De && Ai(De, ae, M), Mt && et.enter(ke), lt && Po(M, null, ae, 'mounted');
          }, de);
    },
    se = (M, V, J, ae, de) => {
      if ((J && x(M, J), ae)) for (let ye = 0; ye < ae.length; ye++) x(M, ae[ye]);
      if (de) {
        let ye = de.subTree;
        if (V === ye) {
          const Le = de.vnode;
          se(M, Le, Le.scopeId, Le.slotScopeIds, de.parent);
        }
      }
    },
    Y = (M, V, J, ae, de, ye, Le, Fe, ke = 0) => {
      for (let De = ke; De < M.length; De++) {
        const Ge = (M[De] = Fe ? Ms(M[De]) : Ti(M[De]));
        F(null, Ge, V, J, ae, de, ye, Le, Fe);
      }
    },
    W = (M, V, J, ae, de, ye, Le) => {
      const Fe = (V.el = M.el);
      let { patchFlag: ke, dynamicChildren: De, dirs: Ge } = V;
      ke |= M.patchFlag & 16;
      const He = M.props || Jt,
        Ze = V.props || Jt;
      let et;
      J && Bo(J, !1),
        (et = Ze.onVnodeBeforeUpdate) && Ai(et, J, V, M),
        Ge && Po(V, M, J, 'beforeUpdate'),
        J && Bo(J, !0);
      const lt = de && V.type !== 'foreignObject';
      if ((De ? X(M.dynamicChildren, De, Fe, J, ae, lt, ye) : Le || G(M, V, Fe, null, J, ae, lt, ye, !1), ke > 0)) {
        if (ke & 16) q(Fe, V, He, Ze, J, ae, de);
        else if (
          (ke & 2 && He.class !== Ze.class && s(Fe, 'class', null, Ze.class, de),
          ke & 4 && s(Fe, 'style', He.style, Ze.style, de),
          ke & 8)
        ) {
          const Mt = V.dynamicProps;
          for (let Et = 0; Et < Mt.length; Et++) {
            const Pt = Mt[Et],
              gr = He[Pt],
              Xn = Ze[Pt];
            (Xn !== gr || Pt === 'value') && s(Fe, Pt, gr, Xn, de, M.children, J, ae, yt);
          }
        }
        ke & 1 && M.children !== V.children && f(Fe, V.children);
      } else !Le && De == null && q(Fe, V, He, Ze, J, ae, de);
      ((et = Ze.onVnodeUpdated) || Ge) &&
        fn(() => {
          et && Ai(et, J, V, M), Ge && Po(V, M, J, 'updated');
        }, ae);
    },
    X = (M, V, J, ae, de, ye, Le) => {
      for (let Fe = 0; Fe < V.length; Fe++) {
        const ke = M[Fe],
          De = V[Fe],
          Ge = ke.el && (ke.type === $t || !Ro(ke, De) || ke.shapeFlag & 70) ? m(ke.el) : J;
        F(ke, De, Ge, null, ae, de, ye, Le, !0);
      }
    },
    q = (M, V, J, ae, de, ye, Le) => {
      if (J !== ae) {
        if (J !== Jt) for (const Fe in J) !Hh(Fe) && !(Fe in ae) && s(M, Fe, J[Fe], null, Le, V.children, de, ye, yt);
        for (const Fe in ae) {
          if (Hh(Fe)) continue;
          const ke = ae[Fe],
            De = J[Fe];
          ke !== De && Fe !== 'value' && s(M, Fe, De, ke, Le, V.children, de, ye, yt);
        }
        'value' in ae && s(M, 'value', J.value, ae.value);
      }
    },
    xe = (M, V, J, ae, de, ye, Le, Fe, ke) => {
      const De = (V.el = M ? M.el : l('')),
        Ge = (V.anchor = M ? M.anchor : l(''));
      let { patchFlag: He, dynamicChildren: Ze, slotScopeIds: et } = V;
      et && (Fe = Fe ? Fe.concat(et) : et),
        M == null
          ? (n(De, J, ae), n(Ge, J, ae), Y(V.children, J, Ge, de, ye, Le, Fe, ke))
          : He > 0 && He & 64 && Ze && M.dynamicChildren
          ? (X(M.dynamicChildren, Ze, J, de, ye, Le, Fe), (V.key != null || (de && V === de.subTree)) && Jb(M, V, !0))
          : G(M, V, J, Ge, de, ye, Le, Fe, ke);
    },
    Re = (M, V, J, ae, de, ye, Le, Fe, ke) => {
      (V.slotScopeIds = Fe),
        M == null
          ? V.shapeFlag & 512
            ? de.ctx.activate(V, J, ae, Le, ke)
            : re(V, J, ae, de, ye, Le, ke)
          : ie(M, V, ke);
    },
    re = (M, V, J, ae, de, ye, Le) => {
      const Fe = (M.component = xP(M, ae, de));
      if ((of(M) && (Fe.ctx.renderer = Te), CP(Fe), Fe.asyncDep)) {
        if ((de && de.registerDep(Fe, Q), !M.el)) {
          const ke = (Fe.subTree = z($n));
          w(null, ke, V, J);
        }
        return;
      }
      Q(Fe, M, V, J, de, ye, Le);
    },
    ie = (M, V, J) => {
      const ae = (V.component = M.component);
      if (Tk(M, V, J))
        if (ae.asyncDep && !ae.asyncResolved) {
          ce(ae, V, J);
          return;
        } else (ae.next = V), Ak(ae.update), ae.update();
      else (V.el = M.el), (ae.vnode = V);
    },
    Q = (M, V, J, ae, de, ye, Le) => {
      const Fe = () => {
          if (M.isMounted) {
            let { next: Ge, bu: He, u: Ze, parent: et, vnode: lt } = M,
              Mt = Ge,
              Et;
            Bo(M, !1),
              Ge ? ((Ge.el = lt.el), ce(M, Ge, Le)) : (Ge = lt),
              He && Rd(He),
              (Et = Ge.props && Ge.props.onVnodeBeforeUpdate) && Ai(Et, et, Ge, lt),
              Bo(M, !0);
            const Pt = jd(M),
              gr = M.subTree;
            (M.subTree = Pt),
              F(gr, Pt, m(gr.el), U(gr), M, de, ye),
              (Ge.el = Pt.el),
              Mt === null && kk(M, Pt.el),
              Ze && fn(Ze, de),
              (Et = Ge.props && Ge.props.onVnodeUpdated) && fn(() => Ai(Et, et, Ge, lt), de);
          } else {
            let Ge;
            const { el: He, props: Ze } = V,
              { bm: et, m: lt, parent: Mt } = M,
              Et = mu(V);
            if (
              (Bo(M, !1), et && Rd(et), !Et && (Ge = Ze && Ze.onVnodeBeforeMount) && Ai(Ge, Mt, V), Bo(M, !0), He && at)
            ) {
              const Pt = () => {
                (M.subTree = jd(M)), at(He, M.subTree, M, de, null);
              };
              Et ? V.type.__asyncLoader().then(() => !M.isUnmounted && Pt()) : Pt();
            } else {
              const Pt = (M.subTree = jd(M));
              F(null, Pt, J, ae, M, de, ye), (V.el = Pt.el);
            }
            if ((lt && fn(lt, de), !Et && (Ge = Ze && Ze.onVnodeMounted))) {
              const Pt = V;
              fn(() => Ai(Ge, Mt, Pt), de);
            }
            (V.shapeFlag & 256 || (Mt && mu(Mt.vnode) && Mt.vnode.shapeFlag & 256)) && M.a && fn(M.a, de),
              (M.isMounted = !0),
              (V = J = ae = null);
          }
        },
        ke = (M.effect = new Ag(Fe, () => kg(De), M.scope)),
        De = (M.update = () => ke.run());
      (De.id = M.uid), Bo(M, !0), De();
    },
    ce = (M, V, J) => {
      V.component = M;
      const ae = M.vnode.props;
      (M.vnode = V), (M.next = null), sP(M, V.props, ae, J), lP(M, V.children, J), ml(), wD(), gl();
    },
    G = (M, V, J, ae, de, ye, Le, Fe, ke = !1) => {
      const De = M && M.children,
        Ge = M ? M.shapeFlag : 0,
        He = V.children,
        { patchFlag: Ze, shapeFlag: et } = V;
      if (Ze > 0) {
        if (Ze & 128) {
          we(De, He, J, ae, de, ye, Le, Fe, ke);
          return;
        } else if (Ze & 256) {
          ge(De, He, J, ae, de, ye, Le, Fe, ke);
          return;
        }
      }
      et & 8
        ? (Ge & 16 && yt(De, de, ye), He !== De && f(J, He))
        : Ge & 16
        ? et & 16
          ? we(De, He, J, ae, de, ye, Le, Fe, ke)
          : yt(De, de, ye, !0)
        : (Ge & 8 && f(J, ''), et & 16 && Y(He, J, ae, de, ye, Le, Fe, ke));
    },
    ge = (M, V, J, ae, de, ye, Le, Fe, ke) => {
      (M = M || Ha), (V = V || Ha);
      const De = M.length,
        Ge = V.length,
        He = Math.min(De, Ge);
      let Ze;
      for (Ze = 0; Ze < He; Ze++) {
        const et = (V[Ze] = ke ? Ms(V[Ze]) : Ti(V[Ze]));
        F(M[Ze], et, J, null, de, ye, Le, Fe, ke);
      }
      De > Ge ? yt(M, de, ye, !0, !1, He) : Y(V, J, ae, de, ye, Le, Fe, ke, He);
    },
    we = (M, V, J, ae, de, ye, Le, Fe, ke) => {
      let De = 0;
      const Ge = V.length;
      let He = M.length - 1,
        Ze = Ge - 1;
      for (; De <= He && De <= Ze; ) {
        const et = M[De],
          lt = (V[De] = ke ? Ms(V[De]) : Ti(V[De]));
        if (Ro(et, lt)) F(et, lt, J, null, de, ye, Le, Fe, ke);
        else break;
        De++;
      }
      for (; De <= He && De <= Ze; ) {
        const et = M[He],
          lt = (V[Ze] = ke ? Ms(V[Ze]) : Ti(V[Ze]));
        if (Ro(et, lt)) F(et, lt, J, null, de, ye, Le, Fe, ke);
        else break;
        He--, Ze--;
      }
      if (De > He) {
        if (De <= Ze) {
          const et = Ze + 1,
            lt = et < Ge ? V[et].el : ae;
          for (; De <= Ze; ) F(null, (V[De] = ke ? Ms(V[De]) : Ti(V[De])), J, lt, de, ye, Le, Fe, ke), De++;
        }
      } else if (De > Ze) for (; De <= He; ) Qe(M[De], de, ye, !0), De++;
      else {
        const et = De,
          lt = De,
          Mt = new Map();
        for (De = lt; De <= Ze; De++) {
          const Fr = (V[De] = ke ? Ms(V[De]) : Ti(V[De]));
          Fr.key != null && Mt.set(Fr.key, De);
        }
        let Et,
          Pt = 0;
        const gr = Ze - lt + 1;
        let Xn = !1,
          qi = 0;
        const Ki = new Array(gr);
        for (De = 0; De < gr; De++) Ki[De] = 0;
        for (De = et; De <= He; De++) {
          const Fr = M[De];
          if (Pt >= gr) {
            Qe(Fr, de, ye, !0);
            continue;
          }
          let Pr;
          if (Fr.key != null) Pr = Mt.get(Fr.key);
          else
            for (Et = lt; Et <= Ze; Et++)
              if (Ki[Et - lt] === 0 && Ro(Fr, V[Et])) {
                Pr = Et;
                break;
              }
          Pr === void 0
            ? Qe(Fr, de, ye, !0)
            : ((Ki[Pr - lt] = De + 1),
              Pr >= qi ? (qi = Pr) : (Xn = !0),
              F(Fr, V[Pr], J, null, de, ye, Le, Fe, ke),
              Pt++);
        }
        const Ji = Xn ? hP(Ki) : Ha;
        for (Et = Ji.length - 1, De = gr - 1; De >= 0; De--) {
          const Fr = lt + De,
            Pr = V[Fr],
            hn = Fr + 1 < Ge ? V[Fr + 1].el : ae;
          Ki[De] === 0
            ? F(null, Pr, J, hn, de, ye, Le, Fe, ke)
            : Xn && (Et < 0 || De !== Ji[Et] ? je(Pr, J, hn, 2) : Et--);
        }
      }
    },
    je = (M, V, J, ae, de = null) => {
      const { el: ye, type: Le, transition: Fe, children: ke, shapeFlag: De } = M;
      if (De & 6) {
        je(M.component.subTree, V, J, ae);
        return;
      }
      if (De & 128) {
        M.suspense.move(V, J, ae);
        return;
      }
      if (De & 64) {
        Le.move(M, V, J, Te);
        return;
      }
      if (Le === $t) {
        n(ye, V, J);
        for (let He = 0; He < ke.length; He++) je(ke[He], V, J, ae);
        n(M.anchor, V, J);
        return;
      }
      if (Le === zd) {
        T(M, V, J);
        return;
      }
      if (ae !== 2 && De & 1 && Fe)
        if (ae === 0) Fe.beforeEnter(ye), n(ye, V, J), fn(() => Fe.enter(ye), de);
        else {
          const { leave: He, delayLeave: Ze, afterLeave: et } = Fe,
            lt = () => n(ye, V, J),
            Mt = () => {
              He(ye, () => {
                lt(), et && et();
              });
            };
          Ze ? Ze(ye, lt, Mt) : Mt();
        }
      else n(ye, V, J);
    },
    Qe = (M, V, J, ae = !1, de = !1) => {
      const {
        type: ye,
        props: Le,
        ref: Fe,
        children: ke,
        dynamicChildren: De,
        shapeFlag: Ge,
        patchFlag: He,
        dirs: Ze,
      } = M;
      if ((Fe != null && qm(Fe, null, J, M, !0), Ge & 256)) {
        V.ctx.deactivate(M);
        return;
      }
      const et = Ge & 1 && Ze,
        lt = !mu(M);
      let Mt;
      if ((lt && (Mt = Le && Le.onVnodeBeforeUnmount) && Ai(Mt, V, M), Ge & 6)) gt(M.component, J, ae);
      else {
        if (Ge & 128) {
          M.suspense.unmount(J, ae);
          return;
        }
        et && Po(M, null, V, 'beforeUnmount'),
          Ge & 64
            ? M.type.remove(M, V, J, de, Te, ae)
            : De && (ye !== $t || (He > 0 && He & 64))
            ? yt(De, V, J, !1, !0)
            : ((ye === $t && He & 384) || (!de && Ge & 16)) && yt(ke, V, J),
          ae && ot(M);
      }
      ((lt && (Mt = Le && Le.onVnodeUnmounted)) || et) &&
        fn(() => {
          Mt && Ai(Mt, V, M), et && Po(M, null, V, 'unmounted');
        }, J);
    },
    ot = (M) => {
      const { type: V, el: J, anchor: ae, transition: de } = M;
      if (V === $t) {
        pt(J, ae);
        return;
      }
      if (V === zd) {
        j(M);
        return;
      }
      const ye = () => {
        i(J), de && !de.persisted && de.afterLeave && de.afterLeave();
      };
      if (M.shapeFlag & 1 && de && !de.persisted) {
        const { leave: Le, delayLeave: Fe } = de,
          ke = () => Le(J, ye);
        Fe ? Fe(M.el, ye, ke) : ke();
      } else ye();
    },
    pt = (M, V) => {
      let J;
      for (; M !== V; ) (J = g(M)), i(M), (M = J);
      i(V);
    },
    gt = (M, V, J) => {
      const { bum: ae, scope: de, update: ye, subTree: Le, um: Fe } = M;
      ae && Rd(ae),
        de.stop(),
        ye && ((ye.active = !1), Qe(Le, M, V, J)),
        Fe && fn(Fe, V),
        fn(() => {
          M.isUnmounted = !0;
        }, V),
        V &&
          V.pendingBranch &&
          !V.isUnmounted &&
          M.asyncDep &&
          !M.asyncResolved &&
          M.suspenseId === V.pendingId &&
          (V.deps--, V.deps === 0 && V.resolve());
    },
    yt = (M, V, J, ae = !1, de = !1, ye = 0) => {
      for (let Le = ye; Le < M.length; Le++) Qe(M[Le], V, J, ae, de);
    },
    U = (M) => (M.shapeFlag & 6 ? U(M.component.subTree) : M.shapeFlag & 128 ? M.suspense.next() : g(M.anchor || M.el)),
    he = (M, V, J) => {
      M == null ? V._vnode && Qe(V._vnode, null, null, !0) : F(V._vnode || null, M, V, null, null, null, J),
        wD(),
        wb(),
        (V._vnode = M);
    },
    Te = { p: F, um: Qe, m: je, r: ot, mt: re, mc: Y, pc: G, pbc: X, n: U, o: t };
  let fe, at;
  return e && ([fe, at] = e(Te)), { render: he, hydrate: fe, createApp: rP(he, fe) };
}
function Bo({ effect: t, update: e }, r) {
  t.allowRecurse = e.allowRecurse = r;
}
function Jb(t, e, r = !1) {
  const n = t.children,
    i = e.children;
  if (st(n) && st(i))
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      let l = i[s];
      l.shapeFlag & 1 &&
        !l.dynamicChildren &&
        ((l.patchFlag <= 0 || l.patchFlag === 32) && ((l = i[s] = Ms(i[s])), (l.el = o.el)), r || Jb(o, l)),
        l.type === lf && (l.el = o.el);
    }
}
function hP(t) {
  const e = t.slice(),
    r = [0];
  let n, i, s, o, l;
  const c = t.length;
  for (n = 0; n < c; n++) {
    const p = t[n];
    if (p !== 0) {
      if (((i = r[r.length - 1]), t[i] < p)) {
        (e[n] = i), r.push(n);
        continue;
      }
      for (s = 0, o = r.length - 1; s < o; ) (l = (s + o) >> 1), t[r[l]] < p ? (s = l + 1) : (o = l);
      p < t[r[s]] && (s > 0 && (e[n] = r[s - 1]), (r[s] = n));
    }
  }
  for (s = r.length, o = r[s - 1]; s-- > 0; ) (r[s] = o), (o = e[o]);
  return r;
}
const pP = (t) => t.__isTeleport,
  $t = Symbol.for('v-fgt'),
  lf = Symbol.for('v-txt'),
  $n = Symbol.for('v-cmt'),
  zd = Symbol.for('v-stc'),
  yu = [];
let ii = null;
function Ne(t = !1) {
  yu.push((ii = t ? null : []));
}
function fP() {
  yu.pop(), (ii = yu[yu.length - 1] || null);
}
let Lu = 1;
function jD(t) {
  Lu += t;
}
function Xb(t) {
  return (t.dynamicChildren = Lu > 0 ? ii || Ha : null), fP(), Lu > 0 && ii && ii.push(t), t;
}
function rt(t, e, r, n, i, s) {
  return Xb($e(t, e, r, n, i, s, !0));
}
function nr(t, e, r, n, i) {
  return Xb(z(t, e, r, n, i, !0));
}
function cp(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function Ro(t, e) {
  return t.type === e.type && t.key === e.key;
}
const uf = '__vInternal',
  Gb = ({ key: t }) => t ?? null,
  Uh = ({ ref: t, ref_key: e, ref_for: r }) => (
    typeof t == 'number' && (t = '' + t),
    t != null ? (pr(t) || tr(t) || ht(t) ? { i: Tr, r: t, k: e, f: !!r } : t) : null
  );
function $e(t, e = null, r = null, n = 0, i = null, s = t === $t ? 0 : 1, o = !1, l = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && Gb(e),
    ref: e && Uh(e),
    scopeId: sf,
    slotScopeIds: null,
    children: r,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: n,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: Tr,
  };
  return (
    l ? (Og(c, r), s & 128 && t.normalize(c)) : r && (c.shapeFlag |= pr(r) ? 8 : 16),
    Lu > 0 && !o && ii && (c.patchFlag > 0 || s & 6) && c.patchFlag !== 32 && ii.push(c),
    c
  );
}
const z = dP;
function dP(t, e = null, r = null, n = 0, i = null, s = !1) {
  if (((!t || t === _b) && (t = $n), cp(t))) {
    const l = eo(t, e, !0);
    return (
      r && Og(l, r),
      Lu > 0 && !s && ii && (l.shapeFlag & 6 ? (ii[ii.indexOf(t)] = l) : ii.push(l)),
      (l.patchFlag |= -2),
      l
    );
  }
  if ((vP(t) && (t = t.__vccOpts), e)) {
    e = mP(e);
    let { class: l, style: c } = e;
    l && !pr(l) && (e.class = Gt(l)), Wt(c) && (xb(c) && !st(c) && (c = mr({}, c)), (e.style = Us(c)));
  }
  const o = pr(t) ? 1 : Pk(t) ? 128 : pP(t) ? 64 : Wt(t) ? 4 : ht(t) ? 2 : 0;
  return $e(t, e, r, n, i, o, s, !0);
}
function mP(t) {
  return t ? (xb(t) || uf in t ? mr({}, t) : t) : null;
}
function eo(t, e, r = !1) {
  const { props: n, ref: i, patchFlag: s, children: o } = t,
    l = e ? gP(n || {}, e) : n;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: l,
    key: l && Gb(l),
    ref: e && e.ref ? (r && i ? (st(i) ? i.concat(Uh(e)) : [i, Uh(e)]) : Uh(e)) : i,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: o,
    target: t.target,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    patchFlag: e && t.type !== $t ? (s === -1 ? 16 : s | 16) : s,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: t.transition,
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && eo(t.ssContent),
    ssFallback: t.ssFallback && eo(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce,
  };
}
function Dn(t = ' ', e = 0) {
  return z(lf, null, t, e);
}
function Ni(t = '', e = !1) {
  return e ? (Ne(), nr($n, null, t)) : z($n, null, t);
}
function Ti(t) {
  return t == null || typeof t == 'boolean'
    ? z($n)
    : st(t)
    ? z($t, null, t.slice())
    : typeof t == 'object'
    ? Ms(t)
    : z(lf, null, String(t));
}
function Ms(t) {
  return (t.el === null && t.patchFlag !== -1) || t.memo ? t : eo(t);
}
function Og(t, e) {
  let r = 0;
  const { shapeFlag: n } = t;
  if (e == null) e = null;
  else if (st(e)) r = 16;
  else if (typeof e == 'object')
    if (n & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), Og(t, i()), i._c && (i._d = !0));
      return;
    } else {
      r = 32;
      const i = e._;
      !i && !(uf in e)
        ? (e._ctx = Tr)
        : i === 3 && Tr && (Tr.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (t.patchFlag |= 1024)));
    }
  else
    ht(e)
      ? ((e = { default: e, _ctx: Tr }), (r = 32))
      : ((e = String(e)), n & 64 ? ((r = 16), (e = [Dn(e)])) : (r = 8));
  (t.children = e), (t.shapeFlag |= r);
}
function gP(...t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    for (const i in n)
      if (i === 'class') e.class !== n.class && (e.class = Gt([e.class, n.class]));
      else if (i === 'style') e.style = Us([e.style, n.style]);
      else if (Xp(i)) {
        const s = e[i],
          o = n[i];
        o && s !== o && !(st(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o);
      } else i !== '' && (e[i] = n[i]);
  }
  return e;
}
function Ai(t, e, r, n = null) {
  jn(t, e, 7, [r, n]);
}
const yP = zb();
let DP = 0;
function xP(t, e, r) {
  const n = t.type,
    i = (e ? e.appContext : t.appContext) || yP,
    s = {
      uid: DP++,
      vnode: t,
      type: n,
      parent: e,
      appContext: i,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new sb(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: e ? e.provides : Object.create(i.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: Wb(n, i),
      emitsOptions: kb(n, i),
      emit: null,
      emitted: null,
      propsDefaults: Jt,
      inheritAttrs: n.inheritAttrs,
      ctx: Jt,
      data: Jt,
      props: Jt,
      attrs: Jt,
      slots: Jt,
      refs: Jt,
      setupState: Jt,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense: r,
      suspenseId: r ? r.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null,
    };
  return (s.ctx = { _: s }), (s.root = e ? e.root : s), (s.emit = Fk.bind(null, s)), t.ce && t.ce(s), s;
}
let br = null;
const cf = () => br || Tr;
let Lg,
  ka,
  $D = '__VUE_INSTANCE_SETTERS__';
(ka = Om()[$D]) || (ka = Om()[$D] = []),
  ka.push((t) => (br = t)),
  (Lg = (t) => {
    ka.length > 1 ? ka.forEach((e) => e(t)) : ka[0](t);
  });
const el = (t) => {
    Lg(t), t.scope.on();
  },
  Go = () => {
    br && br.scope.off(), Lg(null);
  };
function Yb(t) {
  return t.vnode.shapeFlag & 4;
}
let _u = !1;
function CP(t, e = !1) {
  _u = e;
  const { props: r, children: n } = t.vnode,
    i = Yb(t);
  iP(t, r, i, e), aP(t, n);
  const s = i ? bP(t, e) : void 0;
  return (_u = !1), s;
}
function bP(t, e) {
  const r = t.type;
  (t.accessCache = Object.create(null)), (t.proxy = tf(new Proxy(t.ctx, Jk)));
  const { setup: n } = r;
  if (n) {
    const i = (t.setupContext = n.length > 1 ? Zb(t) : null);
    el(t), ml();
    const s = Ks(n, t, 0, [t.props, i]);
    if ((gl(), Go(), eb(s))) {
      if ((s.then(Go, Go), e))
        return s
          .then((o) => {
            VD(t, o, e);
          })
          .catch((o) => {
            rf(o, t, 0);
          });
      t.asyncDep = s;
    } else VD(t, s, e);
  } else Qb(t, e);
}
function VD(t, e, r) {
  ht(e) ? (t.type.__ssrInlineRender ? (t.ssrRender = e) : (t.render = e)) : Wt(e) && (t.setupState = Eb(e)), Qb(t, r);
}
let zD;
function Qb(t, e, r) {
  const n = t.type;
  if (!t.render) {
    if (!e && zD && !n.render) {
      const i = n.template || Ng(t).template;
      if (i) {
        const { isCustomElement: s, compilerOptions: o } = t.appContext.config,
          { delimiters: l, compilerOptions: c } = n,
          p = mr(mr({ isCustomElement: s, delimiters: l }, o), c);
        n.render = zD(i, p);
      }
    }
    t.render = n.render || oi;
  }
  el(t), ml(), Gk(t), gl(), Go();
}
function AP(t) {
  return (
    t.attrsProxy ||
    (t.attrsProxy = new Proxy(t.attrs, {
      get(e, r) {
        return yn(t, 'get', '$attrs'), e[r];
      },
    }))
  );
}
function Zb(t) {
  const e = (r) => {
    t.exposed = r || {};
  };
  return {
    get attrs() {
      return AP(t);
    },
    slots: t.slots,
    emit: t.emit,
    expose: e,
  };
}
function hf(t) {
  if (t.exposed)
    return (
      t.exposeProxy ||
      (t.exposeProxy = new Proxy(Eb(tf(t.exposed)), {
        get(e, r) {
          if (r in e) return e[r];
          if (r in gu) return gu[r](t);
        },
        has(e, r) {
          return r in e || r in gu;
        },
      }))
    );
}
function EP(t, e = !0) {
  return ht(t) ? t.displayName || t.name : t.name || (e && t.__name);
}
function vP(t) {
  return ht(t) && '__vccOpts' in t;
}
const nt = (t, e) => xk(t, e, _u);
function pf(t, e, r) {
  const n = arguments.length;
  return n === 2
    ? Wt(e) && !st(e)
      ? cp(e)
        ? z(t, null, [e])
        : z(t, e)
      : z(t, null, e)
    : (n > 3 ? (r = Array.prototype.slice.call(arguments, 2)) : n === 3 && cp(r) && (r = [r]), z(t, e, r));
}
const FP = Symbol.for('v-scx'),
  SP = () => kn(FP),
  wP = '3.3.4',
  TP = 'http://www.w3.org/2000/svg',
  jo = typeof document < 'u' ? document : null,
  HD = jo && jo.createElement('template'),
  kP = {
    insert: (t, e, r) => {
      e.insertBefore(t, r || null);
    },
    remove: (t) => {
      const e = t.parentNode;
      e && e.removeChild(t);
    },
    createElement: (t, e, r, n) => {
      const i = e ? jo.createElementNS(TP, t) : jo.createElement(t, r ? { is: r } : void 0);
      return t === 'select' && n && n.multiple != null && i.setAttribute('multiple', n.multiple), i;
    },
    createText: (t) => jo.createTextNode(t),
    createComment: (t) => jo.createComment(t),
    setText: (t, e) => {
      t.nodeValue = e;
    },
    setElementText: (t, e) => {
      t.textContent = e;
    },
    parentNode: (t) => t.parentNode,
    nextSibling: (t) => t.nextSibling,
    querySelector: (t) => jo.querySelector(t),
    setScopeId(t, e) {
      t.setAttribute(e, '');
    },
    insertStaticContent(t, e, r, n, i, s) {
      const o = r ? r.previousSibling : e.lastChild;
      if (i && (i === s || i.nextSibling))
        for (; e.insertBefore(i.cloneNode(!0), r), !(i === s || !(i = i.nextSibling)); );
      else {
        HD.innerHTML = n ? `<svg>${t}</svg>` : t;
        const l = HD.content;
        if (n) {
          const c = l.firstChild;
          for (; c.firstChild; ) l.appendChild(c.firstChild);
          l.removeChild(c);
        }
        e.insertBefore(l, r);
      }
      return [o ? o.nextSibling : e.firstChild, r ? r.previousSibling : e.lastChild];
    },
  };
function PP(t, e, r) {
  const n = t._vtc;
  n && (e = (e ? [e, ...n] : [...n]).join(' ')),
    e == null ? t.removeAttribute('class') : r ? t.setAttribute('class', e) : (t.className = e);
}
function BP(t, e, r) {
  const n = t.style,
    i = pr(r);
  if (r && !i) {
    if (e && !pr(e)) for (const s in e) r[s] == null && Km(n, s, '');
    for (const s in r) Km(n, s, r[s]);
  } else {
    const s = n.display;
    i ? e !== r && (n.cssText = r) : e && t.removeAttribute('style'), '_vod' in t && (n.display = s);
  }
}
const WD = /\s*!important$/;
function Km(t, e, r) {
  if (st(r)) r.forEach((n) => Km(t, e, n));
  else if ((r == null && (r = ''), e.startsWith('--'))) t.setProperty(e, r);
  else {
    const n = IP(t, e);
    WD.test(r) ? t.setProperty(aa(n), r.replace(WD, ''), 'important') : (t[n] = r);
  }
}
const UD = ['Webkit', 'Moz', 'ms'],
  Hd = {};
function IP(t, e) {
  const r = Hd[e];
  if (r) return r;
  let n = $i(e);
  if (n !== 'filter' && n in t) return (Hd[e] = n);
  n = Qp(n);
  for (let i = 0; i < UD.length; i++) {
    const s = UD[i] + n;
    if (s in t) return (Hd[e] = s);
  }
  return e;
}
const qD = 'http://www.w3.org/1999/xlink';
function NP(t, e, r, n, i) {
  if (n && e.startsWith('xlink:'))
    r == null ? t.removeAttributeNS(qD, e.slice(6, e.length)) : t.setAttributeNS(qD, e, r);
  else {
    const s = _T(e);
    r == null || (s && !nb(r)) ? t.removeAttribute(e) : t.setAttribute(e, s ? '' : r);
  }
}
function MP(t, e, r, n, i, s, o) {
  if (e === 'innerHTML' || e === 'textContent') {
    n && o(n, i, s), (t[e] = r ?? '');
    return;
  }
  const l = t.tagName;
  if (e === 'value' && l !== 'PROGRESS' && !l.includes('-')) {
    t._value = r;
    const p = l === 'OPTION' ? t.getAttribute('value') : t.value,
      f = r ?? '';
    p !== f && (t.value = f), r == null && t.removeAttribute(e);
    return;
  }
  let c = !1;
  if (r === '' || r == null) {
    const p = typeof t[e];
    p === 'boolean'
      ? (r = nb(r))
      : r == null && p === 'string'
      ? ((r = ''), (c = !0))
      : p === 'number' && ((r = 0), (c = !0));
  }
  try {
    t[e] = r;
  } catch {}
  c && t.removeAttribute(e);
}
function OP(t, e, r, n) {
  t.addEventListener(e, r, n);
}
function LP(t, e, r, n) {
  t.removeEventListener(e, r, n);
}
function _P(t, e, r, n, i = null) {
  const s = t._vei || (t._vei = {}),
    o = s[e];
  if (n && o) o.value = n;
  else {
    const [l, c] = RP(e);
    if (n) {
      const p = (s[e] = VP(n, i));
      OP(t, l, p, c);
    } else o && (LP(t, l, o, c), (s[e] = void 0));
  }
}
const KD = /(?:Once|Passive|Capture)$/;
function RP(t) {
  let e;
  if (KD.test(t)) {
    e = {};
    let n;
    for (; (n = t.match(KD)); ) (t = t.slice(0, t.length - n[0].length)), (e[n[0].toLowerCase()] = !0);
  }
  return [t[2] === ':' ? t.slice(3) : aa(t.slice(2)), e];
}
let Wd = 0;
const jP = Promise.resolve(),
  $P = () => Wd || (jP.then(() => (Wd = 0)), (Wd = Date.now()));
function VP(t, e) {
  const r = (n) => {
    if (!n._vts) n._vts = Date.now();
    else if (n._vts <= r.attached) return;
    jn(zP(n, r.value), e, 5, [n]);
  };
  return (r.value = t), (r.attached = $P()), r;
}
function zP(t, e) {
  if (st(e)) {
    const r = t.stopImmediatePropagation;
    return (
      (t.stopImmediatePropagation = () => {
        r.call(t), (t._stopped = !0);
      }),
      e.map((n) => (i) => !i._stopped && n && n(i))
    );
  } else return e;
}
const JD = /^on[a-z]/,
  HP = (t, e, r, n, i = !1, s, o, l, c) => {
    e === 'class'
      ? PP(t, n, i)
      : e === 'style'
      ? BP(t, r, n)
      : Xp(e)
      ? yg(e) || _P(t, e, r, n, o)
      : (e[0] === '.' ? ((e = e.slice(1)), !0) : e[0] === '^' ? ((e = e.slice(1)), !1) : WP(t, e, n, i))
      ? MP(t, e, n, s, o, l, c)
      : (e === 'true-value' ? (t._trueValue = n) : e === 'false-value' && (t._falseValue = n), NP(t, e, n, i));
  };
function WP(t, e, r, n) {
  return n
    ? !!(e === 'innerHTML' || e === 'textContent' || (e in t && JD.test(e) && ht(r)))
    : e === 'spellcheck' ||
      e === 'draggable' ||
      e === 'translate' ||
      e === 'form' ||
      (e === 'list' && t.tagName === 'INPUT') ||
      (e === 'type' && t.tagName === 'TEXTAREA') ||
      (JD.test(e) && pr(r))
    ? !1
    : e in t;
}
const ws = 'transition',
  Xl = 'animation',
  _g = (t, { slots: e }) => pf(Lk, UP(t), e);
_g.displayName = 'Transition';
const eA = {
  name: String,
  type: String,
  css: { type: Boolean, default: !0 },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String,
};
_g.props = mr({}, Ib, eA);
const Io = (t, e = []) => {
    st(t) ? t.forEach((r) => r(...e)) : t && t(...e);
  },
  XD = (t) => (t ? (st(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1);
function UP(t) {
  const e = {};
  for (const xe in t) xe in eA || (e[xe] = t[xe]);
  if (t.css === !1) return e;
  const {
      name: r = 'v',
      type: n,
      duration: i,
      enterFromClass: s = `${r}-enter-from`,
      enterActiveClass: o = `${r}-enter-active`,
      enterToClass: l = `${r}-enter-to`,
      appearFromClass: c = s,
      appearActiveClass: p = o,
      appearToClass: f = l,
      leaveFromClass: m = `${r}-leave-from`,
      leaveActiveClass: g = `${r}-leave-active`,
      leaveToClass: x = `${r}-leave-to`,
    } = t,
    b = qP(i),
    F = b && b[0],
    E = b && b[1],
    {
      onBeforeEnter: w,
      onEnter: I,
      onEnterCancelled: T,
      onLeave: j,
      onLeaveCancelled: $,
      onBeforeAppear: L = w,
      onAppear: se = I,
      onAppearCancelled: Y = T,
    } = e,
    W = (xe, Re, re) => {
      No(xe, Re ? f : l), No(xe, Re ? p : o), re && re();
    },
    X = (xe, Re) => {
      (xe._isLeaving = !1), No(xe, m), No(xe, x), No(xe, g), Re && Re();
    },
    q = (xe) => (Re, re) => {
      const ie = xe ? se : I,
        Q = () => W(Re, xe, re);
      Io(ie, [Re, Q]),
        GD(() => {
          No(Re, xe ? c : s), Ts(Re, xe ? f : l), XD(ie) || YD(Re, n, F, Q);
        });
    };
  return mr(e, {
    onBeforeEnter(xe) {
      Io(w, [xe]), Ts(xe, s), Ts(xe, o);
    },
    onBeforeAppear(xe) {
      Io(L, [xe]), Ts(xe, c), Ts(xe, p);
    },
    onEnter: q(!1),
    onAppear: q(!0),
    onLeave(xe, Re) {
      xe._isLeaving = !0;
      const re = () => X(xe, Re);
      Ts(xe, m),
        XP(),
        Ts(xe, g),
        GD(() => {
          xe._isLeaving && (No(xe, m), Ts(xe, x), XD(j) || YD(xe, n, E, re));
        }),
        Io(j, [xe, re]);
    },
    onEnterCancelled(xe) {
      W(xe, !1), Io(T, [xe]);
    },
    onAppearCancelled(xe) {
      W(xe, !0), Io(Y, [xe]);
    },
    onLeaveCancelled(xe) {
      X(xe), Io($, [xe]);
    },
  });
}
function qP(t) {
  if (t == null) return null;
  if (Wt(t)) return [Ud(t.enter), Ud(t.leave)];
  {
    const e = Ud(t);
    return [e, e];
  }
}
function Ud(t) {
  return BT(t);
}
function Ts(t, e) {
  e.split(/\s+/).forEach((r) => r && t.classList.add(r)), (t._vtc || (t._vtc = new Set())).add(e);
}
function No(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.remove(n));
  const { _vtc: r } = t;
  r && (r.delete(e), r.size || (t._vtc = void 0));
}
function GD(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let KP = 0;
function YD(t, e, r, n) {
  const i = (t._endId = ++KP),
    s = () => {
      i === t._endId && n();
    };
  if (r) return setTimeout(s, r);
  const { type: o, timeout: l, propCount: c } = JP(t, e);
  if (!o) return n();
  const p = o + 'end';
  let f = 0;
  const m = () => {
      t.removeEventListener(p, g), s();
    },
    g = (x) => {
      x.target === t && ++f >= c && m();
    };
  setTimeout(() => {
    f < c && m();
  }, l + 1),
    t.addEventListener(p, g);
}
function JP(t, e) {
  const r = window.getComputedStyle(t),
    n = (b) => (r[b] || '').split(', '),
    i = n(`${ws}Delay`),
    s = n(`${ws}Duration`),
    o = QD(i, s),
    l = n(`${Xl}Delay`),
    c = n(`${Xl}Duration`),
    p = QD(l, c);
  let f = null,
    m = 0,
    g = 0;
  e === ws
    ? o > 0 && ((f = ws), (m = o), (g = s.length))
    : e === Xl
    ? p > 0 && ((f = Xl), (m = p), (g = c.length))
    : ((m = Math.max(o, p)), (f = m > 0 ? (o > p ? ws : Xl) : null), (g = f ? (f === ws ? s.length : c.length) : 0));
  const x = f === ws && /\b(transform|all)(,|$)/.test(n(`${ws}Property`).toString());
  return { type: f, timeout: m, propCount: g, hasTransform: x };
}
function QD(t, e) {
  for (; t.length < e.length; ) t = t.concat(t);
  return Math.max(...e.map((r, n) => ZD(r) + ZD(t[n])));
}
function ZD(t) {
  return Number(t.slice(0, -1).replace(',', '.')) * 1e3;
}
function XP() {
  return document.body.offsetHeight;
}
const GP = ['ctrl', 'shift', 'alt', 'meta'],
  YP = {
    stop: (t) => t.stopPropagation(),
    prevent: (t) => t.preventDefault(),
    self: (t) => t.target !== t.currentTarget,
    ctrl: (t) => !t.ctrlKey,
    shift: (t) => !t.shiftKey,
    alt: (t) => !t.altKey,
    meta: (t) => !t.metaKey,
    left: (t) => 'button' in t && t.button !== 0,
    middle: (t) => 'button' in t && t.button !== 1,
    right: (t) => 'button' in t && t.button !== 2,
    exact: (t, e) => GP.some((r) => t[`${r}Key`] && !e.includes(r)),
  },
  Or =
    (t, e) =>
    (r, ...n) => {
      for (let i = 0; i < e.length; i++) {
        const s = YP[e[i]];
        if (s && s(r, e)) return;
      }
      return t(r, ...n);
    },
  QP = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace',
  },
  Vi = (t, e) => (r) => {
    if (!('key' in r)) return;
    const n = aa(r.key);
    if (e.some((i) => i === n || QP[i] === n)) return t(r);
  },
  tA = {
    beforeMount(t, { value: e }, { transition: r }) {
      (t._vod = t.style.display === 'none' ? '' : t.style.display), r && e ? r.beforeEnter(t) : Gl(t, e);
    },
    mounted(t, { value: e }, { transition: r }) {
      r && e && r.enter(t);
    },
    updated(t, { value: e, oldValue: r }, { transition: n }) {
      !e != !r &&
        (n
          ? e
            ? (n.beforeEnter(t), Gl(t, !0), n.enter(t))
            : n.leave(t, () => {
                Gl(t, !1);
              })
          : Gl(t, e));
    },
    beforeUnmount(t, { value: e }) {
      Gl(t, e);
    },
  };
function Gl(t, e) {
  t.style.display = e ? t._vod : 'none';
}
const ZP = mr({ patchProp: HP }, kP);
let e1;
function rA() {
  return e1 || (e1 = uP(ZP));
}
const t1 = (...t) => {
    rA().render(...t);
  },
  e3 = (...t) => {
    const e = rA().createApp(...t),
      { mount: r } = e;
    return (
      (e.mount = (n) => {
        const i = t3(n);
        if (!i) return;
        const s = e._component;
        !ht(s) && !s.render && !s.template && (s.template = i.innerHTML), (i.innerHTML = '');
        const o = r(i, !1, i instanceof SVGElement);
        return i instanceof Element && (i.removeAttribute('v-cloak'), i.setAttribute('data-v-app', '')), o;
      }),
      e
    );
  };
function t3(t) {
  return pr(t) ? document.querySelector(t) : t;
}
var r3 = !1;
/*!
 * pinia v2.1.6
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ let nA;
const ff = (t) => (nA = t),
  iA = Symbol();
function Jm(t) {
  return (
    t &&
    typeof t == 'object' &&
    Object.prototype.toString.call(t) === '[object Object]' &&
    typeof t.toJSON != 'function'
  );
}
var Du;
(function (t) {
  (t.direct = 'direct'), (t.patchObject = 'patch object'), (t.patchFunction = 'patch function');
})(Du || (Du = {}));
function n3() {
  const t = ob(!0),
    e = t.run(() => tt({}));
  let r = [],
    n = [];
  const i = tf({
    install(s) {
      ff(i),
        (i._a = s),
        s.provide(iA, i),
        (s.config.globalProperties.$pinia = i),
        n.forEach((o) => r.push(o)),
        (n = []);
    },
    use(s) {
      return !this._a && !r3 ? n.push(s) : r.push(s), this;
    },
    _p: r,
    _a: null,
    _e: t,
    _s: new Map(),
    state: e,
  });
  return i;
}
const sA = () => {};
function r1(t, e, r, n = sA) {
  t.push(e);
  const i = () => {
    const s = t.indexOf(e);
    s > -1 && (t.splice(s, 1), n());
  };
  return !r && Zp() && ab(i), i;
}
function Pa(t, ...e) {
  t.slice().forEach((r) => {
    r(...e);
  });
}
const i3 = (t) => t();
function Xm(t, e) {
  t instanceof Map && e instanceof Map && e.forEach((r, n) => t.set(n, r)),
    t instanceof Set && e instanceof Set && e.forEach(t.add, t);
  for (const r in e) {
    if (!e.hasOwnProperty(r)) continue;
    const n = e[r],
      i = t[r];
    Jm(i) && Jm(n) && t.hasOwnProperty(r) && !tr(n) && !ns(n) ? (t[r] = Xm(i, n)) : (t[r] = n);
  }
  return t;
}
const s3 = Symbol();
function o3(t) {
  return !Jm(t) || !t.hasOwnProperty(s3);
}
const { assign: Is } = Object;
function a3(t) {
  return !!(tr(t) && t.effect);
}
function l3(t, e, r, n) {
  const { state: i, actions: s, getters: o } = e,
    l = r.state.value[t];
  let c;
  function p() {
    l || (r.state.value[t] = i ? i() : {});
    const f = dk(r.state.value[t]);
    return Is(
      f,
      s,
      Object.keys(o || {}).reduce(
        (m, g) => (
          (m[g] = tf(
            nt(() => {
              ff(r);
              const x = r._s.get(t);
              return o[g].call(x, x);
            }),
          )),
          m
        ),
        {},
      ),
    );
  }
  return (c = oA(t, p, e, r, n, !0)), c;
}
function oA(t, e, r = {}, n, i, s) {
  let o;
  const l = Is({ actions: {} }, r),
    c = { deep: !0 };
  let p,
    f,
    m = [],
    g = [],
    x;
  const b = n.state.value[t];
  !s && !b && (n.state.value[t] = {}), tt({});
  let F;
  function E(Y) {
    let W;
    (p = f = !1),
      typeof Y == 'function'
        ? (Y(n.state.value[t]), (W = { type: Du.patchFunction, storeId: t, events: x }))
        : (Xm(n.state.value[t], Y), (W = { type: Du.patchObject, payload: Y, storeId: t, events: x }));
    const X = (F = Symbol());
    gi().then(() => {
      F === X && (p = !0);
    }),
      (f = !0),
      Pa(m, W, n.state.value[t]);
  }
  const w = s
    ? function () {
        const { state: W } = r,
          X = W ? W() : {};
        this.$patch((q) => {
          Is(q, X);
        });
      }
    : sA;
  function I() {
    o.stop(), (m = []), (g = []), n._s.delete(t);
  }
  function T(Y, W) {
    return function () {
      ff(n);
      const X = Array.from(arguments),
        q = [],
        xe = [];
      function Re(Q) {
        q.push(Q);
      }
      function re(Q) {
        xe.push(Q);
      }
      Pa(g, { args: X, name: Y, store: $, after: Re, onError: re });
      let ie;
      try {
        ie = W.apply(this && this.$id === t ? this : $, X);
      } catch (Q) {
        throw (Pa(xe, Q), Q);
      }
      return ie instanceof Promise
        ? ie.then((Q) => (Pa(q, Q), Q)).catch((Q) => (Pa(xe, Q), Promise.reject(Q)))
        : (Pa(q, ie), ie);
    };
  }
  const j = {
      _p: n,
      $id: t,
      $onAction: r1.bind(null, g),
      $patch: E,
      $reset: w,
      $subscribe(Y, W = {}) {
        const X = r1(m, Y, W.detached, () => q()),
          q = o.run(() =>
            Zt(
              () => n.state.value[t],
              (xe) => {
                (W.flush === 'sync' ? f : p) && Y({ storeId: t, type: Du.direct, events: x }, xe);
              },
              Is({}, c, W),
            ),
          );
        return X;
      },
      $dispose: I,
    },
    $ = yl(j);
  n._s.set(t, $);
  const L = (n._a && n._a.runWithContext) || i3,
    se = n._e.run(() => ((o = ob()), L(() => o.run(e))));
  for (const Y in se) {
    const W = se[Y];
    if ((tr(W) && !a3(W)) || ns(W))
      s || (b && o3(W) && (tr(W) ? (W.value = b[Y]) : Xm(W, b[Y])), (n.state.value[t][Y] = W));
    else if (typeof W == 'function') {
      const X = T(Y, W);
      (se[Y] = X), (l.actions[Y] = W);
    }
  }
  return (
    Is($, se),
    Is(bt($), se),
    Object.defineProperty($, '$state', {
      get: () => n.state.value[t],
      set: (Y) => {
        E((W) => {
          Is(W, Y);
        });
      },
    }),
    n._p.forEach((Y) => {
      Is(
        $,
        o.run(() => Y({ store: $, app: n._a, pinia: n, options: l })),
      );
    }),
    b && s && r.hydrate && r.hydrate($.$state, b),
    (p = !0),
    (f = !0),
    $
  );
}
function df(t, e, r) {
  let n, i;
  const s = typeof e == 'function';
  typeof t == 'string' ? ((n = t), (i = s ? r : e)) : ((i = t), (n = t.id));
  function o(l, c) {
    const p = nP();
    return (
      (l = l || (p ? kn(iA, null) : null)),
      l && ff(l),
      (l = nA),
      l._s.has(n) || (s ? oA(n, e, i, l) : l3(n, i, l)),
      l._s.get(n)
    );
  }
  return (o.$id = n), o;
}
function u3(t) {
  {
    t = bt(t);
    const e = {};
    for (const r in t) {
      const n = t[r];
      (tr(n) || ns(n)) && (e[r] = yk(t, r));
    }
    return e;
  }
}
/*!
 * vue-router v4.2.5
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ const Ma = typeof window < 'u';
function c3(t) {
  return t.__esModule || t[Symbol.toStringTag] === 'Module';
}
const jt = Object.assign;
function qd(t, e) {
  const r = {};
  for (const n in e) {
    const i = e[n];
    r[n] = fi(i) ? i.map(t) : t(i);
  }
  return r;
}
const xu = () => {},
  fi = Array.isArray,
  h3 = /\/$/,
  p3 = (t) => t.replace(h3, '');
function Kd(t, e, r = '/') {
  let n,
    i = {},
    s = '',
    o = '';
  const l = e.indexOf('#');
  let c = e.indexOf('?');
  return (
    l < c && l >= 0 && (c = -1),
    c > -1 && ((n = e.slice(0, c)), (s = e.slice(c + 1, l > -1 ? l : e.length)), (i = t(s))),
    l > -1 && ((n = n || e.slice(0, l)), (o = e.slice(l, e.length))),
    (n = g3(n ?? e, r)),
    { fullPath: n + (s && '?') + s + o, path: n, query: i, hash: o }
  );
}
function f3(t, e) {
  const r = e.query ? t(e.query) : '';
  return e.path + (r && '?') + r + (e.hash || '');
}
function n1(t, e) {
  return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || '/';
}
function d3(t, e, r) {
  const n = e.matched.length - 1,
    i = r.matched.length - 1;
  return (
    n > -1 &&
    n === i &&
    tl(e.matched[n], r.matched[i]) &&
    aA(e.params, r.params) &&
    t(e.query) === t(r.query) &&
    e.hash === r.hash
  );
}
function tl(t, e) {
  return (t.aliasOf || t) === (e.aliasOf || e);
}
function aA(t, e) {
  if (Object.keys(t).length !== Object.keys(e).length) return !1;
  for (const r in t) if (!m3(t[r], e[r])) return !1;
  return !0;
}
function m3(t, e) {
  return fi(t) ? i1(t, e) : fi(e) ? i1(e, t) : t === e;
}
function i1(t, e) {
  return fi(e) ? t.length === e.length && t.every((r, n) => r === e[n]) : t.length === 1 && t[0] === e;
}
function g3(t, e) {
  if (t.startsWith('/')) return t;
  if (!t) return e;
  const r = e.split('/'),
    n = t.split('/'),
    i = n[n.length - 1];
  (i === '..' || i === '.') && n.push('');
  let s = r.length - 1,
    o,
    l;
  for (o = 0; o < n.length; o++)
    if (((l = n[o]), l !== '.'))
      if (l === '..') s > 1 && s--;
      else break;
  return r.slice(0, s).join('/') + '/' + n.slice(o - (o === n.length ? 1 : 0)).join('/');
}
var Ru;
(function (t) {
  (t.pop = 'pop'), (t.push = 'push');
})(Ru || (Ru = {}));
var Cu;
(function (t) {
  (t.back = 'back'), (t.forward = 'forward'), (t.unknown = '');
})(Cu || (Cu = {}));
function y3(t) {
  if (!t)
    if (Ma) {
      const e = document.querySelector('base');
      (t = (e && e.getAttribute('href')) || '/'), (t = t.replace(/^\w+:\/\/[^\/]+/, ''));
    } else t = '/';
  return t[0] !== '/' && t[0] !== '#' && (t = '/' + t), p3(t);
}
const D3 = /^[^#]+#/;
function x3(t, e) {
  return t.replace(D3, '#') + e;
}
function C3(t, e) {
  const r = document.documentElement.getBoundingClientRect(),
    n = t.getBoundingClientRect();
  return { behavior: e.behavior, left: n.left - r.left - (e.left || 0), top: n.top - r.top - (e.top || 0) };
}
const mf = () => ({ left: window.pageXOffset, top: window.pageYOffset });
function b3(t) {
  let e;
  if ('el' in t) {
    const r = t.el,
      n = typeof r == 'string' && r.startsWith('#'),
      i = typeof r == 'string' ? (n ? document.getElementById(r.slice(1)) : document.querySelector(r)) : r;
    if (!i) return;
    e = C3(i, t);
  } else e = t;
  'scrollBehavior' in document.documentElement.style
    ? window.scrollTo(e)
    : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset);
}
function s1(t, e) {
  return (history.state ? history.state.position - e : -1) + t;
}
const Gm = new Map();
function A3(t, e) {
  Gm.set(t, e);
}
function E3(t) {
  const e = Gm.get(t);
  return Gm.delete(t), e;
}
let v3 = () => location.protocol + '//' + location.host;
function lA(t, e) {
  const { pathname: r, search: n, hash: i } = e,
    s = t.indexOf('#');
  if (s > -1) {
    let l = i.includes(t.slice(s)) ? t.slice(s).length : 1,
      c = i.slice(l);
    return c[0] !== '/' && (c = '/' + c), n1(c, '');
  }
  return n1(r, t) + n + i;
}
function F3(t, e, r, n) {
  let i = [],
    s = [],
    o = null;
  const l = ({ state: g }) => {
    const x = lA(t, location),
      b = r.value,
      F = e.value;
    let E = 0;
    if (g) {
      if (((r.value = x), (e.value = g), o && o === b)) {
        o = null;
        return;
      }
      E = F ? g.position - F.position : 0;
    } else n(x);
    i.forEach((w) => {
      w(r.value, b, { delta: E, type: Ru.pop, direction: E ? (E > 0 ? Cu.forward : Cu.back) : Cu.unknown });
    });
  };
  function c() {
    o = r.value;
  }
  function p(g) {
    i.push(g);
    const x = () => {
      const b = i.indexOf(g);
      b > -1 && i.splice(b, 1);
    };
    return s.push(x), x;
  }
  function f() {
    const { history: g } = window;
    g.state && g.replaceState(jt({}, g.state, { scroll: mf() }), '');
  }
  function m() {
    for (const g of s) g();
    (s = []), window.removeEventListener('popstate', l), window.removeEventListener('beforeunload', f);
  }
  return (
    window.addEventListener('popstate', l),
    window.addEventListener('beforeunload', f, { passive: !0 }),
    { pauseListeners: c, listen: p, destroy: m }
  );
}
function o1(t, e, r, n = !1, i = !1) {
  return { back: t, current: e, forward: r, replaced: n, position: window.history.length, scroll: i ? mf() : null };
}
function S3(t) {
  const { history: e, location: r } = window,
    n = { value: lA(t, r) },
    i = { value: e.state };
  i.value ||
    s(n.value, { back: null, current: n.value, forward: null, position: e.length - 1, replaced: !0, scroll: null }, !0);
  function s(c, p, f) {
    const m = t.indexOf('#'),
      g = m > -1 ? (r.host && document.querySelector('base') ? t : t.slice(m)) + c : v3() + t + c;
    try {
      e[f ? 'replaceState' : 'pushState'](p, '', g), (i.value = p);
    } catch (x) {
      console.error(x), r[f ? 'replace' : 'assign'](g);
    }
  }
  function o(c, p) {
    const f = jt({}, e.state, o1(i.value.back, c, i.value.forward, !0), p, { position: i.value.position });
    s(c, f, !0), (n.value = c);
  }
  function l(c, p) {
    const f = jt({}, i.value, e.state, { forward: c, scroll: mf() });
    s(f.current, f, !0);
    const m = jt({}, o1(n.value, c, null), { position: f.position + 1 }, p);
    s(c, m, !1), (n.value = c);
  }
  return { location: n, state: i, push: l, replace: o };
}
function w3(t) {
  t = y3(t);
  const e = S3(t),
    r = F3(t, e.state, e.location, e.replace);
  function n(s, o = !0) {
    o || r.pauseListeners(), history.go(s);
  }
  const i = jt({ location: '', base: t, go: n, createHref: x3.bind(null, t) }, e, r);
  return (
    Object.defineProperty(i, 'location', { enumerable: !0, get: () => e.location.value }),
    Object.defineProperty(i, 'state', { enumerable: !0, get: () => e.state.value }),
    i
  );
}
function T3(t) {
  return (t = location.host ? t || location.pathname + location.search : ''), t.includes('#') || (t += '#'), w3(t);
}
function k3(t) {
  return typeof t == 'string' || (t && typeof t == 'object');
}
function uA(t) {
  return typeof t == 'string' || typeof t == 'symbol';
}
const ks = {
    path: '/',
    name: void 0,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: void 0,
  },
  cA = Symbol('');
var a1;
(function (t) {
  (t[(t.aborted = 4)] = 'aborted'), (t[(t.cancelled = 8)] = 'cancelled'), (t[(t.duplicated = 16)] = 'duplicated');
})(a1 || (a1 = {}));
function rl(t, e) {
  return jt(new Error(), { type: t, [cA]: !0 }, e);
}
function Qi(t, e) {
  return t instanceof Error && cA in t && (e == null || !!(t.type & e));
}
const l1 = '[^/]+?',
  P3 = { sensitive: !1, strict: !1, start: !0, end: !0 },
  B3 = /[.+*?^${}()[\]/\\]/g;
function I3(t, e) {
  const r = jt({}, P3, e),
    n = [];
  let i = r.start ? '^' : '';
  const s = [];
  for (const p of t) {
    const f = p.length ? [] : [90];
    r.strict && !p.length && (i += '/');
    for (let m = 0; m < p.length; m++) {
      const g = p[m];
      let x = 40 + (r.sensitive ? 0.25 : 0);
      if (g.type === 0) m || (i += '/'), (i += g.value.replace(B3, '\\$&')), (x += 40);
      else if (g.type === 1) {
        const { value: b, repeatable: F, optional: E, regexp: w } = g;
        s.push({ name: b, repeatable: F, optional: E });
        const I = w || l1;
        if (I !== l1) {
          x += 10;
          try {
            new RegExp(`(${I})`);
          } catch (j) {
            throw new Error(`Invalid custom RegExp for param "${b}" (${I}): ` + j.message);
          }
        }
        let T = F ? `((?:${I})(?:/(?:${I}))*)` : `(${I})`;
        m || (T = E && p.length < 2 ? `(?:/${T})` : '/' + T),
          E && (T += '?'),
          (i += T),
          (x += 20),
          E && (x += -8),
          F && (x += -20),
          I === '.*' && (x += -50);
      }
      f.push(x);
    }
    n.push(f);
  }
  if (r.strict && r.end) {
    const p = n.length - 1;
    n[p][n[p].length - 1] += 0.7000000000000001;
  }
  r.strict || (i += '/?'), r.end ? (i += '$') : r.strict && (i += '(?:/|$)');
  const o = new RegExp(i, r.sensitive ? '' : 'i');
  function l(p) {
    const f = p.match(o),
      m = {};
    if (!f) return null;
    for (let g = 1; g < f.length; g++) {
      const x = f[g] || '',
        b = s[g - 1];
      m[b.name] = x && b.repeatable ? x.split('/') : x;
    }
    return m;
  }
  function c(p) {
    let f = '',
      m = !1;
    for (const g of t) {
      (!m || !f.endsWith('/')) && (f += '/'), (m = !1);
      for (const x of g)
        if (x.type === 0) f += x.value;
        else if (x.type === 1) {
          const { value: b, repeatable: F, optional: E } = x,
            w = b in p ? p[b] : '';
          if (fi(w) && !F)
            throw new Error(`Provided param "${b}" is an array but it is not repeatable (* or + modifiers)`);
          const I = fi(w) ? w.join('/') : w;
          if (!I)
            if (E) g.length < 2 && (f.endsWith('/') ? (f = f.slice(0, -1)) : (m = !0));
            else throw new Error(`Missing required param "${b}"`);
          f += I;
        }
    }
    return f || '/';
  }
  return { re: o, score: n, keys: s, parse: l, stringify: c };
}
function N3(t, e) {
  let r = 0;
  for (; r < t.length && r < e.length; ) {
    const n = e[r] - t[r];
    if (n) return n;
    r++;
  }
  return t.length < e.length
    ? t.length === 1 && t[0] === 40 + 40
      ? -1
      : 1
    : t.length > e.length
    ? e.length === 1 && e[0] === 40 + 40
      ? 1
      : -1
    : 0;
}
function M3(t, e) {
  let r = 0;
  const n = t.score,
    i = e.score;
  for (; r < n.length && r < i.length; ) {
    const s = N3(n[r], i[r]);
    if (s) return s;
    r++;
  }
  if (Math.abs(i.length - n.length) === 1) {
    if (u1(n)) return 1;
    if (u1(i)) return -1;
  }
  return i.length - n.length;
}
function u1(t) {
  const e = t[t.length - 1];
  return t.length > 0 && e[e.length - 1] < 0;
}
const O3 = { type: 0, value: '' },
  L3 = /[a-zA-Z0-9_]/;
function _3(t) {
  if (!t) return [[]];
  if (t === '/') return [[O3]];
  if (!t.startsWith('/')) throw new Error(`Invalid path "${t}"`);
  function e(x) {
    throw new Error(`ERR (${r})/"${p}": ${x}`);
  }
  let r = 0,
    n = r;
  const i = [];
  let s;
  function o() {
    s && i.push(s), (s = []);
  }
  let l = 0,
    c,
    p = '',
    f = '';
  function m() {
    p &&
      (r === 0
        ? s.push({ type: 0, value: p })
        : r === 1 || r === 2 || r === 3
        ? (s.length > 1 &&
            (c === '*' || c === '+') &&
            e(`A repeatable param (${p}) must be alone in its segment. eg: '/:ids+.`),
          s.push({
            type: 1,
            value: p,
            regexp: f,
            repeatable: c === '*' || c === '+',
            optional: c === '*' || c === '?',
          }))
        : e('Invalid state to consume buffer'),
      (p = ''));
  }
  function g() {
    p += c;
  }
  for (; l < t.length; ) {
    if (((c = t[l++]), c === '\\' && r !== 2)) {
      (n = r), (r = 4);
      continue;
    }
    switch (r) {
      case 0:
        c === '/' ? (p && m(), o()) : c === ':' ? (m(), (r = 1)) : g();
        break;
      case 4:
        g(), (r = n);
        break;
      case 1:
        c === '(' ? (r = 2) : L3.test(c) ? g() : (m(), (r = 0), c !== '*' && c !== '?' && c !== '+' && l--);
        break;
      case 2:
        c === ')' ? (f[f.length - 1] == '\\' ? (f = f.slice(0, -1) + c) : (r = 3)) : (f += c);
        break;
      case 3:
        m(), (r = 0), c !== '*' && c !== '?' && c !== '+' && l--, (f = '');
        break;
      default:
        e('Unknown state');
        break;
    }
  }
  return r === 2 && e(`Unfinished custom RegExp for param "${p}"`), m(), o(), i;
}
function R3(t, e, r) {
  const n = I3(_3(t.path), r),
    i = jt(n, { record: t, parent: e, children: [], alias: [] });
  return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i;
}
function j3(t, e) {
  const r = [],
    n = new Map();
  e = p1({ strict: !1, end: !0, sensitive: !1 }, e);
  function i(f) {
    return n.get(f);
  }
  function s(f, m, g) {
    const x = !g,
      b = $3(f);
    b.aliasOf = g && g.record;
    const F = p1(e, f),
      E = [b];
    if ('alias' in f) {
      const T = typeof f.alias == 'string' ? [f.alias] : f.alias;
      for (const j of T)
        E.push(jt({}, b, { components: g ? g.record.components : b.components, path: j, aliasOf: g ? g.record : b }));
    }
    let w, I;
    for (const T of E) {
      const { path: j } = T;
      if (m && j[0] !== '/') {
        const $ = m.record.path,
          L = $[$.length - 1] === '/' ? '' : '/';
        T.path = m.record.path + (j && L + j);
      }
      if (
        ((w = R3(T, m, F)),
        g ? g.alias.push(w) : ((I = I || w), I !== w && I.alias.push(w), x && f.name && !h1(w) && o(f.name)),
        b.children)
      ) {
        const $ = b.children;
        for (let L = 0; L < $.length; L++) s($[L], w, g && g.children[L]);
      }
      (g = g || w),
        ((w.record.components && Object.keys(w.record.components).length) || w.record.name || w.record.redirect) &&
          c(w);
    }
    return I
      ? () => {
          o(I);
        }
      : xu;
  }
  function o(f) {
    if (uA(f)) {
      const m = n.get(f);
      m && (n.delete(f), r.splice(r.indexOf(m), 1), m.children.forEach(o), m.alias.forEach(o));
    } else {
      const m = r.indexOf(f);
      m > -1 && (r.splice(m, 1), f.record.name && n.delete(f.record.name), f.children.forEach(o), f.alias.forEach(o));
    }
  }
  function l() {
    return r;
  }
  function c(f) {
    let m = 0;
    for (; m < r.length && M3(f, r[m]) >= 0 && (f.record.path !== r[m].record.path || !hA(f, r[m])); ) m++;
    r.splice(m, 0, f), f.record.name && !h1(f) && n.set(f.record.name, f);
  }
  function p(f, m) {
    let g,
      x = {},
      b,
      F;
    if ('name' in f && f.name) {
      if (((g = n.get(f.name)), !g)) throw rl(1, { location: f });
      (F = g.record.name),
        (x = jt(
          c1(
            m.params,
            g.keys.filter((I) => !I.optional).map((I) => I.name),
          ),
          f.params &&
            c1(
              f.params,
              g.keys.map((I) => I.name),
            ),
        )),
        (b = g.stringify(x));
    } else if ('path' in f)
      (b = f.path), (g = r.find((I) => I.re.test(b))), g && ((x = g.parse(b)), (F = g.record.name));
    else {
      if (((g = m.name ? n.get(m.name) : r.find((I) => I.re.test(m.path))), !g))
        throw rl(1, { location: f, currentLocation: m });
      (F = g.record.name), (x = jt({}, m.params, f.params)), (b = g.stringify(x));
    }
    const E = [];
    let w = g;
    for (; w; ) E.unshift(w.record), (w = w.parent);
    return { name: F, path: b, params: x, matched: E, meta: z3(E) };
  }
  return t.forEach((f) => s(f)), { addRoute: s, resolve: p, removeRoute: o, getRoutes: l, getRecordMatcher: i };
}
function c1(t, e) {
  const r = {};
  for (const n of e) n in t && (r[n] = t[n]);
  return r;
}
function $3(t) {
  return {
    path: t.path,
    redirect: t.redirect,
    name: t.name,
    meta: t.meta || {},
    aliasOf: void 0,
    beforeEnter: t.beforeEnter,
    props: V3(t),
    children: t.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: 'components' in t ? t.components || null : t.component && { default: t.component },
  };
}
function V3(t) {
  const e = {},
    r = t.props || !1;
  if ('component' in t) e.default = r;
  else for (const n in t.components) e[n] = typeof r == 'object' ? r[n] : r;
  return e;
}
function h1(t) {
  for (; t; ) {
    if (t.record.aliasOf) return !0;
    t = t.parent;
  }
  return !1;
}
function z3(t) {
  return t.reduce((e, r) => jt(e, r.meta), {});
}
function p1(t, e) {
  const r = {};
  for (const n in t) r[n] = n in e ? e[n] : t[n];
  return r;
}
function hA(t, e) {
  return e.children.some((r) => r === t || hA(t, r));
}
const pA = /#/g,
  H3 = /&/g,
  W3 = /\//g,
  U3 = /=/g,
  q3 = /\?/g,
  fA = /\+/g,
  K3 = /%5B/g,
  J3 = /%5D/g,
  dA = /%5E/g,
  X3 = /%60/g,
  mA = /%7B/g,
  G3 = /%7C/g,
  gA = /%7D/g,
  Y3 = /%20/g;
function Rg(t) {
  return encodeURI('' + t)
    .replace(G3, '|')
    .replace(K3, '[')
    .replace(J3, ']');
}
function Q3(t) {
  return Rg(t).replace(mA, '{').replace(gA, '}').replace(dA, '^');
}
function Ym(t) {
  return Rg(t)
    .replace(fA, '%2B')
    .replace(Y3, '+')
    .replace(pA, '%23')
    .replace(H3, '%26')
    .replace(X3, '`')
    .replace(mA, '{')
    .replace(gA, '}')
    .replace(dA, '^');
}
function Z3(t) {
  return Ym(t).replace(U3, '%3D');
}
function e8(t) {
  return Rg(t).replace(pA, '%23').replace(q3, '%3F');
}
function t8(t) {
  return t == null ? '' : e8(t).replace(W3, '%2F');
}
function hp(t) {
  try {
    return decodeURIComponent('' + t);
  } catch {}
  return '' + t;
}
function r8(t) {
  const e = {};
  if (t === '' || t === '?') return e;
  const n = (t[0] === '?' ? t.slice(1) : t).split('&');
  for (let i = 0; i < n.length; ++i) {
    const s = n[i].replace(fA, ' '),
      o = s.indexOf('='),
      l = hp(o < 0 ? s : s.slice(0, o)),
      c = o < 0 ? null : hp(s.slice(o + 1));
    if (l in e) {
      let p = e[l];
      fi(p) || (p = e[l] = [p]), p.push(c);
    } else e[l] = c;
  }
  return e;
}
function f1(t) {
  let e = '';
  for (let r in t) {
    const n = t[r];
    if (((r = Z3(r)), n == null)) {
      n !== void 0 && (e += (e.length ? '&' : '') + r);
      continue;
    }
    (fi(n) ? n.map((s) => s && Ym(s)) : [n && Ym(n)]).forEach((s) => {
      s !== void 0 && ((e += (e.length ? '&' : '') + r), s != null && (e += '=' + s));
    });
  }
  return e;
}
function n8(t) {
  const e = {};
  for (const r in t) {
    const n = t[r];
    n !== void 0 && (e[r] = fi(n) ? n.map((i) => (i == null ? null : '' + i)) : n == null ? n : '' + n);
  }
  return e;
}
const i8 = Symbol(''),
  d1 = Symbol(''),
  gf = Symbol(''),
  yA = Symbol(''),
  Qm = Symbol('');
function Yl() {
  let t = [];
  function e(n) {
    return (
      t.push(n),
      () => {
        const i = t.indexOf(n);
        i > -1 && t.splice(i, 1);
      }
    );
  }
  function r() {
    t = [];
  }
  return { add: e, list: () => t.slice(), reset: r };
}
function Os(t, e, r, n, i) {
  const s = n && (n.enterCallbacks[i] = n.enterCallbacks[i] || []);
  return () =>
    new Promise((o, l) => {
      const c = (m) => {
          m === !1
            ? l(rl(4, { from: r, to: e }))
            : m instanceof Error
            ? l(m)
            : k3(m)
            ? l(rl(2, { from: e, to: m }))
            : (s && n.enterCallbacks[i] === s && typeof m == 'function' && s.push(m), o());
        },
        p = t.call(n && n.instances[i], e, r, c);
      let f = Promise.resolve(p);
      t.length < 3 && (f = f.then(c)), f.catch((m) => l(m));
    });
}
function Jd(t, e, r, n) {
  const i = [];
  for (const s of t)
    for (const o in s.components) {
      let l = s.components[o];
      if (!(e !== 'beforeRouteEnter' && !s.instances[o]))
        if (s8(l)) {
          const p = (l.__vccOpts || l)[e];
          p && i.push(Os(p, r, n, s, o));
        } else {
          let c = l();
          i.push(() =>
            c.then((p) => {
              if (!p) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
              const f = c3(p) ? p.default : p;
              s.components[o] = f;
              const g = (f.__vccOpts || f)[e];
              return g && Os(g, r, n, s, o)();
            }),
          );
        }
    }
  return i;
}
function s8(t) {
  return typeof t == 'object' || 'displayName' in t || 'props' in t || '__vccOpts' in t;
}
function m1(t) {
  const e = kn(gf),
    r = kn(yA),
    n = nt(() => e.resolve(te(t.to))),
    i = nt(() => {
      const { matched: c } = n.value,
        { length: p } = c,
        f = c[p - 1],
        m = r.matched;
      if (!f || !m.length) return -1;
      const g = m.findIndex(tl.bind(null, f));
      if (g > -1) return g;
      const x = g1(c[p - 2]);
      return p > 1 && g1(f) === x && m[m.length - 1].path !== x ? m.findIndex(tl.bind(null, c[p - 2])) : g;
    }),
    s = nt(() => i.value > -1 && u8(r.params, n.value.params)),
    o = nt(() => i.value > -1 && i.value === r.matched.length - 1 && aA(r.params, n.value.params));
  function l(c = {}) {
    return l8(c) ? e[te(t.replace) ? 'replace' : 'push'](te(t.to)).catch(xu) : Promise.resolve();
  }
  return { route: n, href: nt(() => n.value.href), isActive: s, isExactActive: o, navigate: l };
}
const o8 = St({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
      to: { type: [String, Object], required: !0 },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: { type: String, default: 'page' },
    },
    useLink: m1,
    setup(t, { slots: e }) {
      const r = yl(m1(t)),
        { options: n } = kn(gf),
        i = nt(() => ({
          [y1(t.activeClass, n.linkActiveClass, 'router-link-active')]: r.isActive,
          [y1(t.exactActiveClass, n.linkExactActiveClass, 'router-link-exact-active')]: r.isExactActive,
        }));
      return () => {
        const s = e.default && e.default(r);
        return t.custom
          ? s
          : pf(
              'a',
              {
                'aria-current': r.isExactActive ? t.ariaCurrentValue : null,
                'href': r.href,
                'onClick': r.navigate,
                'class': i.value,
              },
              s,
            );
      };
    },
  }),
  a8 = o8;
function l8(t) {
  if (
    !(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) &&
    !t.defaultPrevented &&
    !(t.button !== void 0 && t.button !== 0)
  ) {
    if (t.currentTarget && t.currentTarget.getAttribute) {
      const e = t.currentTarget.getAttribute('target');
      if (/\b_blank\b/i.test(e)) return;
    }
    return t.preventDefault && t.preventDefault(), !0;
  }
}
function u8(t, e) {
  for (const r in e) {
    const n = e[r],
      i = t[r];
    if (typeof n == 'string') {
      if (n !== i) return !1;
    } else if (!fi(i) || i.length !== n.length || n.some((s, o) => s !== i[o])) return !1;
  }
  return !0;
}
function g1(t) {
  return t ? (t.aliasOf ? t.aliasOf.path : t.path) : '';
}
const y1 = (t, e, r) => t ?? e ?? r,
  c8 = St({
    name: 'RouterView',
    inheritAttrs: !1,
    props: { name: { type: String, default: 'default' }, route: Object },
    compatConfig: { MODE: 3 },
    setup(t, { attrs: e, slots: r }) {
      const n = kn(Qm),
        i = nt(() => t.route || n.value),
        s = kn(d1, 0),
        o = nt(() => {
          let p = te(s);
          const { matched: f } = i.value;
          let m;
          for (; (m = f[p]) && !m.components; ) p++;
          return p;
        }),
        l = nt(() => i.value.matched[o.value]);
      Wh(
        d1,
        nt(() => o.value + 1),
      ),
        Wh(i8, l),
        Wh(Qm, i);
      const c = tt();
      return (
        Zt(
          () => [c.value, l.value, t.name],
          ([p, f, m], [g, x, b]) => {
            f &&
              ((f.instances[m] = p),
              x &&
                x !== f &&
                p &&
                p === g &&
                (f.leaveGuards.size || (f.leaveGuards = x.leaveGuards),
                f.updateGuards.size || (f.updateGuards = x.updateGuards))),
              p && f && (!x || !tl(f, x) || !g) && (f.enterCallbacks[m] || []).forEach((F) => F(p));
          },
          { flush: 'post' },
        ),
        () => {
          const p = i.value,
            f = t.name,
            m = l.value,
            g = m && m.components[f];
          if (!g) return D1(r.default, { Component: g, route: p });
          const x = m.props[f],
            b = x ? (x === !0 ? p.params : typeof x == 'function' ? x(p) : x) : null,
            E = pf(
              g,
              jt({}, b, e, {
                onVnodeUnmounted: (w) => {
                  w.component.isUnmounted && (m.instances[f] = null);
                },
                ref: c,
              }),
            );
          return D1(r.default, { Component: E, route: p }) || E;
        }
      );
    },
  });
function D1(t, e) {
  if (!t) return null;
  const r = t(e);
  return r.length === 1 ? r[0] : r;
}
const DA = c8;
function h8(t) {
  const e = j3(t.routes, t),
    r = t.parseQuery || r8,
    n = t.stringifyQuery || f1,
    i = t.history,
    s = Yl(),
    o = Yl(),
    l = Yl(),
    c = Ua(ks);
  let p = ks;
  Ma && t.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual');
  const f = qd.bind(null, (U) => '' + U),
    m = qd.bind(null, t8),
    g = qd.bind(null, hp);
  function x(U, he) {
    let Te, fe;
    return uA(U) ? ((Te = e.getRecordMatcher(U)), (fe = he)) : (fe = U), e.addRoute(fe, Te);
  }
  function b(U) {
    const he = e.getRecordMatcher(U);
    he && e.removeRoute(he);
  }
  function F() {
    return e.getRoutes().map((U) => U.record);
  }
  function E(U) {
    return !!e.getRecordMatcher(U);
  }
  function w(U, he) {
    if (((he = jt({}, he || c.value)), typeof U == 'string')) {
      const J = Kd(r, U, he.path),
        ae = e.resolve({ path: J.path }, he),
        de = i.createHref(J.fullPath);
      return jt(J, ae, { params: g(ae.params), hash: hp(J.hash), redirectedFrom: void 0, href: de });
    }
    let Te;
    if ('path' in U) Te = jt({}, U, { path: Kd(r, U.path, he.path).path });
    else {
      const J = jt({}, U.params);
      for (const ae in J) J[ae] == null && delete J[ae];
      (Te = jt({}, U, { params: m(J) })), (he.params = m(he.params));
    }
    const fe = e.resolve(Te, he),
      at = U.hash || '';
    fe.params = f(g(fe.params));
    const M = f3(n, jt({}, U, { hash: Q3(at), path: fe.path })),
      V = i.createHref(M);
    return jt({ fullPath: M, hash: at, query: n === f1 ? n8(U.query) : U.query || {} }, fe, {
      redirectedFrom: void 0,
      href: V,
    });
  }
  function I(U) {
    return typeof U == 'string' ? Kd(r, U, c.value.path) : jt({}, U);
  }
  function T(U, he) {
    if (p !== U) return rl(8, { from: he, to: U });
  }
  function j(U) {
    return se(U);
  }
  function $(U) {
    return j(jt(I(U), { replace: !0 }));
  }
  function L(U) {
    const he = U.matched[U.matched.length - 1];
    if (he && he.redirect) {
      const { redirect: Te } = he;
      let fe = typeof Te == 'function' ? Te(U) : Te;
      return (
        typeof fe == 'string' &&
          ((fe = fe.includes('?') || fe.includes('#') ? (fe = I(fe)) : { path: fe }), (fe.params = {})),
        jt({ query: U.query, hash: U.hash, params: 'path' in fe ? {} : U.params }, fe)
      );
    }
  }
  function se(U, he) {
    const Te = (p = w(U)),
      fe = c.value,
      at = U.state,
      M = U.force,
      V = U.replace === !0,
      J = L(Te);
    if (J)
      return se(jt(I(J), { state: typeof J == 'object' ? jt({}, at, J.state) : at, force: M, replace: V }), he || Te);
    const ae = Te;
    ae.redirectedFrom = he;
    let de;
    return (
      !M && d3(n, fe, Te) && ((de = rl(16, { to: ae, from: fe })), je(fe, fe, !0, !1)),
      (de ? Promise.resolve(de) : X(ae, fe))
        .catch((ye) => (Qi(ye) ? (Qi(ye, 2) ? ye : we(ye)) : G(ye, ae, fe)))
        .then((ye) => {
          if (ye) {
            if (Qi(ye, 2))
              return se(
                jt({ replace: V }, I(ye.to), {
                  state: typeof ye.to == 'object' ? jt({}, at, ye.to.state) : at,
                  force: M,
                }),
                he || ae,
              );
          } else ye = xe(ae, fe, !0, V, at);
          return q(ae, fe, ye), ye;
        })
    );
  }
  function Y(U, he) {
    const Te = T(U, he);
    return Te ? Promise.reject(Te) : Promise.resolve();
  }
  function W(U) {
    const he = pt.values().next().value;
    return he && typeof he.runWithContext == 'function' ? he.runWithContext(U) : U();
  }
  function X(U, he) {
    let Te;
    const [fe, at, M] = p8(U, he);
    Te = Jd(fe.reverse(), 'beforeRouteLeave', U, he);
    for (const J of fe)
      J.leaveGuards.forEach((ae) => {
        Te.push(Os(ae, U, he));
      });
    const V = Y.bind(null, U, he);
    return (
      Te.push(V),
      yt(Te)
        .then(() => {
          Te = [];
          for (const J of s.list()) Te.push(Os(J, U, he));
          return Te.push(V), yt(Te);
        })
        .then(() => {
          Te = Jd(at, 'beforeRouteUpdate', U, he);
          for (const J of at)
            J.updateGuards.forEach((ae) => {
              Te.push(Os(ae, U, he));
            });
          return Te.push(V), yt(Te);
        })
        .then(() => {
          Te = [];
          for (const J of M)
            if (J.beforeEnter)
              if (fi(J.beforeEnter)) for (const ae of J.beforeEnter) Te.push(Os(ae, U, he));
              else Te.push(Os(J.beforeEnter, U, he));
          return Te.push(V), yt(Te);
        })
        .then(
          () => (
            U.matched.forEach((J) => (J.enterCallbacks = {})),
            (Te = Jd(M, 'beforeRouteEnter', U, he)),
            Te.push(V),
            yt(Te)
          ),
        )
        .then(() => {
          Te = [];
          for (const J of o.list()) Te.push(Os(J, U, he));
          return Te.push(V), yt(Te);
        })
        .catch((J) => (Qi(J, 8) ? J : Promise.reject(J)))
    );
  }
  function q(U, he, Te) {
    l.list().forEach((fe) => W(() => fe(U, he, Te)));
  }
  function xe(U, he, Te, fe, at) {
    const M = T(U, he);
    if (M) return M;
    const V = he === ks,
      J = Ma ? history.state : {};
    Te && (fe || V ? i.replace(U.fullPath, jt({ scroll: V && J && J.scroll }, at)) : i.push(U.fullPath, at)),
      (c.value = U),
      je(U, he, Te, V),
      we();
  }
  let Re;
  function re() {
    Re ||
      (Re = i.listen((U, he, Te) => {
        if (!gt.listening) return;
        const fe = w(U),
          at = L(fe);
        if (at) {
          se(jt(at, { replace: !0 }), fe).catch(xu);
          return;
        }
        p = fe;
        const M = c.value;
        Ma && A3(s1(M.fullPath, Te.delta), mf()),
          X(fe, M)
            .catch((V) =>
              Qi(V, 12)
                ? V
                : Qi(V, 2)
                ? (se(V.to, fe)
                    .then((J) => {
                      Qi(J, 20) && !Te.delta && Te.type === Ru.pop && i.go(-1, !1);
                    })
                    .catch(xu),
                  Promise.reject())
                : (Te.delta && i.go(-Te.delta, !1), G(V, fe, M)),
            )
            .then((V) => {
              (V = V || xe(fe, M, !1)),
                V && (Te.delta && !Qi(V, 8) ? i.go(-Te.delta, !1) : Te.type === Ru.pop && Qi(V, 20) && i.go(-1, !1)),
                q(fe, M, V);
            })
            .catch(xu);
      }));
  }
  let ie = Yl(),
    Q = Yl(),
    ce;
  function G(U, he, Te) {
    we(U);
    const fe = Q.list();
    return fe.length ? fe.forEach((at) => at(U, he, Te)) : console.error(U), Promise.reject(U);
  }
  function ge() {
    return ce && c.value !== ks
      ? Promise.resolve()
      : new Promise((U, he) => {
          ie.add([U, he]);
        });
  }
  function we(U) {
    return ce || ((ce = !U), re(), ie.list().forEach(([he, Te]) => (U ? Te(U) : he())), ie.reset()), U;
  }
  function je(U, he, Te, fe) {
    const { scrollBehavior: at } = t;
    if (!Ma || !at) return Promise.resolve();
    const M = (!Te && E3(s1(U.fullPath, 0))) || ((fe || !Te) && history.state && history.state.scroll) || null;
    return gi()
      .then(() => at(U, he, M))
      .then((V) => V && b3(V))
      .catch((V) => G(V, U, he));
  }
  const Qe = (U) => i.go(U);
  let ot;
  const pt = new Set(),
    gt = {
      currentRoute: c,
      listening: !0,
      addRoute: x,
      removeRoute: b,
      hasRoute: E,
      getRoutes: F,
      resolve: w,
      options: t,
      push: j,
      replace: $,
      go: Qe,
      back: () => Qe(-1),
      forward: () => Qe(1),
      beforeEach: s.add,
      beforeResolve: o.add,
      afterEach: l.add,
      onError: Q.add,
      isReady: ge,
      install(U) {
        const he = this;
        U.component('RouterLink', a8),
          U.component('RouterView', DA),
          (U.config.globalProperties.$router = he),
          Object.defineProperty(U.config.globalProperties, '$route', { enumerable: !0, get: () => te(c) }),
          Ma && !ot && c.value === ks && ((ot = !0), j(i.location).catch((at) => {}));
        const Te = {};
        for (const at in ks) Object.defineProperty(Te, at, { get: () => c.value[at], enumerable: !0 });
        U.provide(gf, he), U.provide(yA, Db(Te)), U.provide(Qm, c);
        const fe = U.unmount;
        pt.add(U),
          (U.unmount = function () {
            pt.delete(U),
              pt.size < 1 && ((p = ks), Re && Re(), (Re = null), (c.value = ks), (ot = !1), (ce = !1)),
              fe();
          });
      },
    };
  function yt(U) {
    return U.reduce((he, Te) => he.then(() => W(Te)), Promise.resolve());
  }
  return gt;
}
function p8(t, e) {
  const r = [],
    n = [],
    i = [],
    s = Math.max(e.matched.length, t.matched.length);
  for (let o = 0; o < s; o++) {
    const l = e.matched[o];
    l && (t.matched.find((p) => tl(p, l)) ? n.push(l) : r.push(l));
    const c = t.matched[o];
    c && (e.matched.find((p) => tl(p, c)) || i.push(c));
  }
  return [r, n, i];
}
function xA() {
  return kn(gf);
}
const f8 = { key: 0, class: 'h-full w-full bg-base-100 shadow-md rounded' },
  d8 = { key: 1, class: 'h-full w-full bg-base-100 shadow-md rounded flex flex-col' },
  m8 = { class: 'border-b border-base-300 text-xs font-semibold leading-6' },
  g8 = { class: 'flex-1 min-h-0' },
  ds = St({
    __name: 'ContentCard',
    setup(t) {
      const e = $b();
      return (r, n) =>
        te(e).header
          ? (Ne(), rt('div', d8, [$e('div', m8, [li(r.$slots, 'header')]), $e('div', g8, [li(r.$slots, 'default')])]))
          : (Ne(), rt('div', f8, [li(r.$slots, 'default')]));
    },
  }),
  y8 = St({
    __name: 'Button',
    props: {
      type: {},
      size: { default: 'sm' },
      outline: { type: Boolean },
      active: { type: Boolean },
      disabled: { type: Boolean },
      glass: { type: Boolean },
      noAnimation: { type: Boolean },
      wide: { type: Boolean },
      block: { type: Boolean },
      shape: {},
    },
    setup(t) {
      const e = t,
        r = nt(() => ({
          'btn': !0,
          'btn-neutral': e.type === 'neutral',
          'btn-primary': e.type === 'primary',
          'btn-secondary': e.type === 'secondary',
          'btn-accent': e.type === 'accent',
          'btn-info': e.type === 'info',
          'btn-success': e.type === 'success',
          'btn-warning': e.type === 'warning',
          'btn-error': e.type === 'error',
          'btn-ghost': e.type === 'ghost',
          'btn-link': e.type === 'link',
          'btn-outline': !!e.outline,
          'btn-active': !!e.active,
          'btn-disabled': !!e.disabled,
          'glass': !!e.glass,
          'no-animation': !!e.noAnimation,
          'btn-xs': e.size === 'xs',
          'btn-sm': e.size === 'sm',
          'btn-md': e.size === 'md',
          'btn-lg': e.size === 'lg',
          'btn-wide': !!e.wide,
          'btn-block': !!e.block,
          'btn-circle': e.shape === 'circle',
          'btn-square': e.shape === 'square',
        }));
      return (n, i) => (
        Ne(), rt('button', { class: Gt([r.value, 'rounded']) }, [li(n.$slots, 'default', {}, void 0, !0)], 2)
      );
    },
  });
const In = (t, e) => {
    const r = t.__vccOpts || t;
    for (const [n, i] of e) r[n] = i;
    return r;
  },
  Wn = In(y8, [['__scopeId', 'data-v-14336724']]),
  D8 = {},
  x8 = { class: 'hero w-full h-full' },
  C8 = { class: 'hero-content text-center' };
function b8(t, e) {
  return Ne(), rt('div', x8, [$e('div', C8, [li(t.$slots, 'default')])]);
}
const A8 = In(D8, [['render', b8]]),
  E8 = ['value', 'placeholder', 'onKeydown'],
  to = St({
    __name: 'Input',
    props: { modelValue: {}, placeholder: { default: '' }, size: {}, type: {}, bordered: { type: Boolean } },
    emits: ['update:modelValue', 'change', 'input'],
    setup(t, { expose: e, emit: r }) {
      const n = t;
      e({ focus: o, blur: l, select: c });
      const i = nt(() => ({
          'input': !0,
          'input-primary': n.type === 'primary',
          'input-secondary': n.type === 'secondary',
          'input-accent': n.type === 'accent',
          'input-info': n.type === 'info',
          'input-success': n.type === 'success',
          'input-warning': n.type === 'warning',
          'input-error': n.type === 'error',
          'input-ghost': n.type === 'ghost',
          'input-bordered': !!n.bordered,
          'input-xs': n.size === 'xs',
          'input-sm': n.size === 'sm',
          'input-md': n.size === 'md',
          'input-lg': n.size === 'lg',
        })),
        s = tt(null);
      function o() {
        var g;
        (g = s.value) == null || g.focus();
      }
      function l() {
        var g;
        (g = s.value) == null || g.blur();
      }
      function c() {
        var g;
        return (g = s.value) == null ? void 0 : g.select();
      }
      function p(g) {
        const x = g.target.value;
        r('change', x);
      }
      function f(g) {
        const x = g.target.value;
        r('input', x), r('update:modelValue', x);
      }
      function m() {
        l();
      }
      return (g, x) => (
        Ne(),
        rt(
          'input',
          {
            ref_key: 'input',
            ref: s,
            value: g.modelValue,
            class: Gt(['w-full rounded', i.value]),
            placeholder: g.placeholder,
            type: 'text',
            onChange: p,
            onInput: f,
            onKeydown: Vi(m, ['enter']),
          },
          null,
          42,
          E8,
        )
      );
    },
  }),
  v8 = St({
    __name: 'Loading',
    props: { shape: { default: 'spinner' }, type: {}, size: { default: 'md' } },
    setup(t) {
      const e = t,
        r = nt(() => ({
          'loading': !0,
          'loading-spinner': e.shape === 'spinner',
          'loading-dots': e.shape === 'dots',
          'loading-ring': e.shape === 'ring',
          'loading-ball': e.shape === 'ball',
          'loading-bars': e.shape === 'bars',
          'loading-infinity': e.shape === 'infinity',
          'loading-xs': e.size === 'xs',
          'loading-sm': e.size === 'sm',
          'loading-md': e.size === 'md',
          'loading-lg': e.size === 'lg',
          'text-neutral': e.type === 'neutral',
          'text-primary': e.type === 'primary',
          'text-secondary': e.type === 'secondary',
          'text-accent': e.type === 'accent',
          'text-info': e.type === 'info',
          'text-success': e.type === 'success',
          'text-warning': e.type === 'warning',
          'text-error': e.type === 'error',
        }));
      return (n, i) => (Ne(), rt('div', { class: Gt(r.value) }, null, 2));
    },
  }),
  F8 = { method: 'dialog', class: 'modal-box' },
  S8 = { key: 1, class: 'font-bold text-lg' },
  w8 = { class: 'content py-4' },
  T8 = { key: 2, class: 'modal-action' },
  k8 = { key: 0, method: 'dialog', class: 'modal-backdrop' },
  CA = St({
    __name: 'Modal',
    props: {
      modelValue: { type: Boolean },
      useTopLayer: { type: Boolean, default: !1 },
      title: {},
      showClose: { type: Boolean, default: !0 },
      position: { default: 'middle' },
      closeOnBackdrop: { type: Boolean, default: !0 },
    },
    emits: ['update:modelValue'],
    setup(t, { emit: e }) {
      const r = t,
        n = $b(),
        i = tt(null),
        s = nt(() => ({ top: 'modal-top', bottom: 'modal-bottom', middle: 'modal-middle' })[r.position]);
      function o() {
        e('update:modelValue', !1);
      }
      function l() {
        r.useTopLayer || o();
      }
      return (
        Ik(() => {
          !i.value ||
            !r.useTopLayer ||
            (r.modelValue && !i.value.open ? i.value.showModal() : !r.modelValue && i.value.open && i.value.close());
        }),
        (c, p) => (
          Ne(),
          rt(
            'dialog',
            {
              ref_key: 'dialogRef',
              ref: i,
              class: Gt(['modal', s.value, !c.useTopLayer && c.modelValue && 'modal-open']),
              onClose: o,
            },
            [
              $e('form', F8, [
                c.showClose
                  ? (Ne(),
                    nr(
                      te(Wn),
                      { key: 0, class: 'absolute right-2 top-2', shape: 'circle', type: 'ghost', onClick: l },
                      { default: Ke(() => [Dn(' ✕ ')]), _: 1 },
                    ))
                  : Ni('', !0),
                c.title ? (Ne(), rt('h3', S8, ai(c.title), 1)) : Ni('', !0),
                $e('div', w8, [li(c.$slots, 'default')]),
                te(n).action ? (Ne(), rt('div', T8, [li(c.$slots, 'action')])) : Ni('', !0),
              ]),
              c.closeOnBackdrop ? (Ne(), rt('form', k8, [$e('button', { onClick: l }, 'close')])) : Ni('', !0),
            ],
            34,
          )
        )
      );
    },
  }),
  P8 = ['info', 'success', 'warning', 'error'],
  B8 = 8;
var I8 = {
  size: '1em',
  strokeWidth: 4,
  strokeLinecap: 'round',
  strokeLinejoin: 'round',
  rtl: !1,
  theme: 'outline',
  colors: {
    outline: { fill: '#333', background: 'transparent' },
    filled: { fill: '#333', background: '#FFF' },
    twoTone: { fill: '#333', twoTone: '#2F88FF' },
    multiColor: {
      outStrokeColor: '#333',
      outFillColor: '#2F88FF',
      innerStrokeColor: '#FFF',
      innerFillColor: '#43CCF8',
    },
  },
  prefix: 'i',
};
function N8() {
  return 'icon-' + (((1 + Math.random()) * 4294967296) | 0).toString(16).substring(1);
}
function M8(t, e, r) {
  var n = typeof e.fill == 'string' ? [e.fill] : e.fill || [],
    i = [],
    s = e.theme || r.theme;
  switch (s) {
    case 'outline':
      i.push(typeof n[0] == 'string' ? n[0] : 'currentColor'),
        i.push('none'),
        i.push(typeof n[0] == 'string' ? n[0] : 'currentColor'),
        i.push('none');
      break;
    case 'filled':
      i.push(typeof n[0] == 'string' ? n[0] : 'currentColor'),
        i.push(typeof n[0] == 'string' ? n[0] : 'currentColor'),
        i.push('#FFF'),
        i.push('#FFF');
      break;
    case 'two-tone':
      i.push(typeof n[0] == 'string' ? n[0] : 'currentColor'),
        i.push(typeof n[1] == 'string' ? n[1] : r.colors.twoTone.twoTone),
        i.push(typeof n[0] == 'string' ? n[0] : 'currentColor'),
        i.push(typeof n[1] == 'string' ? n[1] : r.colors.twoTone.twoTone);
      break;
    case 'multi-color':
      i.push(typeof n[0] == 'string' ? n[0] : 'currentColor'),
        i.push(typeof n[1] == 'string' ? n[1] : r.colors.multiColor.outFillColor),
        i.push(typeof n[2] == 'string' ? n[2] : r.colors.multiColor.innerStrokeColor),
        i.push(typeof n[3] == 'string' ? n[3] : r.colors.multiColor.innerFillColor);
      break;
  }
  return {
    size: e.size || r.size,
    strokeWidth: e.strokeWidth || r.strokeWidth,
    strokeLinecap: e.strokeLinecap || r.strokeLinecap,
    strokeLinejoin: e.strokeLinejoin || r.strokeLinejoin,
    colors: i,
    id: t,
  };
}
var O8 = Symbol('icon-context');
function Yt(t, e, r) {
  var n = {
    name: 'icon-' + t,
    props: ['size', 'strokeWidth', 'strokeLinecap', 'strokeLinejoin', 'theme', 'fill', 'spin'],
    setup: function (s) {
      var o = N8(),
        l = kn(O8, I8);
      return function () {
        var c = s.size,
          p = s.strokeWidth,
          f = s.strokeLinecap,
          m = s.strokeLinejoin,
          g = s.theme,
          x = s.fill,
          b = s.spin,
          F = M8(o, { size: c, strokeWidth: p, strokeLinecap: f, strokeLinejoin: m, theme: g, fill: x }, l),
          E = [l.prefix + '-icon'];
        return (
          E.push(l.prefix + '-icon-' + t),
          e && l.rtl && E.push(l.prefix + '-icon-rtl'),
          b && E.push(l.prefix + '-icon-spin'),
          z('span', { class: E.join(' ') }, [r(F)])
        );
      };
    },
  };
  return n;
}
const L8 = Yt('align-text-left', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M42 9H6',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M34 19H6',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M42 29H6',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M34 39H6',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  _8 = Yt('analysis', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M44 5H3.99998V17H44V5Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M3.99998 41.0301L16.1756 28.7293L22.7549 35.0301L30.7982 27L35.2786 31.368',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M44 16.1719V42.1719',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M3.99998 16.1719V30.1719',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M13.0155 43H44',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
        },
        null,
      ),
      z(
        'path',
        { 'd': 'M17 11H38', 'stroke': t.colors[2], 'stroke-width': t.strokeWidth, 'stroke-linecap': t.strokeLinecap },
        null,
      ),
      z(
        'path',
        {
          'd': 'M9.99998 10.9966H11',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
        },
        null,
      ),
    ]);
  }),
  R8 = Yt('attention', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M24 37C25.3807 37 26.5 35.8807 26.5 34.5C26.5 33.1193 25.3807 32 24 32C22.6193 32 21.5 33.1193 21.5 34.5C21.5 35.8807 22.6193 37 24 37Z',
          'fill': t.colors[2],
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M24 12V28',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  bA = Yt('check', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M43 11L16.875 37L5 25.1818',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  j8 = Yt('check-one', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M16 24L22 30L34 18',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  AA = Yt('close', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M8 8L40 40',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M8 40L40 8',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  $8 = Yt('close-one', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M29.6567 18.3432L18.343 29.6569',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M18.3433 18.3432L29.657 29.6569',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  yf = Yt('delete', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M9 10V44H39V10H9Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M20 20V33',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M28 20V33',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M4 10H44',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M16 10L19.289 4H28.7771L32 10H16Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  V8 = Yt('dot', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 33C28.9706 33 33 28.9706 33 24C33 19.0294 28.9706 15 24 15C19.0294 15 15 19.0294 15 24C15 28.9706 19.0294 33 24 33Z',
          'fill': t.colors[0],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
        },
        null,
      ),
    ]);
  }),
  z8 = Yt('down', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M36 18L24 30L12 18',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  jg = Yt('edit', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M7 42H43',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M11 26.7199V34H18.3172L39 13.3081L31.6951 6L11 26.7199Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  $g = Yt('file-addition', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M10 44H38C39.1046 44 40 43.1046 40 42V14H30V4H10C8.89543 4 8 4.89543 8 6V42C8 43.1046 8.89543 44 10 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M30 4L40 14',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M24 21V35',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M17 28H24L31 28',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  H8 = Yt('file-code', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M10 44H38C39.1046 44 40 43.1046 40 42V14H30V4H10C8.89543 4 8 4.89543 8 6V42C8 43.1046 8.89543 44 10 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M30 4L40 14',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M27 24L32 29L27 34',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M21 24L16 29L21 34',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  W8 = Yt('hand-left', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M44 41V19H38V41H44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M38 19.0002C30.8948 12.4304 26.7757 8.66359 25.6428 7.69983C23.9433 6.25419 22.0226 6.86123 22.0226 10.479C22.0226 14.0968 27.2864 16.2443 27.2864 19.0002C27.2898 19.0166 20.529 19.0177 7.00404 19.0035C5.3467 19.0017 4.00175 20.3438 4 22.0012C4 22.0022 4 22.0033 4 22.0043C4 23.6635 5.34501 25.0085 7.00417 25.0085H14.0165C15.2234 32.9771 15.8893 37.3101 16.0144 38.0075C16.2019 39.0536 17.199 41.0002 20.068 41.0002C21.9807 41.0002 27.9581 41.0002 38 41.0002V19.0002Z',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  U8 = Yt('help', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M24 28.6248V24.6248C27.3137 24.6248 30 21.9385 30 18.6248C30 15.3111 27.3137 12.6248 24 12.6248C20.6863 12.6248 18 15.3111 18 18.6248',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M24 37.6248C25.3807 37.6248 26.5 36.5055 26.5 35.1248C26.5 33.7441 25.3807 32.6248 24 32.6248C22.6193 32.6248 21.5 33.7441 21.5 35.1248C21.5 36.5055 22.6193 37.6248 24 37.6248Z',
          'fill': t.colors[2],
        },
        null,
      ),
    ]);
  }),
  q8 = Yt('home', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M9 18V42H39V18L24 6L9 18Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M19 29V42H29V29H19Z',
          'fill': t.colors[3],
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        { 'd': 'M9 42H39', 'stroke': t.colors[0], 'stroke-width': t.strokeWidth, 'stroke-linecap': t.strokeLinecap },
        null,
      ),
    ]);
  }),
  K8 = Yt('info', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M24 11C25.3807 11 26.5 12.1193 26.5 13.5C26.5 14.8807 25.3807 16 24 16C22.6193 16 21.5 14.8807 21.5 13.5C21.5 12.1193 22.6193 11 24 11Z',
          'fill': t.colors[2],
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M24.5 34V20H23.5H22.5',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M21 34H28',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  J8 = Yt('key', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M22.8682 24.2982C25.4105 26.7935 26.4138 30.4526 25.4971 33.8863C24.5805 37.32 21.8844 40.0019 18.4325 40.9137C14.9806 41.8256 11.3022 40.8276 8.79375 38.2986C5.02208 34.4141 5.07602 28.2394 8.91499 24.4206C12.754 20.6019 18.9613 20.5482 22.8664 24.3L22.8682 24.2982Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M23 24L40 7',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M30.3052 16.9001L35.7337 22.3001L42.0671 16.0001L36.6385 10.6001L30.3052 16.9001Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  X8 = Yt('monitor-one', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M5 8C5 6.89543 5.89543 6 7 6H41C42.1046 6 43 6.89543 43 8V32C43 33.1046 42.1046 34 41 34H7C5.89543 34 5 33.1046 5 32V8Z',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M5 26C5 24.8954 5.89543 24 7 24H41C42.1046 24 43 24.8954 43 26V32C43 33.1046 42.1046 34 41 34H7C5.89543 34 5 33.1046 5 32V26Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M22 12L18 17',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M28 14L25 18',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z('circle', { cx: '24', cy: '29', r: '2', fill: t.colors[2] }, null),
      z(
        'path',
        {
          'd': 'M17 34L14 42H34L31 34',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  G8 = Yt('paragraph-break', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M6 4V44',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M42 4V44',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M18 26L14 30L18 34',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M15 30C15 30 25.7909 30 28 30C31.3137 30 34 27.3137 34 24C34 20.6863 31.3137 18 28 18C26.6852 18 14 18 14 18',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  EA = Yt('plus', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24.0605 10L24.0239 38',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M10 24L38 24',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Y8 = Yt('reduce-one', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M16 24L32 24',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Q8 = Yt('search', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M21 38C30.3888 38 38 30.3888 38 21C38 11.6112 30.3888 4 21 4C11.6112 4 4 11.6112 4 21C4 30.3888 11.6112 38 21 38Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M26.657 14.3431C25.2093 12.8954 23.2093 12 21.0001 12C18.791 12 16.791 12.8954 15.3433 14.3431',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M33.2216 33.2217L41.7069 41.707',
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Z8 = Yt('setting', !1, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M36.686 15.171C37.9364 16.9643 38.8163 19.0352 39.2147 21.2727H44V26.7273H39.2147C38.8163 28.9648 37.9364 31.0357 36.686 32.829L40.0706 36.2137L36.2137 40.0706L32.829 36.686C31.0357 37.9364 28.9648 38.8163 26.7273 39.2147V44H21.2727V39.2147C19.0352 38.8163 16.9643 37.9364 15.171 36.686L11.7863 40.0706L7.92939 36.2137L11.314 32.829C10.0636 31.0357 9.18372 28.9648 8.78533 26.7273H4V21.2727H8.78533C9.18372 19.0352 10.0636 16.9643 11.314 15.171L7.92939 11.7863L11.7863 7.92939L15.171 11.314C16.9643 10.0636 19.0352 9.18372 21.2727 8.78533V4H26.7273V8.78533C28.9648 9.18372 31.0357 10.0636 32.829 11.314L36.2137 7.92939L40.0706 11.7863L36.686 15.171Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M24 29C26.7614 29 29 26.7614 29 24C29 21.2386 26.7614 19 24 19C21.2386 19 19 21.2386 19 24C19 26.7614 21.2386 29 24 29Z',
          'fill': t.colors[3],
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  eB = Yt('time', !0, function (t) {
    return z('svg', { width: t.size, height: t.size, viewBox: '0 0 48 48', fill: 'none' }, [
      z(
        'path',
        {
          'd': 'M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z',
          'fill': t.colors[1],
          'stroke': t.colors[0],
          'stroke-width': t.strokeWidth,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
      z(
        'path',
        {
          'd': 'M24.0084 12.0001L24.0072 24.0089L32.4866 32.4883',
          'stroke': t.colors[2],
          'stroke-width': t.strokeWidth,
          'stroke-linecap': t.strokeLinecap,
          'stroke-linejoin': t.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  tB = { class: 'flex items-start max-w-[75vw] w-max' },
  rB = { class: 'h-5 flex-center flex-none' },
  nB = { class: 'ml-1 text-sm whitespace-normal break-all' },
  iB = St({
    __name: 'Toast',
    props: {
      id: {},
      offset: { default: 0 },
      onClose: {},
      onDestroy: {},
      type: {},
      content: {},
      duration: { default: 1500 },
      position: { default: 'top-center' },
      html: { type: Boolean },
    },
    setup(t) {
      const e = t,
        r = tt(!1),
        n = nt(() => e.position.split('-')),
        i = nt(() => n.value[0]),
        s = nt(() => n.value[1]),
        o = nt(() => ({ success: j8, error: $8, info: K8, warning: R8 })[e.type]),
        l = nt(() => ({
          'toast': !0,
          'toast-top': i.value === 'top',
          'toast-bottom': i.value === 'bottom',
          'toast-start': s.value === 'start',
          'toast-center': s.value === 'center',
          'toast-end': s.value === 'end',
          'p-1': !0,
          'z-[9999]': !0,
        })),
        c = nt(() => ({
          'alert': !0,
          'alert-info': e.type === 'info',
          'alert-error': e.type === 'error',
          'alert-warning': e.type === 'warning',
          'alert-success': e.type === 'success',
          'py-2': !0,
        })),
        p = nt(() => ({ [i.value]: `${e.offset}px` })),
        f = nt(() => (s.value === 'center' ? `toast-${e.position}` : `toast-${s.value}`));
      Dl(() => {
        (r.value = !0), m();
      });
      function m() {
        setTimeout(() => {
          g();
        }, e.duration);
      }
      function g() {
        r.value = !1;
      }
      return (x, b) => (
        Ne(),
        nr(
          _g,
          { name: f.value, onBeforeLeave: x.onClose, onAfterLeave: x.onDestroy },
          {
            default: Ke(() => [
              Bb(
                $e(
                  'div',
                  { class: Gt(l.value), style: Us(p.value) },
                  [
                    $e(
                      'div',
                      { class: Gt([c.value, 'grid-cols-[unset] text-left']) },
                      [$e('div', tB, [$e('div', rB, [(Ne(), nr(Rb(o.value)))]), $e('div', nB, ai(x.content), 1)])],
                      2,
                    ),
                  ],
                  6,
                ),
                [[tA, r.value]],
              ),
            ]),
            _: 1,
          },
          8,
          ['name', 'onBeforeLeave', 'onAfterLeave'],
        )
      );
    },
  });
const sB = In(iB, [['__scopeId', 'data-v-737de82e']]);
let oB = 0;
const Xd = new Map(),
  vA = (t) => (Xd.has(t) || Xd.set(t, []), Xd.get(t)),
  x1 = (t, e) => {
    var o;
    const r = e.split('-')[0] === 'top',
      n = vA(e),
      i = n.findIndex((l) => {
        var c, p;
        return ((p = (c = l.component) == null ? void 0 : c.props) == null ? void 0 : p.id) === t;
      });
    if (i === -1) return;
    const s = n.splice(i, 1)[0];
    if (r) {
      const l = n.length;
      if (!l || i >= l) return;
      const c = ((o = s.el) == null ? void 0 : o.offsetHeight) ?? 0;
      for (let p = i; p < l; p++) {
        const f = n[p];
        if (f.el && f.component) {
          const m = parseInt(f.el.style.top, 10) - c;
          f.component.props.offset = m;
        }
      }
    }
  },
  FA = (t) => {
    const { position: e = 'top-center' } = t,
      r = e.split('-')[0] === 'bottom',
      n = document.createElement('div');
    n.classList.add('toast-container');
    const i = vA(e);
    let s = B8;
    r ||
      i.forEach((p) => {
        var f;
        s += ((f = p.el) == null ? void 0 : f.offsetHeight) ?? 0;
      });
    const o = oB++,
      l = {
        ...t,
        id: o,
        offset: s,
        onClose: () => {
          x1(o, e);
        },
        onDestroy: () => {
          t1(null, n), n.remove();
        },
      },
      c = z(sB, l);
    return (
      i.push(c),
      t1(c, n),
      document.body.appendChild(n),
      r &&
        setTimeout(() => {
          var f;
          const p = ((f = c.el) == null ? void 0 : f.offsetHeight) ?? 0;
          for (let m = 0; m < i.length - 1; m++) {
            const g = i[m];
            if (g.el && g.component) {
              const x = parseInt(g.el.style.bottom, 10) + p;
              g.component.props.offset = x;
            }
          }
        }),
      () => {
        x1(o, e);
      }
    );
  },
  aB = P8.reduce((t, e) => ((t[e] = (r, n) => FA({ ...n, content: r, type: e })), t), {}),
  Vg = Object.assign(FA, aB),
  lB = ['checked', 'disabled'],
  uB = St({
    __name: 'Toggle',
    props: {
      modelValue: { type: Boolean },
      type: {},
      size: { default: 'sm' },
      disabled: { type: Boolean, default: !1 },
    },
    emits: ['update:modelValue', 'change'],
    setup(t, { emit: e }) {
      const r = t,
        n = nt(() => ({
          'toggle': !0,
          'toggle-primary': r.type === 'primary',
          'toggle-secondary': r.type === 'secondary',
          'toggle-accent': r.type === 'accent',
          'toggle-info': r.type === 'info',
          'toggle-success': r.type === 'success',
          'toggle-warning': r.type === 'warning',
          'toggle-error': r.type === 'error',
          'toggle-xs': r.size === 'xs',
          'toggle-sm': r.size === 'sm',
          'toggle-md': r.size === 'md',
          'toggle-lg': r.size === 'lg',
        }));
      function i(s) {
        const o = s.target.checked;
        e('update:modelValue', o), e('change', o);
      }
      return (s, o) => (
        Ne(),
        rt(
          'input',
          { class: Gt(n.value), checked: s.modelValue, type: 'checkbox', disabled: s.disabled, onInput: i },
          null,
          42,
          lB,
        )
      );
    },
  }),
  cB = ['data-tip'],
  hB = St({
    __name: 'Tooltip',
    props: {
      type: {},
      content: { default: '' },
      open: { type: Boolean },
      position: { default: 'top' },
      disabled: { type: Boolean, default: !1 },
    },
    setup(t) {
      const e = t,
        r = nt(() => !e.content || e.disabled),
        n = nt(() =>
          r.value
            ? {}
            : {
                'tooltip': !0,
                'tooltip-open': e.open,
                'tooltip-top': e.position === 'top',
                'tooltip-bottom': e.position === 'bottom',
                'tooltip-left': e.position === 'left',
                'tooltip-right': e.position === 'right',
                'tooltip-primary': e.type === 'primary',
                'tooltip-secondary': e.type === 'secondary',
                'tooltip-accent': e.type === 'accent',
                'tooltip-info': e.type === 'info',
                'tooltip-success': e.type === 'success',
                'tooltip-warning': e.type === 'warning',
                'tooltip-error': e.type === 'error',
              },
        );
      return (i, s) => (
        Ne(),
        rt('div', { 'class': Gt(n.value), 'data-tip': i.content }, [li(i.$slots, 'default', {}, void 0, !0)], 10, cB)
      );
    },
  });
const ro = In(hB, [['__scopeId', 'data-v-2a81d5de']]),
  pB = { class: 'form-control w-full' },
  fB = { class: 'label' },
  dB = { class: 'inline-flex items-center' },
  mB = { class: 'label-text font-semibold text-base' },
  gB = { class: 'label font-semibold pb-0' },
  Zm = St({
    __name: 'FormInput',
    props: { modelValue: {}, title: {}, placeholder: { default: '' }, tip: { default: '' }, validateFn: {} },
    emits: ['update:modelValue', 'change', 'input'],
    setup(t, { expose: e, emit: r }) {
      const n = t;
      e({ validate: c, clearValidation: p, focus: l });
      const i = nt({
          get() {
            return n.modelValue;
          },
          set(g) {
            r('update:modelValue', g);
          },
        }),
        s = tt(''),
        o = tt(null);
      function l() {
        var g;
        (g = o.value) == null || g.focus();
      }
      function c() {
        var g;
        return (s.value = ((g = n.validateFn) == null ? void 0 : g.call(n, n.modelValue)) ?? ''), !s.value;
      }
      function p() {
        s.value = '';
      }
      function f(g) {
        r('change', g);
      }
      function m(g) {
        var x;
        (s.value = ((x = n.validateFn) == null ? void 0 : x.call(n, g)) ?? ''), r('input', g);
      }
      return (g, x) => (
        Ne(),
        rt('div', pB, [
          $e('label', fB, [
            $e('div', dB, [
              $e('span', mB, ai(g.title), 1),
              g.tip
                ? (Ne(),
                  nr(
                    te(ro),
                    { key: 0, class: 'ml-1', content: g.tip, position: 'right' },
                    { default: Ke(() => [z(te(U8), { size: 14 })]), _: 1 },
                    8,
                    ['content'],
                  ))
                : Ni('', !0),
            ]),
          ]),
          z(
            te(to),
            {
              'ref_key': 'input',
              'ref': o,
              'modelValue': i.value,
              'onUpdate:modelValue': x[0] || (x[0] = (b) => (i.value = b)),
              'class': Gt({ 'text-error': !!s.value }),
              'placeholder': g.placeholder,
              'size': 'sm',
              'bordered': '',
              'type': s.value ? 'error' : void 0,
              'onChange': f,
              'onInput': m,
            },
            null,
            8,
            ['modelValue', 'class', 'placeholder', 'type'],
          ),
          $e('label', gB, [
            $e('span', { class: Gt(['label-text-alt', { 'text-error': !!s.value }]) }, ai(s.value || ' '), 3),
          ]),
        ])
      );
    },
  }),
  Lr = St({
    __name: 'IconButton',
    props: { size: { default: 24 }, transparent: { type: Boolean, default: !1 }, danger: { type: Boolean } },
    setup(t) {
      const e = t,
        r = nt(() => ({ width: `${e.size}px`, height: `${e.size}px` }));
      return (n, i) => (
        Ne(),
        nr(
          te(Wn),
          {
            class: Gt([
              'min-h-0 rounded',
              { 'hover:!bg-transparent': n.transparent && !n.danger, 'text-base-100': n.danger },
            ]),
            style: Us(r.value),
            shape: 'square',
            type: n.danger ? 'error' : 'ghost',
          },
          { default: Ke(() => [li(n.$slots, 'default')]), _: 3 },
          8,
          ['class', 'style', 'type'],
        )
      );
    },
  });
function Df(t) {
  return Zp() ? (ab(t), !0) : !1;
}
function nl(t) {
  return typeof t == 'function' ? t() : te(t);
}
const xf = typeof window < 'u' && typeof document < 'u',
  yB = Object.prototype.toString,
  DB = (t) => yB.call(t) === '[object Object]',
  ju = () => {},
  xB = CB();
function CB() {
  var t;
  return (
    xf &&
    ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) &&
    /iP(ad|hone|od)/.test(window.navigator.userAgent)
  );
}
function SA(t, e) {
  function r(...n) {
    return new Promise((i, s) => {
      Promise.resolve(t(() => e.apply(this, n), { fn: e, thisArg: this, args: n }))
        .then(i)
        .catch(s);
    });
  }
  return r;
}
const wA = (t) => t();
function bB(t, e = {}) {
  let r,
    n,
    i = ju;
  const s = (l) => {
    clearTimeout(l), i(), (i = ju);
  };
  return (l) => {
    const c = nl(t),
      p = nl(e.maxWait);
    return (
      r && s(r),
      c <= 0 || (p !== void 0 && p <= 0)
        ? (n && (s(n), (n = null)), Promise.resolve(l()))
        : new Promise((f, m) => {
            (i = e.rejectOnCancel ? m : f),
              p &&
                !n &&
                (n = setTimeout(() => {
                  r && s(r), (n = null), f(l());
                }, p)),
              (r = setTimeout(() => {
                n && s(n), (n = null), f(l());
              }, c));
          })
    );
  };
}
function AB(t = wA) {
  const e = tt(!0);
  function r() {
    e.value = !1;
  }
  function n() {
    e.value = !0;
  }
  const i = (...s) => {
    e.value && t(...s);
  };
  return { isActive: ic(e), pause: r, resume: n, eventFilter: i };
}
function zg(t, e = 200, r = {}) {
  return SA(bB(e, r), t);
}
function EB(t, e, r = {}) {
  const { eventFilter: n = wA, ...i } = r;
  return Zt(t, SA(n, e), i);
}
function vB(t, e, r = {}) {
  const { eventFilter: n, ...i } = r,
    { eventFilter: s, pause: o, resume: l, isActive: c } = AB(n);
  return { stop: EB(t, e, { ...i, eventFilter: s }), pause: o, resume: l, isActive: c };
}
function FB(t, e = !0) {
  cf() ? Dl(t) : e ? t() : gi(t);
}
function SB(t, e, r = {}) {
  const { immediate: n = !0 } = r,
    i = tt(!1);
  let s = null;
  function o() {
    s && (clearTimeout(s), (s = null));
  }
  function l() {
    (i.value = !1), o();
  }
  function c(...p) {
    o(),
      (i.value = !0),
      (s = setTimeout(() => {
        (i.value = !1), (s = null), t(...p);
      }, nl(e)));
  }
  return n && ((i.value = !0), xf && c()), Df(l), { isPending: ic(i), start: c, stop: l };
}
function il(t, e, r) {
  return Zt(
    t,
    (n, i, s) => {
      n && e(n, i, s);
    },
    r,
  );
}
function Wo(t) {
  var e;
  const r = nl(t);
  return (e = r == null ? void 0 : r.$el) != null ? e : r;
}
const sl = xf ? window : void 0,
  wB = xf ? window.document : void 0;
function Js(...t) {
  let e, r, n, i;
  if ((typeof t[0] == 'string' || Array.isArray(t[0]) ? (([r, n, i] = t), (e = sl)) : ([e, r, n, i] = t), !e))
    return ju;
  Array.isArray(r) || (r = [r]), Array.isArray(n) || (n = [n]);
  const s = [],
    o = () => {
      s.forEach((f) => f()), (s.length = 0);
    },
    l = (f, m, g, x) => (f.addEventListener(m, g, x), () => f.removeEventListener(m, g, x)),
    c = Zt(
      () => [Wo(e), nl(i)],
      ([f, m]) => {
        if ((o(), !f)) return;
        const g = DB(m) ? { ...m } : m;
        s.push(...r.flatMap((x) => n.map((b) => l(f, x, b, g))));
      },
      { immediate: !0, flush: 'post' },
    ),
    p = () => {
      c(), o();
    };
  return Df(p), p;
}
let C1 = !1;
function TB(t, e, r = {}) {
  const { window: n = sl, ignore: i = [], capture: s = !0, detectIframe: o = !1 } = r;
  if (!n) return;
  xB &&
    !C1 &&
    ((C1 = !0),
    Array.from(n.document.body.children).forEach((g) => g.addEventListener('click', ju)),
    n.document.documentElement.addEventListener('click', ju));
  let l = !0;
  const c = (g) =>
      i.some((x) => {
        if (typeof x == 'string')
          return Array.from(n.document.querySelectorAll(x)).some((b) => b === g.target || g.composedPath().includes(b));
        {
          const b = Wo(x);
          return b && (g.target === b || g.composedPath().includes(b));
        }
      }),
    f = [
      Js(
        n,
        'click',
        (g) => {
          const x = Wo(t);
          if (!(!x || x === g.target || g.composedPath().includes(x))) {
            if ((g.detail === 0 && (l = !c(g)), !l)) {
              l = !0;
              return;
            }
            e(g);
          }
        },
        { passive: !0, capture: s },
      ),
      Js(
        n,
        'pointerdown',
        (g) => {
          const x = Wo(t);
          x && (l = !g.composedPath().includes(x) && !c(g));
        },
        { passive: !0 },
      ),
      o &&
        Js(n, 'blur', (g) => {
          setTimeout(() => {
            var x;
            const b = Wo(t);
            ((x = n.document.activeElement) == null ? void 0 : x.tagName) === 'IFRAME' &&
              !(b != null && b.contains(n.document.activeElement)) &&
              e(g);
          }, 0);
        }),
    ].filter(Boolean);
  return () => f.forEach((g) => g());
}
function kB() {
  const t = tt(!1);
  return (
    cf() &&
      Dl(() => {
        t.value = !0;
      }),
    t
  );
}
function PB(t) {
  const e = kB();
  return nt(() => (e.value, !!t()));
}
const hh =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : typeof self < 'u'
      ? self
      : {},
  ph = '__vueuse_ssr_handlers__',
  BB = IB();
function IB() {
  return ph in hh || (hh[ph] = hh[ph] || {}), hh[ph];
}
function NB(t, e) {
  return BB[t] || e;
}
function MB(t) {
  return t == null
    ? 'any'
    : t instanceof Set
    ? 'set'
    : t instanceof Map
    ? 'map'
    : t instanceof Date
    ? 'date'
    : typeof t == 'boolean'
    ? 'boolean'
    : typeof t == 'string'
    ? 'string'
    : typeof t == 'object'
    ? 'object'
    : Number.isNaN(t)
    ? 'any'
    : 'number';
}
const OB = {
    boolean: { read: (t) => t === 'true', write: (t) => String(t) },
    object: { read: (t) => JSON.parse(t), write: (t) => JSON.stringify(t) },
    number: { read: (t) => Number.parseFloat(t), write: (t) => String(t) },
    any: { read: (t) => t, write: (t) => String(t) },
    string: { read: (t) => t, write: (t) => String(t) },
    map: { read: (t) => new Map(JSON.parse(t)), write: (t) => JSON.stringify(Array.from(t.entries())) },
    set: { read: (t) => new Set(JSON.parse(t)), write: (t) => JSON.stringify(Array.from(t)) },
    date: { read: (t) => new Date(t), write: (t) => t.toISOString() },
  },
  b1 = 'vueuse-storage';
function LB(t, e, r, n = {}) {
  var i;
  const {
      flush: s = 'pre',
      deep: o = !0,
      listenToStorageChanges: l = !0,
      writeDefaults: c = !0,
      mergeDefaults: p = !1,
      shallow: f,
      window: m = sl,
      eventFilter: g,
      onError: x = (Y) => {
        console.error(Y);
      },
    } = n,
    b = (f ? Ua : tt)(e);
  if (!r)
    try {
      r = NB('getDefaultStorage', () => {
        var Y;
        return (Y = sl) == null ? void 0 : Y.localStorage;
      })();
    } catch (Y) {
      x(Y);
    }
  if (!r) return b;
  const F = nl(e),
    E = MB(F),
    w = (i = n.serializer) != null ? i : OB[E],
    { pause: I, resume: T } = vB(b, () => j(b.value), { flush: s, deep: o, eventFilter: g });
  return m && l && (Js(m, 'storage', se), Js(m, b1, L)), se(), b;
  function j(Y) {
    try {
      if (Y == null) r.removeItem(t);
      else {
        const W = w.write(Y),
          X = r.getItem(t);
        X !== W &&
          (r.setItem(t, W),
          m && m.dispatchEvent(new CustomEvent(b1, { detail: { key: t, oldValue: X, newValue: W, storageArea: r } })));
      }
    } catch (W) {
      x(W);
    }
  }
  function $(Y) {
    const W = Y ? Y.newValue : r.getItem(t);
    if (W == null) return c && F !== null && r.setItem(t, w.write(F)), F;
    if (!Y && p) {
      const X = w.read(W);
      return typeof p == 'function' ? p(X, F) : E === 'object' && !Array.isArray(X) ? { ...F, ...X } : X;
    } else return typeof W != 'string' ? W : w.read(W);
  }
  function L(Y) {
    se(Y.detail);
  }
  function se(Y) {
    if (!(Y && Y.storageArea !== r)) {
      if (Y && Y.key == null) {
        b.value = F;
        return;
      }
      if (!(Y && Y.key !== t)) {
        I();
        try {
          (Y == null ? void 0 : Y.newValue) !== w.write(b.value) && (b.value = $(Y));
        } catch (W) {
          x(W);
        } finally {
          Y ? gi(T) : T();
        }
      }
    }
  }
}
function _B(t, e, r = {}) {
  const { window: n = sl, ...i } = r;
  let s;
  const o = PB(() => n && 'ResizeObserver' in n),
    l = () => {
      s && (s.disconnect(), (s = void 0));
    },
    c = nt(() => (Array.isArray(t) ? t.map((m) => Wo(m)) : [Wo(t)])),
    p = Zt(
      c,
      (m) => {
        if ((l(), o.value && n)) {
          s = new ResizeObserver(e);
          for (const g of m) g && s.observe(g, i);
        }
      },
      { immediate: !0, flush: 'post', deep: !0 },
    ),
    f = () => {
      l(), p();
    };
  return Df(f), { isSupported: o, stop: f };
}
const Ql = new Map();
function TA(t) {
  const e = Zp();
  function r(l) {
    var c;
    const p = Ql.get(t) || new Set();
    p.add(l), Ql.set(t, p);
    const f = () => i(l);
    return (c = e == null ? void 0 : e.cleanups) == null || c.push(f), f;
  }
  function n(l) {
    function c(...p) {
      i(c), l(...p);
    }
    return r(c);
  }
  function i(l) {
    const c = Ql.get(t);
    c && (c.delete(l), c.size || s());
  }
  function s() {
    Ql.delete(t);
  }
  function o(l, c) {
    var p;
    (p = Ql.get(t)) == null || p.forEach((f) => f(l, c));
  }
  return { on: r, once: n, off: i, emit: o, reset: s };
}
function kA(t, e, r = {}) {
  const { window: n = sl } = r;
  return LB(t, e, n == null ? void 0 : n.localStorage, r);
}
let RB = 0;
function jB(t, e = {}) {
  const r = tt(!1),
    { document: n = wB, immediate: i = !0, manual: s = !1, id: o = `vueuse_styletag_${++RB}` } = e,
    l = tt(t);
  let c = () => {};
  const p = () => {
      if (!n) return;
      const m = n.getElementById(o) || n.createElement('style');
      m.isConnected || ((m.id = o), e.media && (m.media = e.media), n.head.appendChild(m)),
        !r.value &&
          ((c = Zt(
            l,
            (g) => {
              m.textContent = g;
            },
            { immediate: !0 },
          )),
          (r.value = !0));
    },
    f = () => {
      !n || !r.value || (c(), n.head.removeChild(n.getElementById(o)), (r.value = !1));
    };
  return i && !s && FB(p), s || Df(f), { id: o, css: l, unload: f, load: p, isLoaded: ic(r) };
}
const $B = St({
  __name: 'ResizeLayout',
  props: {
    vertical: { type: Boolean, default: !1 },
    barSize: { default: 8 },
    barColor: { default: 'transparent' },
    barFocusedSize: { default: 2 },
    barFocusedColor: { default: 'hsl(var(--p))' },
    initStartSize: {},
    localKey: { default: '' },
    reverse: { type: Boolean, default: !1 },
    startMinSize: {},
    startMaxSize: {},
  },
  setup(t) {
    const e = t,
      r = tt(null),
      n = tt(null),
      i = tt(null),
      s = tt(null),
      o = tt(!1),
      l = tt(!1),
      c = kA(e.localKey, ''),
      p = tt(c.value || e.initStartSize || '50%'),
      { css: f, load: m, unload: g } = jB(''),
      x = nt(() =>
        e.vertical
          ? {
              'height': p.value,
              'min-height': e.startMinSize && `${e.startMinSize}px`,
              'max-height': e.startMaxSize && `${e.startMaxSize}px`,
            }
          : {
              'width': p.value,
              'min-width': e.startMinSize && `${e.startMinSize}px`,
              'max-width': e.startMaxSize && `${e.startMaxSize}px`,
            },
      ),
      b = nt(() =>
        e.vertical
          ? { 'height': `${e.barSize}px`, 'width': '100%', 'cursor': 'row-resize', 'background-color': e.barColor }
          : { 'width': `${e.barSize}px`, 'height': '100%', 'cursor': 'col-resize', 'background-color': e.barColor },
      ),
      F = nt(() =>
        e.vertical
          ? {
              'height': `${e.barFocusedSize}px`,
              'width': '100%',
              'background-color': o.value || l.value ? e.barFocusedColor : 'transparent',
            }
          : {
              'width': `${e.barFocusedSize}px`,
              'height': '100%',
              'background-color': o.value || l.value ? e.barFocusedColor : 'transparent',
            },
      );
    return (
      Js(n, 'mousedown', () => {
        (l.value = !0),
          (f.value = `
    :root { 
      cursor: ${e.vertical ? 'row-resize' : 'col-resize'}; 
    }
    * {
      user-select: none;
      pointer-events: none;
    }
  `),
          m();
      }),
      Js(document, 'mouseup', () => {
        (l.value = !1), g();
      }),
      Js(document, 'mousemove', (E) => {
        var se, Y;
        if (!l.value) return;
        const { width: w = 0, height: I = 0 } = ((se = r.value) == null ? void 0 : se.getBoundingClientRect()) ?? {},
          { width: T = 0, height: j = 0 } = ((Y = i.value) == null ? void 0 : Y.getBoundingClientRect()) ?? {},
          $ = e.vertical ? I - e.barSize : w - e.barSize,
          L = e.vertical
            ? e.reverse
              ? j - E.movementY
              : j + E.movementY
            : e.reverse
            ? T - E.movementX
            : T + E.movementX;
        (p.value = `${Math.min(L, $)}px`),
          e.localKey && (c.value = p.value),
          gi(() => {
            var q, xe, Re, re, ie, Q;
            const W =
                (e.vertical
                  ? (q = r.value) == null
                    ? void 0
                    : q.scrollHeight
                  : (xe = r.value) == null
                  ? void 0
                  : xe.scrollWidth) ?? 0,
              X =
                (e.vertical
                  ? (Re = r.value) == null
                    ? void 0
                    : Re.offsetHeight
                  : (re = r.value) == null
                  ? void 0
                  : re.offsetWidth) ?? 0;
            if (W > X) {
              const ce =
                (e.vertical
                  ? (ie = s.value) == null
                    ? void 0
                    : ie.scrollHeight
                  : (Q = s.value) == null
                  ? void 0
                  : Q.scrollWidth) ?? 0;
              (p.value = `${X - e.barSize - ce}px`), e.localKey && (c.value = p.value);
            }
          });
      }),
      _B(r, (E) => {
        var L;
        const w = E[0],
          { width: I, height: T } = w.contentRect,
          { width: j = 0, height: $ = 0 } = ((L = i.value) == null ? void 0 : L.getBoundingClientRect()) ?? {};
        e.vertical ? (p.value = `${Math.min($, T - e.barSize)}px`) : (p.value = `${Math.min(j, I - e.barSize)}px`),
          e.localKey && (c.value = p.value);
      }),
      Ig(() => {
        g();
      }),
      (E, w) => (
        Ne(),
        rt(
          'div',
          {
            ref_key: 'layoutRef',
            ref: r,
            class: Gt([
              'resize-layout flex',
              {
                'flex-col': E.vertical && !E.reverse,
                'flex-row-reverse': !E.vertical && E.reverse,
                'flex-col-reverse': E.vertical && E.reverse,
              },
            ]),
          },
          [
            $e(
              'div',
              {
                ref_key: 'startRef',
                ref: i,
                class: Gt([
                  'start-container flex-none',
                  [E.vertical ? 'min-h-0 max-h-full h-1/2' : 'min-w-0 max-w-full w-1/2'],
                ]),
                style: Us(x.value),
              },
              [li(E.$slots, 'start', {}, void 0, !0)],
              6,
            ),
            $e(
              'div',
              {
                ref_key: 'barRef',
                ref: n,
                class: 'flex-none flex-center',
                style: Us(b.value),
                onMouseenter: w[0] || (w[0] = (I) => (o.value = !0)),
                onMouseleave: w[1] || (w[1] = (I) => (o.value = !1)),
              },
              [$e('div', { class: 'transition rounded-full', style: Us(F.value) }, null, 4)],
              36,
            ),
            $e(
              'div',
              {
                ref_key: 'endRef',
                ref: s,
                class: Gt(['end-container flex-1', [E.vertical ? 'min-h-0 max-h-full' : 'min-w-0 max-w-full']]),
              },
              [li(E.$slots, 'end', {}, void 0, !0)],
              2,
            ),
          ],
          2,
        )
      )
    );
  },
});
const A1 = In($B, [['__scopeId', 'data-v-ab7dc4ae']]);
class Ot {
  lineAt(e) {
    if (e < 0 || e > this.length) throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  line(e) {
    if (e < 1 || e > this.lines) throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  replace(e, r, n) {
    let i = [];
    return (
      this.decompose(0, e, i, 2),
      n.length && n.decompose(0, n.length, i, 3),
      this.decompose(r, this.length, i, 1),
      Bi.from(i, this.length - (r - e) + n.length)
    );
  }
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  slice(e, r = this.length) {
    let n = [];
    return this.decompose(e, r, n, 0), Bi.from(n, r - e);
  }
  eq(e) {
    if (e == this) return !0;
    if (e.length != this.length || e.lines != this.lines) return !1;
    let r = this.scanIdentical(e, 1),
      n = this.length - this.scanIdentical(e, -1),
      i = new bu(this),
      s = new bu(e);
    for (let o = r, l = r; ; ) {
      if ((i.next(o), s.next(o), (o = 0), i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value))
        return !1;
      if (((l += i.value.length), i.done || l >= n)) return !0;
    }
  }
  iter(e = 1) {
    return new bu(this, e);
  }
  iterRange(e, r = this.length) {
    return new PA(this, e, r);
  }
  iterLines(e, r) {
    let n;
    if (e == null) n = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      n = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new BA(n);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  constructor() {}
  static of(e) {
    if (e.length == 0) throw new RangeError('A document must have at least one line');
    return e.length == 1 && !e[0] ? Ot.empty : e.length <= 32 ? new hr(e) : Bi.from(hr.split(e, []));
  }
}
class hr extends Ot {
  constructor(e, r = VB(e)) {
    super(), (this.text = e), (this.length = r);
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s],
        l = i + o.length;
      if ((r ? n : l) >= e) return new zB(i, l, n, o);
      (i = l + 1), n++;
    }
  }
  decompose(e, r, n, i) {
    let s = e <= 0 && r >= this.length ? this : new hr(E1(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = n.pop(),
        l = qh(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32) n.push(new hr(l, o.length + s.length));
      else {
        let c = l.length >> 1;
        n.push(new hr(l.slice(0, c)), new hr(l.slice(c)));
      }
    } else n.push(s);
  }
  replace(e, r, n) {
    if (!(n instanceof hr)) return super.replace(e, r, n);
    let i = qh(this.text, qh(n.text, E1(this.text, 0, e)), r),
      s = this.length + n.length - (r - e);
    return i.length <= 32 ? new hr(i, s) : Bi.from(hr.split(i, []), s);
  }
  sliceString(
    e,
    r = this.length,
    n = `
`,
  ) {
    let i = '';
    for (let s = 0, o = 0; s <= r && o < this.text.length; o++) {
      let l = this.text[o],
        c = s + l.length;
      s > e && o && (i += n), e < c && r > s && (i += l.slice(Math.max(0, e - s), r - s)), (s = c + 1);
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text) e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let n = [],
      i = -1;
    for (let s of e) n.push(s), (i += s.length + 1), n.length == 32 && (r.push(new hr(n, i)), (n = []), (i = -1));
    return i > -1 && r.push(new hr(n, i)), r;
  }
}
class Bi extends Ot {
  constructor(e, r) {
    super(), (this.children = e), (this.length = r), (this.lines = 0);
    for (let n of e) this.lines += n.lines;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s],
        l = i + o.length,
        c = n + o.lines - 1;
      if ((r ? c : l) >= e) return o.lineInner(e, r, n, i);
      (i = l + 1), (n = c + 1);
    }
  }
  decompose(e, r, n, i) {
    for (let s = 0, o = 0; o <= r && s < this.children.length; s++) {
      let l = this.children[s],
        c = o + l.length;
      if (e <= c && r >= o) {
        let p = i & ((o <= e ? 1 : 0) | (c >= r ? 2 : 0));
        o >= e && c <= r && !p ? n.push(l) : l.decompose(e - o, r - o, n, p);
      }
      o = c + 1;
    }
  }
  replace(e, r, n) {
    if (n.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i],
          l = s + o.length;
        if (e >= s && r <= l) {
          let c = o.replace(e - s, r - s, n),
            p = this.lines - o.lines + c.lines;
          if (c.lines < p >> (5 - 1) && c.lines > p >> (5 + 1)) {
            let f = this.children.slice();
            return (f[i] = c), new Bi(f, this.length - (r - e) + n.length);
          }
          return super.replace(s, l, c);
        }
        s = l + 1;
      }
    return super.replace(e, r, n);
  }
  sliceString(
    e,
    r = this.length,
    n = `
`,
  ) {
    let i = '';
    for (let s = 0, o = 0; s < this.children.length && o <= r; s++) {
      let l = this.children[s],
        c = o + l.length;
      o > e && s && (i += n), e < c && r > o && (i += l.sliceString(e - o, r - o, n)), (o = c + 1);
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children) r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof Bi)) return 0;
    let n = 0,
      [i, s, o, l] =
        r > 0
          ? [0, 0, this.children.length, e.children.length]
          : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, s += r) {
      if (i == o || s == l) return n;
      let c = this.children[i],
        p = e.children[s];
      if (c != p) return n + c.scanIdentical(p, r);
      n += c.length + 1;
    }
  }
  static from(e, r = e.reduce((n, i) => n + i.length + 1, -1)) {
    let n = 0;
    for (let x of e) n += x.lines;
    if (n < 32) {
      let x = [];
      for (let b of e) b.flatten(x);
      return new hr(x, r);
    }
    let i = Math.max(32, n >> 5),
      s = i << 1,
      o = i >> 1,
      l = [],
      c = 0,
      p = -1,
      f = [];
    function m(x) {
      let b;
      if (x.lines > s && x instanceof Bi) for (let F of x.children) m(F);
      else
        x.lines > o && (c > o || !c)
          ? (g(), l.push(x))
          : x instanceof hr && c && (b = f[f.length - 1]) instanceof hr && x.lines + b.lines <= 32
          ? ((c += x.lines),
            (p += x.length + 1),
            (f[f.length - 1] = new hr(b.text.concat(x.text), b.length + 1 + x.length)))
          : (c + x.lines > i && g(), (c += x.lines), (p += x.length + 1), f.push(x));
    }
    function g() {
      c != 0 && (l.push(f.length == 1 ? f[0] : Bi.from(f, p)), (p = -1), (c = f.length = 0));
    }
    for (let x of e) m(x);
    return g(), l.length == 1 ? l[0] : new Bi(l, r);
  }
}
Ot.empty = new hr([''], 0);
function VB(t) {
  let e = -1;
  for (let r of t) e += r.length + 1;
  return e;
}
function qh(t, e, r = 0, n = 1e9) {
  for (let i = 0, s = 0, o = !0; s < t.length && i <= n; s++) {
    let l = t[s],
      c = i + l.length;
    c >= r &&
      (c > n && (l = l.slice(0, n - i)),
      i < r && (l = l.slice(r - i)),
      o ? ((e[e.length - 1] += l), (o = !1)) : e.push(l)),
      (i = c + 1);
  }
  return e;
}
function E1(t, e, r) {
  return qh(t, [''], e, r);
}
class bu {
  constructor(e, r = 1) {
    (this.dir = r),
      (this.done = !1),
      (this.lineBreak = !1),
      (this.value = ''),
      (this.nodes = [e]),
      (this.offsets = [r > 0 ? 1 : (e instanceof hr ? e.text.length : e.children.length) << 1]);
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1,
        i = this.nodes[n],
        s = this.offsets[n],
        o = s >> 1,
        l = i instanceof hr ? i.text.length : i.children.length;
      if (o == (r > 0 ? l : 0)) {
        if (n == 0) return (this.done = !0), (this.value = ''), this;
        r > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (r > 0 ? 0 : 1)) {
        if (((this.offsets[n] += r), e == 0))
          return (
            (this.lineBreak = !0),
            (this.value = `
`),
            this
          );
        e--;
      } else if (i instanceof hr) {
        let c = i.text[o + (r < 0 ? -1 : 0)];
        if (((this.offsets[n] += r), c.length > Math.max(0, e)))
          return (this.value = e == 0 ? c : r > 0 ? c.slice(e) : c.slice(0, c.length - e)), this;
        e -= c.length;
      } else {
        let c = i.children[o + (r < 0 ? -1 : 0)];
        e > c.length
          ? ((e -= c.length), (this.offsets[n] += r))
          : (r < 0 && this.offsets[n]--,
            this.nodes.push(c),
            this.offsets.push(r > 0 ? 1 : (c instanceof hr ? c.text.length : c.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), (e = this.value.length)), this.nextInner(e, this.dir);
  }
}
class PA {
  constructor(e, r, n) {
    (this.value = ''),
      (this.done = !1),
      (this.cursor = new bu(e, r > n ? -1 : 1)),
      (this.pos = r > n ? e.length : 0),
      (this.from = Math.min(r, n)),
      (this.to = Math.max(r, n));
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to) return (this.value = ''), (this.done = !0), this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let n = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), (n -= e);
    let { value: i } = this.cursor.next(e);
    return (
      (this.pos += (i.length + e) * r),
      (this.value = i.length <= n ? i : r < 0 ? i.slice(i.length - n) : i.slice(0, n)),
      (this.done = !this.value),
      this
    );
  }
  next(e = 0) {
    return (
      e < 0 ? (e = Math.max(e, this.from - this.pos)) : e > 0 && (e = Math.min(e, this.to - this.pos)),
      this.nextInner(e, this.cursor.dir)
    );
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != '';
  }
}
class BA {
  constructor(e) {
    (this.inner = e), (this.afterBreak = !0), (this.value = ''), (this.done = !1);
  }
  next(e = 0) {
    let { done: r, lineBreak: n, value: i } = this.inner.next(e);
    return (
      r
        ? ((this.done = !0), (this.value = ''))
        : n
        ? this.afterBreak
          ? (this.value = '')
          : ((this.afterBreak = !0), this.next())
        : ((this.value = i), (this.afterBreak = !1)),
      this
    );
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < 'u' &&
  ((Ot.prototype[Symbol.iterator] = function () {
    return this.iter();
  }),
  (bu.prototype[Symbol.iterator] =
    PA.prototype[Symbol.iterator] =
    BA.prototype[Symbol.iterator] =
      function () {
        return this;
      }));
class zB {
  constructor(e, r, n, i) {
    (this.from = e), (this.to = r), (this.number = n), (this.text = i);
  }
  get length() {
    return this.to - this.from;
  }
}
let Ka =
  'lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o'
    .split(',')
    .map((t) => (t ? parseInt(t, 36) : 1));
for (let t = 1; t < Ka.length; t++) Ka[t] += Ka[t - 1];
function HB(t) {
  for (let e = 1; e < Ka.length; e += 2) if (Ka[e] > t) return Ka[e - 1] <= t;
  return !1;
}
function v1(t) {
  return t >= 127462 && t <= 127487;
}
const F1 = 8205;
function Yr(t, e, r = !0, n = !0) {
  return (r ? IA : WB)(t, e, n);
}
function IA(t, e, r) {
  if (e == t.length) return e;
  e && NA(t.charCodeAt(e)) && MA(t.charCodeAt(e - 1)) && e--;
  let n = Nr(t, e);
  for (e += _n(n); e < t.length; ) {
    let i = Nr(t, e);
    if (n == F1 || i == F1 || (r && HB(i))) (e += _n(i)), (n = i);
    else if (v1(i)) {
      let s = 0,
        o = e - 2;
      for (; o >= 0 && v1(Nr(t, o)); ) s++, (o -= 2);
      if (s % 2 == 0) break;
      e += 2;
    } else break;
  }
  return e;
}
function WB(t, e, r) {
  for (; e > 0; ) {
    let n = IA(t, e - 2, r);
    if (n < e) return n;
    e--;
  }
  return 0;
}
function NA(t) {
  return t >= 56320 && t < 57344;
}
function MA(t) {
  return t >= 55296 && t < 56320;
}
function Nr(t, e) {
  let r = t.charCodeAt(e);
  if (!MA(r) || e + 1 == t.length) return r;
  let n = t.charCodeAt(e + 1);
  return NA(n) ? ((r - 55296) << 10) + (n - 56320) + 65536 : r;
}
function Hg(t) {
  return t <= 65535
    ? String.fromCharCode(t)
    : ((t -= 65536), String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function _n(t) {
  return t < 65536 ? 1 : 2;
}
const e0 = /\r\n?|\n/;
var sn = (function (t) {
  return (
    (t[(t.Simple = 0)] = 'Simple'),
    (t[(t.TrackDel = 1)] = 'TrackDel'),
    (t[(t.TrackBefore = 2)] = 'TrackBefore'),
    (t[(t.TrackAfter = 3)] = 'TrackAfter'),
    t
  );
})(sn || (sn = {}));
class _i {
  constructor(e) {
    this.sections = e;
  }
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) e += this.sections[r];
    return e;
  }
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r + 1];
      e += n < 0 ? this.sections[r] : n;
    }
    return e;
  }
  get empty() {
    return this.sections.length == 0 || (this.sections.length == 2 && this.sections[1] < 0);
  }
  iterGaps(e) {
    for (let r = 0, n = 0, i = 0; r < this.sections.length; ) {
      let s = this.sections[r++],
        o = this.sections[r++];
      o < 0 ? (e(n, i, s), (i += s)) : (i += o), (n += s);
    }
  }
  iterChangedRanges(e, r = !1) {
    t0(this, e, r);
  }
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++],
        i = this.sections[r++];
      i < 0 ? e.push(n, i) : e.push(i, n);
    }
    return new _i(e);
  }
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : OA(this, e);
  }
  mapDesc(e, r = !1) {
    return e.empty ? this : r0(this, e, r);
  }
  mapPos(e, r = -1, n = sn.Simple) {
    let i = 0,
      s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++],
        c = this.sections[o++],
        p = i + l;
      if (c < 0) {
        if (p > e) return s + (e - i);
        s += l;
      } else {
        if (
          n != sn.Simple &&
          p >= e &&
          ((n == sn.TrackDel && i < e && p > e) || (n == sn.TrackBefore && i < e) || (n == sn.TrackAfter && p > e))
        )
          return null;
        if (p > e || (p == e && r < 0 && !l)) return e == i || r < 0 ? s : s + c;
        s += c;
      }
      i = p;
    }
    if (e > i) throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  touchesRange(e, r = e) {
    for (let n = 0, i = 0; n < this.sections.length && i <= r; ) {
      let s = this.sections[n++],
        o = this.sections[n++],
        l = i + s;
      if (o >= 0 && i <= r && l >= e) return i < e && l > r ? 'cover' : !0;
      i = l;
    }
    return !1;
  }
  toString() {
    let e = '';
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++],
        i = this.sections[r++];
      e += (e ? ' ' : '') + n + (i >= 0 ? ':' + i : '');
    }
    return e;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != 'number'))
      throw new RangeError('Invalid JSON representation of ChangeDesc');
    return new _i(e);
  }
  static create(e) {
    return new _i(e);
  }
}
class Cr extends _i {
  constructor(e, r) {
    super(e), (this.inserted = r);
  }
  apply(e) {
    if (this.length != e.length) throw new RangeError('Applying change set to a document with the wrong length');
    return t0(this, (r, n, i, s, o) => (e = e.replace(i, i + (n - r), o)), !1), e;
  }
  mapDesc(e, r = !1) {
    return r0(this, e, r, !0);
  }
  invert(e) {
    let r = this.sections.slice(),
      n = [];
    for (let i = 0, s = 0; i < r.length; i += 2) {
      let o = r[i],
        l = r[i + 1];
      if (l >= 0) {
        (r[i] = l), (r[i + 1] = o);
        let c = i >> 1;
        for (; n.length < c; ) n.push(Ot.empty);
        n.push(o ? e.slice(s, s + o) : Ot.empty);
      }
      s += o;
    }
    return new Cr(r, n);
  }
  compose(e) {
    return this.empty ? e : e.empty ? this : OA(this, e, !0);
  }
  map(e, r = !1) {
    return e.empty ? this : r0(this, e, r, !0);
  }
  iterChanges(e, r = !1) {
    t0(this, e, r);
  }
  get desc() {
    return _i.create(this.sections);
  }
  filter(e) {
    let r = [],
      n = [],
      i = [],
      s = new $u(this);
    e: for (let o = 0, l = 0; ; ) {
      let c = o == e.length ? 1e9 : e[o++];
      for (; l < c || (l == c && s.len == 0); ) {
        if (s.done) break e;
        let f = Math.min(s.len, c - l);
        Kr(i, f, -1);
        let m = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        Kr(r, f, m), m > 0 && $s(n, r, s.text), s.forward(f), (l += f);
      }
      let p = e[o++];
      for (; l < p; ) {
        if (s.done) break e;
        let f = Math.min(s.len, p - l);
        Kr(r, f, -1), Kr(i, f, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(f), (l += f);
      }
    }
    return { changes: new Cr(r, n), filtered: _i.create(i) };
  }
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r],
        i = this.sections[r + 1];
      i < 0 ? e.push(n) : i == 0 ? e.push([n]) : e.push([n].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  static of(e, r, n) {
    let i = [],
      s = [],
      o = 0,
      l = null;
    function c(f = !1) {
      if (!f && !i.length) return;
      o < r && Kr(i, r - o, -1);
      let m = new Cr(i, s);
      (l = l ? l.compose(m.map(l)) : m), (i = []), (s = []), (o = 0);
    }
    function p(f) {
      if (Array.isArray(f)) for (let m of f) p(m);
      else if (f instanceof Cr) {
        if (f.length != r) throw new RangeError(`Mismatched change set length (got ${f.length}, expected ${r})`);
        c(), (l = l ? l.compose(f.map(l)) : f);
      } else {
        let { from: m, to: g = m, insert: x } = f;
        if (m > g || m < 0 || g > r) throw new RangeError(`Invalid change range ${m} to ${g} (in doc of length ${r})`);
        let b = x ? (typeof x == 'string' ? Ot.of(x.split(n || e0)) : x) : Ot.empty,
          F = b.length;
        if (m == g && F == 0) return;
        m < o && c(), m > o && Kr(i, m - o, -1), Kr(i, g - m, F), $s(s, i, b), (o = g);
      }
    }
    return p(e), c(!l), l;
  }
  static empty(e) {
    return new Cr(e ? [e, -1] : [], []);
  }
  static fromJSON(e) {
    if (!Array.isArray(e)) throw new RangeError('Invalid JSON representation of ChangeSet');
    let r = [],
      n = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == 'number') r.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != 'number' || s.some((o, l) => l && typeof o != 'string'))
          throw new RangeError('Invalid JSON representation of ChangeSet');
        if (s.length == 1) r.push(s[0], 0);
        else {
          for (; n.length < i; ) n.push(Ot.empty);
          (n[i] = Ot.of(s.slice(1))), r.push(s[0], n[i].length);
        }
      }
    }
    return new Cr(r, n);
  }
  static createSet(e, r) {
    return new Cr(e, r);
  }
}
function Kr(t, e, r, n = !1) {
  if (e == 0 && r <= 0) return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1]
    ? (t[i] += e)
    : e == 0 && t[i] == 0
    ? (t[i + 1] += r)
    : n
    ? ((t[i] += e), (t[i + 1] += r))
    : t.push(e, r);
}
function $s(t, e, r) {
  if (r.length == 0) return;
  let n = (e.length - 2) >> 1;
  if (n < t.length) t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < n; ) t.push(Ot.empty);
    t.push(r);
  }
}
function t0(t, e, r) {
  let n = t.inserted;
  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
    let l = t.sections[o++],
      c = t.sections[o++];
    if (c < 0) (i += l), (s += l);
    else {
      let p = i,
        f = s,
        m = Ot.empty;
      for (
        ;
        (p += l),
          (f += c),
          c && n && (m = m.append(n[(o - 2) >> 1])),
          !(r || o == t.sections.length || t.sections[o + 1] < 0);

      )
        (l = t.sections[o++]), (c = t.sections[o++]);
      e(i, p, s, f, m), (i = p), (s = f);
    }
  }
}
function r0(t, e, r, n = !1) {
  let i = [],
    s = n ? [] : null,
    o = new $u(t),
    l = new $u(e);
  for (let c = -1; ; )
    if (o.ins == -1 && l.ins == -1) {
      let p = Math.min(o.len, l.len);
      Kr(i, p, -1), o.forward(p), l.forward(p);
    } else if (l.ins >= 0 && (o.ins < 0 || c == o.i || (o.off == 0 && (l.len < o.len || (l.len == o.len && !r))))) {
      let p = l.len;
      for (Kr(i, l.ins, -1); p; ) {
        let f = Math.min(o.len, p);
        o.ins >= 0 && c < o.i && o.len <= f && (Kr(i, 0, o.ins), s && $s(s, i, o.text), (c = o.i)),
          o.forward(f),
          (p -= f);
      }
      l.next();
    } else if (o.ins >= 0) {
      let p = 0,
        f = o.len;
      for (; f; )
        if (l.ins == -1) {
          let m = Math.min(f, l.len);
          (p += m), (f -= m), l.forward(m);
        } else if (l.ins == 0 && l.len < f) (f -= l.len), l.next();
        else break;
      Kr(i, p, c < o.i ? o.ins : 0), s && c < o.i && $s(s, i, o.text), (c = o.i), o.forward(o.len - f);
    } else {
      if (o.done && l.done) return s ? Cr.createSet(i, s) : _i.create(i);
      throw new Error('Mismatched change set lengths');
    }
}
function OA(t, e, r = !1) {
  let n = [],
    i = r ? [] : null,
    s = new $u(t),
    o = new $u(e);
  for (let l = !1; ; ) {
    if (s.done && o.done) return i ? Cr.createSet(n, i) : _i.create(n);
    if (s.ins == 0) Kr(n, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done) Kr(n, 0, o.ins, l), i && $s(i, n, o.text), o.next();
    else {
      if (s.done || o.done) throw new Error('Mismatched change set lengths');
      {
        let c = Math.min(s.len2, o.len),
          p = n.length;
        if (s.ins == -1) {
          let f = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Kr(n, c, f, l), i && f && $s(i, n, o.text);
        } else
          o.ins == -1
            ? (Kr(n, s.off ? 0 : s.len, c, l), i && $s(i, n, s.textBit(c)))
            : (Kr(n, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && $s(i, n, o.text));
        (l = (s.ins > c || (o.ins >= 0 && o.len > c)) && (l || n.length > p)), s.forward2(c), o.forward(c);
      }
    }
  }
}
class $u {
  constructor(e) {
    (this.set = e), (this.i = 0), this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? ((this.len = e[this.i++]), (this.ins = e[this.i++])) : ((this.len = 0), (this.ins = -2)),
      (this.off = 0);
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set,
      r = (this.i - 2) >> 1;
    return r >= e.length ? Ot.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set,
      n = (this.i - 2) >> 1;
    return n >= r.length && !e ? Ot.empty : r[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : ((this.len -= e), (this.off += e));
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : ((this.ins -= e), (this.off += e));
  }
}
class Uo {
  constructor(e, r, n) {
    (this.from = e), (this.to = r), (this.flags = n);
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  map(e, r = -1) {
    let n, i;
    return (
      this.empty ? (n = i = e.mapPos(this.from, r)) : ((n = e.mapPos(this.from, 1)), (i = e.mapPos(this.to, -1))),
      n == this.from && i == this.to ? this : new Uo(n, i, this.flags)
    );
  }
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor) return pe.range(e, r);
    let n = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return pe.range(this.anchor, n);
  }
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(e) {
    if (!e || typeof e.anchor != 'number' || typeof e.head != 'number')
      throw new RangeError('Invalid JSON representation for SelectionRange');
    return pe.range(e.anchor, e.head);
  }
  static create(e, r, n) {
    return new Uo(e, r, n);
  }
}
class pe {
  constructor(e, r) {
    (this.ranges = e), (this.mainIndex = r);
  }
  map(e, r = -1) {
    return e.empty
      ? this
      : pe.create(
          this.ranges.map((n) => n.map(e, r)),
          this.mainIndex,
        );
  }
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1;
    for (let r = 0; r < this.ranges.length; r++) if (!this.ranges[r].eq(e.ranges[r])) return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new pe([this.main], 0);
  }
  addRange(e, r = !0) {
    return pe.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  replaceRange(e, r = this.mainIndex) {
    let n = this.ranges.slice();
    return (n[r] = e), pe.create(n, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != 'number' || e.main >= e.ranges.length)
      throw new RangeError('Invalid JSON representation for EditorSelection');
    return new pe(
      e.ranges.map((r) => Uo.fromJSON(r)),
      e.main,
    );
  }
  static single(e, r = e) {
    return new pe([pe.range(e, r)], 0);
  }
  static create(e, r = 0) {
    if (e.length == 0) throw new RangeError('A selection needs at least one range');
    for (let n = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= n : s.from < n) return pe.normalized(e.slice(), r);
      n = s.to;
    }
    return new pe(e, r);
  }
  static cursor(e, r = 0, n, i) {
    return Uo.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | ((i ?? 16777215) << 6));
  }
  static range(e, r, n, i) {
    let s = ((n ?? 16777215) << 6) | (i == null ? 7 : Math.min(6, i));
    return r < e ? Uo.create(r, e, 48 | s) : Uo.create(e, r, (r > e ? 8 : 0) | s);
  }
  static normalized(e, r = 0) {
    let n = e[r];
    e.sort((i, s) => i.from - s.from), (r = e.indexOf(n));
    for (let i = 1; i < e.length; i++) {
      let s = e[i],
        o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from,
          c = Math.max(s.to, o.to);
        i <= r && r--, e.splice(--i, 2, s.anchor > s.head ? pe.range(c, l) : pe.range(l, c));
      }
    }
    return new pe(e, r);
  }
}
function LA(t, e) {
  for (let r of t.ranges) if (r.to > e) throw new RangeError('Selection points outside of document');
}
let Wg = 0;
class Ue {
  constructor(e, r, n, i, s) {
    (this.combine = e),
      (this.compareInput = r),
      (this.compare = n),
      (this.isStatic = i),
      (this.id = Wg++),
      (this.default = e([])),
      (this.extensions = typeof s == 'function' ? s(this) : s);
  }
  get reader() {
    return this;
  }
  static define(e = {}) {
    return new Ue(
      e.combine || ((r) => r),
      e.compareInput || ((r, n) => r === n),
      e.compare || (e.combine ? (r, n) => r === n : Ug),
      !!e.static,
      e.enables,
    );
  }
  of(e) {
    return new Kh([], this, 0, e);
  }
  compute(e, r) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new Kh(e, this, 1, r);
  }
  computeN(e, r) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new Kh(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (n) => n), this.compute([e], (n) => r(n.field(e)));
  }
}
function Ug(t, e) {
  return t == e || (t.length == e.length && t.every((r, n) => r === e[n]));
}
class Kh {
  constructor(e, r, n, i) {
    (this.dependencies = e), (this.facet = r), (this.type = n), (this.value = i), (this.id = Wg++);
  }
  dynamicSlot(e) {
    var r;
    let n = this.value,
      i = this.facet.compareInput,
      s = this.id,
      o = e[s] >> 1,
      l = this.type == 2,
      c = !1,
      p = !1,
      f = [];
    for (let m of this.dependencies)
      m == 'doc'
        ? (c = !0)
        : m == 'selection'
        ? (p = !0)
        : ((r = e[m.id]) !== null && r !== void 0 ? r : 1) & 1 || f.push(e[m.id]);
    return {
      create(m) {
        return (m.values[o] = n(m)), 1;
      },
      update(m, g) {
        if ((c && g.docChanged) || (p && (g.docChanged || g.selection)) || n0(m, f)) {
          let x = n(m);
          if (l ? !S1(x, m.values[o], i) : !i(x, m.values[o])) return (m.values[o] = x), 1;
        }
        return 0;
      },
      reconfigure: (m, g) => {
        let x,
          b = g.config.address[s];
        if (b != null) {
          let F = fp(g, b);
          if (
            this.dependencies.every((E) =>
              E instanceof Ue ? g.facet(E) === m.facet(E) : E instanceof vr ? g.field(E, !1) == m.field(E, !1) : !0,
            ) ||
            (l ? S1((x = n(m)), F, i) : i((x = n(m)), F))
          )
            return (m.values[o] = F), 0;
        } else x = n(m);
        return (m.values[o] = x), 1;
      },
    };
  }
}
function S1(t, e, r) {
  if (t.length != e.length) return !1;
  for (let n = 0; n < t.length; n++) if (!r(t[n], e[n])) return !1;
  return !0;
}
function n0(t, e) {
  let r = !1;
  for (let n of e) Au(t, n) & 1 && (r = !0);
  return r;
}
function UB(t, e, r) {
  let n = r.map((c) => t[c.id]),
    i = r.map((c) => c.type),
    s = n.filter((c) => !(c & 1)),
    o = t[e.id] >> 1;
  function l(c) {
    let p = [];
    for (let f = 0; f < n.length; f++) {
      let m = fp(c, n[f]);
      if (i[f] == 2) for (let g of m) p.push(g);
      else p.push(m);
    }
    return e.combine(p);
  }
  return {
    create(c) {
      for (let p of n) Au(c, p);
      return (c.values[o] = l(c)), 1;
    },
    update(c, p) {
      if (!n0(c, s)) return 0;
      let f = l(c);
      return e.compare(f, c.values[o]) ? 0 : ((c.values[o] = f), 1);
    },
    reconfigure(c, p) {
      let f = n0(c, n),
        m = p.config.facets[e.id],
        g = p.facet(e);
      if (m && !f && Ug(r, m)) return (c.values[o] = g), 0;
      let x = l(c);
      return e.compare(x, g) ? ((c.values[o] = g), 0) : ((c.values[o] = x), 1);
    },
  };
}
const w1 = Ue.define({ static: !0 });
class vr {
  constructor(e, r, n, i, s) {
    (this.id = e),
      (this.createF = r),
      (this.updateF = n),
      (this.compareF = i),
      (this.spec = s),
      (this.provides = void 0);
  }
  static define(e) {
    let r = new vr(Wg++, e.create, e.update, e.compare || ((n, i) => n === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(w1).find((n) => n.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (n) => ((n.values[r] = this.create(n)), 1),
      update: (n, i) => {
        let s = n.values[r],
          o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : ((n.values[r] = o), 1);
      },
      reconfigure: (n, i) =>
        i.config.address[this.id] != null ? ((n.values[r] = i.field(this)), 0) : ((n.values[r] = this.create(n)), 1),
    };
  }
  init(e) {
    return [this, w1.of({ field: this, create: e })];
  }
  get extension() {
    return this;
  }
}
const $o = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Zl(t) {
  return (e) => new _A(e, t);
}
const xl = {
  highest: Zl($o.highest),
  high: Zl($o.high),
  default: Zl($o.default),
  low: Zl($o.low),
  lowest: Zl($o.lowest),
};
class _A {
  constructor(e, r) {
    (this.inner = e), (this.prec = r);
  }
}
class ac {
  of(e) {
    return new i0(this, e);
  }
  reconfigure(e) {
    return ac.reconfigure.of({ compartment: this, extension: e });
  }
  get(e) {
    return e.config.compartments.get(this);
  }
}
class i0 {
  constructor(e, r) {
    (this.compartment = e), (this.inner = r);
  }
}
class pp {
  constructor(e, r, n, i, s, o) {
    for (
      this.base = e,
        this.compartments = r,
        this.dynamicSlots = n,
        this.address = i,
        this.staticValues = s,
        this.facets = o,
        this.statusTemplate = [];
      this.statusTemplate.length < n.length;

    )
      this.statusTemplate.push(0);
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, n) {
    let i = [],
      s = Object.create(null),
      o = new Map();
    for (let g of qB(e, r, o)) g instanceof vr ? i.push(g) : (s[g.facet.id] || (s[g.facet.id] = [])).push(g);
    let l = Object.create(null),
      c = [],
      p = [];
    for (let g of i) (l[g.id] = p.length << 1), p.push((x) => g.slot(x));
    let f = n == null ? void 0 : n.config.facets;
    for (let g in s) {
      let x = s[g],
        b = x[0].facet,
        F = (f && f[g]) || [];
      if (x.every((E) => E.type == 0))
        if (((l[b.id] = (c.length << 1) | 1), Ug(F, x))) c.push(n.facet(b));
        else {
          let E = b.combine(x.map((w) => w.value));
          c.push(n && b.compare(E, n.facet(b)) ? n.facet(b) : E);
        }
      else {
        for (let E of x)
          E.type == 0
            ? ((l[E.id] = (c.length << 1) | 1), c.push(E.value))
            : ((l[E.id] = p.length << 1), p.push((w) => E.dynamicSlot(w)));
        (l[b.id] = p.length << 1), p.push((E) => UB(E, b, x));
      }
    }
    let m = p.map((g) => g(l));
    return new pp(e, o, m, l, c, s);
  }
}
function qB(t, e, r) {
  let n = [[], [], [], [], []],
    i = new Map();
  function s(o, l) {
    let c = i.get(o);
    if (c != null) {
      if (c <= l) return;
      let p = n[c].indexOf(o);
      p > -1 && n[c].splice(p, 1), o instanceof i0 && r.delete(o.compartment);
    }
    if ((i.set(o, l), Array.isArray(o))) for (let p of o) s(p, l);
    else if (o instanceof i0) {
      if (r.has(o.compartment)) throw new RangeError('Duplicate use of compartment in extensions');
      let p = e.get(o.compartment) || o.inner;
      r.set(o.compartment, p), s(p, l);
    } else if (o instanceof _A) s(o.inner, o.prec);
    else if (o instanceof vr) n[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof Kh) n[l].push(o), o.facet.extensions && s(o.facet.extensions, $o.default);
    else {
      let p = o.extension;
      if (!p)
        throw new Error(
          `Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`,
        );
      s(p, l);
    }
  }
  return s(t, $o.default), n.reduce((o, l) => o.concat(l));
}
function Au(t, e) {
  if (e & 1) return 2;
  let r = e >> 1,
    n = t.status[r];
  if (n == 4) throw new Error('Cyclic dependency between fields and/or facets');
  if (n & 2) return n;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return (t.status[r] = 2 | i);
}
function fp(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const RA = Ue.define(),
  jA = Ue.define({ combine: (t) => t.some((e) => e), static: !0 }),
  $A = Ue.define({ combine: (t) => (t.length ? t[0] : void 0), static: !0 }),
  VA = Ue.define(),
  zA = Ue.define(),
  HA = Ue.define(),
  WA = Ue.define({ combine: (t) => (t.length ? t[0] : !1) });
class ms {
  constructor(e, r) {
    (this.type = e), (this.value = r);
  }
  static define() {
    return new KB();
  }
}
class KB {
  of(e) {
    return new ms(this, e);
  }
}
class JB {
  constructor(e) {
    this.map = e;
  }
  of(e) {
    return new mt(this, e);
  }
}
class mt {
  constructor(e, r) {
    (this.type = e), (this.value = r);
  }
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new mt(this.type, r);
  }
  is(e) {
    return this.type == e;
  }
  static define(e = {}) {
    return new JB(e.map || ((r) => r));
  }
  static mapEffects(e, r) {
    if (!e.length) return e;
    let n = [];
    for (let i of e) {
      let s = i.map(r);
      s && n.push(s);
    }
    return n;
  }
}
mt.reconfigure = mt.define();
mt.appendConfig = mt.define();
class Ar {
  constructor(e, r, n, i, s, o) {
    (this.startState = e),
      (this.changes = r),
      (this.selection = n),
      (this.effects = i),
      (this.annotations = s),
      (this.scrollIntoView = o),
      (this._doc = null),
      (this._state = null),
      n && LA(n, r.newLength),
      s.some((l) => l.type == Ar.time) || (this.annotations = s.concat(Ar.time.of(Date.now())));
  }
  static create(e, r, n, i, s, o) {
    return new Ar(e, r, n, i, s, o);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(e) {
    for (let r of this.annotations) if (r.type == e) return r.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(e) {
    let r = this.annotation(Ar.userEvent);
    return !!(r && (r == e || (r.length > e.length && r.slice(0, e.length) == e && r[e.length] == '.')));
  }
}
Ar.time = ms.define();
Ar.userEvent = ms.define();
Ar.addToHistory = ms.define();
Ar.remote = ms.define();
function XB(t, e) {
  let r = [];
  for (let n = 0, i = 0; ; ) {
    let s, o;
    if (n < t.length && (i == e.length || e[i] >= t[n])) (s = t[n++]), (o = t[n++]);
    else if (i < e.length) (s = e[i++]), (o = e[i++]);
    else return r;
    !r.length || r[r.length - 1] < s ? r.push(s, o) : r[r.length - 1] < o && (r[r.length - 1] = o);
  }
}
function UA(t, e, r) {
  var n;
  let i, s, o;
  return (
    r
      ? ((i = e.changes), (s = Cr.empty(e.changes.length)), (o = t.changes.compose(e.changes)))
      : ((i = e.changes.map(t.changes)), (s = t.changes.mapDesc(e.changes, !0)), (o = t.changes.compose(i))),
    {
      changes: o,
      selection: e.selection ? e.selection.map(s) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(i),
      effects: mt.mapEffects(t.effects, i).concat(mt.mapEffects(e.effects, s)),
      annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
      scrollIntoView: t.scrollIntoView || e.scrollIntoView,
    }
  );
}
function s0(t, e, r) {
  let n = e.selection,
    i = Ja(e.annotations);
  return (
    e.userEvent && (i = i.concat(Ar.userEvent.of(e.userEvent))),
    {
      changes: e.changes instanceof Cr ? e.changes : Cr.of(e.changes || [], r, t.facet($A)),
      selection: n && (n instanceof pe ? n : pe.single(n.anchor, n.head)),
      effects: Ja(e.effects),
      annotations: i,
      scrollIntoView: !!e.scrollIntoView,
    }
  );
}
function qA(t, e, r) {
  let n = s0(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (r = !1);
    let o = !!e[s].sequential;
    n = UA(n, s0(t, e[s], o ? n.changes.newLength : t.doc.length), o);
  }
  let i = Ar.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return YB(r ? GB(i) : i);
}
function GB(t) {
  let e = t.startState,
    r = !0;
  for (let i of e.facet(VA)) {
    let s = i(t);
    if (s === !1) {
      r = !1;
      break;
    }
    Array.isArray(s) && (r = r === !0 ? s : XB(r, s));
  }
  if (r !== !0) {
    let i, s;
    if (r === !1) (s = t.changes.invertedDesc), (i = Cr.empty(e.doc.length));
    else {
      let o = t.changes.filter(r);
      (i = o.changes), (s = o.filtered.mapDesc(o.changes).invertedDesc);
    }
    t = Ar.create(
      e,
      i,
      t.selection && t.selection.map(s),
      mt.mapEffects(t.effects, s),
      t.annotations,
      t.scrollIntoView,
    );
  }
  let n = e.facet(zA);
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s instanceof Ar
      ? (t = s)
      : Array.isArray(s) && s.length == 1 && s[0] instanceof Ar
      ? (t = s[0])
      : (t = qA(e, Ja(s), !1));
  }
  return t;
}
function YB(t) {
  let e = t.startState,
    r = e.facet(HA),
    n = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s && Object.keys(s).length && (n = UA(n, s0(e, s, t.changes.newLength), !0));
  }
  return n == t ? t : Ar.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
const QB = [];
function Ja(t) {
  return t == null ? QB : Array.isArray(t) ? t : [t];
}
var er = (function (t) {
  return (t[(t.Word = 0)] = 'Word'), (t[(t.Space = 1)] = 'Space'), (t[(t.Other = 2)] = 'Other'), t;
})(er || (er = {}));
const ZB = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let o0;
try {
  o0 = new RegExp('[\\p{Alphabetic}\\p{Number}_]', 'u');
} catch {}
function e4(t) {
  if (o0) return o0.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || (r > '' && (r.toUpperCase() != r.toLowerCase() || ZB.test(r)))) return !0;
  }
  return !1;
}
function t4(t) {
  return (e) => {
    if (!/\S/.test(e)) return er.Space;
    if (e4(e)) return er.Word;
    for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) > -1) return er.Word;
    return er.Other;
  };
}
class Ct {
  constructor(e, r, n, i, s, o) {
    (this.config = e),
      (this.doc = r),
      (this.selection = n),
      (this.values = i),
      (this.status = e.statusTemplate.slice()),
      (this.computeSlot = s),
      o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++) Au(this, l << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (r) throw new RangeError('Field is not present in this state');
      return;
    }
    return Au(this, n), fp(this, n);
  }
  update(...e) {
    return qA(this, e, !0);
  }
  applyTransaction(e) {
    let r = this.config,
      { base: n, compartments: i } = r;
    for (let o of e.effects)
      o.is(ac.reconfigure)
        ? (r && ((i = new Map()), r.compartments.forEach((l, c) => i.set(c, l)), (r = null)),
          i.set(o.value.compartment, o.value.extension))
        : o.is(mt.reconfigure)
        ? ((r = null), (n = o.value))
        : o.is(mt.appendConfig) && ((r = null), (n = Ja(n).concat(o.value)));
    let s;
    r
      ? (s = e.startState.values.slice())
      : ((r = pp.resolve(n, i, this)),
        (s = new Ct(
          r,
          this.doc,
          this.selection,
          r.dynamicSlots.map(() => null),
          (l, c) => c.reconfigure(l, this),
          null,
        ).values)),
      new Ct(r, e.newDoc, e.newSelection, s, (o, l) => l.update(o, e), e);
  }
  replaceSelection(e) {
    return (
      typeof e == 'string' && (e = this.toText(e)),
      this.changeByRange((r) => ({
        changes: { from: r.from, to: r.to, insert: e },
        range: pe.cursor(r.from + e.length),
      }))
    );
  }
  changeByRange(e) {
    let r = this.selection,
      n = e(r.ranges[0]),
      i = this.changes(n.changes),
      s = [n.range],
      o = Ja(n.effects);
    for (let l = 1; l < r.ranges.length; l++) {
      let c = e(r.ranges[l]),
        p = this.changes(c.changes),
        f = p.map(i);
      for (let g = 0; g < l; g++) s[g] = s[g].map(f);
      let m = i.mapDesc(p, !0);
      s.push(c.range.map(m)), (i = i.compose(f)), (o = mt.mapEffects(o, f).concat(mt.mapEffects(Ja(c.effects), m)));
    }
    return { changes: i, selection: pe.create(s, r.mainIndex), effects: o };
  }
  changes(e = []) {
    return e instanceof Cr ? e : Cr.of(e, this.doc.length, this.facet(Ct.lineSeparator));
  }
  toText(e) {
    return Ot.of(e.split(this.facet(Ct.lineSeparator) || e0));
  }
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Au(this, r), fp(this, r));
  }
  toJSON(e) {
    let r = { doc: this.sliceDoc(), selection: this.selection.toJSON() };
    if (e)
      for (let n in e) {
        let i = e[n];
        i instanceof vr && this.config.address[i.id] != null && (r[n] = i.spec.toJSON(this.field(e[n]), this));
      }
    return r;
  }
  static fromJSON(e, r = {}, n) {
    if (!e || typeof e.doc != 'string') throw new RangeError('Invalid JSON representation for EditorState');
    let i = [];
    if (n) {
      for (let s in n)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = n[s],
            l = e[s];
          i.push(o.init((c) => o.spec.fromJSON(l, c)));
        }
    }
    return Ct.create({
      doc: e.doc,
      selection: pe.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i,
    });
  }
  static create(e = {}) {
    let r = pp.resolve(e.extensions || [], new Map()),
      n = e.doc instanceof Ot ? e.doc : Ot.of((e.doc || '').split(r.staticFacet(Ct.lineSeparator) || e0)),
      i = e.selection
        ? e.selection instanceof pe
          ? e.selection
          : pe.single(e.selection.anchor, e.selection.head)
        : pe.single(0);
    return (
      LA(i, n.length),
      r.staticFacet(jA) || (i = i.asSingle()),
      new Ct(
        r,
        n,
        i,
        r.dynamicSlots.map(() => null),
        (s, o) => o.create(s),
        null,
      )
    );
  }
  get tabSize() {
    return this.facet(Ct.tabSize);
  }
  get lineBreak() {
    return (
      this.facet(Ct.lineSeparator) ||
      `
`
    );
  }
  get readOnly() {
    return this.facet(WA);
  }
  phrase(e, ...r) {
    for (let n of this.facet(Ct.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return (
      r.length &&
        (e = e.replace(/\$(\$|\d*)/g, (n, i) => {
          if (i == '$') return '$';
          let s = +(i || 1);
          return !s || s > r.length ? n : r[s - 1];
        })),
      e
    );
  }
  languageDataAt(e, r, n = -1) {
    let i = [];
    for (let s of this.facet(RA))
      for (let o of s(this, r, n)) Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  charCategorizer(e) {
    return t4(this.languageDataAt('wordChars', e).join(''));
  }
  wordAt(e) {
    let { text: r, from: n, length: i } = this.doc.lineAt(e),
      s = this.charCategorizer(e),
      o = e - n,
      l = e - n;
    for (; o > 0; ) {
      let c = Yr(r, o, !1);
      if (s(r.slice(c, o)) != er.Word) break;
      o = c;
    }
    for (; l < i; ) {
      let c = Yr(r, l);
      if (s(r.slice(l, c)) != er.Word) break;
      l = c;
    }
    return o == l ? null : pe.range(o + n, l + n);
  }
}
Ct.allowMultipleSelections = jA;
Ct.tabSize = Ue.define({ combine: (t) => (t.length ? t[0] : 4) });
Ct.lineSeparator = $A;
Ct.readOnly = WA;
Ct.phrases = Ue.define({
  compare(t, e) {
    let r = Object.keys(t),
      n = Object.keys(e);
    return r.length == n.length && r.every((i) => t[i] == e[i]);
  },
});
Ct.languageData = RA;
Ct.changeFilter = VA;
Ct.transactionFilter = zA;
Ct.transactionExtender = HA;
ac.reconfigure = mt.define();
function Wi(t, e, r = {}) {
  let n = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let o = i[s],
        l = n[s];
      if (l === void 0) n[s] = o;
      else if (!(l === o || o === void 0))
        if (Object.hasOwnProperty.call(r, s)) n[s] = r[s](l, o);
        else throw new Error('Config merge conflict for field ' + s);
    }
  for (let i in e) n[i] === void 0 && (n[i] = e[i]);
  return n;
}
class ea {
  eq(e) {
    return this == e;
  }
  range(e, r = e) {
    return a0.create(e, r, this);
  }
}
ea.prototype.startSide = ea.prototype.endSide = 0;
ea.prototype.point = !1;
ea.prototype.mapMode = sn.TrackDel;
let a0 = class KA {
  constructor(e, r, n) {
    (this.from = e), (this.to = r), (this.value = n);
  }
  static create(e, r, n) {
    return new KA(e, r, n);
  }
};
function l0(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class qg {
  constructor(e, r, n, i) {
    (this.from = e), (this.to = r), (this.value = n), (this.maxPoint = i);
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(e, r, n, i = 0) {
    let s = n ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l) return o;
      let c = (o + l) >> 1,
        p = s[c] - e || (n ? this.value[c].endSide : this.value[c].startSide) - r;
      if (c == o) return p >= 0 ? o : l;
      p >= 0 ? (l = c) : (o = c + 1);
    }
  }
  between(e, r, n, i) {
    for (let s = this.findIndex(r, -1e9, !0), o = this.findIndex(n, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1) return !1;
  }
  map(e, r) {
    let n = [],
      i = [],
      s = [],
      o = -1,
      l = -1;
    for (let c = 0; c < this.value.length; c++) {
      let p = this.value[c],
        f = this.from[c] + e,
        m = this.to[c] + e,
        g,
        x;
      if (f == m) {
        let b = r.mapPos(f, p.startSide, p.mapMode);
        if (b == null || ((g = x = b), p.startSide != p.endSide && ((x = r.mapPos(f, p.endSide)), x < g))) continue;
      } else if (
        ((g = r.mapPos(f, p.startSide)),
        (x = r.mapPos(m, p.endSide)),
        g > x || (g == x && p.startSide > 0 && p.endSide <= 0))
      )
        continue;
      (x - g || p.endSide - p.startSide) < 0 ||
        (o < 0 && (o = g), p.point && (l = Math.max(l, x - g)), n.push(p), i.push(g - o), s.push(x - o));
    }
    return { mapped: n.length ? new qg(i, s, n, l) : null, pos: o };
  }
}
class _t {
  constructor(e, r, n, i) {
    (this.chunkPos = e), (this.chunk = r), (this.nextLayer = n), (this.maxPoint = i);
  }
  static create(e, r, n, i) {
    return new _t(e, r, n, i);
  }
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty) return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk) e += r.value.length;
    return e;
  }
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  update(e) {
    let { add: r = [], sort: n = !1, filterFrom: i = 0, filterTo: s = this.length } = e,
      o = e.filter;
    if (r.length == 0 && !o) return this;
    if ((n && (r = r.slice().sort(l0)), this.isEmpty)) return r.length ? _t.of(r) : this;
    let l = new JA(this, null, -1).goto(0),
      c = 0,
      p = [],
      f = new no();
    for (; l.value || c < r.length; )
      if (c < r.length && (l.from - r[c].from || l.startSide - r[c].value.startSide) >= 0) {
        let m = r[c++];
        f.addInner(m.from, m.to, m.value) || p.push(m);
      } else
        l.rangeIndex == 1 &&
        l.chunkIndex < this.chunk.length &&
        (c == r.length || this.chunkEnd(l.chunkIndex) < r[c].from) &&
        (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) &&
        f.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex])
          ? l.nextChunk()
          : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) &&
              (f.addInner(l.from, l.to, l.value) || p.push(a0.create(l.from, l.to, l.value))),
            l.next());
    return f.finishInner(
      this.nextLayer.isEmpty && !p.length
        ? _t.empty
        : this.nextLayer.update({ add: p, filter: o, filterFrom: i, filterTo: s }),
    );
  }
  map(e) {
    if (e.empty || this.isEmpty) return this;
    let r = [],
      n = [],
      i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o],
        c = this.chunk[o],
        p = e.touchesRange(l, l + c.length);
      if (p === !1) (i = Math.max(i, c.maxPoint)), r.push(c), n.push(e.mapPos(l));
      else if (p === !0) {
        let { mapped: f, pos: m } = c.map(l, e);
        f && ((i = Math.max(i, f.maxPoint)), r.push(f), n.push(m));
      }
    }
    let s = this.nextLayer.map(e);
    return r.length == 0 ? s : new _t(n, r, s || _t.empty, i);
  }
  between(e, r, n) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i],
          o = this.chunk[i];
        if (r >= s && e <= s + o.length && o.between(s, e - s, r - s, n) === !1) return;
      }
      this.nextLayer.between(e, r, n);
    }
  }
  iter(e = 0) {
    return Vu.from([this]).goto(e);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(e, r = 0) {
    return Vu.from(e).goto(r);
  }
  static compare(e, r, n, i, s = -1) {
    let o = e.filter((m) => m.maxPoint > 0 || (!m.isEmpty && m.maxPoint >= s)),
      l = r.filter((m) => m.maxPoint > 0 || (!m.isEmpty && m.maxPoint >= s)),
      c = T1(o, l, n),
      p = new eu(o, c, s),
      f = new eu(l, c, s);
    n.iterGaps((m, g, x) => k1(p, m, f, g, x, i)), n.empty && n.length == 0 && k1(p, 0, f, 0, 0, i);
  }
  static eq(e, r, n = 0, i) {
    i == null && (i = 1e9 - 1);
    let s = e.filter((f) => !f.isEmpty && r.indexOf(f) < 0),
      o = r.filter((f) => !f.isEmpty && e.indexOf(f) < 0);
    if (s.length != o.length) return !1;
    if (!s.length) return !0;
    let l = T1(s, o),
      c = new eu(s, l, 0).goto(n),
      p = new eu(o, l, 0).goto(n);
    for (;;) {
      if (c.to != p.to || !u0(c.active, p.active) || (c.point && (!p.point || !c.point.eq(p.point)))) return !1;
      if (c.to > i) return !0;
      c.next(), p.next();
    }
  }
  static spans(e, r, n, i, s = -1) {
    let o = new eu(e, null, s).goto(r),
      l = r,
      c = o.openStart;
    for (;;) {
      let p = Math.min(o.to, n);
      if (o.point) {
        let f = o.activeForPoint(o.to),
          m = o.pointFrom < r ? f.length + 1 : Math.min(f.length, c);
        i.point(l, p, o.point, f, m, o.pointRank), (c = Math.min(o.openEnd(p), f.length));
      } else p > l && (i.span(l, p, o.active, c), (c = o.openEnd(p)));
      if (o.to > n) return c + (o.point && o.to > n ? 1 : 0);
      (l = o.to), o.next();
    }
  }
  static of(e, r = !1) {
    let n = new no();
    for (let i of e instanceof a0 ? [e] : r ? r4(e) : e) n.add(i.from, i.to, i.value);
    return n.finish();
  }
}
_t.empty = new _t([], [], null, -1);
function r4(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let n = t[r];
      if (l0(e, n) > 0) return t.slice().sort(l0);
      e = n;
    }
  return t;
}
_t.empty.nextLayer = _t.empty;
class no {
  finishChunk(e) {
    this.chunks.push(new qg(this.from, this.to, this.value, this.maxPoint)),
      this.chunkPos.push(this.chunkStart),
      (this.chunkStart = -1),
      (this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)),
      (this.maxPoint = -1),
      e && ((this.from = []), (this.to = []), (this.value = []));
  }
  constructor() {
    (this.chunks = []),
      (this.chunkPos = []),
      (this.chunkStart = -1),
      (this.last = null),
      (this.lastFrom = -1e9),
      (this.lastTo = -1e9),
      (this.from = []),
      (this.to = []),
      (this.value = []),
      (this.maxPoint = -1),
      (this.setMaxPoint = -1),
      (this.nextLayer = null);
  }
  add(e, r, n) {
    this.addInner(e, r, n) || (this.nextLayer || (this.nextLayer = new no())).add(e, r, n);
  }
  addInner(e, r, n) {
    let i = e - this.lastTo || n.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error('Ranges must be added sorted by `from` position and `startSide`');
    return i < 0
      ? !1
      : (this.from.length == 250 && this.finishChunk(!0),
        this.chunkStart < 0 && (this.chunkStart = e),
        this.from.push(e - this.chunkStart),
        this.to.push(r - this.chunkStart),
        (this.last = n),
        (this.lastFrom = e),
        (this.lastTo = r),
        this.value.push(n),
        n.point && (this.maxPoint = Math.max(this.maxPoint, r - e)),
        !0);
  }
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0) return !1;
    this.from.length && this.finishChunk(!0),
      (this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint)),
      this.chunks.push(r),
      this.chunkPos.push(e);
    let n = r.value.length - 1;
    return (this.last = r.value[n]), (this.lastFrom = r.from[n] + e), (this.lastTo = r.to[n] + e), !0;
  }
  finish() {
    return this.finishInner(_t.empty);
  }
  finishInner(e) {
    if ((this.from.length && this.finishChunk(!1), this.chunks.length == 0)) return e;
    let r = _t.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return (this.from = null), r;
  }
}
function T1(t, e, r) {
  let n = new Map();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++) s.chunk[o].maxPoint <= 0 && n.set(s.chunk[o], s.chunkPos[o]);
  let i = new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = n.get(s.chunk[o]);
      l != null &&
        (r ? r.mapPos(l) : l) == s.chunkPos[o] &&
        !(r != null && r.touchesRange(l, l + s.chunk[o].length)) &&
        i.add(s.chunk[o]);
    }
  return i;
}
class JA {
  constructor(e, r, n, i = 0) {
    (this.layer = e), (this.skip = r), (this.minPoint = n), (this.rank = i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return (this.chunkIndex = this.rangeIndex = 0), this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!((this.skip && this.skip.has(i)) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, (n = !1);
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!n || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (;;)
      if (this.chunkIndex == this.layer.chunk.length) {
        (this.from = this.to = 1e9), (this.value = null);
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex],
          r = this.layer.chunk[this.chunkIndex],
          n = e + r.from[this.rangeIndex];
        if (
          ((this.from = n),
          (this.to = e + r.to[this.rangeIndex]),
          (this.value = r.value[this.rangeIndex]),
          this.setRangeIndex(this.rangeIndex + 1),
          this.minPoint < 0 || (this.value.point && this.to - this.from >= this.minPoint))
        )
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if ((this.chunkIndex++, this.skip))
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, (this.rangeIndex = 0), this.next();
  }
  compare(e) {
    return (
      this.from - e.from ||
      this.startSide - e.startSide ||
      this.rank - e.rank ||
      this.to - e.to ||
      this.endSide - e.endSide
    );
  }
}
class Vu {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, n = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer) o.maxPoint >= n && i.push(new JA(o, r, n, s));
    return i.length == 1 ? i[0] : new Vu(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let n of this.heap) n.goto(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--) Gd(this.heap, n);
    return this.next(), this;
  }
  forward(e, r) {
    for (let n of this.heap) n.forward(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--) Gd(this.heap, n);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0) (this.from = this.to = 1e9), (this.value = null), (this.rank = -1);
    else {
      let e = this.heap[0];
      (this.from = e.from),
        (this.to = e.to),
        (this.value = e.value),
        (this.rank = e.rank),
        e.value && e.next(),
        Gd(this.heap, 0);
    }
  }
}
function Gd(t, e) {
  for (let r = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length) break;
    let i = t[n];
    if ((n + 1 < t.length && i.compare(t[n + 1]) >= 0 && ((i = t[n + 1]), n++), r.compare(i) < 0)) break;
    (t[n] = r), (t[e] = i), (e = n);
  }
}
class eu {
  constructor(e, r, n) {
    (this.minPoint = n),
      (this.active = []),
      (this.activeTo = []),
      (this.activeRank = []),
      (this.minActive = -1),
      (this.point = null),
      (this.pointFrom = 0),
      (this.pointRank = 0),
      (this.to = -1e9),
      (this.endSide = 0),
      (this.openStart = -1),
      (this.cursor = Vu.from(e, r, n));
  }
  goto(e, r = -1e9) {
    return (
      this.cursor.goto(e, r),
      (this.active.length = this.activeTo.length = this.activeRank.length = 0),
      (this.minActive = -1),
      (this.to = e),
      (this.endSide = r),
      (this.openStart = -1),
      this.next(),
      this
    );
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    fh(this.active, e), fh(this.activeTo, e), fh(this.activeRank, e), (this.minActive = P1(this.active, this.activeTo));
  }
  addActive(e) {
    let r = 0,
      { value: n, to: i, rank: s } = this.cursor;
    for (; r < this.activeRank.length && this.activeRank[r] <= s; ) r++;
    dh(this.active, r, n),
      dh(this.activeTo, r, i),
      dh(this.activeRank, r, s),
      e && dh(e, r, this.cursor.from),
      (this.minActive = P1(this.active, this.activeTo));
  }
  next() {
    let e = this.to,
      r = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (;;) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          (this.to = this.activeTo[i]), (this.endSide = this.active[i].endSide);
          break;
        }
        this.removeActive(i), n && fh(n, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          (this.to = this.cursor.from), (this.endSide = this.cursor.startSide);
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point) this.addActive(n), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to) this.cursor.next();
          else {
            (this.point = s),
              (this.pointFrom = this.cursor.from),
              (this.pointRank = this.cursor.rank),
              (this.to = this.cursor.to),
              (this.endSide = s.endSide),
              this.cursor.next(),
              this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let i = n.length - 1; i >= 0 && n[i] < e; i--) this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length) return this.active;
    let r = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || (this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide)) &&
        r.push(this.active[n]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--) r++;
    return r;
  }
}
function k1(t, e, r, n, i, s) {
  t.goto(e), r.goto(n);
  let o = n + i,
    l = n,
    c = n - e;
  for (;;) {
    let p = t.to + c - r.to || t.endSide - r.endSide,
      f = p < 0 ? t.to + c : r.to,
      m = Math.min(f, o);
    if (
      (t.point || r.point
        ? (t.point &&
            r.point &&
            (t.point == r.point || t.point.eq(r.point)) &&
            u0(t.activeForPoint(t.to), r.activeForPoint(r.to))) ||
          s.comparePoint(l, m, t.point, r.point)
        : m > l && !u0(t.active, r.active) && s.compareRange(l, m, t.active, r.active),
      f > o)
    )
      break;
    (l = f), p <= 0 && t.next(), p >= 0 && r.next();
  }
}
function u0(t, e) {
  if (t.length != e.length) return !1;
  for (let r = 0; r < t.length; r++) if (t[r] != e[r] && !t[r].eq(e[r])) return !1;
  return !0;
}
function fh(t, e) {
  for (let r = e, n = t.length - 1; r < n; r++) t[r] = t[r + 1];
  t.pop();
}
function dh(t, e, r) {
  for (let n = t.length - 1; n >= e; n--) t[n + 1] = t[n];
  t[e] = r;
}
function P1(t, e) {
  let r = -1,
    n = 1e9;
  for (let i = 0; i < e.length; i++) (e[i] - n || t[i].endSide - t[r].endSide) < 0 && ((r = i), (n = e[i]));
  return r;
}
function Cl(t, e, r = t.length) {
  let n = 0;
  for (let i = 0; i < r; ) t.charCodeAt(i) == 9 ? ((n += e - (n % e)), i++) : (n++, (i = Yr(t, i)));
  return n;
}
function c0(t, e, r, n) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e) return i;
    if (i == t.length) break;
    (s += t.charCodeAt(i) == 9 ? r - (s % r) : 1), (i = Yr(t, i));
  }
  return n === !0 ? -1 : t.length;
}
const h0 = 'ͼ',
  B1 = typeof Symbol > 'u' ? '__' + h0 : Symbol.for(h0),
  p0 = typeof Symbol > 'u' ? '__styleSet' + Math.floor(Math.random() * 1e8) : Symbol('styleSet'),
  I1 = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : {};
class io {
  constructor(e, r) {
    this.rules = [];
    let { finish: n } = r || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, c, p) {
      let f = [],
        m = /^@(\w+)\b/.exec(o[0]),
        g = m && m[1] == 'keyframes';
      if (m && l == null) return c.push(o[0] + ';');
      for (let x in l) {
        let b = l[x];
        if (/&/.test(x))
          s(
            x
              .split(/,\s*/)
              .map((F) => o.map((E) => F.replace(/&/, E)))
              .reduce((F, E) => F.concat(E)),
            b,
            c,
          );
        else if (b && typeof b == 'object') {
          if (!m) throw new RangeError('The value of a property (' + x + ') should be a primitive value.');
          s(i(x), b, f, g);
        } else
          b != null && f.push(x.replace(/_.*/, '').replace(/[A-Z]/g, (F) => '-' + F.toLowerCase()) + ': ' + b + ';');
      }
      (f.length || g) && c.push((n && !m && !p ? o.map(n) : o).join(', ') + ' {' + f.join(' ') + '}');
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let e = I1[B1] || 1;
    return (I1[B1] = e + 1), h0 + e.toString(36);
  }
  static mount(e, r, n) {
    let i = e[p0],
      s = n && n.nonce;
    i ? s && i.setNonce(s) : (i = new n4(e, s)), i.mount(Array.isArray(r) ? r : [r]);
  }
}
let N1 = new Map();
class n4 {
  constructor(e, r) {
    let n = e.ownerDocument || e,
      i = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = N1.get(n);
      if (s) return (e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets]), (e[p0] = s);
      (this.sheet = new i.CSSStyleSheet()),
        (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]),
        N1.set(n, this);
    } else {
      (this.styleTag = n.createElement('style')), r && this.styleTag.setAttribute('nonce', r);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    (this.modules = []), (e[p0] = this);
  }
  mount(e) {
    let r = this.sheet,
      n = 0,
      i = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s],
        l = this.modules.indexOf(o);
      if ((l < i && l > -1 && (this.modules.splice(l, 1), i--, (l = -1)), l == -1)) {
        if ((this.modules.splice(i++, 0, o), r)) for (let c = 0; c < o.rules.length; c++) r.insertRule(o.rules[c], n++);
      } else {
        for (; i < l; ) n += this.modules[i++].rules.length;
        (n += o.rules.length), i++;
      }
    }
    if (!r) {
      let s = '';
      for (let o = 0; o < this.modules.length; o++)
        s +=
          this.modules[o].getRules() +
          `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute('nonce') != e && this.styleTag.setAttribute('nonce', e);
  }
}
var so = {
    8: 'Backspace',
    9: 'Tab',
    10: 'Enter',
    12: 'NumLock',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    44: 'PrintScreen',
    45: 'Insert',
    46: 'Delete',
    59: ';',
    61: '=',
    91: 'Meta',
    92: 'Meta',
    106: '*',
    107: '+',
    108: ',',
    109: '-',
    110: '.',
    111: '/',
    144: 'NumLock',
    145: 'ScrollLock',
    160: 'Shift',
    161: 'Shift',
    162: 'Control',
    163: 'Control',
    164: 'Alt',
    165: 'Alt',
    173: '-',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: "'",
  },
  zu = {
    48: ')',
    49: '!',
    50: '@',
    51: '#',
    52: '$',
    53: '%',
    54: '^',
    55: '&',
    56: '*',
    57: '(',
    59: ':',
    61: '+',
    173: '_',
    186: ':',
    187: '+',
    188: '<',
    189: '_',
    190: '>',
    191: '?',
    192: '~',
    219: '{',
    220: '|',
    221: '}',
    222: '"',
  },
  i4 = typeof navigator < 'u' && /Mac/.test(navigator.platform),
  s4 = typeof navigator < 'u' && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Mr = 0; Mr < 10; Mr++) so[48 + Mr] = so[96 + Mr] = String(Mr);
for (var Mr = 1; Mr <= 24; Mr++) so[Mr + 111] = 'F' + Mr;
for (var Mr = 65; Mr <= 90; Mr++) (so[Mr] = String.fromCharCode(Mr + 32)), (zu[Mr] = String.fromCharCode(Mr));
for (var Yd in so) zu.hasOwnProperty(Yd) || (zu[Yd] = so[Yd]);
function o4(t) {
  var e =
      (i4 && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
      (s4 && t.shiftKey && t.key && t.key.length == 1) ||
      t.key == 'Unidentified',
    r = (!e && t.key) || (t.shiftKey ? zu : so)[t.keyCode] || t.key || 'Unidentified';
  return (
    r == 'Esc' && (r = 'Escape'),
    r == 'Del' && (r = 'Delete'),
    r == 'Left' && (r = 'ArrowLeft'),
    r == 'Up' && (r = 'ArrowUp'),
    r == 'Right' && (r = 'ArrowRight'),
    r == 'Down' && (r = 'ArrowDown'),
    r
  );
}
function dp(t) {
  let e;
  return t.nodeType == 11 ? (e = t.getSelection ? t : t.ownerDocument) : (e = t), e.getSelection();
}
function f0(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function a4(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
  return e;
}
function Jh(t, e) {
  if (!e.anchorNode) return !1;
  try {
    return f0(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function ol(t) {
  return t.nodeType == 3 ? ta(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function mp(t, e, r, n) {
  return r ? M1(t, e, r, n, -1) || M1(t, e, r, n, 1) : !1;
}
function Hu(t) {
  for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
}
function M1(t, e, r, n, i) {
  for (;;) {
    if (t == r && e == n) return !0;
    if (e == (i < 0 ? 0 : os(t))) {
      if (t.nodeName == 'DIV') return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1) return !1;
      (e = Hu(t) + (i < 0 ? 0 : 1)), (t = s);
    } else if (t.nodeType == 1) {
      if (((t = t.childNodes[e + (i < 0 ? -1 : 0)]), t.nodeType == 1 && t.contentEditable == 'false')) return !1;
      e = i < 0 ? os(t) : 0;
    } else return !1;
  }
}
function os(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Cf(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function l4(t) {
  return { left: 0, right: t.innerWidth, top: 0, bottom: t.innerHeight };
}
function u4(t, e, r, n, i, s, o, l) {
  let c = t.ownerDocument,
    p = c.defaultView || window;
  for (let f = t, m = !1; f && !m; )
    if (f.nodeType == 1) {
      let g,
        x = f == c.body,
        b = 1,
        F = 1;
      if (x) g = l4(p);
      else {
        if (
          (/^(fixed|sticky)$/.test(getComputedStyle(f).position) && (m = !0),
          f.scrollHeight <= f.clientHeight && f.scrollWidth <= f.clientWidth)
        ) {
          f = f.assignedSlot || f.parentNode;
          continue;
        }
        let I = f.getBoundingClientRect();
        (b = I.width / f.offsetWidth),
          (F = I.height / f.offsetHeight),
          (g = { left: I.left, right: I.left + f.clientWidth * b, top: I.top, bottom: I.top + f.clientHeight * F });
      }
      let E = 0,
        w = 0;
      if (i == 'nearest')
        e.top < g.top
          ? ((w = -(g.top - e.top + o)), r > 0 && e.bottom > g.bottom + w && (w = e.bottom - g.bottom + w + o))
          : e.bottom > g.bottom &&
            ((w = e.bottom - g.bottom + o), r < 0 && e.top - w < g.top && (w = -(g.top + w - e.top + o)));
      else {
        let I = e.bottom - e.top,
          T = g.bottom - g.top;
        w =
          (i == 'center' && I <= T
            ? e.top + I / 2 - T / 2
            : i == 'start' || (i == 'center' && r < 0)
            ? e.top - o
            : e.bottom - T + o) - g.top;
      }
      if (
        (n == 'nearest'
          ? e.left < g.left
            ? ((E = -(g.left - e.left + s)), r > 0 && e.right > g.right + E && (E = e.right - g.right + E + s))
            : e.right > g.right &&
              ((E = e.right - g.right + s), r < 0 && e.left < g.left + E && (E = -(g.left + E - e.left + s)))
          : (E =
              (n == 'center'
                ? e.left + (e.right - e.left) / 2 - (g.right - g.left) / 2
                : (n == 'start') == l
                ? e.left - s
                : e.right - (g.right - g.left) + s) - g.left),
        E || w)
      )
        if (x) p.scrollBy(E, w);
        else {
          let I = 0,
            T = 0;
          if (w) {
            let j = f.scrollTop;
            (f.scrollTop += w / F), (T = (f.scrollTop - j) * F);
          }
          if (E) {
            let j = f.scrollLeft;
            (f.scrollLeft += E / b), (I = (f.scrollLeft - j) * b);
          }
          (e = { left: e.left - I, top: e.top - T, right: e.right - I, bottom: e.bottom - T }),
            I && Math.abs(I - E) < 1 && (n = 'nearest'),
            T && Math.abs(T - w) < 1 && (i = 'nearest');
        }
      if (x) break;
      f = f.assignedSlot || f.parentNode;
    } else if (f.nodeType == 11) f = f.host;
    else break;
}
function c4(t) {
  let e = t.ownerDocument;
  for (let r = t.parentNode; r && r != e.body; )
    if (r.nodeType == 1) {
      if (r.scrollHeight > r.clientHeight || r.scrollWidth > r.clientWidth) return r;
      r = r.assignedSlot || r.parentNode;
    } else if (r.nodeType == 11) r = r.host;
    else break;
  return null;
}
class h4 {
  constructor() {
    (this.anchorNode = null), (this.anchorOffset = 0), (this.focusNode = null), (this.focusOffset = 0);
  }
  eq(e) {
    return (
      this.anchorNode == e.anchorNode &&
      this.anchorOffset == e.anchorOffset &&
      this.focusNode == e.focusNode &&
      this.focusOffset == e.focusOffset
    );
  }
  setRange(e) {
    let { anchorNode: r, focusNode: n } = e;
    this.set(r, Math.min(e.anchorOffset, r ? os(r) : 0), n, Math.min(e.focusOffset, n ? os(n) : 0));
  }
  set(e, r, n, i) {
    (this.anchorNode = e), (this.anchorOffset = r), (this.focusNode = n), (this.focusOffset = i);
  }
}
let Ba = null;
function XA(t) {
  if (t.setActive) return t.setActive();
  if (Ba) return t.focus(Ba);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode);
  if (
    (t.focus(
      Ba == null
        ? {
            get preventScroll() {
              return (Ba = { preventScroll: !0 }), !0;
            },
          }
        : void 0,
    ),
    !Ba)
  ) {
    Ba = !1;
    for (let r = 0; r < e.length; ) {
      let n = e[r++],
        i = e[r++],
        s = e[r++];
      n.scrollTop != i && (n.scrollTop = i), n.scrollLeft != s && (n.scrollLeft = s);
    }
  }
}
let O1;
function ta(t, e, r = e) {
  let n = O1 || (O1 = document.createRange());
  return n.setEnd(t, r), n.setStart(t, e), n;
}
function Xa(t, e, r) {
  let n = { key: e, code: e, keyCode: r, which: r, cancelable: !0 },
    i = new KeyboardEvent('keydown', n);
  (i.synthetic = !0), t.dispatchEvent(i);
  let s = new KeyboardEvent('keyup', n);
  return (s.synthetic = !0), t.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;
}
function p4(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || (t.nodeType == 11 && t.host))) return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function GA(t) {
  for (; t.attributes.length; ) t.removeAttributeNode(t.attributes[0]);
}
function f4(t, e) {
  let r = e.focusNode,
    n = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != n) return !1;
  for (n = Math.min(n, os(r)); ; )
    if (n) {
      if (r.nodeType != 1) return !1;
      let i = r.childNodes[n - 1];
      i.contentEditable == 'false' ? n-- : ((r = i), (n = os(r)));
    } else {
      if (r == t) return !0;
      (n = Hu(r)), (r = r.parentNode);
    }
}
function YA(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class Xr {
  constructor(e, r, n = !0) {
    (this.node = e), (this.offset = r), (this.precise = n);
  }
  static before(e, r) {
    return new Xr(e.parentNode, Hu(e), r);
  }
  static after(e, r) {
    return new Xr(e.parentNode, Hu(e) + 1, r);
  }
}
const Kg = [];
class Xt {
  constructor() {
    (this.parent = null), (this.dom = null), (this.flags = 2);
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let n of this.children) {
      if (n == e) return r;
      r += n.length + n.breakAfter;
    }
    throw new RangeError('Invalid child in posBefore');
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let n = this.dom,
        i = null,
        s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : n.firstChild)) {
            let l = Xt.get(s);
            (!l || (!l.parent && l.canReuseDOM(o))) && o.reuseDOM(s);
          }
          o.sync(e, r), (o.flags &= -8);
        }
        if (
          ((s = i ? i.nextSibling : n.firstChild),
          r && !r.written && r.node == n && s != o.dom && (r.written = !0),
          o.dom.parentNode == n)
        )
          for (; s && s != o.dom; ) s = L1(s);
        else n.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : n.firstChild, s && r && r.node == n && (r.written = !0); s; ) s = L1(s);
    } else if (this.flags & 1) for (let n of this.children) n.flags & 7 && (n.sync(e, r), (n.flags &= -8));
  }
  reuseDOM(e) {}
  localPosFromDOM(e, r) {
    let n;
    if (e == this.dom) n = this.dom.childNodes[r];
    else {
      let i = os(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (;;) {
        let s = e.parentNode;
        if (s == this.dom) break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? (i = -1) : (i = 1)), (e = s);
      }
      i < 0 ? (n = e) : (n = e.nextSibling);
    }
    if (n == this.dom.firstChild) return 0;
    for (; n && !Xt.get(n); ) n = n.nextSibling;
    if (!n) return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == n) return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, r, n = 0) {
    let i = -1,
      s = -1,
      o = -1,
      l = -1;
    for (let c = 0, p = n, f = n; c < this.children.length; c++) {
      let m = this.children[c],
        g = p + m.length;
      if (p < e && g > r) return m.domBoundsAround(e, r, p);
      if ((g >= e && i == -1 && ((i = c), (s = p)), p > r && m.dom.parentNode == this.dom)) {
        (o = c), (l = f);
        break;
      }
      (f = g), (p = g + m.breakAfter);
    }
    return {
      from: s,
      to: l < 0 ? n + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null,
    };
  }
  markDirty(e = !1) {
    (this.flags |= 2), this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if ((e && (r.flags |= 2), r.flags & 1)) return;
      (r.flags |= 1), (e = !1);
    }
  }
  setParent(e) {
    this.parent != e && ((this.parent = e), this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), (this.dom = e), (e.cmView = this));
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r) return e;
      e = r;
    }
  }
  replaceChildren(e, r, n = Kg) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let s = this.children[i];
      s.parent == this && s.destroy();
    }
    this.children.splice(e, r - e, ...n);
    for (let i = 0; i < n.length; i++) n[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new QA(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace('View', '');
    return (
      e +
      (this.children.length
        ? '(' + this.children.join() + ')'
        : this.length
        ? '[' + (e == 'Text' ? this.text : this.length) + ']'
        : '') +
      (this.breakAfter ? '#' : '')
    );
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, n, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
Xt.prototype.breakAfter = 0;
function L1(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class QA {
  constructor(e, r, n) {
    (this.children = e), (this.pos = r), (this.i = n), (this.off = 0);
  }
  findPos(e, r = 1) {
    for (;;) {
      if (e > this.pos || (e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)))
        return (this.off = e - this.pos), this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function ZA(t, e, r, n, i, s, o, l, c) {
  let { children: p } = t,
    f = p.length ? p[e] : null,
    m = s.length ? s[s.length - 1] : null,
    g = m ? m.breakAfter : o;
  if (!(e == n && f && !o && !g && s.length < 2 && f.merge(r, i, s.length ? m : null, r == 0, l, c))) {
    if (n < p.length) {
      let x = p[n];
      x && (i < x.length || (x.breakAfter && m != null && m.breakAfter))
        ? (e == n && ((x = x.split(i)), (i = 0)),
          !g && m && x.merge(0, i, m, !0, 0, c)
            ? (s[s.length - 1] = x)
            : ((i || (x.children.length && !x.children[0].length)) && x.merge(0, i, null, !1, 0, c), s.push(x)))
        : x != null && x.breakAfter && (m ? (m.breakAfter = 1) : (o = 1)),
        n++;
    }
    for (
      f &&
      ((f.breakAfter = o),
      r > 0 &&
        (!o && s.length && f.merge(r, f.length, s[0], !1, l, 0)
          ? (f.breakAfter = s.shift().breakAfter)
          : (r < f.length || (f.children.length && f.children[f.children.length - 1].length == 0)) &&
            f.merge(r, f.length, null, !1, l, 0),
        e++));
      e < n && s.length;

    )
      if (p[n - 1].become(s[s.length - 1])) n--, s.pop(), (c = s.length ? 0 : l);
      else if (p[e].become(s[0])) e++, s.shift(), (l = s.length ? 0 : c);
      else break;
    !s.length && e && n < p.length && !p[e - 1].breakAfter && p[n].merge(0, 0, p[e - 1], !1, l, c) && e--,
      (e < n || s.length) && t.replaceChildren(e, n, s);
  }
}
function eE(t, e, r, n, i, s) {
  let o = t.childCursor(),
    { i: l, off: c } = o.findPos(r, 1),
    { i: p, off: f } = o.findPos(e, -1),
    m = e - r;
  for (let g of n) m += g.length;
  (t.length += m), ZA(t, p, f, l, c, n, 0, i, s);
}
let Sn = typeof navigator < 'u' ? navigator : { userAgent: '', vendor: '', platform: '' },
  d0 = typeof document < 'u' ? document : { documentElement: { style: {} } };
const m0 = /Edge\/(\d+)/.exec(Sn.userAgent),
  tE = /MSIE \d/.test(Sn.userAgent),
  g0 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Sn.userAgent),
  bf = !!(tE || g0 || m0),
  _1 = !bf && /gecko\/(\d+)/i.test(Sn.userAgent),
  Qd = !bf && /Chrome\/(\d+)/.exec(Sn.userAgent),
  R1 = 'webkitFontSmoothing' in d0.documentElement.style,
  rE = !bf && /Apple Computer/.test(Sn.vendor),
  j1 = rE && (/Mobile\/\w+/.test(Sn.userAgent) || Sn.maxTouchPoints > 2);
var Je = {
  mac: j1 || /Mac/.test(Sn.platform),
  windows: /Win/.test(Sn.platform),
  linux: /Linux|X11/.test(Sn.platform),
  ie: bf,
  ie_version: tE ? d0.documentMode || 6 : g0 ? +g0[1] : m0 ? +m0[1] : 0,
  gecko: _1,
  gecko_version: _1 ? +(/Firefox\/(\d+)/.exec(Sn.userAgent) || [0, 0])[1] : 0,
  chrome: !!Qd,
  chrome_version: Qd ? +Qd[1] : 0,
  ios: j1,
  android: /Android\b/.test(Sn.userAgent),
  webkit: R1,
  safari: rE,
  webkit_version: R1 ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: d0.documentElement.style.tabSize != null ? 'tab-size' : '-moz-tab-size',
};
const d4 = 256;
class as extends Xt {
  constructor(e) {
    super(), (this.text = e);
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(),
      this.dom.nodeValue != this.text &&
        (r && r.node == this.dom && (r.written = !0), (this.dom.nodeValue = this.text));
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, n) {
    return this.flags & 8 || (n && (!(n instanceof as) || this.length - (r - e) + n.length > d4 || n.flags & 8))
      ? !1
      : ((this.text = this.text.slice(0, e) + (n ? n.text : '') + this.text.slice(r)), this.markDirty(), !0);
  }
  split(e) {
    let r = new as(this.text.slice(e));
    return (this.text = this.text.slice(0, e)), this.markDirty(), (r.flags |= this.flags & 8), r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Xr(this.dom, e);
  }
  domBoundsAround(e, r, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return m4(this.dom, e, r);
  }
}
class ls extends Xt {
  constructor(e, r = [], n = 0) {
    super(), (this.mark = e), (this.children = r), (this.length = n);
    for (let i of r) i.setParent(this);
  }
  setAttrs(e) {
    if ((GA(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs))
      for (let r in this.mark.attrs) e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, r) {
    this.dom
      ? this.flags & 4 && this.setAttrs(this.dom)
      : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
      super.sync(e, r);
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof ls && n.mark.eq(this.mark)) || (e && s <= 0) || (r < this.length && o <= 0))
      ? !1
      : (eE(this, e, r, n ? n.children : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [],
      n = 0,
      i = -1,
      s = 0;
    for (let l of this.children) {
      let c = n + l.length;
      c > e && r.push(n < e ? l.split(e - n) : l), i < 0 && n >= e && (i = s), (n = c), s++;
    }
    let o = this.length - e;
    return (this.length = e), i > -1 && ((this.children.length = i), this.markDirty()), new ls(this.mark, r, o);
  }
  domAtPos(e) {
    return nE(this, e);
  }
  coordsAt(e, r) {
    return sE(this, e, r);
  }
}
function m4(t, e, r) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let i = e,
    s = e,
    o = 0;
  (e == 0 && r < 0) || (e == n && r >= 0)
    ? Je.chrome || Je.gecko || (e ? (i--, (o = 1)) : s < n && (s++, (o = -1)))
    : r < 0
    ? i--
    : s < n && s++;
  let l = ta(t, i, s).getClientRects();
  if (!l.length) return null;
  let c = l[(o ? o < 0 : r >= 0) ? 0 : l.length - 1];
  return (
    Je.safari && !o && c.width == 0 && (c = Array.prototype.find.call(l, (p) => p.width) || c),
    o ? Cf(c, o < 0) : c || null
  );
}
class Vs extends Xt {
  static create(e, r, n) {
    return new Vs(e, r, n);
  }
  constructor(e, r, n) {
    super(), (this.widget = e), (this.length = r), (this.side = n), (this.prevWidget = null);
  }
  split(e) {
    let r = Vs.create(this.widget, this.length - e, this.side);
    return (this.length -= e), r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      (this.dom.contentEditable = 'false'));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, n, i, s, o) {
    return n &&
      (!(n instanceof Vs) || !this.widget.compare(n.widget) || (e > 0 && s <= 0) || (r < this.length && o <= 0))
      ? !1
      : ((this.length = e + (n ? n.length : 0) + (this.length - r)), !0);
  }
  become(e) {
    return e instanceof Vs && e.side == this.side && this.widget.constructor == e.widget.constructor
      ? (this.widget.compare(e.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0) return Ot.empty;
    let e = this;
    for (; e.parent; ) e = e.parent;
    let { view: r } = e,
      n = r && r.state.doc,
      i = this.posAtStart;
    return n ? n.slice(i, i + this.length) : Ot.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Xr.before(this.dom) : Xr.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let n = this.widget.coordsAt(this.dom, e, r);
    if (n) return n;
    let i = this.dom.getClientRects(),
      s = null;
    if (!i.length) return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (
      let l = o ? i.length - 1 : 0;
      (s = i[l]), !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom);
      l += o ? -1 : 1
    );
    return Cf(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class al extends Xt {
  constructor(e) {
    super(), (this.side = e);
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof al && e.side == this.side;
  }
  split() {
    return new al(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement('img');
      (e.className = 'cm-widgetBuffer'), e.setAttribute('aria-hidden', 'true'), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Xr.before(this.dom) : Xr.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Ot.empty;
  }
  get isHidden() {
    return !0;
  }
}
as.prototype.children = Vs.prototype.children = al.prototype.children = Kg;
function nE(t, e) {
  let r = t.dom,
    { children: n } = t,
    i = 0;
  for (let s = 0; i < n.length; i++) {
    let o = n[i],
      l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == r) return o.domAtPos(e - s);
      if (e <= s) break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = n[s - 1];
    if (o.dom.parentNode == r) return o.domAtPos(o.length);
  }
  for (let s = i; s < n.length; s++) {
    let o = n[s];
    if (o.dom.parentNode == r) return o.domAtPos(0);
  }
  return new Xr(r, 0);
}
function iE(t, e, r) {
  let n,
    { children: i } = t;
  r > 0 && e instanceof ls && i.length && (n = i[i.length - 1]) instanceof ls && n.mark.eq(e.mark)
    ? iE(n, e.children[0], r - 1)
    : (i.push(e), e.setParent(t)),
    (t.length += e.length);
}
function sE(t, e, r) {
  let n = null,
    i = -1,
    s = null,
    o = -1;
  function l(p, f) {
    for (let m = 0, g = 0; m < p.children.length && g <= f; m++) {
      let x = p.children[m],
        b = g + x.length;
      b >= f &&
        (x.children.length
          ? l(x, f - g)
          : (!s || (s.isHidden && r > 0)) && (b > f || (g == b && x.getSide() > 0))
          ? ((s = x), (o = f - g))
          : (g < f || (g == b && x.getSide() < 0 && !x.isHidden)) && ((n = x), (i = f - g))),
        (g = b);
    }
  }
  l(t, e);
  let c = (r < 0 ? n : s) || n || s;
  return c ? c.coordsAt(Math.max(0, c == n ? i : o), r) : g4(t);
}
function g4(t) {
  let e = t.dom.lastChild;
  if (!e) return t.dom.getBoundingClientRect();
  let r = ol(e);
  return r[r.length - 1] || null;
}
function y0(t, e) {
  for (let r in t)
    r == 'class' && e.class
      ? (e.class += ' ' + t.class)
      : r == 'style' && e.style
      ? (e.style += ';' + t.style)
      : (e[r] = t[r]);
  return e;
}
const $1 = Object.create(null);
function Jg(t, e, r) {
  if (t == e) return !0;
  t || (t = $1), e || (e = $1);
  let n = Object.keys(t),
    i = Object.keys(e);
  if (n.length - (r && n.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0)) return !1;
  for (let s of n) if (s != r && (i.indexOf(s) == -1 || t[s] !== e[s])) return !1;
  return !0;
}
function D0(t, e, r) {
  let n = !1;
  if (e) for (let i in e) (r && i in r) || ((n = !0), i == 'style' ? (t.style.cssText = '') : t.removeAttribute(i));
  if (r)
    for (let i in r)
      (e && e[i] == r[i]) || ((n = !0), i == 'style' ? (t.style.cssText = r[i]) : t.setAttribute(i, r[i]));
  return n;
}
function y4(t) {
  let e = Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let n = t.attributes[r];
    e[n.name] = n.value;
  }
  return e;
}
class xr extends Xt {
  constructor() {
    super(...arguments),
      (this.children = []),
      (this.length = 0),
      (this.prevAttrs = void 0),
      (this.attrs = null),
      (this.breakAfter = 0);
  }
  merge(e, r, n, i, s, o) {
    if (n) {
      if (!(n instanceof xr)) return !1;
      this.dom || n.transferDOM(this);
    }
    return i && this.setDeco(n ? n.attrs : null), eE(this, e, r, n ? n.children : [], s, o), !0;
  }
  split(e) {
    let r = new xr();
    if (((r.breakAfter = this.breakAfter), this.length == 0)) return r;
    let { i: n, off: i } = this.childPos(e);
    i &&
      (r.append(this.children[n].split(i), 0), this.children[n].merge(i, this.children[n].length, null, !1, 0, 0), n++);
    for (let s = n; s < this.children.length; s++) r.append(this.children[s], 0);
    for (; n > 0 && this.children[n - 1].length == 0; ) this.children[--n].destroy();
    return (this.children.length = n), this.markDirty(), (this.length = e), r;
  }
  transferDOM(e) {
    this.dom &&
      (this.markDirty(),
      e.setDOM(this.dom),
      (e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs),
      (this.prevAttrs = void 0),
      (this.dom = null));
  }
  setDeco(e) {
    Jg(this.attrs, e) || (this.dom && ((this.prevAttrs = this.attrs), this.markDirty()), (this.attrs = e));
  }
  append(e, r) {
    iE(this, e, r);
  }
  addLineDeco(e) {
    let r = e.spec.attributes,
      n = e.spec.class;
    r && (this.attrs = y0(r, this.attrs || {})), n && (this.attrs = y0({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return nE(this, e);
  }
  reuseDOM(e) {
    e.nodeName == 'DIV' && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, r) {
    var n;
    this.dom
      ? this.flags & 4 &&
        (GA(this.dom), (this.dom.className = 'cm-line'), (this.prevAttrs = this.attrs ? null : void 0))
      : (this.setDOM(document.createElement('div')),
        (this.dom.className = 'cm-line'),
        (this.prevAttrs = this.attrs ? null : void 0)),
      this.prevAttrs !== void 0 &&
        (D0(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add('cm-line'), (this.prevAttrs = void 0)),
      super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && Xt.get(i) instanceof ls; ) i = i.lastChild;
    if (
      !i ||
      !this.length ||
      (i.nodeName != 'BR' &&
        ((n = Xt.get(i)) === null || n === void 0 ? void 0 : n.isEditable) == !1 &&
        (!Je.ios || !this.children.some((s) => s instanceof as)))
    ) {
      let s = document.createElement('BR');
      (s.cmIgnore = !0), this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null;
    let e = 0,
      r;
    for (let n of this.children) {
      if (!(n instanceof as) || /[^ -~]/.test(n.text)) return null;
      let i = ol(n.dom);
      if (i.length != 1) return null;
      (e += i[0].width), (r = i[0].height);
    }
    return e
      ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: e / this.length, textHeight: r }
      : null;
  }
  coordsAt(e, r) {
    let n = sE(this, e, r);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState,
        s = n.bottom - n.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: n.top + o, bottom: n.bottom - o, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let n = 0, i = 0; n < e.children.length; n++) {
      let s = e.children[n],
        o = i + s.length;
      if (o >= r) {
        if (s instanceof xr) return s;
        if (o > r) break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class Xs extends Xt {
  constructor(e, r, n) {
    super(), (this.widget = e), (this.length = r), (this.deco = n), (this.breakAfter = 0), (this.prevWidget = null);
  }
  merge(e, r, n, i, s, o) {
    return n &&
      (!(n instanceof Xs) || !this.widget.compare(n.widget) || (e > 0 && s <= 0) || (r < this.length && o <= 0))
      ? !1
      : ((this.length = e + (n ? n.length : 0) + (this.length - r)), !0);
  }
  domAtPos(e) {
    return e == 0 ? Xr.before(this.dom) : Xr.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let n = new Xs(this.widget, r, this.deco);
    return (n.breakAfter = this.breakAfter), n;
  }
  get children() {
    return Kg;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      (this.dom.contentEditable = 'false'));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Ot.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Xs && e.widget.constructor == this.widget.constructor
      ? (e.widget.compare(this.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        (this.deco = e.deco),
        (this.breakAfter = e.breakAfter),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: n } = this.deco;
    return r == n ? !1 : e < 0 ? r < 0 : n > 0;
  }
}
class gs {
  eq(e) {
    return !1;
  }
  updateDOM(e, r) {
    return !1;
  }
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(e) {
    return !0;
  }
  coordsAt(e, r, n) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  destroy(e) {}
}
var ln = (function (t) {
  return (
    (t[(t.Text = 0)] = 'Text'),
    (t[(t.WidgetBefore = 1)] = 'WidgetBefore'),
    (t[(t.WidgetAfter = 2)] = 'WidgetAfter'),
    (t[(t.WidgetRange = 3)] = 'WidgetRange'),
    t
  );
})(ln || (ln = {}));
class it extends ea {
  constructor(e, r, n, i) {
    super(), (this.startSide = e), (this.endSide = r), (this.widget = n), (this.spec = i);
  }
  get heightRelevant() {
    return !1;
  }
  static mark(e) {
    return new lc(e);
  }
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)),
      n = !!e.block;
    return (
      (r += n && !e.inlineOrder ? (r > 0 ? 3e8 : -4e8) : r > 0 ? 1e8 : -1e8), new oo(e, r, r, n, e.widget || null, !1)
    );
  }
  static replace(e) {
    let r = !!e.block,
      n,
      i;
    if (e.isBlockGap) (n = -5e8), (i = 4e8);
    else {
      let { start: s, end: o } = oE(e, r);
      (n = (s ? (r ? -3e8 : -1) : 5e8) - 1), (i = (o ? (r ? 2e8 : 1) : -6e8) + 1);
    }
    return new oo(e, n, i, r, e.widget || null, !0);
  }
  static line(e) {
    return new uc(e);
  }
  static set(e, r = !1) {
    return _t.of(e, r);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
it.none = _t.empty;
class lc extends it {
  constructor(e) {
    let { start: r, end: n } = oE(e);
    super(r ? -1 : 5e8, n ? 1 : -6e8, null, e),
      (this.tagName = e.tagName || 'span'),
      (this.class = e.class || ''),
      (this.attrs = e.attributes || null);
  }
  eq(e) {
    var r, n;
    return (
      this == e ||
      (e instanceof lc &&
        this.tagName == e.tagName &&
        (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) ==
          (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) &&
        Jg(this.attrs, e.attrs, 'class'))
    );
  }
  range(e, r = e) {
    if (e >= r) throw new RangeError('Mark decorations may not be empty');
    return super.range(e, r);
  }
}
lc.prototype.point = !1;
class uc extends it {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof uc && this.spec.class == e.spec.class && Jg(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e) throw new RangeError('Line decoration ranges must be zero-length');
    return super.range(e, r);
  }
}
uc.prototype.mapMode = sn.TrackBefore;
uc.prototype.point = !0;
class oo extends it {
  constructor(e, r, n, i, s, o) {
    super(r, n, s, e),
      (this.block = i),
      (this.isReplace = o),
      (this.mapMode = i ? (r <= 0 ? sn.TrackBefore : sn.TrackAfter) : sn.TrackDel);
  }
  get type() {
    return this.startSide != this.endSide ? ln.WidgetRange : this.startSide <= 0 ? ln.WidgetBefore : ln.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || (!!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0));
  }
  eq(e) {
    return (
      e instanceof oo &&
      D4(this.widget, e.widget) &&
      this.block == e.block &&
      this.startSide == e.startSide &&
      this.endSide == e.endSide
    );
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || (e == r && this.startSide > 0 && this.endSide <= 0)))
      throw new RangeError('Invalid range for replacement decoration');
    if (!this.isReplace && r != e) throw new RangeError('Widget decorations can only have zero-length ranges');
    return super.range(e, r);
  }
}
oo.prototype.point = !0;
function oE(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: n } = t;
  return r == null && (r = t.inclusive), n == null && (n = t.inclusive), { start: r ?? e, end: n ?? e };
}
function D4(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function x0(t, e, r, n = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + n >= t ? (r[i] = Math.max(r[i], e)) : r.push(t, e);
}
class Eu {
  constructor(e, r, n, i) {
    (this.doc = e),
      (this.pos = r),
      (this.end = n),
      (this.disallowBlockEffectsFor = i),
      (this.content = []),
      (this.curLine = null),
      (this.breakAtStart = 0),
      (this.pendingBuffer = 0),
      (this.bufferMarks = []),
      (this.atCursorPos = !0),
      (this.openStart = -1),
      (this.openEnd = -1),
      (this.text = ''),
      (this.textOff = 0),
      (this.cursor = e.iter()),
      (this.skip = r);
  }
  posCovered() {
    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || (e instanceof Xs && e.deco.endSide < 0));
  }
  getLine() {
    return this.curLine || (this.content.push((this.curLine = new xr())), (this.atCursorPos = !0)), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(mh(new al(-1), e), e.length), (this.pendingBuffer = 0));
  }
  addBlockWidget(e) {
    this.flushBuffer(), (this.curLine = null), this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : (this.pendingBuffer = 0),
      !this.posCovered() &&
        !(e && this.content.length && this.content[this.content.length - 1] instanceof Xs) &&
        this.getLine();
  }
  buildText(e, r, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (((this.skip = 0), l)) throw new Error('Ran out of text content when drawing inline views');
        if (o) {
          this.posCovered() || this.getLine(),
            this.content.length ? (this.content[this.content.length - 1].breakAfter = 1) : (this.breakAtStart = 1),
            this.flushBuffer(),
            (this.curLine = null),
            (this.atCursorPos = !0),
            e--;
          continue;
        } else (this.text = s), (this.textOff = 0);
      }
      let i = Math.min(this.text.length - this.textOff, e, 512);
      this.flushBuffer(r.slice(r.length - n)),
        this.getLine().append(mh(new as(this.text.slice(this.textOff, this.textOff + i)), r), n),
        (this.atCursorPos = !0),
        (this.textOff += i),
        (e -= i),
        (n = 0);
    }
  }
  span(e, r, n, i) {
    this.buildText(r - e, n, i), (this.pos = r), this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, n, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && n instanceof oo) {
      if (n.block) throw new RangeError('Block decorations may not be specified via plugins');
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError('Decorations that replace line breaks may not be specified via plugins');
    }
    let l = r - e;
    if (n instanceof oo)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(),
          this.addBlockWidget(new Xs(n.widget || new V1('div'), l, n));
      else {
        let c = Vs.create(n.widget || new V1('span'), l, l ? 0 : n.startSide),
          p = this.atCursorPos && !c.isEditable && s <= i.length && (e < r || n.startSide > 0),
          f = !c.isEditable && (e < r || s > i.length || n.startSide <= 0),
          m = this.getLine();
        this.pendingBuffer == 2 && !p && !c.isEditable && (this.pendingBuffer = 0),
          this.flushBuffer(i),
          p && (m.append(mh(new al(1), i), s), (s = i.length + Math.max(0, s - i.length))),
          m.append(mh(c, i), s),
          (this.atCursorPos = f),
          (this.pendingBuffer = f ? (e < r || s > i.length ? 1 : 2) : 0),
          this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    l &&
      (this.textOff + l <= this.text.length
        ? (this.textOff += l)
        : ((this.skip += l - (this.text.length - this.textOff)), (this.text = ''), (this.textOff = 0)),
      (this.pos = r)),
      this.openStart < 0 && (this.openStart = s);
  }
  static build(e, r, n, i, s) {
    let o = new Eu(e, r, n, s);
    return (o.openEnd = _t.spans(i, r, n, o)), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function mh(t, e) {
  for (let r of e) t = new ls(r, [t], t.length);
  return t;
}
class V1 extends gs {
  constructor(e) {
    super(), (this.tag = e);
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const aE = Ue.define(),
  lE = Ue.define(),
  uE = Ue.define(),
  cE = Ue.define(),
  C0 = Ue.define(),
  hE = Ue.define(),
  pE = Ue.define(),
  fE = Ue.define({ combine: (t) => t.some((e) => e) }),
  dE = Ue.define({ combine: (t) => t.some((e) => e) });
class gp {
  constructor(e, r = 'nearest', n = 'nearest', i = 5, s = 5) {
    (this.range = e), (this.y = r), (this.x = n), (this.yMargin = i), (this.xMargin = s);
  }
  map(e) {
    return e.empty ? this : new gp(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const z1 = mt.define({ map: (t, e) => t.map(e) });
function Vn(t, e, r) {
  let n = t.facet(cE);
  n.length
    ? n[0](e)
    : window.onerror
    ? window.onerror(String(e), r, void 0, void 0, e)
    : r
    ? console.error(r + ':', e)
    : console.error(e);
}
const Af = Ue.define({ combine: (t) => (t.length ? t[0] : !0) });
let x4 = 0;
const lu = Ue.define();
class ar {
  constructor(e, r, n, i, s) {
    (this.id = e),
      (this.create = r),
      (this.domEventHandlers = n),
      (this.domEventObservers = i),
      (this.extension = s(this));
  }
  static define(e, r) {
    const { eventHandlers: n, eventObservers: i, provide: s, decorations: o } = r || {};
    return new ar(x4++, e, n, i, (l) => {
      let c = [lu.of(l)];
      return (
        o &&
          c.push(
            Wu.of((p) => {
              let f = p.plugin(l);
              return f ? o(f) : it.none;
            }),
          ),
        s && c.push(s(l)),
        c
      );
    });
  }
  static fromClass(e, r) {
    return ar.define((n) => new e(n), r);
  }
}
class Zd {
  constructor(e) {
    (this.spec = e), (this.mustUpdate = null), (this.value = null);
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (((this.mustUpdate = null), this.value.update))
          try {
            this.value.update(r);
          } catch (n) {
            if ((Vn(r.state, n, 'CodeMirror plugin crashed'), this.value.destroy))
              try {
                this.value.destroy();
              } catch {}
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (r) {
        Vn(e.state, r, 'CodeMirror plugin crashed'), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        Vn(e.state, n, 'CodeMirror plugin crashed');
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const mE = Ue.define(),
  Xg = Ue.define(),
  Wu = Ue.define(),
  Gg = Ue.define(),
  gE = Ue.define();
function H1(t, e, r) {
  let n = t.state.facet(gE);
  if (!n.length) return n;
  let i = n.map((o) => (o instanceof Function ? o(t) : o)),
    s = [];
  return (
    _t.spans(i, e, r, {
      point() {},
      span(o, l, c, p) {
        let f = s;
        for (let m = c.length - 1; m >= 0; m--, p--) {
          let g = c[m].spec.bidiIsolate,
            x;
          if (g != null)
            if (p > 0 && f.length && (x = f[f.length - 1]).to == o && x.direction == g) (x.to = l), (f = x.inner);
            else {
              let b = { from: o, to: l, direction: g, inner: [] };
              f.push(b), (f = b.inner);
            }
        }
      },
    }),
    s
  );
}
const yE = Ue.define();
function DE(t) {
  let e = 0,
    r = 0,
    n = 0,
    i = 0;
  for (let s of t.state.facet(yE)) {
    let o = s(t);
    o &&
      (o.left != null && (e = Math.max(e, o.left)),
      o.right != null && (r = Math.max(r, o.right)),
      o.top != null && (n = Math.max(n, o.top)),
      o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: r, top: n, bottom: i };
}
const uu = Ue.define();
class zn {
  constructor(e, r, n, i) {
    (this.fromA = e), (this.toA = r), (this.fromB = n), (this.toB = i);
  }
  join(e) {
    return new zn(
      Math.min(this.fromA, e.fromA),
      Math.max(this.toA, e.toA),
      Math.min(this.fromB, e.fromB),
      Math.max(this.toB, e.toB),
    );
  }
  addToSet(e) {
    let r = e.length,
      n = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > n.toA)) {
        if (i.toA < n.fromA) break;
        (n = n.join(i)), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, n), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0) return e;
    let n = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let c = i == e.length ? null : e[i],
        p = o - l,
        f = c ? c.fromB : 1e9;
      for (; s < r.length && r[s] < f; ) {
        let m = r[s],
          g = r[s + 1],
          x = Math.max(l, m),
          b = Math.min(f, g);
        if ((x <= b && new zn(x + p, b + p, x, b).addToSet(n), g > f)) break;
        s += 2;
      }
      if (!c) return n;
      new zn(c.fromA, c.toA, c.fromB, c.toB).addToSet(n), (o = c.toA), (l = c.toB);
    }
  }
}
class yp {
  constructor(e, r, n) {
    (this.view = e),
      (this.state = r),
      (this.transactions = n),
      (this.flags = 0),
      (this.startState = e.state),
      (this.changes = Cr.empty(this.startState.doc.length));
    for (let s of n) this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, c) => i.push(new zn(s, o, l, c))), (this.changedRanges = i);
  }
  static create(e, r, n) {
    return new yp(e, r, n);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var rr = (function (t) {
  return (t[(t.LTR = 0)] = 'LTR'), (t[(t.RTL = 1)] = 'RTL'), t;
})(rr || (rr = {}));
const Uu = rr.LTR,
  xE = rr.RTL;
function CE(t) {
  let e = [];
  for (let r = 0; r < t.length; r++) e.push(1 << +t[r]);
  return e;
}
const C4 = CE(
    '88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008',
  ),
  b4 = CE(
    '4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333',
  ),
  b0 = Object.create(null),
  Ei = [];
for (let t of ['()', '[]', '{}']) {
  let e = t.charCodeAt(0),
    r = t.charCodeAt(1);
  (b0[e] = r), (b0[r] = -e);
}
function A4(t) {
  return t <= 247
    ? C4[t]
    : 1424 <= t && t <= 1524
    ? 2
    : 1536 <= t && t <= 1785
    ? b4[t - 1536]
    : 1774 <= t && t <= 2220
    ? 4
    : 8192 <= t && t <= 8203
    ? 256
    : 64336 <= t && t <= 65023
    ? 4
    : t == 8204
    ? 256
    : 1;
}
const E4 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class zs {
  get dir() {
    return this.level % 2 ? xE : Uu;
  }
  constructor(e, r, n) {
    (this.from = e), (this.to = r), (this.level = n);
  }
  side(e, r) {
    return (this.dir == r) == e ? this.to : this.from;
  }
  static find(e, r, n, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= r && l.to >= r) {
        if (l.level == n) return o;
        (s < 0 || (i != 0 ? (i < 0 ? l.from < r : l.to > r) : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0) throw new RangeError('Index out of range');
    return s;
  }
}
function bE(t, e) {
  if (t.length != e.length) return !1;
  for (let r = 0; r < t.length; r++) {
    let n = t[r],
      i = e[r];
    if (n.from != i.from || n.to != i.to || n.direction != i.direction || !bE(n.inner, i.inner)) return !1;
  }
  return !0;
}
const Vt = [];
function v4(t, e, r, n, i) {
  for (let s = 0; s <= n.length; s++) {
    let o = s ? n[s - 1].to : e,
      l = s < n.length ? n[s].from : r,
      c = s ? 256 : i;
    for (let p = o, f = c, m = c; p < l; p++) {
      let g = A4(t.charCodeAt(p));
      g == 512 ? (g = f) : g == 8 && m == 4 && (g = 16), (Vt[p] = g == 4 ? 2 : g), g & 7 && (m = g), (f = g);
    }
    for (let p = o, f = c, m = c; p < l; p++) {
      let g = Vt[p];
      if (g == 128) p < l - 1 && f == Vt[p + 1] && f & 24 ? (g = Vt[p] = f) : (Vt[p] = 256);
      else if (g == 64) {
        let x = p + 1;
        for (; x < l && Vt[x] == 64; ) x++;
        let b = (p && f == 8) || (x < r && Vt[x] == 8) ? (m == 1 ? 1 : 8) : 256;
        for (let F = p; F < x; F++) Vt[F] = b;
        p = x - 1;
      } else g == 8 && m == 1 && (Vt[p] = 1);
      (f = g), g & 7 && (m = g);
    }
  }
}
function F4(t, e, r, n, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, c = 0; o <= n.length; o++) {
    let p = o ? n[o - 1].to : e,
      f = o < n.length ? n[o].from : r;
    for (let m = p, g, x, b; m < f; m++)
      if ((x = b0[(g = t.charCodeAt(m))]))
        if (x < 0) {
          for (let F = l - 3; F >= 0; F -= 3)
            if (Ei[F + 1] == -x) {
              let E = Ei[F + 2],
                w = E & 2 ? i : E & 4 ? (E & 1 ? s : i) : 0;
              w && (Vt[m] = Vt[Ei[F]] = w), (l = F);
              break;
            }
        } else {
          if (Ei.length == 189) break;
          (Ei[l++] = m), (Ei[l++] = g), (Ei[l++] = c);
        }
      else if ((b = Vt[m]) == 2 || b == 1) {
        let F = b == i;
        c = F ? 0 : 1;
        for (let E = l - 3; E >= 0; E -= 3) {
          let w = Ei[E + 2];
          if (w & 2) break;
          if (F) Ei[E + 2] |= 2;
          else {
            if (w & 4) break;
            Ei[E + 2] |= 4;
          }
        }
      }
  }
}
function S4(t, e, r, n) {
  for (let i = 0, s = n; i <= r.length; i++) {
    let o = i ? r[i - 1].to : t,
      l = i < r.length ? r[i].from : e;
    for (let c = o; c < l; ) {
      let p = Vt[c];
      if (p == 256) {
        let f = c + 1;
        for (;;)
          if (f == l) {
            if (i == r.length) break;
            (f = r[i++].to), (l = i < r.length ? r[i].from : e);
          } else if (Vt[f] == 256) f++;
          else break;
        let m = s == 1,
          g = (f < e ? Vt[f] : n) == 1,
          x = m == g ? (m ? 1 : 2) : n;
        for (let b = f, F = i, E = F ? r[F - 1].to : t; b > c; )
          b == E && ((b = r[--F].from), (E = F ? r[F - 1].to : t)), (Vt[--b] = x);
        c = f;
      } else (s = p), c++;
    }
  }
}
function A0(t, e, r, n, i, s, o) {
  let l = n % 2 ? 2 : 1;
  if (n % 2 == i % 2)
    for (let c = e, p = 0; c < r; ) {
      let f = !0,
        m = !1;
      if (p == s.length || c < s[p].from) {
        let F = Vt[c];
        F != l && ((f = !1), (m = F == 16));
      }
      let g = !f && l == 1 ? [] : null,
        x = f ? n : n + 1,
        b = c;
      e: for (;;)
        if (p < s.length && b == s[p].from) {
          if (m) break e;
          let F = s[p];
          if (!f)
            for (let E = F.to, w = p + 1; ; ) {
              if (E == r) break e;
              if (w < s.length && s[w].from == E) E = s[w++].to;
              else {
                if (Vt[E] == l) break e;
                break;
              }
            }
          if ((p++, g)) g.push(F);
          else {
            F.from > c && o.push(new zs(c, F.from, x));
            let E = (F.direction == Uu) != !(x % 2);
            E0(t, E ? n + 1 : n, i, F.inner, F.from, F.to, o), (c = F.to);
          }
          b = F.to;
        } else {
          if (b == r || (f ? Vt[b] != l : Vt[b] == l)) break;
          b++;
        }
      g ? A0(t, c, b, n + 1, i, g, o) : c < b && o.push(new zs(c, b, x)), (c = b);
    }
  else
    for (let c = r, p = s.length; c > e; ) {
      let f = !0,
        m = !1;
      if (!p || c > s[p - 1].to) {
        let F = Vt[c - 1];
        F != l && ((f = !1), (m = F == 16));
      }
      let g = !f && l == 1 ? [] : null,
        x = f ? n : n + 1,
        b = c;
      e: for (;;)
        if (p && b == s[p - 1].to) {
          if (m) break e;
          let F = s[--p];
          if (!f)
            for (let E = F.from, w = p; ; ) {
              if (E == e) break e;
              if (w && s[w - 1].to == E) E = s[--w].from;
              else {
                if (Vt[E - 1] == l) break e;
                break;
              }
            }
          if (g) g.push(F);
          else {
            F.to < c && o.push(new zs(F.to, c, x));
            let E = (F.direction == Uu) != !(x % 2);
            E0(t, E ? n + 1 : n, i, F.inner, F.from, F.to, o), (c = F.from);
          }
          b = F.from;
        } else {
          if (b == e || (f ? Vt[b - 1] != l : Vt[b - 1] == l)) break;
          b--;
        }
      g ? A0(t, b, c, n + 1, i, g, o) : b < c && o.push(new zs(b, c, x)), (c = b);
    }
}
function E0(t, e, r, n, i, s, o) {
  let l = e % 2 ? 2 : 1;
  v4(t, i, s, n, l), F4(t, i, s, n, l), S4(i, s, n, l), A0(t, i, s, e, r, n, o);
}
function w4(t, e, r) {
  if (!t) return [new zs(0, 0, e == xE ? 1 : 0)];
  if (e == Uu && !r.length && !E4.test(t)) return AE(t.length);
  if (r.length) for (; t.length > Vt.length; ) Vt[Vt.length] = 256;
  let n = [],
    i = e == Uu ? 0 : 1;
  return E0(t, i, i, r, 0, t.length, n), n;
}
function AE(t) {
  return [new zs(0, t, 0)];
}
let EE = '';
function T4(t, e, r, n, i) {
  var s;
  let o = n.head - t.from,
    l = -1;
  if (o == 0) {
    if (!i || !t.length) return null;
    e[0].level != r && ((o = e[0].side(!1, r)), (l = 0));
  } else if (o == t.length) {
    if (i) return null;
    let g = e[e.length - 1];
    g.level != r && ((o = g.side(!0, r)), (l = e.length - 1));
  }
  l < 0 && (l = zs.find(e, o, (s = n.bidiLevel) !== null && s !== void 0 ? s : -1, n.assoc));
  let c = e[l];
  o == c.side(i, r) && ((c = e[(l += i ? 1 : -1)]), (o = c.side(!i, r)));
  let p = i == (c.dir == r),
    f = Yr(t.text, o, p);
  if (((EE = t.text.slice(Math.min(o, f), Math.max(o, f))), f != c.side(i, r)))
    return pe.cursor(f + t.from, p ? -1 : 1, c.level);
  let m = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return !m && c.level != r
    ? pe.cursor(i ? t.to : t.from, i ? -1 : 1, r)
    : m && m.level < c.level
    ? pe.cursor(m.side(!i, r) + t.from, i ? 1 : -1, m.level)
    : pe.cursor(f + t.from, i ? -1 : 1, c.level);
}
class W1 extends Xt {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(),
      (this.view = e),
      (this.decorations = []),
      (this.dynamicDecorationMap = []),
      (this.domChanged = null),
      (this.hasComposition = null),
      (this.markedForComposition = new Set()),
      (this.minWidth = 0),
      (this.minWidthFrom = 0),
      (this.minWidthTo = 0),
      (this.impreciseAnchor = null),
      (this.impreciseHead = null),
      (this.forceSelection = !1),
      (this.lastUpdate = Date.now()),
      this.setDOM(e.contentDOM),
      (this.children = [new xr()]),
      this.children[0].setParent(this),
      this.updateDeco(),
      this.updateInner([new zn(0, 0, 0, e.state.doc.length)], 0, null);
  }
  update(e) {
    var r;
    let n = e.changedRanges;
    this.minWidth > 0 &&
      n.length &&
      (n.every(({ fromA: p, toA: f }) => f < this.minWidthFrom || p > this.minWidthTo)
        ? ((this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1)),
          (this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)))
        : (this.minWidth = this.minWidthFrom = this.minWidthTo = 0));
    let i = -1;
    this.view.inputState.composing >= 0 &&
      (!((r = this.domChanged) === null || r === void 0) && r.newSel
        ? (i = this.domChanged.newSel.head)
        : !O4(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? P4(this.view, e.changes, i) : null;
    if (((this.domChanged = null), this.hasComposition)) {
      this.markedForComposition.clear();
      let { from: p, to: f } = this.hasComposition;
      n = new zn(p, f, e.changes.mapPos(p, -1), e.changes.mapPos(f, 1)).addToSet(n.slice());
    }
    (this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null),
      (Je.ie || Je.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations,
      l = this.updateDeco(),
      c = N4(o, l, e.changes);
    return (
      (n = zn.extendWithRanges(n, c)),
      !(this.flags & 7) && n.length == 0
        ? !1
        : (this.updateInner(n, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0)
    );
  }
  updateInner(e, r, n) {
    (this.view.viewState.mustMeasureContent = !0), this.updateChildren(e, r, n);
    let { observer: i } = this.view;
    i.ignore(() => {
      (this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + 'px'),
        (this.dom.style.flexBasis = this.minWidth ? this.minWidth + 'px' : '');
      let o = Je.chrome || Je.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o),
        (this.flags &= -8),
        o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0),
        (this.dom.style.height = '');
    }),
      this.markedForComposition.forEach((o) => (o.flags &= -9));
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children) o instanceof Xs && o.widget instanceof U1 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, r, n) {
    let i = n ? n.range.addToSet(e.slice()) : e,
      s = this.childCursor(r);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l) break;
      let { fromA: c, toA: p, fromB: f, toB: m } = l,
        g,
        x,
        b,
        F;
      if (n && n.range.fromB < m && n.range.toB > f) {
        let j = Eu.build(this.view.state.doc, f, n.range.fromB, this.decorations, this.dynamicDecorationMap),
          $ = Eu.build(this.view.state.doc, n.range.toB, m, this.decorations, this.dynamicDecorationMap);
        (x = j.breakAtStart), (b = j.openStart), (F = $.openEnd);
        let L = this.compositionView(n);
        $.breakAtStart
          ? (L.breakAfter = 1)
          : $.content.length &&
            L.merge(L.length, L.length, $.content[0], !1, $.openStart, 0) &&
            ((L.breakAfter = $.content[0].breakAfter), $.content.shift()),
          j.content.length && L.merge(0, 0, j.content[j.content.length - 1], !0, 0, j.openEnd) && j.content.pop(),
          (g = j.content.concat(L).concat($.content));
      } else
        ({
          content: g,
          breakAtStart: x,
          openStart: b,
          openEnd: F,
        } = Eu.build(this.view.state.doc, f, m, this.decorations, this.dynamicDecorationMap));
      let { i: E, off: w } = s.findPos(p, 1),
        { i: I, off: T } = s.findPos(c, -1);
      ZA(this, I, T, E, w, g, x, b, F);
    }
    n && this.fixCompositionDOM(n);
  }
  compositionView(e) {
    let r = new as(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks) r = new ls(i, [r], r.length);
    let n = new xr();
    return n.append(r, 0), n;
  }
  fixCompositionDOM(e) {
    let r = (s, o) => {
        (o.flags |= 8 | (o.children.some((c) => c.flags & 7) ? 1 : 0)), this.markedForComposition.add(o);
        let l = Xt.get(s);
        l && l != o && (l.dom = null), o.setDOM(s);
      },
      n = this.childPos(e.range.fromB, 1),
      i = this.children[n.i];
    r(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      (n = i.childPos(n.off, 1)), (i = i.children[n.i]), r(s >= 0 ? e.marks[s].node : e.text, i);
  }
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement,
      i = n == this.dom,
      s = !i && Jh(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(i || r || s)) return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main,
      c = this.moveToLine(this.domAtPos(l.anchor)),
      p = l.empty ? c : this.moveToLine(this.domAtPos(l.head));
    if (Je.gecko && l.empty && !this.hasComposition && k4(c)) {
      let m = document.createTextNode('');
      this.view.observer.ignore(() => c.node.insertBefore(m, c.node.childNodes[c.offset] || null)),
        (c = p = new Xr(m, 0)),
        (o = !0);
    }
    let f = this.view.observer.selectionRange;
    (o ||
      !f.focusNode ||
      !mp(c.node, c.offset, f.anchorNode, f.anchorOffset) ||
      !mp(p.node, p.offset, f.focusNode, f.focusOffset)) &&
      (this.view.observer.ignore(() => {
        Je.android &&
          Je.chrome &&
          this.dom.contains(f.focusNode) &&
          M4(f.focusNode, this.dom) &&
          (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
        let m = dp(this.view.root);
        if (m)
          if (l.empty) {
            if (Je.gecko) {
              let g = B4(c.node, c.offset);
              if (g && g != 3) {
                let x = FE(c.node, c.offset, g == 1 ? 1 : -1);
                x && (c = new Xr(x.node, x.offset));
              }
            }
            m.collapse(c.node, c.offset),
              l.bidiLevel != null && m.caretBidiLevel !== void 0 && (m.caretBidiLevel = l.bidiLevel);
          } else if (m.extend) {
            m.collapse(c.node, c.offset);
            try {
              m.extend(p.node, p.offset);
            } catch {}
          } else {
            let g = document.createRange();
            l.anchor > l.head && ([c, p] = [p, c]),
              g.setEnd(p.node, p.offset),
              g.setStart(c.node, c.offset),
              m.removeAllRanges(),
              m.addRange(g);
          }
        s && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
      }),
      this.view.observer.setSelectionRange(c, p)),
      (this.impreciseAnchor = c.precise ? null : new Xr(f.anchorNode, f.anchorOffset)),
      (this.impreciseHead = p.precise ? null : new Xr(f.focusNode, f.focusOffset));
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: e } = this,
      r = e.state.selection.main,
      n = dp(e.root),
      { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!n || !r.empty || !r.assoc || !n.modify) return;
    let o = xr.find(this, r.head);
    if (!o) return;
    let l = o.posAtStart;
    if (r.head == l || r.head == l + o.length) return;
    let c = this.coordsAt(r.head, -1),
      p = this.coordsAt(r.head, 1);
    if (!c || !p || c.bottom > p.top) return;
    let f = this.domAtPos(r.head + r.assoc);
    n.collapse(f.node, f.offset),
      n.modify('move', r.assoc < 0 ? 'forward' : 'backward', 'lineboundary'),
      e.observer.readSelectionRange();
    let m = e.observer.selectionRange;
    e.docView.posFromDOM(m.anchorNode, m.anchorOffset) != r.from && n.collapse(i, s);
  }
  moveToLine(e) {
    let r = this.dom,
      n;
    if (e.node != r) return e;
    for (let i = e.offset; !n && i < r.childNodes.length; i++) {
      let s = Xt.get(r.childNodes[i]);
      s instanceof xr && (n = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !n && i >= 0; i--) {
      let s = Xt.get(r.childNodes[i]);
      s instanceof xr && (n = s.domAtPos(s.length));
    }
    return n ? new Xr(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let n = Xt.get(r);
      if (n && n.rootView == this) return n;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let n = this.nearest(e);
    if (!n) throw new RangeError('Trying to find position for a DOM position outside of the document');
    return n.localPosFromDOM(e, r) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: n } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (n < i.length || i instanceof xr) break;
      r++, (n = 0);
    }
    return this.children[r].domAtPos(n);
  }
  coordsAt(e, r) {
    let n = null,
      i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o],
        c = s - l.breakAfter,
        p = c - l.length;
      if (c < e) break;
      p <= e &&
        (p < e || l.covers(-1)) &&
        (c > e || l.covers(1)) &&
        (!n || (l instanceof xr && !(n instanceof xr && r >= 0))) &&
        ((n = l), (i = p)),
        (s = p);
    }
    return n ? n.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: n } = this.childPos(e, 1),
      i = this.children[r];
    if (!(i instanceof xr)) return null;
    for (; i.children.length; ) {
      let { i: l, off: c } = i.childPos(n, 1);
      for (; ; l++) {
        if (l == i.children.length) return null;
        if ((i = i.children[l]).length) break;
      }
      n = c;
    }
    if (!(i instanceof as)) return null;
    let s = Yr(i.text, n);
    if (s == n) return null;
    let o = ta(i.dom, n, s).getClientRects();
    return !o.length || o[0].top >= o[0].bottom ? null : o[0];
  }
  measureVisibleLineHeights(e) {
    let r = [],
      { from: n, to: i } = e,
      s = this.view.contentDOM.clientWidth,
      o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
      l = -1,
      c = this.view.textDirection == rr.LTR;
    for (let p = 0, f = 0; f < this.children.length; f++) {
      let m = this.children[f],
        g = p + m.length;
      if (g > i) break;
      if (p >= n) {
        let x = m.dom.getBoundingClientRect();
        if ((r.push(x.height), o)) {
          let b = m.dom.lastChild,
            F = b ? ol(b) : [];
          if (F.length) {
            let E = F[F.length - 1],
              w = c ? E.right - x.left : x.right - E.left;
            w > l && ((l = w), (this.minWidth = s), (this.minWidthFrom = p), (this.minWidthTo = g));
          }
        }
      }
      p = g + m.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == 'rtl' ? rr.RTL : rr.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof xr) {
        let o = s.measureTextSize();
        if (o) return o;
      }
    let e = document.createElement('div'),
      r,
      n,
      i;
    return (
      (e.className = 'cm-line'),
      (e.style.width = '99999px'),
      (e.style.position = 'absolute'),
      (e.textContent = 'abc def ghi jkl mno pqr stu'),
      this.view.observer.ignore(() => {
        this.dom.appendChild(e);
        let s = ol(e.firstChild)[0];
        (r = e.getBoundingClientRect().height), (n = s ? s.width / 27 : 7), (i = s ? s.height : r), e.remove();
      }),
      { lineHeight: r, charWidth: n, textHeight: i }
    );
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new QA(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [],
      r = this.view.viewState;
    for (let n = 0, i = 0; ; i++) {
      let s = i == r.viewports.length ? null : r.viewports[i],
        o = s ? s.from - 1 : this.length;
      if (o > n) {
        let l = (r.lineBlockAt(o).bottom - r.lineBlockAt(n).top) / this.view.scaleY;
        e.push(it.replace({ widget: new U1(l), block: !0, inclusive: !0, isBlockGap: !0 }).range(n, o));
      }
      if (!s) break;
      n = s.to + 1;
    }
    return it.set(e);
  }
  updateDeco() {
    let e = this.view.state
      .facet(Wu)
      .map((r, n) => ((this.dynamicDecorationMap[n] = typeof r == 'function') ? r(this.view) : r));
    for (let r = e.length; r < e.length + 3; r++) this.dynamicDecorationMap[r] = !1;
    return (this.decorations = [...e, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]);
  }
  scrollIntoView(e) {
    let { range: r } = e,
      n = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1),
      i;
    if (!n) return;
    !r.empty &&
      (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) &&
      (n = {
        left: Math.min(n.left, i.left),
        top: Math.min(n.top, i.top),
        right: Math.max(n.right, i.right),
        bottom: Math.max(n.bottom, i.bottom),
      });
    let s = DE(this.view),
      o = { left: n.left - s.left, top: n.top - s.top, right: n.right + s.right, bottom: n.bottom + s.bottom };
    u4(
      this.view.scrollDOM,
      o,
      r.head < r.anchor ? -1 : 1,
      e.x,
      e.y,
      e.xMargin,
      e.yMargin,
      this.view.textDirection == rr.LTR,
    );
  }
}
function k4(t) {
  return (
    t.node.nodeType == 1 &&
    t.node.firstChild &&
    (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == 'false') &&
    (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == 'false')
  );
}
class U1 extends gs {
  constructor(e) {
    super(), (this.height = e);
  }
  toDOM() {
    let e = document.createElement('div');
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return (e.style.height = this.height + 'px'), !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function vE(t, e) {
  let r = t.observer.selectionRange,
    n = r.focusNode && FE(r.focusNode, r.focusOffset, 0);
  if (!n) return null;
  let i = e - n.offset;
  return { from: i, to: i + n.node.nodeValue.length, node: n.node };
}
function P4(t, e, r) {
  let n = vE(t, r);
  if (!n) return null;
  let { node: i, from: s, to: o } = n,
    l = i.nodeValue;
  if (/[\n\r]/.test(l) || t.state.doc.sliceString(n.from, n.to) != l) return null;
  let c = e.invertedDesc,
    p = new zn(c.mapPos(s), c.mapPos(o), s, o),
    f = [];
  for (let m = i.parentNode; ; m = m.parentNode) {
    let g = Xt.get(m);
    if (g instanceof ls) f.push({ node: m, deco: g.mark });
    else {
      if (g instanceof xr || (m.nodeName == 'DIV' && m.parentNode == t.contentDOM))
        return { range: p, text: i, marks: f, line: m };
      if (m != t.contentDOM)
        f.push({ node: m, deco: new lc({ inclusive: !0, attributes: y4(m), tagName: m.tagName.toLowerCase() }) });
      else return null;
    }
  }
}
function FE(t, e, r) {
  if (r <= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3) return { node: n, offset: i };
      if (n.nodeType == 1 && i > 0) (n = n.childNodes[i - 1]), (i = os(n));
      else break;
    }
  if (r >= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3) return { node: n, offset: i };
      if (n.nodeType == 1 && i < n.childNodes.length && r >= 0) (n = n.childNodes[i]), (i = 0);
      else break;
    }
  return null;
}
function B4(t, e) {
  return t.nodeType != 1
    ? 0
    : (e && t.childNodes[e - 1].contentEditable == 'false' ? 1 : 0) |
        (e < t.childNodes.length && t.childNodes[e].contentEditable == 'false' ? 2 : 0);
}
let I4 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, r) {
    x0(e, r, this.changes);
  }
  comparePoint(e, r) {
    x0(e, r, this.changes);
  }
};
function N4(t, e, r) {
  let n = new I4();
  return _t.compare(t, e, r, n), n.changes;
}
function M4(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == 'false') return !0;
  return !1;
}
function O4(t, e) {
  let r = !1;
  return (
    e &&
      t.iterChangedRanges((n, i) => {
        n < e.to && i > e.from && (r = !0);
      }),
    r
  );
}
function L4(t, e, r = 1) {
  let n = t.charCategorizer(e),
    i = t.doc.lineAt(e),
    s = e - i.from;
  if (i.length == 0) return pe.cursor(e);
  s == 0 ? (r = 1) : s == i.length && (r = -1);
  let o = s,
    l = s;
  r < 0 ? (o = Yr(i.text, s, !1)) : (l = Yr(i.text, s));
  let c = n(i.text.slice(o, l));
  for (; o > 0; ) {
    let p = Yr(i.text, o, !1);
    if (n(i.text.slice(p, o)) != c) break;
    o = p;
  }
  for (; l < i.length; ) {
    let p = Yr(i.text, l);
    if (n(i.text.slice(l, p)) != c) break;
    l = p;
  }
  return pe.range(o + i.from, l + i.from);
}
function _4(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function R4(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function em(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function q1(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function K1(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function v0(t, e, r) {
  let n,
    i,
    s,
    o,
    l = !1,
    c,
    p,
    f,
    m;
  for (let b = t.firstChild; b; b = b.nextSibling) {
    let F = ol(b);
    for (let E = 0; E < F.length; E++) {
      let w = F[E];
      i && em(i, w) && (w = q1(K1(w, i.bottom), i.top));
      let I = _4(e, w),
        T = R4(r, w);
      if (I == 0 && T == 0) return b.nodeType == 3 ? J1(b, e, r) : v0(b, e, r);
      if (!n || o > T || (o == T && s > I)) {
        (n = b), (i = w), (s = I), (o = T);
        let j = T ? (r < w.top ? -1 : 1) : I ? (e < w.left ? -1 : 1) : 0;
        l = !j || (j > 0 ? E < F.length - 1 : E > 0);
      }
      I == 0
        ? r > w.bottom && (!f || f.bottom < w.bottom)
          ? ((c = b), (f = w))
          : r < w.top && (!m || m.top > w.top) && ((p = b), (m = w))
        : f && em(f, w)
        ? (f = K1(f, w.bottom))
        : m && em(m, w) && (m = q1(m, w.top));
    }
  }
  if ((f && f.bottom >= r ? ((n = c), (i = f)) : m && m.top <= r && ((n = p), (i = m)), !n))
    return { node: t, offset: 0 };
  let g = Math.max(i.left, Math.min(i.right, e));
  if (n.nodeType == 3) return J1(n, g, r);
  if (l && n.contentEditable != 'false') return v0(n, g, r);
  let x = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: x };
}
function J1(t, e, r) {
  let n = t.nodeValue.length,
    i = -1,
    s = 1e9,
    o = 0;
  for (let l = 0; l < n; l++) {
    let c = ta(t, l, l + 1).getClientRects();
    for (let p = 0; p < c.length; p++) {
      let f = c[p];
      if (f.top == f.bottom) continue;
      o || (o = e - f.left);
      let m = (f.top > r ? f.top - r : r - f.bottom) - 1;
      if (f.left - 1 <= e && f.right + 1 >= e && m < s) {
        let g = e >= (f.left + f.right) / 2,
          x = g;
        if (((Je.chrome || Je.gecko) && ta(t, l).getBoundingClientRect().left == f.right && (x = !g), m <= 0))
          return { node: t, offset: l + (x ? 1 : 0) };
        (i = l + (x ? 1 : 0)), (s = m);
      }
    }
  }
  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };
}
function SE(t, e, r, n = -1) {
  var i, s;
  let o = t.contentDOM.getBoundingClientRect(),
    l = o.top + t.viewState.paddingTop,
    c,
    { docHeight: p } = t.viewState,
    { x: f, y: m } = e,
    g = m - l;
  if (g < 0) return 0;
  if (g > p) return t.state.doc.length;
  for (let j = t.viewState.heightOracle.textHeight / 2, $ = !1; (c = t.elementAtHeight(g)), c.type != ln.Text; )
    for (; (g = n > 0 ? c.bottom + j : c.top - j), !(g >= 0 && g <= p); ) {
      if ($) return r ? null : 0;
      ($ = !0), (n = -n);
    }
  m = l + g;
  let x = c.from;
  if (x < t.viewport.from) return t.viewport.from == 0 ? 0 : r ? null : X1(t, o, c, f, m);
  if (x > t.viewport.to) return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : X1(t, o, c, f, m);
  let b = t.dom.ownerDocument,
    F = t.root.elementFromPoint ? t.root : b,
    E = F.elementFromPoint(f, m);
  E && !t.contentDOM.contains(E) && (E = null),
    E ||
      ((f = Math.max(o.left + 1, Math.min(o.right - 1, f))),
      (E = F.elementFromPoint(f, m)),
      E && !t.contentDOM.contains(E) && (E = null));
  let w,
    I = -1;
  if (E && ((i = t.docView.nearest(E)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (b.caretPositionFromPoint) {
      let j = b.caretPositionFromPoint(f, m);
      j && ({ offsetNode: w, offset: I } = j);
    } else if (b.caretRangeFromPoint) {
      let j = b.caretRangeFromPoint(f, m);
      j &&
        (({ startContainer: w, startOffset: I } = j),
        (!t.contentDOM.contains(w) || (Je.safari && j4(w, I, f)) || (Je.chrome && $4(w, I, f))) && (w = void 0));
    }
  }
  if (!w || !t.docView.dom.contains(w)) {
    let j = xr.find(t.docView, x);
    if (!j) return g > c.top + c.height / 2 ? c.to : c.from;
    ({ node: w, offset: I } = v0(j.dom, f, m));
  }
  let T = t.docView.nearest(w);
  if (!T) return null;
  if (T.isWidget && ((s = T.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let j = T.dom.getBoundingClientRect();
    return e.y < j.top || (e.y <= j.bottom && e.x <= (j.left + j.right) / 2) ? T.posAtStart : T.posAtEnd;
  } else return T.localPosFromDOM(w, I) + T.posAtStart;
}
function X1(t, e, r, n, i) {
  let s = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let l = t.viewState.heightOracle.textHeight,
      c = Math.floor((i - r.top - (t.defaultLineHeight - l) * 0.5) / l);
    s += c * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(r.from, r.to);
  return r.from + c0(o, s, t.state.tabSize);
}
function j4(t, e, r) {
  let n;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length)) return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling) if (i.nodeType != 1 || i.nodeName != 'BR') return !1;
  return ta(t, n - 1, n).getBoundingClientRect().left > r;
}
function $4(t, e, r) {
  if (e != 0) return !1;
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i) return !1;
    if (s.classList.contains('cm-line')) break;
    i = s;
  }
  let n =
    t.nodeType == 1 ? t.getBoundingClientRect() : ta(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - n.left > 5;
}
function F0(t, e) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    for (let n of r.type) if (n.to > e || (n.to == e && (n.to == r.to || n.type == ln.Text))) return n;
  }
  return r;
}
function V4(t, e, r, n) {
  let i = F0(t, e.head),
    s =
      !n || i.type != ln.Text || !(t.lineWrapping || i.widgetLineBreaks)
        ? null
        : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(),
      l = t.textDirectionAt(i.from),
      c = t.posAtCoords({ x: r == (l == rr.LTR) ? o.right - 1 : o.left + 1, y: (s.top + s.bottom) / 2 });
    if (c != null) return pe.cursor(c, r ? -1 : 1);
  }
  return pe.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function G1(t, e, r, n) {
  let i = t.state.doc.lineAt(e.head),
    s = t.bidiSpans(i),
    o = t.textDirectionAt(i.from);
  for (let l = e, c = null; ; ) {
    let p = T4(i, s, o, l, r),
      f = EE;
    if (!p) {
      if (i.number == (r ? t.state.doc.lines : 1)) return l;
      (f = `
`),
        (i = t.state.doc.line(i.number + (r ? 1 : -1))),
        (s = t.bidiSpans(i)),
        (p = pe.cursor(r ? i.from : i.to));
    }
    if (c) {
      if (!c(f)) return l;
    } else {
      if (!n) return p;
      c = n(f);
    }
    l = p;
  }
}
function z4(t, e, r) {
  let n = t.state.charCategorizer(e),
    i = n(r);
  return (s) => {
    let o = n(s);
    return i == er.Space && (i = o), i == o;
  };
}
function H4(t, e, r, n) {
  let i = e.head,
    s = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0)) return pe.cursor(i, e.assoc);
  let o = e.goalColumn,
    l,
    c = t.contentDOM.getBoundingClientRect(),
    p = t.coordsAtPos(i, e.assoc || -1),
    f = t.documentTop;
  if (p) o == null && (o = p.left - c.left), (l = s < 0 ? p.top : p.bottom);
  else {
    let x = t.viewState.lineBlockAt(i);
    o == null && (o = Math.min(c.right - c.left, t.defaultCharacterWidth * (i - x.from))),
      (l = (s < 0 ? x.top : x.bottom) + f);
  }
  let m = c.left + o,
    g = n ?? t.viewState.heightOracle.textHeight >> 1;
  for (let x = 0; ; x += 10) {
    let b = l + (g + x) * s,
      F = SE(t, { x: m, y: b }, !1, s);
    if (b < c.top || b > c.bottom || (s < 0 ? F < i : F > i)) {
      let E = t.docView.coordsForChar(F),
        w = !E || b < E.top ? -1 : 1;
      return pe.cursor(F, w, void 0, o);
    }
  }
}
function Xh(t, e, r) {
  for (;;) {
    let n = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let c = n || r || (e - s < o - e ? -1 : 1);
          (e = c < 0 ? s : o), (n = c);
        }
      });
    if (!n) return e;
  }
}
function tm(t, e, r) {
  let n = Xh(
    t.state.facet(Gg).map((i) => i(t)),
    r.from,
    e.head > r.from ? -1 : 1,
  );
  return n == r.from ? r : pe.cursor(n, n < r.from ? 1 : -1);
}
class W4 {
  setSelectionOrigin(e) {
    (this.lastSelectionOrigin = e), (this.lastSelectionTime = Date.now());
  }
  constructor(e) {
    (this.view = e),
      (this.lastKeyCode = 0),
      (this.lastKeyTime = 0),
      (this.lastTouchTime = 0),
      (this.lastFocusTime = 0),
      (this.lastScrollTop = 0),
      (this.lastScrollLeft = 0),
      (this.pendingIOSKey = void 0),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastEscPress = 0),
      (this.lastContextMenu = 0),
      (this.scrollHandlers = []),
      (this.handlers = Object.create(null)),
      (this.composing = -1),
      (this.compositionFirstChange = null),
      (this.compositionEndedAt = 0),
      (this.compositionPendingKey = !1),
      (this.compositionPendingChange = !1),
      (this.mouseSelection = null),
      (this.handleEvent = this.handleEvent.bind(this)),
      e.scrollDOM.addEventListener('mousedown', (r) => {
        if (
          r.target == e.scrollDOM &&
          r.clientY > e.contentDOM.getBoundingClientRect().bottom &&
          (this.runHandlers('mousedown', r), !r.defaultPrevented && r.button == 2)
        ) {
          let n = e.contentDOM.style.minHeight;
          (e.contentDOM.style.minHeight = '100%'), setTimeout(() => (e.contentDOM.style.minHeight = n), 200);
        }
      }),
      e.scrollDOM.addEventListener('drop', (r) => {
        r.target == e.scrollDOM &&
          r.clientY > e.contentDOM.getBoundingClientRect().bottom &&
          this.runHandlers('drop', r);
      }),
      (this.notifiedFocused = e.hasFocus),
      Je.safari && e.contentDOM.addEventListener('input', () => null),
      Je.gecko && o6(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !Q4(this.view, e) ||
      this.ignoreDuringComposition(e) ||
      (e.type == 'keydown' && this.keydown(e)) ||
      this.runHandlers(e.type, e);
  }
  runHandlers(e, r) {
    let n = this.handlers[e];
    if (n) {
      for (let i of n.observers) i(this.view, r);
      for (let i of n.handlers) {
        if (r.defaultPrevented) break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = U4(e),
      n = this.handlers,
      i = this.view.contentDOM;
    for (let s in r)
      if (s != 'scroll') {
        let o = !r[s].handlers.length,
          l = n[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), (l = null)),
          l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in n) s != 'scroll' && !r[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (
      ((this.lastKeyCode = e.keyCode),
      (this.lastKeyTime = Date.now()),
      e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
    )
      return !0;
    if (
      (e.keyCode != 27 && TE.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0),
      Je.android && Je.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
    )
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return Je.ios &&
      !e.synthetic &&
      !e.altKey &&
      !e.metaKey &&
      (((r = wE.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey) ||
        (q4.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey))
      ? ((this.pendingIOSKey = r || e), setTimeout(() => this.flushIOSKey(), 250), !0)
      : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? ((this.pendingIOSKey = void 0), Xa(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type)
      ? this.composing > 0
        ? !0
        : Je.safari && !Je.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100
        ? ((this.compositionPendingKey = !1), !0)
        : !1
      : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), (this.mouseSelection = e);
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e),
      e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function Y1(t, e) {
  return (r, n) => {
    try {
      return e.call(t, n, r);
    } catch (i) {
      Vn(r.state, i);
    }
  };
}
function U4(t) {
  let e = Object.create(null);
  function r(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of t) {
    let i = n.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s];
        o && r(s).handlers.push(Y1(n.value, o));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s];
        o && r(s).observers.push(Y1(n.value, o));
      }
  }
  for (let n in zi) r(n).handlers.push(zi[n]);
  for (let n in di) r(n).observers.push(di[n]);
  return e;
}
const wE = [
    { key: 'Backspace', keyCode: 8, inputType: 'deleteContentBackward' },
    { key: 'Enter', keyCode: 13, inputType: 'insertParagraph' },
    { key: 'Enter', keyCode: 13, inputType: 'insertLineBreak' },
    { key: 'Delete', keyCode: 46, inputType: 'deleteContentForward' },
  ],
  q4 = 'dthko',
  TE = [16, 17, 18, 20, 91, 92, 224, 225],
  gh = 6;
function yh(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function K4(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class J4 {
  constructor(e, r, n, i) {
    (this.view = e),
      (this.startEvent = r),
      (this.style = n),
      (this.mustSelect = i),
      (this.scrollSpeed = { x: 0, y: 0 }),
      (this.scrolling = -1),
      (this.lastEvent = r),
      (this.scrollParent = c4(e.contentDOM)),
      (this.atoms = e.state.facet(Gg).map((o) => o(e)));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener('mousemove', (this.move = this.move.bind(this))),
      s.addEventListener('mouseup', (this.up = this.up.bind(this))),
      (this.extend = r.shiftKey),
      (this.multiple = e.state.facet(Ct.allowMultipleSelections) && X4(e, r)),
      (this.dragging = Y4(e, r) && IE(r) == 1 ? null : !1);
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var r;
    if (e.buttons == 0) return this.destroy();
    if (this.dragging || (this.dragging == null && K4(this.startEvent, e) < 10)) return;
    this.select((this.lastEvent = e));
    let n = 0,
      i = 0,
      s = ((r = this.scrollParent) === null || r === void 0 ? void 0 : r.getBoundingClientRect()) || {
        left: 0,
        top: 0,
        right: this.view.win.innerWidth,
        bottom: this.view.win.innerHeight,
      },
      o = DE(this.view);
    e.clientX - o.left <= s.left + gh
      ? (n = -yh(s.left - e.clientX))
      : e.clientX + o.right >= s.right - gh && (n = yh(e.clientX - s.right)),
      e.clientY - o.top <= s.top + gh
        ? (i = -yh(s.top - e.clientY))
        : e.clientY + o.bottom >= s.bottom - gh && (i = yh(e.clientY - s.bottom)),
      this.setScrollSpeed(n, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener('mousemove', this.move),
      e.removeEventListener('mouseup', this.up),
      (this.view.inputState.mouseSelection = null);
  }
  setScrollSpeed(e, r) {
    (this.scrollSpeed = { x: e, y: r }),
      e || r
        ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50))
        : this.scrolling > -1 && (clearInterval(this.scrolling), (this.scrolling = -1));
  }
  scroll() {
    this.scrollParent
      ? ((this.scrollParent.scrollLeft += this.scrollSpeed.x), (this.scrollParent.scrollTop += this.scrollSpeed.y))
      : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
      this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let n = 0; n < e.ranges.length; n++) {
      let i = e.ranges[n],
        s = null;
      if (i.empty) {
        let o = Xh(this.atoms, i.from, 0);
        o != i.from && (s = pe.cursor(o, -1));
      } else {
        let o = Xh(this.atoms, i.from, -1),
          l = Xh(this.atoms, i.to, 1);
        (o != i.from || l != i.to) && (s = pe.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
      }
      s && (r || (r = e.ranges.slice()), (r[n] = s));
    }
    return r ? pe.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this,
      n = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect ||
      !n.eq(r.state.selection) ||
      (n.main.assoc != r.state.selection.main.assoc && this.dragging === !1)) &&
      this.view.dispatch({ selection: n, userEvent: 'select.pointer' }),
      (this.mustSelect = !1);
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)),
      this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function X4(t, e) {
  let r = t.state.facet(aE);
  return r.length ? r[0](e) : Je.mac ? e.metaKey : e.ctrlKey;
}
function G4(t, e) {
  let r = t.state.facet(lE);
  return r.length ? r[0](e) : Je.mac ? !e.altKey : !e.ctrlKey;
}
function Y4(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty) return !1;
  let n = dp(t.root);
  if (!n || n.rangeCount == 0) return !0;
  let i = n.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY) return !0;
  }
  return !1;
}
function Q4(t, e) {
  if (!e.bubbles) return !0;
  if (e.defaultPrevented) return !1;
  for (let r = e.target, n; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || ((n = Xt.get(r)) && n.ignoreEvent(e))) return !1;
  return !0;
}
const zi = Object.create(null),
  di = Object.create(null),
  kE = (Je.ie && Je.ie_version < 15) || (Je.ios && Je.webkit_version < 604);
function Z4(t) {
  let e = t.dom.parentNode;
  if (!e) return;
  let r = e.appendChild(document.createElement('textarea'));
  (r.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    r.focus(),
    setTimeout(() => {
      t.focus(), r.remove(), PE(t, r.value);
    }, 50);
}
function PE(t, e) {
  let { state: r } = t,
    n,
    i = 1,
    s = r.toText(e),
    o = s.lines == r.selection.ranges.length;
  if (S0 != null && r.selection.ranges.every((c) => c.empty) && S0 == s.toString()) {
    let c = -1;
    n = r.changeByRange((p) => {
      let f = r.doc.lineAt(p.from);
      if (f.from == c) return { range: p };
      c = f.from;
      let m = r.toText((o ? s.line(i++).text : e) + r.lineBreak);
      return { changes: { from: f.from, insert: m }, range: pe.cursor(p.from + m.length) };
    });
  } else
    o
      ? (n = r.changeByRange((c) => {
          let p = s.line(i++);
          return { changes: { from: c.from, to: c.to, insert: p.text }, range: pe.cursor(c.from + p.length) };
        }))
      : (n = r.replaceSelection(s));
  t.dispatch(n, { userEvent: 'input.paste', scrollIntoView: !0 });
}
di.scroll = (t) => {
  (t.inputState.lastScrollTop = t.scrollDOM.scrollTop), (t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft);
};
zi.keydown = (t, e) => (
  t.inputState.setSelectionOrigin('select'), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1
);
di.touchstart = (t, e) => {
  (t.inputState.lastTouchTime = Date.now()), t.inputState.setSelectionOrigin('select.pointer');
};
di.touchmove = (t) => {
  t.inputState.setSelectionOrigin('select.pointer');
};
zi.mousedown = (t, e) => {
  if ((t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)) return !1;
  let r = null;
  for (let n of t.state.facet(uE)) if (((r = n(t, e)), r)) break;
  if ((!r && e.button == 0 && (r = r6(t, e)), r)) {
    let n = !t.hasFocus;
    t.inputState.startMouseSelection(new J4(t, e, r, n)), n && t.observer.ignore(() => XA(t.contentDOM));
    let i = t.inputState.mouseSelection;
    if (i) return i.start(e), i.dragging === !1;
  }
  return !1;
};
function Q1(t, e, r, n) {
  if (n == 1) return pe.cursor(e, r);
  if (n == 2) return L4(t.state, e, r);
  {
    let i = xr.find(t.docView, e),
      s = t.state.doc.lineAt(i ? i.posAtEnd : e),
      o = i ? i.posAtStart : s.from,
      l = i ? i.posAtEnd : s.to;
    return l < t.state.doc.length && l == s.to && l++, pe.range(o, l);
  }
}
let BE = (t, e) => t >= e.top && t <= e.bottom,
  Z1 = (t, e, r) => BE(e, r) && t >= r.left && t <= r.right;
function e6(t, e, r, n) {
  let i = xr.find(t.docView, e);
  if (!i) return 1;
  let s = e - i.posAtStart;
  if (s == 0) return 1;
  if (s == i.length) return -1;
  let o = i.coordsAt(s, -1);
  if (o && Z1(r, n, o)) return -1;
  let l = i.coordsAt(s, 1);
  return l && Z1(r, n, l) ? 1 : o && BE(n, o) ? -1 : 1;
}
function ex(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: e6(t, r, e.clientX, e.clientY) };
}
const t6 = Je.ie && Je.ie_version <= 11;
let tx = null,
  rx = 0,
  nx = 0;
function IE(t) {
  if (!t6) return t.detail;
  let e = tx,
    r = nx;
  return (
    (tx = t),
    (nx = Date.now()),
    (rx =
      !e || (r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2)
        ? (rx + 1) % 3
        : 1)
  );
}
function r6(t, e) {
  let r = ex(t, e),
    n = IE(e),
    i = t.state.selection;
  return {
    update(s) {
      s.docChanged && ((r.pos = s.changes.mapPos(r.pos)), (i = i.map(s.changes)));
    },
    get(s, o, l) {
      let c = ex(t, s),
        p,
        f = Q1(t, c.pos, c.bias, n);
      if (r.pos != c.pos && !o) {
        let m = Q1(t, r.pos, r.bias, n),
          g = Math.min(m.from, f.from),
          x = Math.max(m.to, f.to);
        f = g < f.from ? pe.range(g, x) : pe.range(x, g);
      }
      return o
        ? i.replaceRange(i.main.extend(f.from, f.to))
        : l && n == 1 && i.ranges.length > 1 && (p = n6(i, c.pos))
        ? p
        : l
        ? i.addRange(f)
        : pe.create([f]);
    },
  };
}
function n6(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: n, to: i } = t.ranges[r];
    if (n <= e && i >= e)
      return pe.create(
        t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)),
        t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0),
      );
  }
  return null;
}
zi.dragstart = (t, e) => {
  let {
      selection: { main: r },
    } = t.state,
    { mouseSelection: n } = t.inputState;
  return (
    n && (n.dragging = r),
    e.dataTransfer &&
      (e.dataTransfer.setData('Text', t.state.sliceDoc(r.from, r.to)), (e.dataTransfer.effectAllowed = 'copyMove')),
    !1
  );
};
function ix(t, e, r, n) {
  if (!r) return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    { mouseSelection: s } = t.inputState,
    o = n && s && s.dragging && G4(t, e) ? { from: s.dragging.from, to: s.dragging.to } : null,
    l = { from: i, insert: r },
    c = t.state.changes(o ? [o, l] : l);
  t.focus(),
    t.dispatch({
      changes: c,
      selection: { anchor: c.mapPos(i, -1), head: c.mapPos(i, 1) },
      userEvent: o ? 'move.drop' : 'input.drop',
    });
}
zi.drop = (t, e) => {
  if (!e.dataTransfer) return !1;
  if (t.state.readOnly) return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let n = Array(r.length),
      i = 0,
      s = () => {
        ++i == r.length && ix(t, e, n.filter((o) => o != null).join(t.state.lineBreak), !1);
      };
    for (let o = 0; o < r.length; o++) {
      let l = new FileReader();
      (l.onerror = s),
        (l.onload = () => {
          /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (n[o] = l.result), s();
        }),
        l.readAsText(r[o]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData('Text');
    if (n) return ix(t, e, n, !0), !0;
  }
  return !1;
};
zi.paste = (t, e) => {
  if (t.state.readOnly) return !0;
  t.observer.flush();
  let r = kE ? null : e.clipboardData;
  return r ? (PE(t, r.getData('text/plain') || r.getData('text/uri-text')), !0) : (Z4(t), !1);
};
function i6(t, e) {
  let r = t.dom.parentNode;
  if (!r) return;
  let n = r.appendChild(document.createElement('textarea'));
  (n.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    (n.value = e),
    n.focus(),
    (n.selectionEnd = e.length),
    (n.selectionStart = 0),
    setTimeout(() => {
      n.remove(), t.focus();
    }, 50);
}
function s6(t) {
  let e = [],
    r = [],
    n = !1;
  for (let i of t.selection.ranges) i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > i && (e.push(o.text), r.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), (i = o.number);
    }
    n = !0;
  }
  return { text: e.join(t.lineBreak), ranges: r, linewise: n };
}
let S0 = null;
zi.copy = zi.cut = (t, e) => {
  let { text: r, ranges: n, linewise: i } = s6(t.state);
  if (!r && !i) return !1;
  (S0 = i ? r : null),
    e.type == 'cut' && !t.state.readOnly && t.dispatch({ changes: n, scrollIntoView: !0, userEvent: 'delete.cut' });
  let s = kE ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData('text/plain', r), !0) : (i6(t, r), !1);
};
const NE = ms.define();
function ME(t, e) {
  let r = [];
  for (let n of t.facet(pE)) {
    let i = n(t, e);
    i && r.push(i);
  }
  return r ? t.update({ effects: r, annotations: NE.of(!0) }) : null;
}
function OE(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = ME(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
di.focus = (t) => {
  (t.inputState.lastFocusTime = Date.now()),
    !t.scrollDOM.scrollTop &&
      (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) &&
      ((t.scrollDOM.scrollTop = t.inputState.lastScrollTop), (t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft)),
    OE(t);
};
di.blur = (t) => {
  t.observer.clearSelectionRange(), OE(t);
};
di.compositionstart = di.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0),
    t.inputState.composing < 0 && (t.inputState.composing = 0);
};
di.compositionend = (t) => {
  (t.inputState.composing = -1),
    (t.inputState.compositionEndedAt = Date.now()),
    (t.inputState.compositionPendingKey = !0),
    (t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0),
    (t.inputState.compositionFirstChange = null),
    Je.chrome && Je.android
      ? t.observer.flushSoon()
      : t.inputState.compositionPendingChange
      ? Promise.resolve().then(() => t.observer.flush())
      : setTimeout(() => {
          t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
        }, 50);
};
di.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
zi.beforeinput = (t, e) => {
  var r;
  let n;
  if (
    Je.chrome &&
    Je.android &&
    (n = wE.find((i) => i.inputType == e.inputType)) &&
    (t.observer.delayAndroidKey(n.key, n.keyCode), n.key == 'Backspace' || n.key == 'Delete')
  ) {
    let i = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 &&
        t.hasFocus &&
        (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const sx = new Set();
function o6(t) {
  sx.has(t) || (sx.add(t), t.addEventListener('copy', () => {}), t.addEventListener('cut', () => {}));
}
const ox = ['pre-wrap', 'normal', 'pre-line', 'break-spaces'];
class a6 {
  constructor(e) {
    (this.lineWrapping = e),
      (this.doc = Ot.empty),
      (this.heightSamples = {}),
      (this.lineHeight = 14),
      (this.charWidth = 7),
      (this.textHeight = 14),
      (this.lineLength = 30),
      (this.heightChanged = !1);
  }
  heightForGap(e, r) {
    let n = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return (
      this.lineWrapping && (n += Math.max(0, Math.ceil((r - e - n * this.lineLength * 0.5) / this.lineLength))),
      this.lineHeight * n
    );
  }
  heightForLine(e) {
    return this.lineWrapping
      ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight
      : this.lineHeight;
  }
  setDoc(e) {
    return (this.doc = e), this;
  }
  mustRefreshForWrapping(e) {
    return ox.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      i < 0 ? n++ : this.heightSamples[Math.floor(i * 10)] || ((r = !0), (this.heightSamples[Math.floor(i * 10)] = !0));
    }
    return r;
  }
  refresh(e, r, n, i, s, o) {
    let l = ox.indexOf(e) > -1,
      c = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (
      ((this.lineWrapping = l),
      (this.lineHeight = r),
      (this.charWidth = n),
      (this.textHeight = i),
      (this.lineLength = s),
      c)
    ) {
      this.heightSamples = {};
      for (let p = 0; p < o.length; p++) {
        let f = o[p];
        f < 0 ? p++ : (this.heightSamples[Math.floor(f * 10)] = !0);
      }
    }
    return c;
  }
}
class l6 {
  constructor(e, r) {
    (this.from = e), (this.heights = r), (this.index = 0);
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Ii {
  constructor(e, r, n, i, s) {
    (this.from = e), (this.length = r), (this.top = n), (this.height = i), (this._content = s);
  }
  get type() {
    return typeof this._content == 'number'
      ? ln.Text
      : Array.isArray(this._content)
      ? this._content
      : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof oo ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == 'number' ? this._content : 0;
  }
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(
      Array.isArray(e._content) ? e._content : [e],
    );
    return new Ii(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var Kt = (function (t) {
  return (
    (t[(t.ByPos = 0)] = 'ByPos'), (t[(t.ByHeight = 1)] = 'ByHeight'), (t[(t.ByPosNoHeight = 2)] = 'ByPosNoHeight'), t
  );
})(Kt || (Kt = {}));
const Gh = 0.001;
class un {
  constructor(e, r, n = 2) {
    (this.length = e), (this.height = r), (this.flags = n);
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | (this.flags & -3);
  }
  setHeight(e, r) {
    this.height != r && (Math.abs(this.height - r) > Gh && (e.heightChanged = !0), (this.height = r));
  }
  replace(e, r, n) {
    return un.of(n);
  }
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, n, i) {
    let s = this,
      o = n.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: c, toA: p, fromB: f, toB: m } = i[l],
        g = s.lineAt(c, Kt.ByPosNoHeight, n.setDoc(r), 0, 0),
        x = g.to >= p ? g : s.lineAt(p, Kt.ByPosNoHeight, n, 0, 0);
      for (m += x.to - p, p = x.to; l > 0 && g.from <= i[l - 1].toA; )
        (c = i[l - 1].fromA), (f = i[l - 1].fromB), l--, c < g.from && (g = s.lineAt(c, Kt.ByPosNoHeight, n, 0, 0));
      (f += g.from - c), (c = g.from);
      let b = Yg.build(n.setDoc(o), e, f, m);
      s = s.replace(c, p, b);
    }
    return s.updateHeight(n, 0);
  }
  static empty() {
    return new vn(0, 0);
  }
  static of(e) {
    if (e.length == 1) return e[0];
    let r = 0,
      n = e.length,
      i = 0,
      s = 0;
    for (;;)
      if (r == n)
        if (i > s * 2) {
          let l = e[r - 1];
          l.break ? e.splice(--r, 1, l.left, null, l.right) : e.splice(--r, 1, l.left, l.right),
            (n += 1 + l.break),
            (i -= l.size);
        } else if (s > i * 2) {
          let l = e[n];
          l.break ? e.splice(n, 1, l.left, null, l.right) : e.splice(n, 1, l.left, l.right),
            (n += 2 + l.break),
            (s -= l.size);
        } else break;
      else if (i < s) {
        let l = e[r++];
        l && (i += l.size);
      } else {
        let l = e[--n];
        l && (s += l.size);
      }
    let o = 0;
    return (
      e[r - 1] == null ? ((o = 1), r--) : e[r] == null && ((o = 1), n++),
      new u6(un.of(e.slice(0, r)), o, un.of(e.slice(n)))
    );
  }
}
un.prototype.size = 1;
class LE extends un {
  constructor(e, r, n) {
    super(e, r), (this.deco = n);
  }
  blockAt(e, r, n, i) {
    return new Ii(i, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, r, n, i, s) {
    return this.blockAt(0, n, i, s);
  }
  forEachLine(e, r, n, i, s, o) {
    e <= s + this.length && r >= s && o(this.blockAt(0, n, i, s));
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(e, i.heights[i.index++]), (this.outdated = !1), this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class vn extends LE {
  constructor(e, r) {
    super(e, r, null), (this.collapsed = 0), (this.widgetHeight = 0), (this.breaks = 0);
  }
  blockAt(e, r, n, i) {
    return new Ii(i, this.length, n, this.height, this.breaks);
  }
  replace(e, r, n) {
    let i = n[0];
    return n.length == 1 &&
      (i instanceof vn || (i instanceof Ir && i.flags & 4)) &&
      Math.abs(this.length - i.length) < 10
      ? (i instanceof Ir ? (i = new vn(i.length, this.height)) : (i.height = this.height),
        this.outdated || (i.outdated = !1),
        i)
      : un.of(n);
  }
  updateHeight(e, r = 0, n = !1, i) {
    return (
      i && i.from <= r && i.more
        ? this.setHeight(e, i.heights[i.index++])
        : (n || this.outdated) &&
          this.setHeight(
            e,
            Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight,
          ),
      (this.outdated = !1),
      this
    );
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ''}${
      this.widgetHeight ? ':' + this.widgetHeight : ''
    })`;
  }
}
class Ir extends un {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let n = e.doc.lineAt(r).number,
      i = e.doc.lineAt(r + this.length).number,
      s = i - n + 1,
      o,
      l = 0;
    if (e.lineWrapping) {
      let c = Math.min(this.height, e.lineHeight * s);
      (o = c / s), this.length > s + 1 && (l = (this.height - c) / (this.length - s - 1));
    } else o = this.height / s;
    return { firstLine: n, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, r, n, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: c } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let p = i + Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length),
        f = r.doc.lineAt(p),
        m = l + f.length * c,
        g = Math.max(n, e - m / 2);
      return new Ii(f.from, f.length, g, m, 0);
    } else {
      let p = Math.max(0, Math.min(o - s, Math.floor((e - n) / l))),
        { from: f, length: m } = r.doc.line(s + p);
      return new Ii(f, m, n + l * p, l, 0);
    }
  }
  lineAt(e, r, n, i, s) {
    if (r == Kt.ByHeight) return this.blockAt(e, n, i, s);
    if (r == Kt.ByPosNoHeight) {
      let { from: x, to: b } = n.doc.lineAt(e);
      return new Ii(x, b - x, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: c } = this.heightMetrics(n, s),
      p = n.doc.lineAt(e),
      f = l + p.length * c,
      m = p.number - o,
      g = i + l * m + c * (p.from - s - m);
    return new Ii(p.from, p.length, Math.max(i, Math.min(g, i + this.height - f)), f, 0);
  }
  forEachLine(e, r, n, i, s, o) {
    (e = Math.max(e, s)), (r = Math.min(r, s + this.length));
    let { firstLine: l, perLine: c, perChar: p } = this.heightMetrics(n, s);
    for (let f = e, m = i; f <= r; ) {
      let g = n.doc.lineAt(f);
      if (f == e) {
        let b = g.number - l;
        m += c * b + p * (e - s - b);
      }
      let x = c + p * g.length;
      o(new Ii(g.from, g.length, m, x, 0)), (m += x), (f = g.to + 1);
    }
  }
  replace(e, r, n) {
    let i = this.length - r;
    if (i > 0) {
      let s = n[n.length - 1];
      s instanceof Ir ? (n[n.length - 1] = new Ir(s.length + i)) : n.push(null, new Ir(i - 1));
    }
    if (e > 0) {
      let s = n[0];
      s instanceof Ir ? (n[0] = new Ir(e + s.length)) : n.unshift(new Ir(e - 1), null);
    }
    return un.of(n);
  }
  decomposeLeft(e, r) {
    r.push(new Ir(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new Ir(this.length - e - 1));
  }
  updateHeight(e, r = 0, n = !1, i) {
    let s = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let o = [],
        l = Math.max(r, i.from),
        c = -1;
      for (i.from > r && o.push(new Ir(i.from - r - 1).updateHeight(e, r)); l <= s && i.more; ) {
        let f = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let m = i.heights[i.index++];
        c == -1 ? (c = m) : Math.abs(m - c) >= Gh && (c = -2);
        let g = new vn(f, m);
        (g.outdated = !1), o.push(g), (l += f + 1);
      }
      l <= s && o.push(null, new Ir(s - l).updateHeight(e, l));
      let p = un.of(o);
      return (
        (c < 0 || Math.abs(p.height - this.height) >= Gh || Math.abs(c - this.heightMetrics(e, r).perLine) >= Gh) &&
          (e.heightChanged = !0),
        p
      );
    } else (n || this.outdated) && (this.setHeight(e, e.heightForGap(r, r + this.length)), (this.outdated = !1));
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class u6 extends un {
  constructor(e, r, n) {
    super(e.length + r + n.length, e.height + n.height, r | (e.outdated || n.outdated ? 2 : 0)),
      (this.left = e),
      (this.right = n),
      (this.size = e.size + n.size);
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, n, i) {
    let s = n + this.left.height;
    return e < s ? this.left.blockAt(e, r, n, i) : this.right.blockAt(e, r, s, i + this.left.length + this.break);
  }
  lineAt(e, r, n, i, s) {
    let o = i + this.left.height,
      l = s + this.left.length + this.break,
      c = r == Kt.ByHeight ? e < o : e < l,
      p = c ? this.left.lineAt(e, r, n, i, s) : this.right.lineAt(e, r, n, o, l);
    if (this.break || (c ? p.to < l : p.from > l)) return p;
    let f = r == Kt.ByPosNoHeight ? Kt.ByPosNoHeight : Kt.ByPos;
    return c ? p.join(this.right.lineAt(l, f, n, o, l)) : this.left.lineAt(l, f, n, i, s).join(p);
  }
  forEachLine(e, r, n, i, s, o) {
    let l = i + this.left.height,
      c = s + this.left.length + this.break;
    if (this.break)
      e < c && this.left.forEachLine(e, r, n, i, s, o), r >= c && this.right.forEachLine(e, r, n, l, c, o);
    else {
      let p = this.lineAt(c, Kt.ByPos, n, i, s);
      e < p.from && this.left.forEachLine(e, p.from - 1, n, i, s, o),
        p.to >= e && p.from <= r && o(p),
        r > p.to && this.right.forEachLine(p.to + 1, r, n, l, c, o);
    }
  }
  replace(e, r, n) {
    let i = this.left.length + this.break;
    if (r < i) return this.balanced(this.left.replace(e, r, n), this.right);
    if (e > this.left.length) return this.balanced(this.left, this.right.replace(e - i, r - i, n));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of n) s.push(l);
    if ((e > 0 && ax(s, o - 1), r < this.length)) {
      let l = s.length;
      this.decomposeRight(r, s), ax(s, l);
    }
    return un.of(s);
  }
  decomposeLeft(e, r) {
    let n = this.left.length;
    if (e <= n) return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (n++, e >= n && r.push(null)), e > n && this.right.decomposeLeft(e - n, r);
  }
  decomposeRight(e, r) {
    let n = this.left.length,
      i = n + this.break;
    if (e >= i) return this.right.decomposeRight(e - i, r);
    e < n && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size
      ? un.of(this.break ? [e, null, r] : [e, r])
      : ((this.left = e),
        (this.right = r),
        (this.height = e.height + r.height),
        (this.outdated = e.outdated || r.outdated),
        (this.size = e.size + r.size),
        (this.length = e.length + this.break + r.length),
        this);
  }
  updateHeight(e, r = 0, n = !1, i) {
    let { left: s, right: o } = this,
      l = r + s.length + this.break,
      c = null;
    return (
      i && i.from <= r + s.length && i.more ? (c = s = s.updateHeight(e, r, n, i)) : s.updateHeight(e, r, n),
      i && i.from <= l + o.length && i.more ? (c = o = o.updateHeight(e, l, n, i)) : o.updateHeight(e, l, n),
      c ? this.balanced(s, o) : ((this.height = this.left.height + this.right.height), (this.outdated = !1), this)
    );
  }
  toString() {
    return this.left + (this.break ? ' ' : '-') + this.right;
  }
}
function ax(t, e) {
  let r, n;
  t[e] == null &&
    (r = t[e - 1]) instanceof Ir &&
    (n = t[e + 1]) instanceof Ir &&
    t.splice(e - 1, 3, new Ir(r.length + 1 + n.length));
}
const c6 = 5;
class Yg {
  constructor(e, r) {
    (this.pos = e),
      (this.oracle = r),
      (this.nodes = []),
      (this.lineStart = -1),
      (this.lineEnd = -1),
      (this.covering = null),
      (this.writtenTo = e);
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let n = Math.min(r, this.lineEnd),
        i = this.nodes[this.nodes.length - 1];
      i instanceof vn
        ? (i.length += n - this.pos)
        : (n > this.pos || !this.isCovered) && this.nodes.push(new vn(n - this.pos, -1)),
        (this.writtenTo = n),
        r > n && (this.nodes.push(null), this.writtenTo++, (this.lineStart = -1));
    }
    this.pos = r;
  }
  point(e, r, n) {
    if (e < r || n.heightRelevant) {
      let i = n.widget ? n.widget.estimatedHeight : 0,
        s = n.widget ? n.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = r - e;
      n.block ? this.addBlock(new LE(o, i, n)) : (o || s || i >= c6) && this.addLineDeco(i, s, o);
    } else r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    (this.lineStart = e),
      (this.lineEnd = r),
      this.writtenTo < e &&
        ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) &&
          this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
        this.nodes.push(null)),
      this.pos > e && this.nodes.push(new vn(this.pos - e, -1)),
      (this.writtenTo = this.pos);
  }
  blankContent(e, r) {
    let n = new Ir(r - e);
    return this.oracle.doc.lineAt(e).to == r && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof vn) return e;
    let r = new vn(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(),
      this.nodes.push(e),
      (this.writtenTo = this.pos = this.pos + e.length),
      r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, n) {
    let i = this.ensureLine();
    (i.length += n),
      (i.collapsed += n),
      (i.widgetHeight = Math.max(i.widgetHeight, e)),
      (i.breaks += r),
      (this.writtenTo = this.pos = this.pos + n);
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof vn) && !this.isCovered
      ? this.nodes.push(new vn(0, -1))
      : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let i of this.nodes) i instanceof vn && i.updateHeight(this.oracle, n), (n += i ? i.length : 1);
    return this.nodes;
  }
  static build(e, r, n, i) {
    let s = new Yg(n, e);
    return _t.spans(r, n, i, s, 0), s.finish(n);
  }
}
function h6(t, e, r) {
  let n = new p6();
  return _t.compare(t, e, r, n, 0), n.changes;
}
class p6 {
  constructor() {
    this.changes = [];
  }
  compareRange() {}
  comparePoint(e, r, n, i) {
    (e < r || (n && n.heightRelevant) || (i && i.heightRelevant)) && x0(e, r, this.changes, 5);
  }
}
function f6(t, e) {
  let r = t.getBoundingClientRect(),
    n = t.ownerDocument,
    i = n.defaultView || window,
    s = Math.max(0, r.left),
    o = Math.min(i.innerWidth, r.right),
    l = Math.max(0, r.top),
    c = Math.min(i.innerHeight, r.bottom);
  for (let p = t.parentNode; p && p != n.body; )
    if (p.nodeType == 1) {
      let f = p,
        m = window.getComputedStyle(f);
      if ((f.scrollHeight > f.clientHeight || f.scrollWidth > f.clientWidth) && m.overflow != 'visible') {
        let g = f.getBoundingClientRect();
        (s = Math.max(s, g.left)),
          (o = Math.min(o, g.right)),
          (l = Math.max(l, g.top)),
          (c = p == t.parentNode ? g.bottom : Math.min(c, g.bottom));
      }
      p = m.position == 'absolute' || m.position == 'fixed' ? f.offsetParent : f.parentNode;
    } else if (p.nodeType == 11) p = p.host;
    else break;
  return {
    left: s - r.left,
    right: Math.max(s, o) - r.left,
    top: l - (r.top + e),
    bottom: Math.max(l, c) - (r.top + e),
  };
}
function d6(t, e) {
  let r = t.getBoundingClientRect();
  return { left: 0, right: r.right - r.left, top: e, bottom: r.bottom - (r.top + e) };
}
class rm {
  constructor(e, r, n) {
    (this.from = e), (this.to = r), (this.size = n);
  }
  static same(e, r) {
    if (e.length != r.length) return !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n],
        s = r[n];
      if (i.from != s.from || i.to != s.to || i.size != s.size) return !1;
    }
    return !0;
  }
  draw(e, r) {
    return it.replace({ widget: new m6(this.size * (r ? e.scaleY : e.scaleX), r) }).range(this.from, this.to);
  }
}
class m6 extends gs {
  constructor(e, r) {
    super(), (this.size = e), (this.vertical = r);
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement('div');
    return (
      this.vertical
        ? (e.style.height = this.size + 'px')
        : ((e.style.width = this.size + 'px'), (e.style.height = '2px'), (e.style.display = 'inline-block')),
      e
    );
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class lx {
  constructor(e) {
    (this.state = e),
      (this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }),
      (this.inView = !0),
      (this.paddingTop = 0),
      (this.paddingBottom = 0),
      (this.contentDOMWidth = 0),
      (this.contentDOMHeight = 0),
      (this.editorHeight = 0),
      (this.editorWidth = 0),
      (this.scrollTop = 0),
      (this.scrolledToBottom = !0),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.scrollAnchorPos = 0),
      (this.scrollAnchorHeight = -1),
      (this.scaler = ux),
      (this.scrollTarget = null),
      (this.printing = !1),
      (this.mustMeasureContent = !0),
      (this.defaultTextDirection = rr.LTR),
      (this.visibleRanges = []),
      (this.mustEnforceCursorAssoc = !1);
    let r = e.facet(Xg).some((n) => typeof n != 'function' && n.class == 'cm-lineWrapping');
    (this.heightOracle = new a6(r)),
      (this.stateDeco = e.facet(Wu).filter((n) => typeof n != 'function')),
      (this.heightMap = un
        .empty()
        .applyChanges(this.stateDeco, Ot.empty, this.heightOracle.setDoc(e.doc), [new zn(0, 0, 0, e.doc.length)])),
      (this.viewport = this.getViewport(0, null)),
      this.updateViewportLines(),
      this.updateForViewport(),
      (this.lineGaps = this.ensureLineGaps([])),
      (this.lineGapDeco = it.set(this.lineGaps.map((n) => n.draw(this, !1)))),
      this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport],
      { main: r } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let i = n ? r.head : r.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new Dh(s, o));
      }
    }
    (this.viewports = e.sort((n, i) => n.from - i.from)),
      (this.scaler = this.heightMap.height <= 7e6 ? ux : new D6(this.heightOracle, this.heightMap, this.viewports));
  }
  updateViewportLines() {
    (this.viewportLines = []),
      this.heightMap.forEachLine(
        this.viewport.from,
        this.viewport.to,
        this.heightOracle.setDoc(this.state.doc),
        0,
        0,
        (e) => {
          this.viewportLines.push(this.scaler.scale == 1 ? e : cu(e, this.scaler));
        },
      );
  }
  update(e, r = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(Wu).filter((f) => typeof f != 'function');
    let i = e.changedRanges,
      s = zn.extendWithRanges(i, h6(n, this.stateDeco, e ? e.changes : Cr.empty(this.state.doc.length))),
      o = this.heightMap.height,
      l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    (this.heightMap = this.heightMap.applyChanges(
      this.stateDeco,
      e.startState.doc,
      this.heightOracle.setDoc(this.state.doc),
      s,
    )),
      this.heightMap.height != o && (e.flags |= 2),
      l
        ? ((this.scrollAnchorPos = e.changes.mapPos(l.from, -1)), (this.scrollAnchorHeight = l.top))
        : ((this.scrollAnchorPos = -1), (this.scrollAnchorHeight = this.heightMap.height));
    let c = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    ((r && (r.range.head < c.from || r.range.head > c.to)) || !this.viewportIsAppropriate(c)) &&
      (c = this.getViewport(0, r));
    let p = !e.changes.empty || e.flags & 2 || c.from != this.viewport.from || c.to != this.viewport.to;
    (this.viewport = c),
      this.updateForViewport(),
      p && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))),
      (e.flags |= this.computeVisibleRanges()),
      r && (this.scrollTarget = r),
      !this.mustEnforceCursorAssoc &&
        e.selectionSet &&
        e.view.lineWrapping &&
        e.state.selection.main.empty &&
        e.state.selection.main.assoc &&
        !e.state.facet(dE) &&
        (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM,
      n = window.getComputedStyle(r),
      i = this.heightOracle,
      s = n.whiteSpace;
    this.defaultTextDirection = n.direction == 'rtl' ? rr.RTL : rr.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s),
      l = r.getBoundingClientRect(),
      c = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    (this.contentDOMHeight = l.height), (this.mustMeasureContent = !1);
    let p = 0,
      f = 0;
    if (l.width && l.height) {
      let j = l.width / r.offsetWidth,
        $ = l.height / r.offsetHeight;
      ((j > 0.995 && j < 1.005) || !isFinite(j) || Math.abs(l.width - r.offsetWidth) < 1) && (j = 1),
        (($ > 0.995 && $ < 1.005) || !isFinite($) || Math.abs(l.height - r.offsetHeight) < 1) && ($ = 1),
        (this.scaleX != j || this.scaleY != $) && ((this.scaleX = j), (this.scaleY = $), (p |= 8), (o = c = !0));
    }
    let m = (parseInt(n.paddingTop) || 0) * this.scaleY,
      g = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != m || this.paddingBottom != g) && ((this.paddingTop = m), (this.paddingBottom = g), (p |= 10)),
      this.editorWidth != e.scrollDOM.clientWidth &&
        (i.lineWrapping && (c = !0), (this.editorWidth = e.scrollDOM.clientWidth), (p |= 8));
    let x = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != x && ((this.scrollAnchorHeight = -1), (this.scrollTop = x)),
      (this.scrolledToBottom = YA(e.scrollDOM));
    let b = (this.printing ? d6 : f6)(r, this.paddingTop),
      F = b.top - this.pixelViewport.top,
      E = b.bottom - this.pixelViewport.bottom;
    this.pixelViewport = b;
    let w = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if ((w != this.inView && ((this.inView = w), w && (c = !0)), !this.inView && !this.scrollTarget)) return 0;
    let I = l.width;
    if (
      ((this.contentDOMWidth != I || this.editorHeight != e.scrollDOM.clientHeight) &&
        ((this.contentDOMWidth = l.width), (this.editorHeight = e.scrollDOM.clientHeight), (p |= 8)),
      c)
    ) {
      let j = e.docView.measureVisibleLineHeights(this.viewport);
      if (
        (i.mustRefreshForHeights(j) && (o = !0),
        o || (i.lineWrapping && Math.abs(I - this.contentDOMWidth) > i.charWidth))
      ) {
        let { lineHeight: $, charWidth: L, textHeight: se } = e.docView.measureTextSize();
        (o = $ > 0 && i.refresh(s, $, L, se, I / L, j)), o && ((e.docView.minWidth = 0), (p |= 8));
      }
      F > 0 && E > 0 ? (f = Math.max(F, E)) : F < 0 && E < 0 && (f = Math.min(F, E)), (i.heightChanged = !1);
      for (let $ of this.viewports) {
        let L = $.from == this.viewport.from ? j : e.docView.measureVisibleLineHeights($);
        this.heightMap = (
          o
            ? un
                .empty()
                .applyChanges(this.stateDeco, Ot.empty, this.heightOracle, [new zn(0, 0, 0, e.state.doc.length)])
            : this.heightMap
        ).updateHeight(i, 0, o, new l6($.from, L));
      }
      i.heightChanged && (p |= 2);
    }
    let T =
      !this.viewportIsAppropriate(this.viewport, f) ||
      (this.scrollTarget &&
        (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to));
    return (
      T && (this.viewport = this.getViewport(f, this.scrollTarget)),
      this.updateForViewport(),
      (p & 2 || T) && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)),
      (p |= this.computeVisibleRanges()),
      this.mustEnforceCursorAssoc && ((this.mustEnforceCursorAssoc = !1), e.docView.enforceCursorAssoc()),
      p
    );
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)),
      i = this.heightMap,
      s = this.heightOracle,
      { visibleTop: o, visibleBottom: l } = this,
      c = new Dh(
        i.lineAt(o - n * 1e3, Kt.ByHeight, s, 0, 0).from,
        i.lineAt(l + (1 - n) * 1e3, Kt.ByHeight, s, 0, 0).to,
      );
    if (r) {
      let { head: p } = r.range;
      if (p < c.from || p > c.to) {
        let f = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top),
          m = i.lineAt(p, Kt.ByPos, s, 0, 0),
          g;
        r.y == 'center'
          ? (g = (m.top + m.bottom) / 2 - f / 2)
          : r.y == 'start' || (r.y == 'nearest' && p < c.from)
          ? (g = m.top)
          : (g = m.bottom - f),
          (c = new Dh(
            i.lineAt(g - 1e3 / 2, Kt.ByHeight, s, 0, 0).from,
            i.lineAt(g + f + 1e3 / 2, Kt.ByHeight, s, 0, 0).to,
          ));
      }
    }
    return c;
  }
  mapViewport(e, r) {
    let n = r.mapPos(e.from, -1),
      i = r.mapPos(e.to, 1);
    return new Dh(
      this.heightMap.lineAt(n, Kt.ByPos, this.heightOracle, 0, 0).from,
      this.heightMap.lineAt(i, Kt.ByPos, this.heightOracle, 0, 0).to,
    );
  }
  viewportIsAppropriate({ from: e, to: r }, n = 0) {
    if (!this.inView) return !0;
    let { top: i } = this.heightMap.lineAt(e, Kt.ByPos, this.heightOracle, 0, 0),
      { bottom: s } = this.heightMap.lineAt(r, Kt.ByPos, this.heightOracle, 0, 0),
      { visibleTop: o, visibleBottom: l } = this;
    return (
      (e == 0 || i <= o - Math.max(10, Math.min(-n, 250))) &&
      (r == this.state.doc.length || s >= l + Math.max(10, Math.min(n, 250))) &&
      i > o - 2 * 1e3 &&
      s < l + 2 * 1e3
    );
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty) return e;
    let n = [];
    for (let i of e) r.touchesRange(i.from, i.to) || n.push(new rm(r.mapPos(i.from), r.mapPos(i.to), i.size));
    return n;
  }
  ensureLineGaps(e, r) {
    let n = this.heightOracle.lineWrapping,
      i = n ? 1e4 : 2e3,
      s = i >> 1,
      o = i << 1;
    if (this.defaultTextDirection != rr.LTR && !n) return [];
    let l = [],
      c = (p, f, m, g) => {
        if (f - p < s) return;
        let x = this.state.selection.main,
          b = [x.from];
        x.empty || b.push(x.to);
        for (let E of b)
          if (E > p && E < f) {
            c(p, E - 10, m, g), c(E + 10, f, m, g);
            return;
          }
        let F = y6(
          e,
          (E) =>
            E.from >= m.from &&
            E.to <= m.to &&
            Math.abs(E.from - p) < s &&
            Math.abs(E.to - f) < s &&
            !b.some((w) => E.from < w && E.to > w),
        );
        if (!F) {
          if (f < m.to && r && n && r.visibleRanges.some((E) => E.from <= f && E.to >= f)) {
            let E = r.moveToLineBoundary(pe.cursor(f), !1, !0).head;
            E > p && (f = E);
          }
          F = new rm(p, f, this.gapSize(m, p, f, g));
        }
        l.push(F);
      };
    for (let p of this.viewportLines) {
      if (p.length < o) continue;
      let f = g6(p.from, p.to, this.stateDeco);
      if (f.total < o) continue;
      let m = this.scrollTarget ? this.scrollTarget.range.head : null,
        g,
        x;
      if (n) {
        let b = (i / this.heightOracle.lineLength) * this.heightOracle.lineHeight,
          F,
          E;
        if (m != null) {
          let w = Ch(f, m),
            I = ((this.visibleBottom - this.visibleTop) / 2 + b) / p.height;
          (F = w - I), (E = w + I);
        } else (F = (this.visibleTop - p.top - b) / p.height), (E = (this.visibleBottom - p.top + b) / p.height);
        (g = xh(f, F)), (x = xh(f, E));
      } else {
        let b = f.total * this.heightOracle.charWidth,
          F = i * this.heightOracle.charWidth,
          E,
          w;
        if (m != null) {
          let I = Ch(f, m),
            T = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + F) / b;
          (E = I - T), (w = I + T);
        } else (E = (this.pixelViewport.left - F) / b), (w = (this.pixelViewport.right + F) / b);
        (g = xh(f, E)), (x = xh(f, w));
      }
      g > p.from && c(p.from, g, p, f), x < p.to && c(x, p.to, p, f);
    }
    return l;
  }
  gapSize(e, r, n, i) {
    let s = Ch(i, n) - Ch(i, r);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    rm.same(e, this.lineGaps) ||
      ((this.lineGaps = e), (this.lineGapDeco = it.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping)))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let r = [];
    _t.spans(
      e,
      this.viewport.from,
      this.viewport.to,
      {
        span(i, s) {
          r.push({ from: i, to: s });
        },
        point() {},
      },
      20,
    );
    let n =
      r.length != this.visibleRanges.length ||
      this.visibleRanges.some((i, s) => i.from != r[s].from || i.to != r[s].to);
    return (this.visibleRanges = r), n ? 4 : 0;
  }
  lineBlockAt(e) {
    return (
      (e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e)) ||
      cu(this.heightMap.lineAt(e, Kt.ByPos, this.heightOracle, 0, 0), this.scaler)
    );
  }
  lineBlockAtHeight(e) {
    return cu(this.heightMap.lineAt(this.scaler.fromDOM(e), Kt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return cu(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Dh {
  constructor(e, r) {
    (this.from = e), (this.to = r);
  }
}
function g6(t, e, r) {
  let n = [],
    i = t,
    s = 0;
  return (
    _t.spans(
      r,
      t,
      e,
      {
        span() {},
        point(o, l) {
          o > i && (n.push({ from: i, to: o }), (s += o - i)), (i = l);
        },
      },
      20,
    ),
    i < e && (n.push({ from: i, to: e }), (s += e - i)),
    { total: s, ranges: n }
  );
}
function xh({ total: t, ranges: e }, r) {
  if (r <= 0) return e[0].from;
  if (r >= 1) return e[e.length - 1].to;
  let n = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i],
      l = o - s;
    if (n <= l) return s + n;
    n -= l;
  }
}
function Ch(t, e) {
  let r = 0;
  for (let { from: n, to: i } of t.ranges) {
    if (e <= i) {
      r += e - n;
      break;
    }
    r += i - n;
  }
  return r / t.total;
}
function y6(t, e) {
  for (let r of t) if (e(r)) return r;
}
const ux = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
};
class D6 {
  constructor(e, r, n) {
    let i = 0,
      s = 0,
      o = 0;
    (this.viewports = n.map(({ from: l, to: c }) => {
      let p = r.lineAt(l, Kt.ByPos, e, 0, 0).top,
        f = r.lineAt(c, Kt.ByPos, e, 0, 0).bottom;
      return (i += f - p), { from: l, to: c, top: p, bottom: f, domTop: 0, domBottom: 0 };
    })),
      (this.scale = (7e6 - i) / (r.height - i));
    for (let l of this.viewports)
      (l.domTop = o + (l.top - s) * this.scale), (o = l.domBottom = l.domTop + (l.bottom - l.top)), (s = l.bottom);
  }
  toDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.top) return i + (e - n) * this.scale;
      if (e <= s.bottom) return s.domTop + (e - s.top);
      (n = s.bottom), (i = s.domBottom);
    }
  }
  fromDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.domTop) return n + (e - i) / this.scale;
      if (e <= s.domBottom) return s.top + (e - s.domTop);
      (n = s.bottom), (i = s.domBottom);
    }
  }
}
function cu(t, e) {
  if (e.scale == 1) return t;
  let r = e.toDOM(t.top),
    n = e.toDOM(t.bottom);
  return new Ii(t.from, t.length, r, n - r, Array.isArray(t._content) ? t._content.map((i) => cu(i, e)) : t._content);
}
const bh = Ue.define({ combine: (t) => t.join(' ') }),
  w0 = Ue.define({ combine: (t) => t.indexOf(!0) > -1 }),
  T0 = io.newName(),
  _E = io.newName(),
  RE = io.newName(),
  jE = { '&light': '.' + _E, '&dark': '.' + RE };
function k0(t, e, r) {
  return new io(e, {
    finish(n) {
      return /&/.test(n)
        ? n.replace(/&\w*/, (i) => {
            if (i == '&') return t;
            if (!r || !r[i]) throw new RangeError(`Unsupported selector: ${i}`);
            return r[i];
          })
        : t + ' ' + n;
    },
  });
}
const x6 = k0(
    '.' + T0,
    {
      '&': {
        'position': 'relative !important',
        'boxSizing': 'border-box',
        '&.cm-focused': { outline: '1px dotted #212121' },
        'display': 'flex !important',
        'flexDirection': 'column',
      },
      '.cm-scroller': {
        display: 'flex !important',
        alignItems: 'flex-start !important',
        fontFamily: 'monospace',
        lineHeight: 1.4,
        height: '100%',
        overflowX: 'auto',
        position: 'relative',
        zIndex: 0,
      },
      '.cm-content': {
        'margin': 0,
        'flexGrow': 2,
        'flexShrink': 0,
        'display': 'block',
        'whiteSpace': 'pre',
        'wordWrap': 'normal',
        'boxSizing': 'border-box',
        'padding': '4px 0',
        'outline': 'none',
        '&[contenteditable=true]': { WebkitUserModify: 'read-write-plaintext-only' },
      },
      '.cm-lineWrapping': {
        whiteSpace_fallback: 'pre-wrap',
        whiteSpace: 'break-spaces',
        wordBreak: 'break-word',
        overflowWrap: 'anywhere',
        flexShrink: 1,
      },
      '&light .cm-content': { caretColor: 'black' },
      '&dark .cm-content': { caretColor: 'white' },
      '.cm-line': { display: 'block', padding: '0 2px 0 6px' },
      '.cm-layer': {
        'position': 'absolute',
        'left': 0,
        'top': 0,
        'contain': 'size style',
        '& > *': { position: 'absolute' },
      },
      '&light .cm-selectionBackground': { background: '#d9d9d9' },
      '&dark .cm-selectionBackground': { background: '#222' },
      '&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': { background: '#d7d4f0' },
      '&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': { background: '#233' },
      '.cm-cursorLayer': { pointerEvents: 'none' },
      '&.cm-focused > .cm-scroller > .cm-cursorLayer': { animation: 'steps(1) cm-blink 1.2s infinite' },
      '@keyframes cm-blink': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
      '@keyframes cm-blink2': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
      '.cm-cursor, .cm-dropCursor': { borderLeft: '1.2px solid black', marginLeft: '-0.6px', pointerEvents: 'none' },
      '.cm-cursor': { display: 'none' },
      '&dark .cm-cursor': { borderLeftColor: '#444' },
      '.cm-dropCursor': { position: 'absolute' },
      '&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor': { display: 'block' },
      '&light .cm-activeLine': { backgroundColor: '#cceeff44' },
      '&dark .cm-activeLine': { backgroundColor: '#99eeff33' },
      '&light .cm-specialChar': { color: 'red' },
      '&dark .cm-specialChar': { color: '#f78' },
      '.cm-gutters': {
        flexShrink: 0,
        display: 'flex',
        height: '100%',
        boxSizing: 'border-box',
        insetInlineStart: 0,
        zIndex: 200,
      },
      '&light .cm-gutters': { backgroundColor: '#f5f5f5', color: '#6c6c6c', borderRight: '1px solid #ddd' },
      '&dark .cm-gutters': { backgroundColor: '#333338', color: '#ccc' },
      '.cm-gutter': {
        display: 'flex !important',
        flexDirection: 'column',
        flexShrink: 0,
        boxSizing: 'border-box',
        minHeight: '100%',
        overflow: 'hidden',
      },
      '.cm-gutterElement': { boxSizing: 'border-box' },
      '.cm-lineNumbers .cm-gutterElement': {
        padding: '0 3px 0 5px',
        minWidth: '20px',
        textAlign: 'right',
        whiteSpace: 'nowrap',
      },
      '&light .cm-activeLineGutter': { backgroundColor: '#e2f2ff' },
      '&dark .cm-activeLineGutter': { backgroundColor: '#222227' },
      '.cm-panels': { boxSizing: 'border-box', position: 'sticky', left: 0, right: 0 },
      '&light .cm-panels': { backgroundColor: '#f5f5f5', color: 'black' },
      '&light .cm-panels-top': { borderBottom: '1px solid #ddd' },
      '&light .cm-panels-bottom': { borderTop: '1px solid #ddd' },
      '&dark .cm-panels': { backgroundColor: '#333338', color: 'white' },
      '.cm-tab': { display: 'inline-block', overflow: 'hidden', verticalAlign: 'bottom' },
      '.cm-widgetBuffer': { verticalAlign: 'text-top', height: '1em', width: 0, display: 'inline' },
      '.cm-placeholder': { color: '#888', display: 'inline-block', verticalAlign: 'top' },
      '.cm-highlightSpace:before': {
        content: 'attr(data-display)',
        position: 'absolute',
        pointerEvents: 'none',
        color: '#888',
      },
      '.cm-highlightTab': {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: 'auto 100%',
        backgroundPosition: 'right 90%',
        backgroundRepeat: 'no-repeat',
      },
      '.cm-trailingSpace': { backgroundColor: '#ff332255' },
      '.cm-button': {
        verticalAlign: 'middle',
        color: 'inherit',
        fontSize: '70%',
        padding: '.2em 1em',
        borderRadius: '1px',
      },
      '&light .cm-button': {
        'backgroundImage': 'linear-gradient(#eff1f5, #d9d9df)',
        'border': '1px solid #888',
        '&:active': { backgroundImage: 'linear-gradient(#b4b4b4, #d0d3d6)' },
      },
      '&dark .cm-button': {
        'backgroundImage': 'linear-gradient(#393939, #111)',
        'border': '1px solid #888',
        '&:active': { backgroundImage: 'linear-gradient(#111, #333)' },
      },
      '.cm-textfield': {
        verticalAlign: 'middle',
        color: 'inherit',
        fontSize: '70%',
        border: '1px solid silver',
        padding: '.2em .5em',
      },
      '&light .cm-textfield': { backgroundColor: 'white' },
      '&dark .cm-textfield': { border: '1px solid #555', backgroundColor: 'inherit' },
    },
    jE,
  ),
  hu = '￿';
class C6 {
  constructor(e, r) {
    (this.points = e), (this.text = ''), (this.lineSeparator = r.facet(Ct.lineSeparator));
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += hu;
  }
  readRange(e, r) {
    if (!e) return this;
    let n = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(n, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == r) break;
      let l = Xt.get(i),
        c = Xt.get(o);
      (l && c
        ? l.breakAfter
        : (l ? l.breakAfter : cx(i)) || (cx(o) && (i.nodeName != 'BR' || i.cmIgnore) && this.text.length > s)) &&
        this.lineBreak(),
        (i = o);
    }
    return this.findPointBefore(n, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let n of this.points) n.node == e && (n.pos = this.text.length + Math.min(n.offset, r.length));
    for (let n = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1,
        o = 1,
        l;
      if (
        (this.lineSeparator
          ? ((s = r.indexOf(this.lineSeparator, n)), (o = this.lineSeparator.length))
          : (l = i.exec(r)) && ((s = l.index), (o = l[0].length)),
        this.append(r.slice(n, s < 0 ? r.length : s)),
        s < 0)
      )
        break;
      if ((this.lineBreak(), o > 1))
        for (let c of this.points) c.node == e && c.pos > this.text.length && (c.pos -= o - 1);
      n = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore) return;
    let r = Xt.get(e),
      n = r && r.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let i = n.iter(); !i.next().done; ) i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3
        ? this.readTextNode(e)
        : e.nodeName == 'BR'
        ? e.nextSibling && this.lineBreak()
        : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let n of this.points) n.node == e && e.childNodes[n.offset] == r && (n.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) &&
        (n.pos = this.text.length + (b6(e, n.node, n.offset) ? r : 0));
  }
}
function b6(t, e, r) {
  for (;;) {
    if (!e || r < os(e)) return !1;
    if (e == t) return !0;
    (r = Hu(e) + 1), (e = e.parentNode);
  }
}
function cx(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class hx {
  constructor(e, r) {
    (this.node = e), (this.offset = r), (this.pos = -1);
  }
}
class A6 {
  constructor(e, r, n, i) {
    (this.typeOver = i), (this.bounds = null), (this.text = '');
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && r > -1) this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, n, 0))) {
      let l = s || o ? [] : F6(e),
        c = new C6(l, e.state);
      c.readRange(this.bounds.startDOM, this.bounds.endDOM),
        (this.text = c.text),
        (this.newSel = S6(l, this.bounds.from));
    } else {
      let l = e.observer.selectionRange,
        c =
          (s && s.node == l.focusNode && s.offset == l.focusOffset) || !f0(e.contentDOM, l.focusNode)
            ? e.state.selection.main.head
            : e.docView.posFromDOM(l.focusNode, l.focusOffset),
        p =
          (o && o.node == l.anchorNode && o.offset == l.anchorOffset) || !f0(e.contentDOM, l.anchorNode)
            ? e.state.selection.main.anchor
            : e.docView.posFromDOM(l.anchorNode, l.anchorOffset);
      this.newSel = pe.single(p, c);
    }
  }
}
function $E(t, e) {
  let r,
    { newSel: n } = e,
    i = t.state.selection.main,
    s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds,
      c = i.from,
      p = null;
    (s === 8 || (Je.android && e.text.length < l - o)) && ((c = i.to), (p = 'end'));
    let f = v6(t.state.doc.sliceString(o, l, hu), e.text, c - o, p);
    f &&
      (Je.chrome && s == 13 && f.toB == f.from + 2 && e.text.slice(f.from, f.toB) == hu + hu && f.toB--,
      (r = { from: o + f.from, to: o + f.toA, insert: Ot.of(e.text.slice(f.from, f.toB).split(hu)) }));
  } else n && ((!t.hasFocus && t.state.facet(Af)) || n.main.eq(i)) && (n = null);
  if (!r && !n) return !1;
  if (
    (!r && e.typeOver && !i.empty && n && n.main.empty
      ? (r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) })
      : r &&
        r.from >= i.from &&
        r.to <= i.to &&
        (r.from != i.from || r.to != i.to) &&
        i.to - i.from - (r.to - r.from) <= 4
      ? (r = {
          from: i.from,
          to: i.to,
          insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to)),
        })
      : (Je.mac || Je.android) &&
        r &&
        r.from == r.to &&
        r.from == i.head - 1 &&
        /^\. ?$/.test(r.insert.toString()) &&
        t.contentDOM.getAttribute('autocorrect') == 'off'
      ? (n && r.insert.length == 2 && (n = pe.single(n.main.anchor - 1, n.main.head - 1)),
        (r = { from: i.from, to: i.to, insert: Ot.of([' ']) }))
      : Je.chrome &&
        r &&
        r.from == r.to &&
        r.from == i.head &&
        r.insert.toString() ==
          `
 ` &&
        t.lineWrapping &&
        (n && (n = pe.single(n.main.anchor - 1, n.main.head - 1)),
        (r = { from: i.from, to: i.to, insert: Ot.of([' ']) })),
    r)
  ) {
    if (
      (Je.ios && t.inputState.flushIOSKey()) ||
      (Je.android &&
        ((r.from == i.from &&
          r.to == i.to &&
          r.insert.length == 1 &&
          r.insert.lines == 2 &&
          Xa(t.contentDOM, 'Enter', 13)) ||
          (((r.from == i.from - 1 && r.to == i.to && r.insert.length == 0) ||
            (s == 8 && r.insert.length < r.to - r.from && r.to > i.head)) &&
            Xa(t.contentDOM, 'Backspace', 8)) ||
          (r.from == i.from && r.to == i.to + 1 && r.insert.length == 0 && Xa(t.contentDOM, 'Delete', 46))))
    )
      return !0;
    let o = r.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let l,
      c = () => l || (l = E6(t, r, n));
    return t.state.facet(hE).some((p) => p(t, r.from, r.to, o, c)) || t.dispatch(c()), !0;
  } else if (n && !n.main.eq(i)) {
    let o = !1,
      l = 'select';
    return (
      t.inputState.lastSelectionTime > Date.now() - 50 &&
        (t.inputState.lastSelectionOrigin == 'select' && (o = !0), (l = t.inputState.lastSelectionOrigin)),
      t.dispatch({ selection: n, scrollIntoView: o, userEvent: l }),
      !0
    );
  } else return !1;
}
function E6(t, e, r) {
  let n,
    i = t.state,
    s = i.selection.main;
  if (
    e.from >= s.from &&
    e.to <= s.to &&
    e.to - e.from >= (s.to - s.from) / 3 &&
    (!r || (r.main.empty && r.main.from == e.from + e.insert.length)) &&
    t.inputState.composing < 0
  ) {
    let l = s.from < e.from ? i.sliceDoc(s.from, e.from) : '',
      c = s.to > e.to ? i.sliceDoc(e.to, s.to) : '';
    n = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + c));
  } else {
    let l = i.changes(e),
      c = r && r.main.to <= l.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let p = t.state.sliceDoc(e.from, e.to),
        f,
        m = r && vE(t, r.main.head);
      if (m) {
        let b = e.insert.length - (e.to - e.from);
        f = { from: m.from, to: m.to - b };
      } else f = t.state.doc.lineAt(s.head);
      let g = s.to - e.to,
        x = s.to - s.from;
      n = i.changeByRange((b) => {
        if (b.from == s.from && b.to == s.to) return { changes: l, range: c || b.map(l) };
        let F = b.to - g,
          E = F - p.length;
        if (b.to - b.from != x || t.state.sliceDoc(E, F) != p || (b.to >= f.from && b.from <= f.to))
          return { range: b };
        let w = i.changes({ from: E, to: F, insert: e.insert }),
          I = b.to - s.to;
        return { changes: w, range: c ? pe.range(Math.max(0, c.anchor + I), Math.max(0, c.head + I)) : b.map(w) };
      });
    } else n = { changes: l, selection: c && i.selection.replaceRange(c) };
  }
  let o = 'input.type';
  return (
    (t.composing || (t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50)) &&
      ((t.inputState.compositionPendingChange = !1),
      (o += '.compose'),
      t.inputState.compositionFirstChange && ((o += '.start'), (t.inputState.compositionFirstChange = !1))),
    i.update(n, { userEvent: o, scrollIntoView: !0 })
  );
}
function v6(t, e, r, n) {
  let i = Math.min(t.length, e.length),
    s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); ) s++;
  if (s == i && t.length == e.length) return null;
  let o = t.length,
    l = e.length;
  for (; o > 0 && l > 0 && t.charCodeAt(o - 1) == e.charCodeAt(l - 1); ) o--, l--;
  if (n == 'end') {
    let c = Math.max(0, s - Math.min(o, l));
    r -= o + c - s;
  }
  if (o < s && t.length < e.length) {
    let c = r <= s && r >= o ? s - r : 0;
    (s -= c), (l = s + (l - o)), (o = s);
  } else if (l < s) {
    let c = r <= s && r >= l ? s - r : 0;
    (s -= c), (o = s + (o - l)), (l = s);
  }
  return { from: s, toA: o, toB: l };
}
function F6(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM) return e;
  let { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return r && (e.push(new hx(r, n)), (i != r || s != n) && e.push(new hx(i, s))), e;
}
function S6(t, e) {
  if (t.length == 0) return null;
  let r = t[0].pos,
    n = t.length == 2 ? t[1].pos : r;
  return r > -1 && n > -1 ? pe.single(r + e, n + e) : null;
}
const w6 = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 },
  nm = Je.ie && Je.ie_version <= 11;
class T6 {
  constructor(e) {
    (this.view = e),
      (this.active = !1),
      (this.selectionRange = new h4()),
      (this.selectionChanged = !1),
      (this.delayedFlush = -1),
      (this.resizeTimeout = -1),
      (this.queue = []),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1),
      (this.lastChange = 0),
      (this.scrollTargets = []),
      (this.intersection = null),
      (this.resizeScroll = null),
      (this.resizeContent = null),
      (this.intersecting = !1),
      (this.gapIntersection = null),
      (this.gaps = []),
      (this.parentCheck = -1),
      (this.dom = e.contentDOM),
      (this.observer = new MutationObserver((r) => {
        for (let n of r) this.queue.push(n);
        ((Je.ie && Je.ie_version <= 11) || (Je.ios && e.composing)) &&
        r.some(
          (n) =>
            (n.type == 'childList' && n.removedNodes.length) ||
            (n.type == 'characterData' && n.oldValue.length > n.target.nodeValue.length),
        )
          ? this.flushSoon()
          : this.flush();
      })),
      nm &&
        (this.onCharData = (r) => {
          this.queue.push({ target: r.target, type: 'characterData', oldValue: r.prevValue }), this.flushSoon();
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this)),
      (this.onResize = this.onResize.bind(this)),
      (this.onPrint = this.onPrint.bind(this)),
      (this.onScroll = this.onScroll.bind(this)),
      typeof ResizeObserver == 'function' &&
        ((this.resizeScroll = new ResizeObserver(() => {
          var r;
          ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 &&
            this.onResize();
        })),
        this.resizeScroll.observe(e.scrollDOM),
        (this.resizeContent = new ResizeObserver(() => this.view.requestMeasure())),
        this.resizeContent.observe(e.contentDOM)),
      this.addWindowListeners((this.win = e.win)),
      this.start(),
      typeof IntersectionObserver == 'function' &&
        ((this.intersection = new IntersectionObserver(
          (r) => {
            this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)),
              r.length > 0 &&
                r[r.length - 1].intersectionRatio > 0 != this.intersecting &&
                ((this.intersecting = !this.intersecting),
                this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent('Event')));
          },
          { threshold: [0, 0.001] },
        )),
        this.intersection.observe(this.dom),
        (this.gapIntersection = new IntersectionObserver((r) => {
          r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent('Event'));
        }, {}))),
      this.listenForScroll(),
      this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers('scroll', e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 &&
      (this.resizeTimeout = setTimeout(() => {
        (this.resizeTimeout = -1), this.view.requestMeasure();
      }, 50));
  }
  onPrint() {
    (this.view.viewState.printing = !0),
      this.view.measure(),
      setTimeout(() => {
        (this.view.viewState.printing = !1), this.view.requestMeasure();
      }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, n) => r != e[n]))) {
      this.gapIntersection.disconnect();
      for (let r of e) this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: n } = this,
      i = this.selectionRange;
    if (n.state.facet(Af) ? n.root.activeElement != this.dom : !Jh(n.dom, i)) return;
    let s = i.anchorNode && n.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    ((Je.ie && Je.ie_version <= 11) || (Je.android && Je.chrome)) &&
    !n.state.selection.main.empty &&
    i.focusNode &&
    mp(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset)
      ? this.flushSoon()
      : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this,
      r = (Je.safari && e.root.nodeType == 11 && a4(this.dom.ownerDocument) == this.dom && k6(this.view)) || dp(e.root);
    if (!r || this.selectionRange.eq(r)) return !1;
    let n = Jh(this.dom, r);
    return n &&
      !this.selectionChanged &&
      e.inputState.lastFocusTime > Date.now() - 200 &&
      e.inputState.lastTouchTime < Date.now() - 300 &&
      f4(this.dom, r)
      ? ((this.view.inputState.lastFocusTime = 0), e.docView.updateSelection(), !1)
      : (this.selectionRange.setRange(r), n && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), (this.selectionChanged = !1);
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0,
      r = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == n
          ? e++
          : r || (r = this.scrollTargets.slice(0, e)),
          r && r.push(n),
          (n = n.assignedSlot || n.parentNode);
      else if (n.nodeType == 11) n = n.host;
      else break;
    if ((e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r)) {
      for (let n of this.scrollTargets) n.removeEventListener('scroll', this.onScroll);
      for (let n of (this.scrollTargets = r)) n.addEventListener('scroll', this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active) return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active ||
      (this.observer.observe(this.dom, w6),
      nm && this.dom.addEventListener('DOMCharacterDataModified', this.onCharData),
      (this.active = !0));
  }
  stop() {
    this.active &&
      ((this.active = !1),
      this.observer.disconnect(),
      nm && this.dom.removeEventListener('DOMCharacterDataModified', this.onCharData));
  }
  clear() {
    this.processRecords(), (this.queue.length = 0), (this.selectionChanged = !1);
  }
  delayAndroidKey(e, r) {
    var n;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s &&
          (this.clearDelayedAndroidKey(),
          (this.view.inputState.lastKeyCode = s.keyCode),
          (this.view.inputState.lastKeyTime = Date.now()),
          !this.flush() && s.force && Xa(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == 'Enter') &&
      (this.delayedAndroidKey = {
        key: e,
        keyCode: r,
        force:
          this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force),
      });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1);
  }
  flushSoon() {
    this.delayedFlush < 0 &&
      (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        (this.delayedFlush = -1), this.flush();
      }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), (this.delayedFlush = -1)),
      this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords()) this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1,
      n = -1,
      i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o &&
        (o.typeOver && (i = !0),
        r == -1 ? ({ from: r, to: n } = o) : ((r = Math.min(o.from, r)), (n = Math.max(o.to, n))));
    }
    return { from: r, to: n, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: n } = this.processRecords(),
      i = this.selectionChanged && Jh(this.dom, this.selectionRange);
    if (e < 0 && !i) return null;
    e > -1 && (this.lastChange = Date.now()), (this.view.inputState.lastFocusTime = 0), (this.selectionChanged = !1);
    let s = new A6(this.view, e, r, n);
    return (this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }), s;
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r) return !1;
    let n = this.view.state,
      i = $E(this.view, r);
    return this.view.state == n && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e)) return null;
    if ((r.markDirty(e.type == 'attributes'), e.type == 'attributes' && (r.flags |= 4), e.type == 'childList')) {
      let n = px(r, e.previousSibling || e.target.previousSibling, -1),
        i = px(r, e.nextSibling || e.target.nextSibling, 1);
      return { from: n ? r.posAfter(n) : r.posAtStart, to: i ? r.posBefore(i) : r.posAtEnd, typeOver: !1 };
    } else
      return e.type == 'characterData'
        ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }
        : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), (this.win = e), this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener('resize', this.onResize),
      e.addEventListener('beforeprint', this.onPrint),
      e.addEventListener('scroll', this.onScroll),
      e.document.addEventListener('selectionchange', this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener('scroll', this.onScroll),
      e.removeEventListener('resize', this.onResize),
      e.removeEventListener('beforeprint', this.onPrint),
      e.document.removeEventListener('selectionchange', this.onSelectionChange);
  }
  destroy() {
    var e, r, n, i;
    this.stop(),
      (e = this.intersection) === null || e === void 0 || e.disconnect(),
      (r = this.gapIntersection) === null || r === void 0 || r.disconnect(),
      (n = this.resizeScroll) === null || n === void 0 || n.disconnect(),
      (i = this.resizeContent) === null || i === void 0 || i.disconnect();
    for (let s of this.scrollTargets) s.removeEventListener('scroll', this.onScroll);
    this.removeWindowListeners(this.win),
      clearTimeout(this.parentCheck),
      clearTimeout(this.resizeTimeout),
      this.win.cancelAnimationFrame(this.delayedFlush),
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function px(t, e, r) {
  for (; e; ) {
    let n = Xt.get(e);
    if (n && n.parent == t) return n;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function k6(t) {
  let e = null;
  function r(c) {
    c.preventDefault(), c.stopImmediatePropagation(), (e = c.getTargetRanges()[0]);
  }
  if (
    (t.contentDOM.addEventListener('beforeinput', r, !0),
    t.dom.ownerDocument.execCommand('indent'),
    t.contentDOM.removeEventListener('beforeinput', r, !0),
    !e)
  )
    return null;
  let n = e.startContainer,
    i = e.startOffset,
    s = e.endContainer,
    o = e.endOffset,
    l = t.docView.domAtPos(t.state.selection.main.anchor);
  return (
    mp(l.node, l.offset, s, o) && ([n, i, s, o] = [s, o, n, i]),
    { anchorNode: n, anchorOffset: i, focusNode: s, focusOffset: o }
  );
}
class ze {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(e = {}) {
    (this.plugins = []),
      (this.pluginMap = new Map()),
      (this.editorAttrs = {}),
      (this.contentAttrs = {}),
      (this.bidiCache = []),
      (this.destroyed = !1),
      (this.updateState = 2),
      (this.measureScheduled = -1),
      (this.measureRequests = []),
      (this.contentDOM = document.createElement('div')),
      (this.scrollDOM = document.createElement('div')),
      (this.scrollDOM.tabIndex = -1),
      (this.scrollDOM.className = 'cm-scroller'),
      this.scrollDOM.appendChild(this.contentDOM),
      (this.announceDOM = document.createElement('div')),
      (this.announceDOM.style.cssText = 'position: fixed; top: -10000px'),
      this.announceDOM.setAttribute('aria-live', 'polite'),
      (this.dom = document.createElement('div')),
      this.dom.appendChild(this.announceDOM),
      this.dom.appendChild(this.scrollDOM);
    let { dispatch: r } = e;
    (this.dispatchTransactions =
      e.dispatchTransactions || (r && ((n) => n.forEach((i) => r(i, this)))) || ((n) => this.update(n))),
      (this.dispatch = this.dispatch.bind(this)),
      (this._root = e.root || p4(e.parent) || document),
      (this.viewState = new lx(e.state || Ct.create(e))),
      (this.plugins = this.state.facet(lu).map((n) => new Zd(n)));
    for (let n of this.plugins) n.update(this);
    (this.observer = new T6(this)),
      (this.inputState = new W4(this)),
      this.inputState.ensureHandlers(this.plugins),
      (this.docView = new W1(this)),
      this.mountStyles(),
      this.updateAttrs(),
      (this.updateState = 0),
      this.requestMeasure(),
      e.parent && e.parent.appendChild(this.dom);
  }
  dispatch(...e) {
    let r =
      e.length == 1 && e[0] instanceof Ar ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  update(e) {
    if (this.updateState != 0)
      throw new Error('Calls to EditorView.update are not allowed while an update is in progress');
    let r = !1,
      n = !1,
      i,
      s = this.state;
    for (let g of e) {
      if (g.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = g.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus,
      l = 0,
      c = null;
    e.some((g) => g.annotation(NE))
      ? ((this.inputState.notifiedFocused = o), (l = 1))
      : o != this.inputState.notifiedFocused && ((this.inputState.notifiedFocused = o), (c = ME(s, o)), c || (l = 1));
    let p = this.observer.delayedAndroidKey,
      f = null;
    if (
      (p
        ? (this.observer.clearDelayedAndroidKey(),
          (f = this.observer.readChange()),
          ((f && !this.state.doc.eq(s.doc)) || !this.state.selection.eq(s.selection)) && (f = null))
        : this.observer.clear(),
      s.facet(Ct.phrases) != this.state.facet(Ct.phrases))
    )
      return this.setState(s);
    (i = yp.create(this, s, e)), (i.flags |= l);
    let m = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let g of e) {
        if ((m && (m = m.map(g.changes)), g.scrollIntoView)) {
          let { main: x } = g.state.selection;
          m = new gp(x.empty ? x : pe.cursor(x.head, x.head > x.anchor ? -1 : 1));
        }
        for (let x of g.effects) x.is(z1) && (m = x.value);
      }
      this.viewState.update(i, m),
        (this.bidiCache = Dp.update(this.bidiCache, i.changes)),
        i.empty || (this.updatePlugins(i), this.inputState.update(i)),
        (r = this.docView.update(i)),
        this.state.facet(uu) != this.styleModules && this.mountStyles(),
        (n = this.updateAttrs()),
        this.showAnnouncements(e),
        this.docView.updateSelection(
          r,
          e.some((g) => g.isUserEvent('select.pointer')),
        );
    } finally {
      this.updateState = 0;
    }
    if (
      (i.startState.facet(bh) != i.state.facet(bh) && (this.viewState.mustMeasureContent = !0),
      (r || n || m || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) &&
        this.requestMeasure(),
      !i.empty)
    )
      for (let g of this.state.facet(C0)) g(i);
    (c || f) &&
      Promise.resolve().then(() => {
        c && this.state == c.startState && this.dispatch(c),
          f && !$E(this, f) && p.force && Xa(this.contentDOM, p.key, p.keyCode);
      });
  }
  setState(e) {
    if (this.updateState != 0)
      throw new Error('Calls to EditorView.setState are not allowed while an update is in progress');
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let n of this.plugins) n.destroy(this);
      (this.viewState = new lx(e)), (this.plugins = e.facet(lu).map((n) => new Zd(n))), this.pluginMap.clear();
      for (let n of this.plugins) n.update(this);
      (this.docView = new W1(this)),
        this.inputState.ensureHandlers(this.plugins),
        this.mountStyles(),
        this.updateAttrs(),
        (this.bidiCache = []);
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(lu),
      n = e.state.facet(lu);
    if (r != n) {
      let i = [];
      for (let s of n) {
        let o = r.indexOf(s);
        if (o < 0) i.push(new Zd(s));
        else {
          let l = this.plugins[o];
          (l.mustUpdate = e), i.push(l);
        }
      }
      for (let s of this.plugins) s.mustUpdate != e && s.destroy(this);
      (this.plugins = i), this.pluginMap.clear();
    } else for (let i of this.plugins) i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);
    r != n && this.inputState.ensureHandlers(this.plugins);
  }
  measure(e = !0) {
    if (this.destroyed) return;
    if (
      (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
      this.observer.delayedAndroidKey)
    ) {
      (this.measureScheduled = -1), this.requestMeasure();
      return;
    }
    (this.measureScheduled = 0), e && this.observer.forceFlush();
    let r = null,
      n = this.scrollDOM,
      i = n.scrollTop * this.scaleY,
      { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), (this.viewState.scrollAnchorHeight = -1);
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (YA(n)) (s = -1), (o = this.viewState.heightMap.height);
          else {
            let x = this.viewState.scrollAnchorAt(i);
            (s = x.from), (o = x.top);
          }
        this.updateState = 1;
        let c = this.viewState.measure(this);
        if (!c && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
        if (l > 5) {
          console.warn(
            this.measureRequests.length ? 'Measure loop restarted more than 5 times' : 'Viewport failed to stabilize',
          );
          break;
        }
        let p = [];
        c & 4 || ([this.measureRequests, p] = [p, this.measureRequests]);
        let f = p.map((x) => {
            try {
              return x.read(this);
            } catch (b) {
              return Vn(this.state, b), fx;
            }
          }),
          m = yp.create(this, this.state, []),
          g = !1;
        (m.flags |= c),
          r ? (r.flags |= c) : (r = m),
          (this.updateState = 2),
          m.empty ||
            (this.updatePlugins(m), this.inputState.update(m), this.updateAttrs(), (g = this.docView.update(m)));
        for (let x = 0; x < p.length; x++)
          if (f[x] != fx)
            try {
              let b = p[x];
              b.write && b.write(f[x], this);
            } catch (b) {
              Vn(this.state, b);
            }
        if ((g && this.docView.updateSelection(!0), !m.viewportChanged && this.measureRequests.length == 0)) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), (this.viewState.scrollTarget = null);
              continue;
            } else {
              let b = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (b > 1 || b < -1) {
                (i = i + b), (n.scrollTop = i / this.scaleY), (o = -1);
                continue;
              }
            }
          break;
        }
      }
    } finally {
      (this.updateState = 0), (this.measureScheduled = -1);
    }
    if (r && !r.empty) for (let l of this.state.facet(C0)) l(r);
  }
  get themeClasses() {
    return T0 + ' ' + (this.state.facet(w0) ? RE : _E) + ' ' + this.state.facet(bh);
  }
  updateAttrs() {
    let e = dx(this, mE, { class: 'cm-editor' + (this.hasFocus ? ' cm-focused ' : ' ') + this.themeClasses }),
      r = {
        'spellcheck': 'false',
        'autocorrect': 'off',
        'autocapitalize': 'off',
        'translate': 'no',
        'contenteditable': this.state.facet(Af) ? 'true' : 'false',
        'class': 'cm-content',
        'style': `${Je.tabSize}: ${this.state.tabSize}`,
        'role': 'textbox',
        'aria-multiline': 'true',
      };
    this.state.readOnly && (r['aria-readonly'] = 'true'), dx(this, Xg, r);
    let n = this.observer.ignore(() => {
      let i = D0(this.contentDOM, this.contentAttrs, r),
        s = D0(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return (this.editorAttrs = e), (this.contentAttrs = r), n;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let n of e)
      for (let i of n.effects)
        if (i.is(ze.announce)) {
          r && (this.announceDOM.textContent = ''), (r = !1);
          let s = this.announceDOM.appendChild(document.createElement('div'));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(uu);
    let e = this.state.facet(ze.cspNonce);
    io.mount(this.root, this.styleModules.concat(x6).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(e) {
    if (
      (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e)
    ) {
      if (this.measureRequests.indexOf(e) > -1) return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (
      (r === void 0 || (r && r.spec != e)) &&
        this.pluginMap.set(e, (r = this.plugins.find((n) => n.spec == e) || null)),
      r && r.update(this).value
    );
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(e, r, n) {
    return tm(this, e, G1(this, e, r, n));
  }
  moveByGroup(e, r) {
    return tm(
      this,
      e,
      G1(this, e, r, (n) => z4(this, e.head, n)),
    );
  }
  moveToLineBoundary(e, r, n = !0) {
    return V4(this, e, r, n);
  }
  moveVertically(e, r, n) {
    return tm(this, e, H4(this, e, r, n));
  }
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), SE(this, e, r);
  }
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, r);
    if (!n || n.left == n.right) return n;
    let i = this.state.doc.lineAt(e),
      s = this.bidiSpans(i),
      o = s[zs.find(s, e - i.from, -1, r)];
    return Cf(n, (o.dir == rr.LTR) == r > 0);
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(e) {
    return !this.state.facet(fE) || e < this.viewport.from || e > this.viewport.to
      ? this.textDirection
      : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(e) {
    if (e.length > P6) return AE(e.length);
    let r = this.textDirectionAt(e.from),
      n;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == r && (s.fresh || bE(s.isolates, (n = H1(this, e.from, e.to))))) return s.order;
    n || (n = H1(this, e.from, e.to));
    let i = w4(e.text, r, n);
    return this.bidiCache.push(new Dp(e.from, e.to, r, n, !0, i)), i;
  }
  get hasFocus() {
    var e;
    return (
      (this.dom.ownerDocument.hasFocus() ||
        (Je.safari &&
          ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4)) &&
      this.root.activeElement == this.contentDOM
    );
  }
  focus() {
    this.observer.ignore(() => {
      XA(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(e) {
    this._root != e &&
      ((this._root = e),
      this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window),
      this.mountStyles());
  }
  destroy() {
    for (let e of this.plugins) e.destroy(this);
    (this.plugins = []),
      this.inputState.destroy(),
      this.dom.remove(),
      this.observer.destroy(),
      this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
      (this.destroyed = !0);
  }
  static scrollIntoView(e, r = {}) {
    return z1.of(new gp(typeof e == 'number' ? pe.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  static domEventHandlers(e) {
    return ar.define(() => ({}), { eventHandlers: e });
  }
  static domEventObservers(e) {
    return ar.define(() => ({}), { eventObservers: e });
  }
  static theme(e, r) {
    let n = io.newName(),
      i = [bh.of(n), uu.of(k0(`.${n}`, e))];
    return r && r.dark && i.push(w0.of(!0)), i;
  }
  static baseTheme(e) {
    return xl.lowest(uu.of(k0('.' + T0, e, jE)));
  }
  static findFromDOM(e) {
    var r;
    let n = e.querySelector('.cm-content'),
      i = (n && Xt.get(n)) || Xt.get(e);
    return ((r = i == null ? void 0 : i.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
ze.styleModule = uu;
ze.inputHandler = hE;
ze.focusChangeEffect = pE;
ze.perLineTextDirection = fE;
ze.exceptionSink = cE;
ze.updateListener = C0;
ze.editable = Af;
ze.mouseSelectionStyle = uE;
ze.dragMovesSelection = lE;
ze.clickAddsSelectionRange = aE;
ze.decorations = Wu;
ze.atomicRanges = Gg;
ze.bidiIsolatedRanges = gE;
ze.scrollMargins = yE;
ze.darkTheme = w0;
ze.cspNonce = Ue.define({ combine: (t) => (t.length ? t[0] : '') });
ze.contentAttributes = Xg;
ze.editorAttributes = mE;
ze.lineWrapping = ze.contentAttributes.of({ class: 'cm-lineWrapping' });
ze.announce = mt.define();
const P6 = 4096,
  fx = {};
class Dp {
  constructor(e, r, n, i, s, o) {
    (this.from = e), (this.to = r), (this.dir = n), (this.isolates = i), (this.fresh = s), (this.order = o);
  }
  static update(e, r) {
    if (r.empty && !e.some((s) => s.fresh)) return e;
    let n = [],
      i = e.length ? e[e.length - 1].dir : rr.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i &&
        !r.touchesRange(o.from, o.to) &&
        n.push(new Dp(r.mapPos(o.from, 1), r.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return n;
  }
}
function dx(t, e, r) {
  for (let n = t.state.facet(e), i = n.length - 1; i >= 0; i--) {
    let s = n[i],
      o = typeof s == 'function' ? s(t) : s;
    o && y0(o, r);
  }
  return r;
}
const B6 = Je.mac ? 'mac' : Je.windows ? 'win' : Je.linux ? 'linux' : 'key';
function I6(t, e) {
  const r = t.split(/-(?!$)/);
  let n = r[r.length - 1];
  n == 'Space' && (n = ' ');
  let i, s, o, l;
  for (let c = 0; c < r.length - 1; ++c) {
    const p = r[c];
    if (/^(cmd|meta|m)$/i.test(p)) l = !0;
    else if (/^a(lt)?$/i.test(p)) i = !0;
    else if (/^(c|ctrl|control)$/i.test(p)) s = !0;
    else if (/^s(hift)?$/i.test(p)) o = !0;
    else if (/^mod$/i.test(p)) e == 'mac' ? (l = !0) : (s = !0);
    else throw new Error('Unrecognized modifier name: ' + p);
  }
  return i && (n = 'Alt-' + n), s && (n = 'Ctrl-' + n), l && (n = 'Meta-' + n), o && (n = 'Shift-' + n), n;
}
function Ah(t, e, r) {
  return (
    e.altKey && (t = 'Alt-' + t),
    e.ctrlKey && (t = 'Ctrl-' + t),
    e.metaKey && (t = 'Meta-' + t),
    r !== !1 && e.shiftKey && (t = 'Shift-' + t),
    t
  );
}
const N6 = xl.default(
    ze.domEventHandlers({
      keydown(t, e) {
        return zE(VE(e.state), t, e, 'editor');
      },
    }),
  ),
  Ef = Ue.define({ enables: N6 }),
  mx = new WeakMap();
function VE(t) {
  let e = t.facet(Ef),
    r = mx.get(e);
  return r || mx.set(e, (r = L6(e.reduce((n, i) => n.concat(i), [])))), r;
}
function M6(t, e, r) {
  return zE(VE(t.state), e, t, r);
}
let Rs = null;
const O6 = 4e3;
function L6(t, e = B6) {
  let r = Object.create(null),
    n = Object.create(null),
    i = (o, l) => {
      let c = n[o];
      if (c == null) n[o] = l;
      else if (c != l)
        throw new Error('Key binding ' + o + ' is used both as a regular binding and as a multi-stroke prefix');
    },
    s = (o, l, c, p, f) => {
      var m, g;
      let x = r[o] || (r[o] = Object.create(null)),
        b = l.split(/ (?!$)/).map((w) => I6(w, e));
      for (let w = 1; w < b.length; w++) {
        let I = b.slice(0, w).join(' ');
        i(I, !0),
          x[I] ||
            (x[I] = {
              preventDefault: !0,
              stopPropagation: !1,
              run: [
                (T) => {
                  let j = (Rs = { view: T, prefix: I, scope: o });
                  return (
                    setTimeout(() => {
                      Rs == j && (Rs = null);
                    }, O6),
                    !0
                  );
                },
              ],
            });
      }
      let F = b.join(' ');
      i(F, !1);
      let E =
        x[F] ||
        (x[F] = {
          preventDefault: !1,
          stopPropagation: !1,
          run:
            ((g = (m = x._any) === null || m === void 0 ? void 0 : m.run) === null || g === void 0
              ? void 0
              : g.slice()) || [],
        });
      c && E.run.push(c), p && (E.preventDefault = !0), f && (E.stopPropagation = !0);
    };
  for (let o of t) {
    let l = o.scope ? o.scope.split(' ') : ['editor'];
    if (o.any)
      for (let p of l) {
        let f = r[p] || (r[p] = Object.create(null));
        f._any || (f._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let m in f) f[m].run.push(o.any);
      }
    let c = o[e] || o.key;
    if (c)
      for (let p of l)
        s(p, c, o.run, o.preventDefault, o.stopPropagation),
          o.shift && s(p, 'Shift-' + c, o.shift, o.preventDefault, o.stopPropagation);
  }
  return r;
}
function zE(t, e, r, n) {
  let i = o4(e),
    s = Nr(i, 0),
    o = _n(s) == i.length && i != ' ',
    l = '',
    c = !1,
    p = !1,
    f = !1;
  Rs && Rs.view == r && Rs.scope == n && ((l = Rs.prefix + ' '), TE.indexOf(e.keyCode) < 0 && ((p = !0), (Rs = null)));
  let m = new Set(),
    g = (E) => {
      if (E) {
        for (let w of E.run) if (!m.has(w) && (m.add(w), w(r, e))) return E.stopPropagation && (f = !0), !0;
        E.preventDefault && (E.stopPropagation && (f = !0), (p = !0));
      }
      return !1;
    },
    x = t[n],
    b,
    F;
  return (
    x &&
      (g(x[l + Ah(i, e, !o)])
        ? (c = !0)
        : o &&
          (e.altKey || e.metaKey || e.ctrlKey) &&
          !(Je.windows && e.ctrlKey && e.altKey) &&
          (b = so[e.keyCode]) &&
          b != i
        ? (g(x[l + Ah(b, e, !0)]) || (e.shiftKey && (F = zu[e.keyCode]) != i && F != b && g(x[l + Ah(F, e, !1)]))) &&
          (c = !0)
        : o && e.shiftKey && g(x[l + Ah(i, e, !0)]) && (c = !0),
      !c && g(x._any) && (c = !0)),
    p && (c = !0),
    c && f && e.stopPropagation(),
    c
  );
}
class cc {
  constructor(e, r, n, i, s) {
    (this.className = e), (this.left = r), (this.top = n), (this.width = i), (this.height = s);
  }
  draw() {
    let e = document.createElement('div');
    return (e.className = this.className), this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    (e.style.left = this.left + 'px'),
      (e.style.top = this.top + 'px'),
      this.width != null && (e.style.width = this.width + 'px'),
      (e.style.height = this.height + 'px');
  }
  eq(e) {
    return (
      this.left == e.left &&
      this.top == e.top &&
      this.width == e.width &&
      this.height == e.height &&
      this.className == e.className
    );
  }
  static forRange(e, r, n) {
    if (n.empty) {
      let i = e.coordsAtPos(n.head, n.assoc || 1);
      if (!i) return [];
      let s = HE(e);
      return [new cc(r, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else return _6(e, r, n);
  }
}
function HE(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return {
    left:
      (t.textDirection == rr.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) -
      t.scrollDOM.scrollLeft * t.scaleX,
    top: e.top - t.scrollDOM.scrollTop * t.scaleY,
  };
}
function gx(t, e, r) {
  let n = pe.cursor(e);
  return {
    from: Math.max(r.from, t.moveToLineBoundary(n, !1, !0).from),
    to: Math.min(r.to, t.moveToLineBoundary(n, !0, !0).from),
    type: ln.Text,
  };
}
function _6(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to) return [];
  let n = Math.max(r.from, t.viewport.from),
    i = Math.min(r.to, t.viewport.to),
    s = t.textDirection == rr.LTR,
    o = t.contentDOM,
    l = o.getBoundingClientRect(),
    c = HE(t),
    p = o.querySelector('.cm-line'),
    f = p && window.getComputedStyle(p),
    m = l.left + (f ? parseInt(f.paddingLeft) + Math.min(0, parseInt(f.textIndent)) : 0),
    g = l.right - (f ? parseInt(f.paddingRight) : 0),
    x = F0(t, n),
    b = F0(t, i),
    F = x.type == ln.Text ? x : null,
    E = b.type == ln.Text ? b : null;
  if (
    (F && (t.lineWrapping || x.widgetLineBreaks) && (F = gx(t, n, F)),
    E && (t.lineWrapping || b.widgetLineBreaks) && (E = gx(t, i, E)),
    F && E && F.from == E.from)
  )
    return I(T(r.from, r.to, F));
  {
    let $ = F ? T(r.from, null, F) : j(x, !1),
      L = E ? T(null, r.to, E) : j(b, !0),
      se = [];
    return (
      (F || x).to < (E || b).from - (F && E ? 1 : 0) ||
      (x.widgetLineBreaks > 1 && $.bottom + t.defaultLineHeight / 2 < L.top)
        ? se.push(w(m, $.bottom, g, L.top))
        : $.bottom < L.top &&
          t.elementAtHeight(($.bottom + L.top) / 2).type == ln.Text &&
          ($.bottom = L.top = ($.bottom + L.top) / 2),
      I($).concat(se).concat(I(L))
    );
  }
  function w($, L, se, Y) {
    return new cc(e, $ - c.left, L - c.top - 0.01, se - $, Y - L + 0.01);
  }
  function I({ top: $, bottom: L, horizontal: se }) {
    let Y = [];
    for (let W = 0; W < se.length; W += 2) Y.push(w(se[W], $, se[W + 1], L));
    return Y;
  }
  function T($, L, se) {
    let Y = 1e9,
      W = -1e9,
      X = [];
    function q(re, ie, Q, ce, G) {
      let ge = t.coordsAtPos(re, re == se.to ? -2 : 2),
        we = t.coordsAtPos(Q, Q == se.from ? 2 : -2);
      !ge ||
        !we ||
        ((Y = Math.min(ge.top, we.top, Y)),
        (W = Math.max(ge.bottom, we.bottom, W)),
        G == rr.LTR
          ? X.push(s && ie ? m : ge.left, s && ce ? g : we.right)
          : X.push(!s && ce ? m : we.left, !s && ie ? g : ge.right));
    }
    let xe = $ ?? se.from,
      Re = L ?? se.to;
    for (let re of t.visibleRanges)
      if (re.to > xe && re.from < Re)
        for (let ie = Math.max(re.from, xe), Q = Math.min(re.to, Re); ; ) {
          let ce = t.state.doc.lineAt(ie);
          for (let G of t.bidiSpans(ce)) {
            let ge = G.from + ce.from,
              we = G.to + ce.from;
            if (ge >= Q) break;
            we > ie && q(Math.max(ge, ie), $ == null && ge <= xe, Math.min(we, Q), L == null && we >= Re, G.dir);
          }
          if (((ie = ce.to + 1), ie >= Q)) break;
        }
    return X.length == 0 && q(xe, $ == null, Re, L == null, t.textDirection), { top: Y, bottom: W, horizontal: X };
  }
  function j($, L) {
    let se = l.top + (L ? $.top : $.bottom);
    return { top: se, bottom: se, horizontal: [] };
  }
}
function R6(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class j6 {
  constructor(e, r) {
    (this.view = e),
      (this.layer = r),
      (this.drawn = []),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }),
      (this.dom = e.scrollDOM.appendChild(document.createElement('div'))),
      this.dom.classList.add('cm-layer'),
      r.above && this.dom.classList.add('cm-layer-above'),
      r.class && this.dom.classList.add(r.class),
      this.scale(),
      this.dom.setAttribute('aria-hidden', 'true'),
      this.setOrder(e.state),
      e.requestMeasure(this.measureReq),
      r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Yh) != e.state.facet(Yh) && this.setOrder(e.state),
      (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let r = 0,
      n = e.facet(Yh);
    for (; r < n.length && n[r] != this.layer; ) r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) &&
      ((this.scaleX = e), (this.scaleY = r), (this.dom.style.transform = `scale(${1 / e}, ${1 / r})`));
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, n) => !R6(r, this.drawn[n]))) {
      let r = this.dom.firstChild,
        n = 0;
      for (let i of e)
        i.update && r && i.constructor && this.drawn[n].constructor && i.update(r, this.drawn[n])
          ? ((r = r.nextSibling), n++)
          : this.dom.insertBefore(i.draw(), r);
      for (; r; ) {
        let i = r.nextSibling;
        r.remove(), (r = i);
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Yh = Ue.define();
function WE(t) {
  return [ar.define((e) => new j6(e, t)), Yh.of(t)];
}
const UE = !Je.ios,
  qu = Ue.define({
    combine(t) {
      return Wi(
        t,
        { cursorBlinkRate: 1200, drawRangeCursor: !0 },
        { cursorBlinkRate: (e, r) => Math.min(e, r), drawRangeCursor: (e, r) => e || r },
      );
    },
  });
function $6(t = {}) {
  return [qu.of(t), V6, z6, H6, dE.of(!0)];
}
function qE(t) {
  return t.startState.facet(qu) != t.state.facet(qu);
}
const V6 = WE({
  above: !0,
  markers(t) {
    let { state: e } = t,
      r = e.facet(qu),
      n = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty ? !s || UE : r.drawRangeCursor) {
        let o = s ? 'cm-cursor cm-cursor-primary' : 'cm-cursor cm-cursor-secondary',
          l = i.empty ? i : pe.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let c of cc.forRange(t, o, l)) n.push(c);
      }
    }
    return n;
  },
  update(t, e) {
    t.transactions.some((n) => n.selection) &&
      (e.style.animationName = e.style.animationName == 'cm-blink' ? 'cm-blink2' : 'cm-blink');
    let r = qE(t);
    return r && yx(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    yx(e.state, t);
  },
  class: 'cm-cursorLayer',
});
function yx(t, e) {
  e.style.animationDuration = t.facet(qu).cursorBlinkRate + 'ms';
}
const z6 = WE({
    above: !1,
    markers(t) {
      return t.state.selection.ranges
        .map((e) => (e.empty ? [] : cc.forRange(t, 'cm-selectionBackground', e)))
        .reduce((e, r) => e.concat(r));
    },
    update(t, e) {
      return t.docChanged || t.selectionSet || t.viewportChanged || qE(t);
    },
    class: 'cm-selectionLayer',
  }),
  KE = {
    '.cm-line': {
      '& ::selection': { backgroundColor: 'transparent !important' },
      '&::selection': { backgroundColor: 'transparent !important' },
    },
  };
UE && (KE['.cm-line'].caretColor = 'transparent !important');
const H6 = xl.highest(ze.theme(KE)),
  JE = mt.define({
    map(t, e) {
      return t == null ? null : e.mapPos(t);
    },
  }),
  pu = vr.define({
    create() {
      return null;
    },
    update(t, e) {
      return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, n) => (n.is(JE) ? n.value : r), t);
    },
  }),
  W6 = ar.fromClass(
    class {
      constructor(t) {
        (this.view = t),
          (this.cursor = null),
          (this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) });
      }
      update(t) {
        var e;
        let r = t.state.field(pu);
        r == null
          ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), (this.cursor = null))
          : (this.cursor ||
              ((this.cursor = this.view.scrollDOM.appendChild(document.createElement('div'))),
              (this.cursor.className = 'cm-dropCursor')),
            (t.startState.field(pu) != r || t.docChanged || t.geometryChanged) &&
              this.view.requestMeasure(this.measureReq));
      }
      readPos() {
        let { view: t } = this,
          e = t.state.field(pu),
          r = e != null && t.coordsAtPos(e);
        if (!r) return null;
        let n = t.scrollDOM.getBoundingClientRect();
        return {
          left: r.left - n.left + t.scrollDOM.scrollLeft * t.scaleX,
          top: r.top - n.top + t.scrollDOM.scrollTop * t.scaleY,
          height: r.bottom - r.top,
        };
      }
      drawCursor(t) {
        if (this.cursor) {
          let { scaleX: e, scaleY: r } = this.view;
          t
            ? ((this.cursor.style.left = t.left / e + 'px'),
              (this.cursor.style.top = t.top / r + 'px'),
              (this.cursor.style.height = t.height / r + 'px'))
            : (this.cursor.style.left = '-100000px');
        }
      }
      destroy() {
        this.cursor && this.cursor.remove();
      }
      setDropPos(t) {
        this.view.state.field(pu) != t && this.view.dispatch({ effects: JE.of(t) });
      }
    },
    {
      eventObservers: {
        dragover(t) {
          this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
        },
        dragleave(t) {
          (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) &&
            this.setDropPos(null);
        },
        dragend() {
          this.setDropPos(null);
        },
        drop() {
          this.setDropPos(null);
        },
      },
    },
  );
function U6() {
  return [pu, W6];
}
function Dx(t, e, r, n, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(r, n), o = r, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak) for (; (l = e.exec(s.value)); ) i(o + l.index, l);
}
function q6(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to) return r;
  let n = [];
  for (let { from: i, to: s } of r)
    (i = Math.max(t.state.doc.lineAt(i).from, i - e)),
      (s = Math.min(t.state.doc.lineAt(s).to, s + e)),
      n.length && n[n.length - 1].to >= i ? (n[n.length - 1].to = s) : n.push({ from: i, to: s });
  return n;
}
class K6 {
  constructor(e) {
    const { regexp: r, decoration: n, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!r.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (((this.regexp = r), i)) this.addMatch = (l, c, p, f) => i(f, p, p + l[0].length, l, c);
    else if (typeof n == 'function')
      this.addMatch = (l, c, p, f) => {
        let m = n(l, c, p);
        m && f(p, p + l[0].length, m);
      };
    else if (n) this.addMatch = (l, c, p, f) => f(p, p + l[0].length, n);
    else throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    (this.boundary = s), (this.maxLength = o);
  }
  createDeco(e) {
    let r = new no(),
      n = r.add.bind(r);
    for (let { from: i, to: s } of q6(e, this.maxLength))
      Dx(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, n));
    return r.finish();
  }
  updateDeco(e, r) {
    let n = 1e9,
      i = -1;
    return (
      e.docChanged &&
        e.changes.iterChanges((s, o, l, c) => {
          c > e.view.viewport.from && l < e.view.viewport.to && ((n = Math.min(l, n)), (i = Math.max(c, i)));
        }),
      e.viewportChanged || i - n > 1e3
        ? this.createDeco(e.view)
        : i > -1
        ? this.updateRange(e.view, r.map(e.changes), n, i)
        : r
    );
  }
  updateRange(e, r, n, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, n),
        l = Math.min(s.to, i);
      if (l > o) {
        let c = e.state.doc.lineAt(o),
          p = c.to < l ? e.state.doc.lineAt(l) : c,
          f = Math.max(s.from, c.from),
          m = Math.min(s.to, p.to);
        if (this.boundary) {
          for (; o > c.from; o--)
            if (this.boundary.test(c.text[o - 1 - c.from])) {
              f = o;
              break;
            }
          for (; l < p.to; l++)
            if (this.boundary.test(p.text[l - p.from])) {
              m = l;
              break;
            }
        }
        let g = [],
          x,
          b = (F, E, w) => g.push(w.range(F, E));
        if (c == p)
          for (this.regexp.lastIndex = f - c.from; (x = this.regexp.exec(c.text)) && x.index < m - c.from; )
            this.addMatch(x, e, x.index + c.from, b);
        else Dx(e.state.doc, this.regexp, f, m, (F, E) => this.addMatch(E, e, F, b));
        r = r.update({ filterFrom: f, filterTo: m, filter: (F, E) => F < f || E > m, add: g });
      }
    }
    return r;
  }
}
const P0 = /x/.unicode != null ? 'gu' : 'g',
  J6 = new RegExp(
    `[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`,
    P0,
  ),
  X6 = {
    0: 'null',
    7: 'bell',
    8: 'backspace',
    10: 'newline',
    11: 'vertical tab',
    13: 'carriage return',
    27: 'escape',
    8203: 'zero width space',
    8204: 'zero width non-joiner',
    8205: 'zero width joiner',
    8206: 'left-to-right mark',
    8207: 'right-to-left mark',
    8232: 'line separator',
    8237: 'left-to-right override',
    8238: 'right-to-left override',
    8294: 'left-to-right isolate',
    8295: 'right-to-left isolate',
    8297: 'pop directional isolate',
    8233: 'paragraph separator',
    65279: 'zero width no-break space',
    65532: 'object replacement',
  };
let im = null;
function G6() {
  var t;
  if (im == null && typeof document < 'u' && document.body) {
    let e = document.body.style;
    im = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return im || !1;
}
const Qh = Ue.define({
  combine(t) {
    let e = Wi(t, { render: null, specialChars: J6, addSpecialChars: null });
    return (
      (e.replaceTabs = !G6()) && (e.specialChars = new RegExp('	|' + e.specialChars.source, P0)),
      e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + '|' + e.addSpecialChars.source, P0)),
      e
    );
  },
});
function Y6(t = {}) {
  return [Qh.of(t), Q6()];
}
let xx = null;
function Q6() {
  return (
    xx ||
    (xx = ar.fromClass(
      class {
        constructor(t) {
          (this.view = t),
            (this.decorations = it.none),
            (this.decorationCache = Object.create(null)),
            (this.decorator = this.makeDecorator(t.state.facet(Qh))),
            (this.decorations = this.decorator.createDeco(t));
        }
        makeDecorator(t) {
          return new K6({
            regexp: t.specialChars,
            decoration: (e, r, n) => {
              let { doc: i } = r.state,
                s = Nr(e[0], 0);
              if (s == 9) {
                let o = i.lineAt(n),
                  l = r.state.tabSize,
                  c = Cl(o.text, l, n - o.from);
                return it.replace({
                  widget: new rI(((l - (c % l)) * this.view.defaultCharacterWidth) / this.view.scaleX),
                });
              }
              return this.decorationCache[s] || (this.decorationCache[s] = it.replace({ widget: new tI(t, s) }));
            },
            boundary: t.replaceTabs ? void 0 : /[^]/,
          });
        }
        update(t) {
          let e = t.state.facet(Qh);
          t.startState.facet(Qh) != e
            ? ((this.decorator = this.makeDecorator(e)), (this.decorations = this.decorator.createDeco(t.view)))
            : (this.decorations = this.decorator.updateDeco(t, this.decorations));
        }
      },
      { decorations: (t) => t.decorations },
    ))
  );
}
const Z6 = '•';
function eI(t) {
  return t >= 32 ? Z6 : t == 10 ? '␤' : String.fromCharCode(9216 + t);
}
class tI extends gs {
  constructor(e, r) {
    super(), (this.options = e), (this.code = r);
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = eI(this.code),
      n = e.state.phrase('Control character') + ' ' + (X6[this.code] || '0x' + this.code.toString(16)),
      i = this.options.render && this.options.render(this.code, n, r);
    if (i) return i;
    let s = document.createElement('span');
    return (s.textContent = r), (s.title = n), s.setAttribute('aria-label', n), (s.className = 'cm-specialChar'), s;
  }
  ignoreEvent() {
    return !1;
  }
}
class rI extends gs {
  constructor(e) {
    super(), (this.width = e);
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement('span');
    return (e.textContent = '	'), (e.className = 'cm-tab'), (e.style.width = this.width + 'px'), e;
  }
  ignoreEvent() {
    return !1;
  }
}
function nI() {
  return sI;
}
const iI = it.line({ class: 'cm-activeLine' }),
  sI = ar.fromClass(
    class {
      constructor(t) {
        this.decorations = this.getDeco(t);
      }
      update(t) {
        (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
      }
      getDeco(t) {
        let e = -1,
          r = [];
        for (let n of t.state.selection.ranges) {
          let i = t.lineBlockAt(n.head);
          i.from > e && (r.push(iI.range(i.from)), (e = i.from));
        }
        return it.set(r);
      }
    },
    { decorations: (t) => t.decorations },
  );
class oI extends gs {
  constructor(e) {
    super(), (this.content = e);
  }
  toDOM() {
    let e = document.createElement('span');
    return (
      (e.className = 'cm-placeholder'),
      (e.style.pointerEvents = 'none'),
      e.appendChild(typeof this.content == 'string' ? document.createTextNode(this.content) : this.content),
      typeof this.content == 'string'
        ? e.setAttribute('aria-label', 'placeholder ' + this.content)
        : e.setAttribute('aria-hidden', 'true'),
      e
    );
  }
  coordsAt(e) {
    let r = e.firstChild ? ol(e.firstChild) : [];
    if (!r.length) return null;
    let n = window.getComputedStyle(e.parentNode),
      i = Cf(r[0], n.direction != 'rtl'),
      s = parseInt(n.lineHeight);
    return i.bottom - i.top > s * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + s } : i;
  }
  ignoreEvent() {
    return !1;
  }
}
function aI(t) {
  return ar.fromClass(
    class {
      constructor(e) {
        (this.view = e),
          (this.placeholder = t ? it.set([it.widget({ widget: new oI(t), side: 1 }).range(0)]) : it.none);
      }
      get decorations() {
        return this.view.state.doc.length ? it.none : this.placeholder;
      }
    },
    { decorations: (e) => e.decorations },
  );
}
const B0 = 2e3;
function lI(t, e, r) {
  let n = Math.min(e.line, r.line),
    i = Math.max(e.line, r.line),
    s = [];
  if (e.off > B0 || r.off > B0 || e.col < 0 || r.col < 0) {
    let o = Math.min(e.off, r.off),
      l = Math.max(e.off, r.off);
    for (let c = n; c <= i; c++) {
      let p = t.doc.line(c);
      p.length <= l && s.push(pe.range(p.from + o, p.to + l));
    }
  } else {
    let o = Math.min(e.col, r.col),
      l = Math.max(e.col, r.col);
    for (let c = n; c <= i; c++) {
      let p = t.doc.line(c),
        f = c0(p.text, o, t.tabSize, !0);
      if (f < 0) s.push(pe.cursor(p.to));
      else {
        let m = c0(p.text, l, t.tabSize);
        s.push(pe.range(p.from + f, p.from + m));
      }
    }
  }
  return s;
}
function uI(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function Cx(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    n = t.state.doc.lineAt(r),
    i = r - n.from,
    s = i > B0 ? -1 : i == n.length ? uI(t, e.clientX) : Cl(n.text, t.state.tabSize, r - n.from);
  return { line: n.number, col: s, off: i };
}
function cI(t, e) {
  let r = Cx(t, e),
    n = t.state.selection;
  return r
    ? {
        update(i) {
          if (i.docChanged) {
            let s = i.changes.mapPos(i.startState.doc.line(r.line).from),
              o = i.state.doc.lineAt(s);
            (r = { line: o.number, col: r.col, off: Math.min(r.off, o.length) }), (n = n.map(i.changes));
          }
        },
        get(i, s, o) {
          let l = Cx(t, i);
          if (!l) return n;
          let c = lI(t.state, r, l);
          return c.length ? (o ? pe.create(c.concat(n.ranges)) : pe.create(c)) : n;
        },
      }
    : null;
}
function hI(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((r) => r.altKey && r.button == 0);
  return ze.mouseSelectionStyle.of((r, n) => (e(n) ? cI(r, n) : null));
}
const pI = {
    Alt: [18, (t) => !!t.altKey],
    Control: [17, (t) => !!t.ctrlKey],
    Shift: [16, (t) => !!t.shiftKey],
    Meta: [91, (t) => !!t.metaKey],
  },
  fI = { style: 'cursor: crosshair' };
function dI(t = {}) {
  let [e, r] = pI[t.key || 'Alt'],
    n = ar.fromClass(
      class {
        constructor(i) {
          (this.view = i), (this.isDown = !1);
        }
        set(i) {
          this.isDown != i && ((this.isDown = i), this.view.update([]));
        }
      },
      {
        eventObservers: {
          keydown(i) {
            this.set(i.keyCode == e || r(i));
          },
          keyup(i) {
            (i.keyCode == e || !r(i)) && this.set(!1);
          },
          mousemove(i) {
            this.set(r(i));
          },
        },
      },
    );
  return [
    n,
    ze.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(n)) === null || s === void 0) && s.isDown ? fI : null;
    }),
  ];
}
const Eh = '-10000px';
class XE {
  constructor(e, r, n) {
    (this.facet = r),
      (this.createTooltipView = n),
      (this.input = e.state.facet(r)),
      (this.tooltips = this.input.filter((i) => i)),
      (this.tooltipViews = this.tooltips.map(n));
  }
  update(e) {
    var r;
    let n = e.state.facet(this.facet),
      i = n.filter((o) => o);
    if (n === this.input) {
      for (let o of this.tooltipViews) o.update && o.update(e);
      return !1;
    }
    let s = [];
    for (let o = 0; o < i.length; o++) {
      let l = i[o],
        c = -1;
      if (l) {
        for (let p = 0; p < this.tooltips.length; p++) {
          let f = this.tooltips[p];
          f && f.create == l.create && (c = p);
        }
        if (c < 0) s[o] = this.createTooltipView(l);
        else {
          let p = (s[o] = this.tooltipViews[c]);
          p.update && p.update(e);
        }
      }
    }
    for (let o of this.tooltipViews)
      s.indexOf(o) < 0 && (o.dom.remove(), (r = o.destroy) === null || r === void 0 || r.call(o));
    return (this.input = n), (this.tooltips = i), (this.tooltipViews = s), !0;
  }
}
function mI(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const sm = Ue.define({
    combine: (t) => {
      var e, r, n;
      return {
        position: Je.ios
          ? 'absolute'
          : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || 'fixed',
        parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
        tooltipSpace: ((n = t.find((i) => i.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || mI,
      };
    },
  }),
  bx = new WeakMap(),
  GE = ar.fromClass(
    class {
      constructor(t) {
        (this.view = t),
          (this.inView = !0),
          (this.madeAbsolute = !1),
          (this.lastTransaction = 0),
          (this.measureTimeout = -1);
        let e = t.state.facet(sm);
        (this.position = e.position),
          (this.parent = e.parent),
          (this.classes = t.themeClasses),
          this.createContainer(),
          (this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }),
          (this.manager = new XE(t, Qg, (r) => this.createTooltip(r))),
          (this.intersectionObserver =
            typeof IntersectionObserver == 'function'
              ? new IntersectionObserver(
                  (r) => {
                    Date.now() > this.lastTransaction - 50 &&
                      r.length > 0 &&
                      r[r.length - 1].intersectionRatio < 1 &&
                      this.measureSoon();
                  },
                  { threshold: [1] },
                )
              : null),
          this.observeIntersection(),
          t.win.addEventListener('resize', (this.measureSoon = this.measureSoon.bind(this))),
          this.maybeMeasure();
      }
      createContainer() {
        this.parent
          ? ((this.container = document.createElement('div')),
            (this.container.style.position = 'relative'),
            (this.container.className = this.view.themeClasses),
            this.parent.appendChild(this.container))
          : (this.container = this.view.dom);
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          for (let t of this.manager.tooltipViews) this.intersectionObserver.observe(t.dom);
        }
      }
      measureSoon() {
        this.measureTimeout < 0 &&
          (this.measureTimeout = setTimeout(() => {
            (this.measureTimeout = -1), this.maybeMeasure();
          }, 50));
      }
      update(t) {
        t.transactions.length && (this.lastTransaction = Date.now());
        let e = this.manager.update(t);
        e && this.observeIntersection();
        let r = e || t.geometryChanged,
          n = t.state.facet(sm);
        if (n.position != this.position && !this.madeAbsolute) {
          this.position = n.position;
          for (let i of this.manager.tooltipViews) i.dom.style.position = this.position;
          r = !0;
        }
        if (n.parent != this.parent) {
          this.parent && this.container.remove(), (this.parent = n.parent), this.createContainer();
          for (let i of this.manager.tooltipViews) this.container.appendChild(i.dom);
          r = !0;
        } else
          this.parent &&
            this.view.themeClasses != this.classes &&
            (this.classes = this.container.className = this.view.themeClasses);
        r && this.maybeMeasure();
      }
      createTooltip(t) {
        let e = t.create(this.view);
        if ((e.dom.classList.add('cm-tooltip'), t.arrow && !e.dom.querySelector('.cm-tooltip > .cm-tooltip-arrow'))) {
          let r = document.createElement('div');
          (r.className = 'cm-tooltip-arrow'), e.dom.appendChild(r);
        }
        return (
          (e.dom.style.position = this.position),
          (e.dom.style.top = Eh),
          this.container.appendChild(e.dom),
          e.mount && e.mount(this.view),
          e
        );
      }
      destroy() {
        var t, e;
        this.view.win.removeEventListener('resize', this.measureSoon);
        for (let r of this.manager.tooltipViews) r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);
        this.parent && this.container.remove(),
          (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(),
          clearTimeout(this.measureTimeout);
      }
      readMeasure() {
        let t = this.view.dom.getBoundingClientRect(),
          e = 1,
          r = 1,
          n = !1;
        if (this.position == 'fixed' && this.manager.tooltipViews.length) {
          let { offsetParent: i } = this.manager.tooltipViews[0].dom;
          n = !!(i && i != this.container.ownerDocument.body);
        }
        if (n || this.position == 'absolute')
          if (this.parent) {
            let i = this.parent.getBoundingClientRect();
            i.width && i.height && ((e = i.width / this.parent.offsetWidth), (r = i.height / this.parent.offsetHeight));
          } else ({ scaleX: e, scaleY: r } = this.view.viewState);
        return {
          editor: t,
          parent: this.parent ? this.container.getBoundingClientRect() : t,
          pos: this.manager.tooltips.map((i, s) => {
            let o = this.manager.tooltipViews[s];
            return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
          }),
          size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
          space: this.view.state.facet(sm).tooltipSpace(this.view),
          scaleX: e,
          scaleY: r,
          makeAbsolute: n,
        };
      }
      writeMeasure(t) {
        var e;
        if (t.makeAbsolute) {
          (this.madeAbsolute = !0), (this.position = 'absolute');
          for (let l of this.manager.tooltipViews) l.dom.style.position = 'absolute';
        }
        let { editor: r, space: n, scaleX: i, scaleY: s } = t,
          o = [];
        for (let l = 0; l < this.manager.tooltips.length; l++) {
          let c = this.manager.tooltips[l],
            p = this.manager.tooltipViews[l],
            { dom: f } = p,
            m = t.pos[l],
            g = t.size[l];
          if (
            !m ||
            m.bottom <= Math.max(r.top, n.top) ||
            m.top >= Math.min(r.bottom, n.bottom) ||
            m.right < Math.max(r.left, n.left) - 0.1 ||
            m.left > Math.min(r.right, n.right) + 0.1
          ) {
            f.style.top = Eh;
            continue;
          }
          let x = c.arrow ? p.dom.querySelector('.cm-tooltip-arrow') : null,
            b = x ? 7 : 0,
            F = g.right - g.left,
            E = (e = bx.get(p)) !== null && e !== void 0 ? e : g.bottom - g.top,
            w = p.offset || yI,
            I = this.view.textDirection == rr.LTR,
            T =
              g.width > n.right - n.left
                ? I
                  ? n.left
                  : n.right - g.width
                : I
                ? Math.min(m.left - (x ? 14 : 0) + w.x, n.right - F)
                : Math.max(n.left, m.left - F + (x ? 14 : 0) - w.x),
            j = !!c.above;
          !c.strictSide &&
            (j ? m.top - (g.bottom - g.top) - w.y < n.top : m.bottom + (g.bottom - g.top) + w.y > n.bottom) &&
            j == n.bottom - m.bottom > m.top - n.top &&
            (j = !j);
          let $ = (j ? m.top - n.top : n.bottom - m.bottom) - b;
          if ($ < E && p.resize !== !1) {
            if ($ < this.view.defaultLineHeight) {
              f.style.top = Eh;
              continue;
            }
            bx.set(p, E), (f.style.height = (E = $) / s + 'px');
          } else f.style.height && (f.style.height = '');
          let L = j ? m.top - E - b - w.y : m.bottom + b + w.y,
            se = T + F;
          if (p.overlap !== !0)
            for (let Y of o)
              Y.left < se &&
                Y.right > T &&
                Y.top < L + E &&
                Y.bottom > L &&
                (L = j ? Y.top - E - 2 - b : Y.bottom + b + 2);
          if (
            (this.position == 'absolute'
              ? ((f.style.top = (L - t.parent.top) / s + 'px'), (f.style.left = (T - t.parent.left) / i + 'px'))
              : ((f.style.top = L / s + 'px'), (f.style.left = T / i + 'px')),
            x)
          ) {
            let Y = m.left + (I ? w.x : -w.x) - (T + 14 - 7);
            x.style.left = Y / i + 'px';
          }
          p.overlap !== !0 && o.push({ left: T, top: L, right: se, bottom: L + E }),
            f.classList.toggle('cm-tooltip-above', j),
            f.classList.toggle('cm-tooltip-below', !j),
            p.positioned && p.positioned(t.space);
        }
      }
      maybeMeasure() {
        if (
          this.manager.tooltips.length &&
          (this.view.inView && this.view.requestMeasure(this.measureReq),
          this.inView != this.view.inView && ((this.inView = this.view.inView), !this.inView))
        )
          for (let t of this.manager.tooltipViews) t.dom.style.top = Eh;
      }
    },
    {
      eventObservers: {
        scroll() {
          this.maybeMeasure();
        },
      },
    },
  ),
  gI = ze.baseTheme({
    '.cm-tooltip': { zIndex: 100, boxSizing: 'border-box' },
    '&light .cm-tooltip': { border: '1px solid #bbb', backgroundColor: '#f5f5f5' },
    '&light .cm-tooltip-section:not(:first-child)': { borderTop: '1px solid #bbb' },
    '&dark .cm-tooltip': { backgroundColor: '#333338', color: 'white' },
    '.cm-tooltip-arrow': {
      'height': '7px',
      'width': `${7 * 2}px`,
      'position': 'absolute',
      'zIndex': -1,
      'overflow': 'hidden',
      '&:before, &:after': {
        content: "''",
        position: 'absolute',
        width: 0,
        height: 0,
        borderLeft: '7px solid transparent',
        borderRight: '7px solid transparent',
      },
      '.cm-tooltip-above &': {
        'bottom': '-7px',
        '&:before': { borderTop: '7px solid #bbb' },
        '&:after': { borderTop: '7px solid #f5f5f5', bottom: '1px' },
      },
      '.cm-tooltip-below &': {
        'top': '-7px',
        '&:before': { borderBottom: '7px solid #bbb' },
        '&:after': { borderBottom: '7px solid #f5f5f5', top: '1px' },
      },
    },
    '&dark .cm-tooltip .cm-tooltip-arrow': {
      '&:before': { borderTopColor: '#333338', borderBottomColor: '#333338' },
      '&:after': { borderTopColor: 'transparent', borderBottomColor: 'transparent' },
    },
  }),
  yI = { x: 0, y: 0 },
  Qg = Ue.define({ enables: [GE, gI] }),
  xp = Ue.define();
class Zg {
  static create(e) {
    return new Zg(e);
  }
  constructor(e) {
    (this.view = e),
      (this.mounted = !1),
      (this.dom = document.createElement('div')),
      this.dom.classList.add('cm-tooltip-hover'),
      (this.manager = new XE(e, xp, (r) => this.createHostedView(r)));
  }
  createHostedView(e) {
    let r = e.create(this.view);
    return (
      r.dom.classList.add('cm-tooltip-section'),
      this.dom.appendChild(r.dom),
      this.mounted && r.mount && r.mount(this.view),
      r
    );
  }
  mount(e) {
    for (let r of this.manager.tooltipViews) r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews) r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews) (e = r.destroy) === null || e === void 0 || e.call(r);
  }
}
const DI = Qg.compute([xp], (t) => {
  let e = t.facet(xp).filter((r) => r);
  return e.length === 0
    ? null
    : {
        pos: Math.min(...e.map((r) => r.pos)),
        end: Math.max(...e.filter((r) => r.end != null).map((r) => r.end)),
        create: Zg.create,
        above: e[0].above,
        arrow: e.some((r) => r.arrow),
      };
});
class xI {
  constructor(e, r, n, i, s) {
    (this.view = e),
      (this.source = r),
      (this.field = n),
      (this.setHover = i),
      (this.hoverTime = s),
      (this.hoverTimeout = -1),
      (this.restartTimeout = -1),
      (this.pending = null),
      (this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }),
      (this.checkHover = this.checkHover.bind(this)),
      e.dom.addEventListener('mouseleave', (this.mouseleave = this.mouseleave.bind(this))),
      e.dom.addEventListener('mousemove', (this.mousemove = this.mousemove.bind(this)));
  }
  update() {
    this.pending &&
      ((this.pending = null),
      clearTimeout(this.restartTimeout),
      (this.restartTimeout = setTimeout(() => this.startHover(), 20)));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (((this.hoverTimeout = -1), this.active)) return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e)) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this,
      n = e.docView.nearest(r.target);
    if (!n) return;
    let i,
      s = 1;
    if (n instanceof Vs) i = n.posAtStart;
    else {
      if (((i = e.posAtCoords(r)), i == null)) return;
      let l = e.coordsAtPos(i);
      if (
        !l ||
        r.y < l.top ||
        r.y > l.bottom ||
        r.x < l.left - e.defaultCharacterWidth ||
        r.x > l.right + e.defaultCharacterWidth
      )
        return;
      let c = e.bidiSpans(e.state.doc.lineAt(i)).find((f) => f.from <= i && f.to >= i),
        p = c && c.dir == rr.RTL ? -1 : 1;
      s = r.x < l.left ? -p : p;
    }
    let o = this.source(e, i, s);
    if (o != null && o.then) {
      let l = (this.pending = { pos: i });
      o.then(
        (c) => {
          this.pending == l && ((this.pending = null), c && e.dispatch({ effects: this.setHover.of(c) }));
        },
        (c) => Vn(e.state, c, 'hover tooltip'),
      );
    } else o && e.dispatch({ effects: this.setHover.of(o) });
  }
  mousemove(e) {
    var r;
    (this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }),
      this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let n = this.active;
    if ((n && !Ax(this.lastMove.target)) || this.pending) {
      let { pos: i } = n || this.pending,
        s = (r = n == null ? void 0 : n.end) !== null && r !== void 0 ? r : i;
      (i == s ? this.view.posAtCoords(this.lastMove) != i : !CI(this.view, i, s, e.clientX, e.clientY)) &&
        (this.view.dispatch({ effects: this.setHover.of(null) }), (this.pending = null));
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout),
      (this.hoverTimeout = -1),
      this.active && !Ax(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout),
      this.view.dom.removeEventListener('mouseleave', this.mouseleave),
      this.view.dom.removeEventListener('mousemove', this.mousemove);
  }
}
function Ax(t) {
  for (let e = t; e; e = e.parentNode) if (e.nodeType == 1 && e.classList.contains('cm-tooltip')) return !0;
  return !1;
}
function CI(t, e, r, n, i, s) {
  let o = t.scrollDOM.getBoundingClientRect(),
    l = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (o.left > n || o.right < n || o.top > i || Math.min(o.bottom, l) < i) return !1;
  let c = t.posAtCoords({ x: n, y: i }, !1);
  return c >= e && c <= r;
}
function bI(t, e = {}) {
  let r = mt.define(),
    n = vr.define({
      create() {
        return null;
      },
      update(i, s) {
        if (i && ((e.hideOnChange && (s.docChanged || s.selection)) || (e.hideOn && e.hideOn(s, i)))) return null;
        if (i && s.docChanged) {
          let o = s.changes.mapPos(i.pos, -1, sn.TrackDel);
          if (o == null) return null;
          let l = Object.assign(Object.create(null), i);
          (l.pos = o), i.end != null && (l.end = s.changes.mapPos(i.end)), (i = l);
        }
        for (let o of s.effects) o.is(r) && (i = o.value), o.is(AI) && (i = null);
        return i;
      },
      provide: (i) => xp.from(i),
    });
  return [n, ar.define((i) => new xI(i, t, n, r, e.hoverTime || 300)), DI];
}
function YE(t, e) {
  let r = t.plugin(GE);
  if (!r) return null;
  let n = r.manager.tooltips.indexOf(e);
  return n < 0 ? null : r.manager.tooltipViews[n];
}
const AI = mt.define(),
  Ex = Ue.define({
    combine(t) {
      let e, r;
      for (let n of t) (e = e || n.topContainer), (r = r || n.bottomContainer);
      return { topContainer: e, bottomContainer: r };
    },
  });
function Ku(t, e) {
  let r = t.plugin(QE),
    n = r ? r.specs.indexOf(e) : -1;
  return n > -1 ? r.panels[n] : null;
}
const QE = ar.fromClass(
  class {
    constructor(t) {
      (this.input = t.state.facet(Ju)),
        (this.specs = this.input.filter((r) => r)),
        (this.panels = this.specs.map((r) => r(t)));
      let e = t.state.facet(Ex);
      (this.top = new vh(t, !0, e.topContainer)),
        (this.bottom = new vh(t, !1, e.bottomContainer)),
        this.top.sync(this.panels.filter((r) => r.top)),
        this.bottom.sync(this.panels.filter((r) => !r.top));
      for (let r of this.panels) r.dom.classList.add('cm-panel'), r.mount && r.mount();
    }
    update(t) {
      let e = t.state.facet(Ex);
      this.top.container != e.topContainer && (this.top.sync([]), (this.top = new vh(t.view, !0, e.topContainer))),
        this.bottom.container != e.bottomContainer &&
          (this.bottom.sync([]), (this.bottom = new vh(t.view, !1, e.bottomContainer))),
        this.top.syncClasses(),
        this.bottom.syncClasses();
      let r = t.state.facet(Ju);
      if (r != this.input) {
        let n = r.filter((c) => c),
          i = [],
          s = [],
          o = [],
          l = [];
        for (let c of n) {
          let p = this.specs.indexOf(c),
            f;
          p < 0 ? ((f = c(t.view)), l.push(f)) : ((f = this.panels[p]), f.update && f.update(t)),
            i.push(f),
            (f.top ? s : o).push(f);
        }
        (this.specs = n), (this.panels = i), this.top.sync(s), this.bottom.sync(o);
        for (let c of l) c.dom.classList.add('cm-panel'), c.mount && c.mount();
      } else for (let n of this.panels) n.update && n.update(t);
    }
    destroy() {
      this.top.sync([]), this.bottom.sync([]);
    }
  },
  {
    provide: (t) =>
      ze.scrollMargins.of((e) => {
        let r = e.plugin(t);
        return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
      }),
  },
);
class vh {
  constructor(e, r, n) {
    (this.view = e),
      (this.top = r),
      (this.container = n),
      (this.dom = void 0),
      (this.classes = ''),
      (this.panels = []),
      this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels) r.destroy && e.indexOf(r) < 0 && r.destroy();
    (this.panels = e), this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), (this.dom = void 0));
      return;
    }
    if (!this.dom) {
      (this.dom = document.createElement('div')),
        (this.dom.className = this.top ? 'cm-panels cm-panels-top' : 'cm-panels cm-panels-bottom'),
        (this.dom.style[this.top ? 'top' : 'bottom'] = '0');
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; ) e = vx(e);
        e = e.nextSibling;
      } else this.dom.insertBefore(r.dom, e);
    for (; e; ) e = vx(e);
  }
  scrollMargin() {
    return !this.dom || this.container
      ? 0
      : Math.max(
          0,
          this.top
            ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
            : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) -
                this.dom.getBoundingClientRect().top,
        );
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(' ')) e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(' ')) e && this.container.classList.add(e);
    }
  }
}
function vx(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const Ju = Ue.define({ enables: QE });
class us extends ea {
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  eq(e) {
    return !1;
  }
  destroy(e) {}
}
us.prototype.elementClass = '';
us.prototype.toDOM = void 0;
us.prototype.mapMode = sn.TrackBefore;
us.prototype.startSide = us.prototype.endSide = -1;
us.prototype.point = !0;
const Zh = Ue.define(),
  EI = {
    class: '',
    renderEmptyElements: !1,
    elementStyle: '',
    markers: () => _t.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {},
  },
  vu = Ue.define();
function vI(t) {
  return [ZE(), vu.of(Object.assign(Object.assign({}, EI), t))];
}
const I0 = Ue.define({ combine: (t) => t.some((e) => e) });
function ZE(t) {
  let e = [FI];
  return t && t.fixed === !1 && e.push(I0.of(!0)), e;
}
const FI = ar.fromClass(
  class {
    constructor(t) {
      (this.view = t),
        (this.prevViewport = t.viewport),
        (this.dom = document.createElement('div')),
        (this.dom.className = 'cm-gutters'),
        this.dom.setAttribute('aria-hidden', 'true'),
        (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + 'px'),
        (this.gutters = t.state.facet(vu).map((e) => new Sx(t, e)));
      for (let e of this.gutters) this.dom.appendChild(e.dom);
      (this.fixed = !t.state.facet(I0)),
        this.fixed && (this.dom.style.position = 'sticky'),
        this.syncGutters(!1),
        t.scrollDOM.insertBefore(this.dom, t.contentDOM);
    }
    update(t) {
      if (this.updateGutters(t)) {
        let e = this.prevViewport,
          r = t.view.viewport,
          n = Math.min(e.to, r.to) - Math.max(e.from, r.from);
        this.syncGutters(n < (r.to - r.from) * 0.8);
      }
      t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + 'px'),
        this.view.state.facet(I0) != !this.fixed &&
          ((this.fixed = !this.fixed), (this.dom.style.position = this.fixed ? 'sticky' : '')),
        (this.prevViewport = t.view.viewport);
    }
    syncGutters(t) {
      let e = this.dom.nextSibling;
      t && this.dom.remove();
      let r = _t.iter(this.view.state.facet(Zh), this.view.viewport.from),
        n = [],
        i = this.gutters.map((s) => new SI(s, this.view.viewport, -this.view.documentPadding.top));
      for (let s of this.view.viewportLineBlocks)
        if ((n.length && (n = []), Array.isArray(s.type))) {
          let o = !0;
          for (let l of s.type)
            if (l.type == ln.Text && o) {
              N0(r, n, l.from);
              for (let c of i) c.line(this.view, l, n);
              o = !1;
            } else if (l.widget) for (let c of i) c.widget(this.view, l);
        } else if (s.type == ln.Text) {
          N0(r, n, s.from);
          for (let o of i) o.line(this.view, s, n);
        } else if (s.widget) for (let o of i) o.widget(this.view, s);
      for (let s of i) s.finish();
      t && this.view.scrollDOM.insertBefore(this.dom, e);
    }
    updateGutters(t) {
      let e = t.startState.facet(vu),
        r = t.state.facet(vu),
        n =
          t.docChanged ||
          t.heightChanged ||
          t.viewportChanged ||
          !_t.eq(t.startState.facet(Zh), t.state.facet(Zh), t.view.viewport.from, t.view.viewport.to);
      if (e == r) for (let i of this.gutters) i.update(t) && (n = !0);
      else {
        n = !0;
        let i = [];
        for (let s of r) {
          let o = e.indexOf(s);
          o < 0 ? i.push(new Sx(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));
        }
        for (let s of this.gutters) s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
        for (let s of i) this.dom.appendChild(s.dom);
        this.gutters = i;
      }
      return n;
    }
    destroy() {
      for (let t of this.gutters) t.destroy();
      this.dom.remove();
    }
  },
  {
    provide: (t) =>
      ze.scrollMargins.of((e) => {
        let r = e.plugin(t);
        return !r || r.gutters.length == 0 || !r.fixed
          ? null
          : e.textDirection == rr.LTR
          ? { left: r.dom.offsetWidth * e.scaleX }
          : { right: r.dom.offsetWidth * e.scaleX };
      }),
  },
);
function Fx(t) {
  return Array.isArray(t) ? t : [t];
}
function N0(t, e, r) {
  for (; t.value && t.from <= r; ) t.from == r && e.push(t.value), t.next();
}
class SI {
  constructor(e, r, n) {
    (this.gutter = e), (this.height = n), (this.i = 0), (this.cursor = _t.iter(e.markers, r.from));
  }
  addElement(e, r, n) {
    let { gutter: i } = this,
      s = (r.top - this.height) / e.scaleY,
      o = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new e2(e, o, s, n);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else i.elements[this.i].update(e, o, s, n);
    (this.height = r.bottom), this.i++;
  }
  line(e, r, n) {
    let i = [];
    N0(this.cursor, i, r.from), n.length && (i = i.concat(n));
    let s = this.gutter.config.lineMarker(e, r, i);
    s && i.unshift(s);
    let o = this.gutter;
    (i.length == 0 && !o.config.renderEmptyElements) || this.addElement(e, r, i);
  }
  widget(e, r) {
    let n = this.gutter.config.widgetMarker(e, r.widget, r);
    n && this.addElement(e, r, [n]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class Sx {
  constructor(e, r) {
    (this.view = e),
      (this.config = r),
      (this.elements = []),
      (this.spacer = null),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-gutter' + (this.config.class ? ' ' + this.config.class : ''));
    for (let n in r.domEventHandlers)
      this.dom.addEventListener(n, (i) => {
        let s = i.target,
          o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; ) s = s.parentNode;
          let c = s.getBoundingClientRect();
          o = (c.top + c.bottom) / 2;
        } else o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        r.domEventHandlers[n](e, l, i) && i.preventDefault();
      });
    (this.markers = Fx(r.markers(e))),
      r.initialSpacer &&
        ((this.spacer = new e2(e, 0, 0, [r.initialSpacer(e)])),
        this.dom.appendChild(this.spacer.dom),
        (this.spacer.dom.style.cssText += 'visibility: hidden; pointer-events: none'));
  }
  update(e) {
    let r = this.markers;
    if (((this.markers = Fx(this.config.markers(e.view))), this.spacer && this.config.updateSpacer)) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let n = e.view.viewport;
    return (
      !_t.eq(this.markers, r, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1)
    );
  }
  destroy() {
    for (let e of this.elements) e.destroy();
  }
}
class e2 {
  constructor(e, r, n, i) {
    (this.height = -1),
      (this.above = 0),
      (this.markers = []),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-gutterElement'),
      this.update(e, r, n, i);
  }
  update(e, r, n, i) {
    this.height != r && ((this.height = r), (this.dom.style.height = r + 'px')),
      this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + 'px' : ''),
      wI(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let n = 'cm-gutterElement',
      i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o,
        c = s < r.length ? r[s++] : null,
        p = !1;
      if (c) {
        let f = c.elementClass;
        f && (n += ' ' + f);
        for (let m = o; m < this.markers.length; m++)
          if (this.markers[m].compare(c)) {
            (l = m), (p = !0);
            break;
          }
      } else l = this.markers.length;
      for (; o < l; ) {
        let f = this.markers[o++];
        if (f.toDOM) {
          f.destroy(i);
          let m = i.nextSibling;
          i.remove(), (i = m);
        }
      }
      if (!c) break;
      c.toDOM && (p ? (i = i.nextSibling) : this.dom.insertBefore(c.toDOM(e), i)), p && o++;
    }
    (this.dom.className = n), (this.markers = r);
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function wI(t, e) {
  if (t.length != e.length) return !1;
  for (let r = 0; r < t.length; r++) if (!t[r].compare(e[r])) return !1;
  return !0;
}
const TI = Ue.define(),
  $a = Ue.define({
    combine(t) {
      return Wi(
        t,
        { formatNumber: String, domEventHandlers: {} },
        {
          domEventHandlers(e, r) {
            let n = Object.assign({}, e);
            for (let i in r) {
              let s = n[i],
                o = r[i];
              n[i] = s ? (l, c, p) => s(l, c, p) || o(l, c, p) : o;
            }
            return n;
          },
        },
      );
    },
  });
class om extends us {
  constructor(e) {
    super(), (this.number = e);
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function am(t, e) {
  return t.state.facet($a).formatNumber(e, t.state);
}
const kI = vu.compute([$a], (t) => ({
  class: 'cm-lineNumbers',
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(TI);
  },
  lineMarker(e, r, n) {
    return n.some((i) => i.toDOM) ? null : new om(am(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet($a) != e.state.facet($a),
  initialSpacer(e) {
    return new om(am(e, wx(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let n = am(r.view, wx(r.view.state.doc.lines));
    return n == e.number ? e : new om(n);
  },
  domEventHandlers: t.facet($a).domEventHandlers,
}));
function PI(t = {}) {
  return [$a.of(t), ZE(), kI];
}
function wx(t) {
  let e = 9;
  for (; e < t; ) e = e * 10 + 9;
  return e;
}
const BI = new (class extends us {
    constructor() {
      super(...arguments), (this.elementClass = 'cm-activeLineGutter');
    }
  })(),
  II = Zh.compute(['selection'], (t) => {
    let e = [],
      r = -1;
    for (let n of t.selection.ranges) {
      let i = t.doc.lineAt(n.head).from;
      i > r && ((r = i), e.push(BI.range(i)));
    }
    return _t.of(e);
  });
function NI() {
  return II;
}
const t2 = 1024;
let MI = 0;
class lm {
  constructor(e, r) {
    (this.from = e), (this.to = r);
  }
}
class At {
  constructor(e = {}) {
    (this.id = MI++),
      (this.perNode = !!e.perNode),
      (this.deserialize =
        e.deserialize ||
        (() => {
          throw new Error("This node type doesn't define a deserialize function");
        }));
  }
  add(e) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types");
    return (
      typeof e != 'function' && (e = xn.match(e)),
      (r) => {
        let n = e(r);
        return n === void 0 ? null : [this, n];
      }
    );
  }
}
At.closedBy = new At({ deserialize: (t) => t.split(' ') });
At.openedBy = new At({ deserialize: (t) => t.split(' ') });
At.group = new At({ deserialize: (t) => t.split(' ') });
At.contextHash = new At({ perNode: !0 });
At.lookAhead = new At({ perNode: !0 });
At.mounted = new At({ perNode: !0 });
class Cp {
  constructor(e, r, n) {
    (this.tree = e), (this.overlay = r), (this.parser = n);
  }
  static get(e) {
    return e && e.props && e.props[At.mounted.id];
  }
}
const OI = Object.create(null);
class xn {
  constructor(e, r, n, i = 0) {
    (this.name = e), (this.props = r), (this.id = n), (this.flags = i);
  }
  static define(e) {
    let r = e.props && e.props.length ? Object.create(null) : OI,
      n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0),
      i = new xn(e.name || '', r, e.id, n);
    if (e.props) {
      for (let s of e.props)
        if ((Array.isArray(s) || (s = s(i)), s)) {
          if (s[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
          r[s[0].id] = s[1];
        }
    }
    return i;
  }
  prop(e) {
    return this.props[e.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(e) {
    if (typeof e == 'string') {
      if (this.name == e) return !0;
      let r = this.prop(At.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  static match(e) {
    let r = Object.create(null);
    for (let n in e) for (let i of n.split(' ')) r[i] = e[n];
    return (n) => {
      for (let i = n.prop(At.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = r[s < 0 ? n.name : i[s]];
        if (o) return o;
      }
    };
  }
}
xn.none = new xn('', Object.create(null), 0, 8);
class ey {
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError('Node type ids should correspond to array positions when creating a node set');
  }
  extend(...e) {
    let r = [];
    for (let n of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(n);
        o && (i || (i = Object.assign({}, n.props)), (i[o[0].id] = o[1]));
      }
      r.push(i ? new xn(n.name, i, n.id, n.flags) : n);
    }
    return new ey(r);
  }
}
const Fh = new WeakMap(),
  Tx = new WeakMap();
var wr;
(function (t) {
  (t[(t.ExcludeBuffers = 1)] = 'ExcludeBuffers'),
    (t[(t.IncludeAnonymous = 2)] = 'IncludeAnonymous'),
    (t[(t.IgnoreMounts = 4)] = 'IgnoreMounts'),
    (t[(t.IgnoreOverlays = 8)] = 'IgnoreOverlays');
})(wr || (wr = {}));
class fr {
  constructor(e, r, n, i, s) {
    if (
      ((this.type = e),
      (this.children = r),
      (this.positions = n),
      (this.length = i),
      (this.props = null),
      s && s.length)
    ) {
      this.props = Object.create(null);
      for (let [o, l] of s) this.props[typeof o == 'number' ? o : o.id] = l;
    }
  }
  toString() {
    let e = Cp.get(this);
    if (e && !e.overlay) return e.tree.toString();
    let r = '';
    for (let n of this.children) {
      let i = n.toString();
      i && (r && (r += ','), (r += i));
    }
    return this.type.name
      ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
          (r.length ? '(' + r + ')' : '')
      : r;
  }
  cursor(e = 0) {
    return new O0(this.topNode, e);
  }
  cursorAt(e, r = 0, n = 0) {
    let i = Fh.get(this) || this.topNode,
      s = new O0(i);
    return s.moveTo(e, r), Fh.set(this, s._tree), s;
  }
  get topNode() {
    return new Hn(this, 0, 0, null);
  }
  resolve(e, r = 0) {
    let n = Xu(Fh.get(this) || this.topNode, e, r, !1);
    return Fh.set(this, n), n;
  }
  resolveInner(e, r = 0) {
    let n = Xu(Tx.get(this) || this.topNode, e, r, !0);
    return Tx.set(this, n), n;
  }
  resolveStack(e, r = 0) {
    return RI(this, e, r);
  }
  iterate(e) {
    let { enter: r, leave: n, from: i = 0, to: s = this.length } = e,
      o = e.mode || 0,
      l = (o & wr.IncludeAnonymous) > 0;
    for (let c = this.cursor(o | wr.IncludeAnonymous); ; ) {
      let p = !1;
      if (c.from <= s && c.to >= i && ((!l && c.type.isAnonymous) || r(c) !== !1)) {
        if (c.firstChild()) continue;
        p = !0;
      }
      for (; p && n && (l || !c.type.isAnonymous) && n(c), !c.nextSibling(); ) {
        if (!c.parent()) return;
        p = !0;
      }
    }
  }
  prop(e) {
    return e.perNode ? (this.props ? this.props[e.id] : void 0) : this.type.prop(e);
  }
  get propValues() {
    let e = [];
    if (this.props) for (let r in this.props) e.push([+r, this.props[r]]);
    return e;
  }
  balance(e = {}) {
    return this.children.length <= 8
      ? this
      : ny(
          xn.none,
          this.children,
          this.positions,
          0,
          this.children.length,
          0,
          this.length,
          (r, n, i) => new fr(this.type, r, n, i, this.propValues),
          e.makeTree || ((r, n, i) => new fr(xn.none, r, n, i)),
        );
  }
  static build(e) {
    return jI(e);
  }
}
fr.empty = new fr(xn.none, [], [], 0);
class ty {
  constructor(e, r) {
    (this.buffer = e), (this.index = r);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new ty(this.buffer, this.index);
  }
}
class la {
  constructor(e, r, n) {
    (this.buffer = e), (this.length = r), (this.set = n);
  }
  get type() {
    return xn.none;
  }
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; ) e.push(this.childString(r)), (r = this.buffer[r + 3]);
    return e.join(',');
  }
  childString(e) {
    let r = this.buffer[e],
      n = this.buffer[e + 3],
      i = this.set.types[r],
      s = i.name;
    if ((/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), (e += 4), n == e)) return s;
    let o = [];
    for (; e < n; ) o.push(this.childString(e)), (e = this.buffer[e + 3]);
    return s + '(' + o.join(',') + ')';
  }
  findChild(e, r, n, i, s) {
    let { buffer: o } = this,
      l = -1;
    for (let c = e; c != r && !(r2(s, i, o[c + 1], o[c + 2]) && ((l = c), n > 0)); c = o[c + 3]);
    return l;
  }
  slice(e, r, n) {
    let i = this.buffer,
      s = new Uint16Array(r - e),
      o = 0;
    for (let l = e, c = 0; l < r; ) {
      (s[c++] = i[l++]), (s[c++] = i[l++] - n);
      let p = (s[c++] = i[l++] - n);
      (s[c++] = i[l++] - e), (o = Math.max(o, p));
    }
    return new la(s, o, this.set);
  }
}
function r2(t, e, r, n) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return n >= e && r < e;
    case 0:
      return r < e && n > e;
    case 1:
      return r <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function Xu(t, e, r, n) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let o = !n && t instanceof Hn && t.index < 0 ? null : t.parent;
    if (!o) return t;
    t = o;
  }
  let s = n ? 0 : wr.IgnoreOverlays;
  if (n)
    for (let o = t, l = o.parent; l; o = l, l = o.parent)
      o instanceof Hn &&
        o.index < 0 &&
        ((i = l.enter(e, r, s)) === null || i === void 0 ? void 0 : i.from) != o.from &&
        (t = l);
  for (;;) {
    let o = t.enter(e, r, s);
    if (!o) return t;
    t = o;
  }
}
class n2 {
  cursor(e = 0) {
    return new O0(this, e);
  }
  getChild(e, r = null, n = null) {
    let i = kx(this, e, r, n);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, n = null) {
    return kx(this, e, r, n);
  }
  resolve(e, r = 0) {
    return Xu(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return Xu(this, e, r, !0);
  }
  matchContext(e) {
    return M0(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e),
      n = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to) break;
      i.type.isError && i.from == i.to ? ((n = r), (r = i.prevSibling)) : (r = i);
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Hn extends n2 {
  constructor(e, r, n, i) {
    super(), (this._tree = e), (this.from = r), (this.index = n), (this._parent = i);
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, n, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: c } = o._tree, p = r > 0 ? l.length : -1; e != p; e += r) {
        let f = l[e],
          m = c[e] + o.from;
        if (r2(i, n, m, m + f.length)) {
          if (f instanceof la) {
            if (s & wr.ExcludeBuffers) continue;
            let g = f.findChild(0, f.buffer.length, r, n - m, i);
            if (g > -1) return new Hs(new LI(o, f, e, m), null, g);
          } else if (s & wr.IncludeAnonymous || !f.type.isAnonymous || ry(f)) {
            let g;
            if (!(s & wr.IgnoreMounts) && (g = Cp.get(f)) && !g.overlay) return new Hn(g.tree, m, e, o);
            let x = new Hn(f, m, e, o);
            return s & wr.IncludeAnonymous || !x.type.isAnonymous
              ? x
              : x.nextChild(r < 0 ? f.children.length - 1 : 0, r, n, i);
          }
        }
      }
      if (
        s & wr.IncludeAnonymous ||
        !o.type.isAnonymous ||
        (o.index >= 0 ? (e = o.index + r) : (e = r < 0 ? -1 : o._parent._tree.children.length), (o = o._parent), !o)
      )
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(e) {
    return this.nextChild(0, 1, e, 2);
  }
  childBefore(e) {
    return this.nextChild(this._tree.children.length - 1, -1, e, -2);
  }
  enter(e, r, n = 0) {
    let i;
    if (!(n & wr.IgnoreOverlays) && (i = Cp.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((r > 0 ? o <= s : o < s) && (r < 0 ? l >= s : l > s))
          return new Hn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; ) e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function kx(t, e, r, n) {
  let i = t.cursor(),
    s = [];
  if (!i.firstChild()) return s;
  if (r != null) {
    for (; !i.type.is(r); ) if (!i.nextSibling()) return s;
  }
  for (;;) {
    if (n != null && i.type.is(n)) return s;
    if ((i.type.is(e) && s.push(i.node), !i.nextSibling())) return n == null ? s : [];
  }
}
function M0(t, e, r = e.length - 1) {
  for (let n = t.parent; r >= 0; n = n.parent) {
    if (!n) return !1;
    if (!n.type.isAnonymous) {
      if (e[r] && e[r] != n.name) return !1;
      r--;
    }
  }
  return !0;
}
class LI {
  constructor(e, r, n, i) {
    (this.parent = e), (this.buffer = r), (this.index = n), (this.start = i);
  }
}
class Hs extends n2 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, n) {
    super(),
      (this.context = e),
      (this._parent = r),
      (this.index = n),
      (this.type = e.buffer.set.types[e.buffer.buffer[n]]);
  }
  child(e, r, n) {
    let { buffer: i } = this.context,
      s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, n);
    return s < 0 ? null : new Hs(this.context, this, s);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(e) {
    return this.child(1, e, 2);
  }
  childBefore(e) {
    return this.child(-1, e, -2);
  }
  enter(e, r, n = 0) {
    if (n & wr.ExcludeBuffers) return null;
    let { buffer: i } = this.context,
      s = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return s < 0 ? null : new Hs(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
  }
  get nextSibling() {
    let { buffer: e } = this.context,
      r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length)
      ? new Hs(this.context, this._parent, r)
      : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context,
      r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r
      ? this.externalSibling(-1)
      : new Hs(this.context, this._parent, e.findChild(r, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [],
      r = [],
      { buffer: n } = this.context,
      i = this.index + 4,
      s = n.buffer[this.index + 3];
    if (s > i) {
      let o = n.buffer[this.index + 1];
      e.push(n.slice(i, s, o)), r.push(0);
    }
    return new fr(this.type, e, r, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function i2(t) {
  if (!t.length) return null;
  if (t.length == 1) return t[0];
  let e = 0,
    r = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > r.from || o.to < r.to) && ((r = o), (e = s));
  }
  let n = r instanceof Hn && r.index < 0 ? null : r.parent,
    i = t.slice();
  return n ? (i[e] = n) : i.splice(e, 1), new _I(i, r);
}
class _I {
  constructor(e, r) {
    (this.heads = e), (this.node = r);
  }
  get next() {
    return i2(this.heads);
  }
}
function RI(t, e, r) {
  let n = t.resolveInner(e, r),
    i = null;
  for (let s = n instanceof Hn ? n : n.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [n])).push(o.resolve(e, r)), (s = o);
    } else {
      let o = Cp.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new Hn(o.tree, o.overlay[0].from + s.from, 0, null);
        (i || (i = [n])).push(Xu(l, e, r, !1));
      }
    }
  return i ? i2(i) : n;
}
class O0 {
  get name() {
    return this.type.name;
  }
  constructor(e, r = 0) {
    if (
      ((this.mode = r),
      (this.buffer = null),
      (this.stack = []),
      (this.index = 0),
      (this.bufferNode = null),
      e instanceof Hn)
    )
      this.yieldNode(e);
    else {
      (this._tree = e.context.parent), (this.buffer = e.context);
      for (let n = e._parent; n; n = n._parent) this.stack.unshift(n.index);
      (this.bufferNode = e), this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? ((this._tree = e), (this.type = e.type), (this.from = e.from), (this.to = e.to), !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: n, buffer: i } = this.buffer;
    return (
      (this.type = r || i.set.types[i.buffer[e]]),
      (this.from = n + i.buffer[e + 1]),
      (this.to = n + i.buffer[e + 2]),
      !0
    );
  }
  yield(e) {
    return e
      ? e instanceof Hn
        ? ((this.buffer = null), this.yieldNode(e))
        : ((this.buffer = e.context), this.yieldBuf(e.index, e.type))
      : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(e, r, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, n, this.mode));
    let { buffer: i } = this.buffer,
      s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, n);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(e) {
    return this.enterChild(1, e, 2);
  }
  childBefore(e) {
    return this.enterChild(-1, e, -2);
  }
  enter(e, r, n = this.mode) {
    return this.buffer
      ? n & wr.ExcludeBuffers
        ? !1
        : this.enterChild(1, e, r)
      : this.yield(this._tree.enter(e, r, n));
  }
  parent() {
    if (!this.buffer) return this.yieldNode(this.mode & wr.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let e = this.mode & wr.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return (this.buffer = null), this.yieldNode(e);
  }
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent
        ? this.yield(
            this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode),
          )
        : !1;
    let { buffer: r } = this.buffer,
      n = this.stack.length - 1;
    if (e < 0) {
      let i = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != i) return this.yieldBuf(r.findChild(i, this.index, -1, 0, 4));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (n < 0 ? r.buffer.length : r.buffer[this.stack[n] + 3])) return this.yieldBuf(i);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r,
      n,
      { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length) return !1;
      } else for (let s = 0; s < this.index; s++) if (i.buffer.buffer[s + 3] < this.index) return !1;
      ({ index: r, parent: n } = i);
    } else ({ index: r, _parent: n } = this._tree);
    for (; n; { index: r, _parent: n } = n)
      if (r > -1)
        for (let s = r + e, o = e < 0 ? -1 : n._tree.children.length; s != o; s += e) {
          let l = n._tree.children[s];
          if (this.mode & wr.IncludeAnonymous || l instanceof la || !l.type.isAnonymous || ry(l)) return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(e, 0, 4)) return !0;
    for (;;) {
      if (this.sibling(e)) return !0;
      if (this.atLastNode(e) || !this.parent()) return !1;
    }
  }
  next(e = !0) {
    return this.move(1, e);
  }
  prev(e = !0) {
    return this.move(-1, e);
  }
  moveTo(e, r = 0) {
    for (
      ;
      (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) &&
      this.parent();

    );
    for (; this.enterChild(1, e, r); );
    return this;
  }
  get node() {
    if (!this.buffer) return this._tree;
    let e = this.bufferNode,
      r = null,
      n = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index) return o;
            (r = o), (n = s + 1);
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = n; i < this.stack.length; i++) r = new Hs(this.buffer, r, this.stack[i]);
    return (this.bufferNode = new Hs(this.buffer, r, this.index));
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(e, r) {
    for (let n = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && r && r(this), (i = this.type.isAnonymous), !this.nextSibling(); ) {
        if (!n) return;
        this.parent(), n--, (i = !0);
      }
    }
  }
  matchContext(e) {
    if (!this.buffer) return M0(this.node, e);
    let { buffer: r } = this.buffer,
      { types: n } = r.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0) return M0(this.node, e, i);
      let o = n[r.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name) return !1;
        i--;
      }
    }
    return !0;
  }
}
function ry(t) {
  return t.children.some((e) => e instanceof la || !e.type.isAnonymous || ry(e));
}
function jI(t) {
  var e;
  let { buffer: r, nodeSet: n, maxBufferLength: i = t2, reused: s = [], minRepeatType: o = n.types.length } = t,
    l = Array.isArray(r) ? new ty(r, r.length) : r,
    c = n.types,
    p = 0,
    f = 0;
  function m(j, $, L, se, Y) {
    let { id: W, start: X, end: q, size: xe } = l,
      Re = f;
    for (; xe < 0; )
      if ((l.next(), xe == -1)) {
        let G = s[W];
        L.push(G), se.push(X - j);
        return;
      } else if (xe == -3) {
        p = W;
        return;
      } else if (xe == -4) {
        f = W;
        return;
      } else throw new RangeError(`Unrecognized record size: ${xe}`);
    let re = c[W],
      ie,
      Q,
      ce = X - j;
    if (q - X <= i && (Q = F(l.pos - $, Y))) {
      let G = new Uint16Array(Q.size - Q.skip),
        ge = l.pos - Q.size,
        we = G.length;
      for (; l.pos > ge; ) we = E(Q.start, G, we);
      (ie = new la(G, q - Q.start, n)), (ce = Q.start - j);
    } else {
      let G = l.pos - xe;
      l.next();
      let ge = [],
        we = [],
        je = W >= o ? W : -1,
        Qe = 0,
        ot = q;
      for (; l.pos > G; )
        je >= 0 && l.id == je && l.size >= 0
          ? (l.end <= ot - i && (x(ge, we, X, Qe, l.end, ot, je, Re), (Qe = ge.length), (ot = l.end)), l.next())
          : m(X, G, ge, we, je);
      if (
        (je >= 0 && Qe > 0 && Qe < ge.length && x(ge, we, X, Qe, X, ot, je, Re),
        ge.reverse(),
        we.reverse(),
        je > -1 && Qe > 0)
      ) {
        let pt = g(re);
        ie = ny(re, ge, we, 0, ge.length, 0, q - X, pt, pt);
      } else ie = b(re, ge, we, q - X, Re - q);
    }
    L.push(ie), se.push(ce);
  }
  function g(j) {
    return ($, L, se) => {
      let Y = 0,
        W = $.length - 1,
        X,
        q;
      if (W >= 0 && (X = $[W]) instanceof fr) {
        if (!W && X.type == j && X.length == se) return X;
        (q = X.prop(At.lookAhead)) && (Y = L[W] + X.length + q);
      }
      return b(j, $, L, se, Y);
    };
  }
  function x(j, $, L, se, Y, W, X, q) {
    let xe = [],
      Re = [];
    for (; j.length > se; ) xe.push(j.pop()), Re.push($.pop() + L - Y);
    j.push(b(n.types[X], xe, Re, W - Y, q - W)), $.push(Y - L);
  }
  function b(j, $, L, se, Y = 0, W) {
    if (p) {
      let X = [At.contextHash, p];
      W = W ? [X].concat(W) : [X];
    }
    if (Y > 25) {
      let X = [At.lookAhead, Y];
      W = W ? [X].concat(W) : [X];
    }
    return new fr(j, $, L, se, W);
  }
  function F(j, $) {
    let L = l.fork(),
      se = 0,
      Y = 0,
      W = 0,
      X = L.end - i,
      q = { size: 0, start: 0, skip: 0 };
    e: for (let xe = L.pos - j; L.pos > xe; ) {
      let Re = L.size;
      if (L.id == $ && Re >= 0) {
        (q.size = se), (q.start = Y), (q.skip = W), (W += 4), (se += 4), L.next();
        continue;
      }
      let re = L.pos - Re;
      if (Re < 0 || re < xe || L.start < X) break;
      let ie = L.id >= o ? 4 : 0,
        Q = L.start;
      for (L.next(); L.pos > re; ) {
        if (L.size < 0)
          if (L.size == -3) ie += 4;
          else break e;
        else L.id >= o && (ie += 4);
        L.next();
      }
      (Y = Q), (se += Re), (W += ie);
    }
    return ($ < 0 || se == j) && ((q.size = se), (q.start = Y), (q.skip = W)), q.size > 4 ? q : void 0;
  }
  function E(j, $, L) {
    let { id: se, start: Y, end: W, size: X } = l;
    if ((l.next(), X >= 0 && se < o)) {
      let q = L;
      if (X > 4) {
        let xe = l.pos - (X - 4);
        for (; l.pos > xe; ) L = E(j, $, L);
      }
      ($[--L] = q), ($[--L] = W - j), ($[--L] = Y - j), ($[--L] = se);
    } else X == -3 ? (p = se) : X == -4 && (f = se);
    return L;
  }
  let w = [],
    I = [];
  for (; l.pos > 0; ) m(t.start || 0, t.bufferStart || 0, w, I, -1);
  let T = (e = t.length) !== null && e !== void 0 ? e : w.length ? I[0] + w[0].length : 0;
  return new fr(c[t.topID], w.reverse(), I.reverse(), T);
}
const Px = new WeakMap();
function ep(t, e) {
  if (!t.isAnonymous || e instanceof la || e.type != t) return 1;
  let r = Px.get(e);
  if (r == null) {
    r = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof fr)) {
        r = 1;
        break;
      }
      r += ep(t, n);
    }
    Px.set(e, r);
  }
  return r;
}
function ny(t, e, r, n, i, s, o, l, c) {
  let p = 0;
  for (let b = n; b < i; b++) p += ep(t, e[b]);
  let f = Math.ceil((p * 1.5) / 8),
    m = [],
    g = [];
  function x(b, F, E, w, I) {
    for (let T = E; T < w; ) {
      let j = T,
        $ = F[T],
        L = ep(t, b[T]);
      for (T++; T < w; T++) {
        let se = ep(t, b[T]);
        if (L + se >= f) break;
        L += se;
      }
      if (T == j + 1) {
        if (L > f) {
          let se = b[j];
          x(se.children, se.positions, 0, se.children.length, F[j] + I);
          continue;
        }
        m.push(b[j]);
      } else {
        let se = F[T - 1] + b[T - 1].length - $;
        m.push(ny(t, b, F, j, T, $, se, null, c));
      }
      g.push($ + I - s);
    }
  }
  return x(e, r, n, i, 0), (l || c)(m, g, o);
}
class Yo {
  constructor(e, r, n, i, s = !1, o = !1) {
    (this.from = e), (this.to = r), (this.tree = n), (this.offset = i), (this.open = (s ? 1 : 0) | (o ? 2 : 0));
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(e, r = [], n = !1) {
    let i = [new Yo(0, e.length, e, 0, !1, n)];
    for (let s of r) s.to > e.length && i.push(s);
    return i;
  }
  static applyChanges(e, r, n = 128) {
    if (!r.length) return e;
    let i = [],
      s = 1,
      o = e.length ? e[0] : null;
    for (let l = 0, c = 0, p = 0; ; l++) {
      let f = l < r.length ? r[l] : null,
        m = f ? f.fromA : 1e9;
      if (m - c >= n)
        for (; o && o.from < m; ) {
          let g = o;
          if (c >= g.from || m <= g.to || p) {
            let x = Math.max(g.from, c) - p,
              b = Math.min(g.to, m) - p;
            g = x >= b ? null : new Yo(x, b, g.tree, g.offset + p, l > 0, !!f);
          }
          if ((g && i.push(g), o.to > m)) break;
          o = s < e.length ? e[s++] : null;
        }
      if (!f) break;
      (c = f.toA), (p = f.toA - f.toB);
    }
    return i;
  }
}
class s2 {
  startParse(e, r, n) {
    return (
      typeof e == 'string' && (e = new $I(e)),
      (n = n ? (n.length ? n.map((i) => new lm(i.from, i.to)) : [new lm(0, 0)]) : [new lm(0, e.length)]),
      this.createParse(e, r || [], n)
    );
  }
  parse(e, r, n) {
    let i = this.startParse(e, r, n);
    for (;;) {
      let s = i.advance();
      if (s) return s;
    }
  }
}
class $I {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
new At({ perNode: !0 });
let VI = 0;
class ki {
  constructor(e, r, n) {
    (this.set = e), (this.base = r), (this.modified = n), (this.id = VI++);
  }
  static define(e) {
    if (e != null && e.base) throw new Error('Can not derive from a modified tag');
    let r = new ki([], null, []);
    if ((r.set.push(r), e)) for (let n of e.set) r.set.push(n);
    return r;
  }
  static defineModifier() {
    let e = new bp();
    return (r) =>
      r.modified.indexOf(e) > -1
        ? r
        : bp.get(
            r.base || r,
            r.modified.concat(e).sort((n, i) => n.id - i.id),
          );
  }
}
let zI = 0;
class bp {
  constructor() {
    (this.instances = []), (this.id = zI++);
  }
  static get(e, r) {
    if (!r.length) return e;
    let n = r[0].instances.find((l) => l.base == e && HI(r, l.modified));
    if (n) return n;
    let i = [],
      s = new ki(i, e, r);
    for (let l of r) l.instances.push(s);
    let o = WI(r);
    for (let l of e.set) if (!l.modified.length) for (let c of o) i.push(bp.get(l, c));
    return s;
  }
}
function HI(t, e) {
  return t.length == e.length && t.every((r, n) => r == e[n]);
}
function WI(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++) for (let n = 0, i = e.length; n < i; n++) e.push(e[n].concat(t[r]));
  return e.sort((r, n) => n.length - r.length);
}
function o2(t) {
  let e = Object.create(null);
  for (let r in t) {
    let n = t[r];
    Array.isArray(n) || (n = [n]);
    for (let i of r.split(' '))
      if (i) {
        let s = [],
          o = 2,
          l = i;
        for (let m = 0; ; ) {
          if (l == '...' && m > 0 && m + 3 == i.length) {
            o = 1;
            break;
          }
          let g = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!g) throw new RangeError('Invalid path: ' + i);
          if ((s.push(g[0] == '*' ? '' : g[0][0] == '"' ? JSON.parse(g[0]) : g[0]), (m += g[0].length), m == i.length))
            break;
          let x = i[m++];
          if (m == i.length && x == '!') {
            o = 0;
            break;
          }
          if (x != '/') throw new RangeError('Invalid path: ' + i);
          l = i.slice(m);
        }
        let c = s.length - 1,
          p = s[c];
        if (!p) throw new RangeError('Invalid path: ' + i);
        let f = new Ap(n, o, c > 0 ? s.slice(0, c) : null);
        e[p] = f.sort(e[p]);
      }
  }
  return a2.add(e);
}
const a2 = new At();
class Ap {
  constructor(e, r, n, i) {
    (this.tags = e), (this.mode = r), (this.context = n), (this.next = i);
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? ((this.next = e), this) : ((e.next = this.sort(e.next)), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Ap.empty = new Ap([], 2, null);
function l2(t, e) {
  let r = Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag)) r[s.tag.id] = s.class;
    else for (let o of s.tag) r[o.id] = s.class;
  let { scope: n, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let c of l.set) {
          let p = r[c.id];
          if (p) {
            o = o ? o + ' ' + p : p;
            break;
          }
        }
      return o;
    },
    scope: n,
  };
}
function UI(t, e) {
  let r = null;
  for (let n of t) {
    let i = n.style(e);
    i && (r = r ? r + ' ' + i : i);
  }
  return r;
}
function qI(t, e, r, n = 0, i = t.length) {
  let s = new KI(n, Array.isArray(e) ? e : [e], r);
  s.highlightRange(t.cursor(), n, i, '', s.highlighters), s.flush(i);
}
class KI {
  constructor(e, r, n) {
    (this.at = e), (this.highlighters = r), (this.span = n), (this.class = '');
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), (this.class = r));
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, n, i, s) {
    let { type: o, from: l, to: c } = e;
    if (l >= n || c <= r) return;
    o.isTop && (s = this.highlighters.filter((x) => !x.scope || x.scope(o)));
    let p = i,
      f = JI(e) || Ap.empty,
      m = UI(s, f.tags);
    if (
      (m && (p && (p += ' '), (p += m), f.mode == 1 && (i += (i ? ' ' : '') + m)),
      this.startSpan(Math.max(r, l), p),
      f.opaque)
    )
      return;
    let g = e.tree && e.tree.prop(At.mounted);
    if (g && g.overlay) {
      let x = e.node.enter(g.overlay[0].from + l, 1),
        b = this.highlighters.filter((E) => !E.scope || E.scope(g.tree.type)),
        F = e.firstChild();
      for (let E = 0, w = l; ; E++) {
        let I = E < g.overlay.length ? g.overlay[E] : null,
          T = I ? I.from + l : c,
          j = Math.max(r, w),
          $ = Math.min(n, T);
        if (j < $ && F)
          for (
            ;
            e.from < $ &&
            (this.highlightRange(e, j, $, i, s),
            this.startSpan(Math.min($, e.to), p),
            !(e.to >= T || !e.nextSibling()));

          );
        if (!I || T > n) break;
        (w = I.to + l),
          w > r &&
            (this.highlightRange(x.cursor(), Math.max(r, I.from + l), Math.min(n, w), '', b),
            this.startSpan(Math.min(n, w), p));
      }
      F && e.parent();
    } else if (e.firstChild()) {
      g && (i = '');
      do
        if (!(e.to <= r)) {
          if (e.from >= n) break;
          this.highlightRange(e, r, n, i, s), this.startSpan(Math.min(n, e.to), p);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function JI(t) {
  let e = t.type.prop(a2);
  for (; e && e.context && !t.matchContext(e.context); ) e = e.next;
  return e || null;
}
const Be = ki.define,
  Sh = Be(),
  Ls = Be(),
  Bx = Be(Ls),
  Ix = Be(Ls),
  _s = Be(),
  wh = Be(_s),
  um = Be(_s),
  Si = Be(),
  Mo = Be(Si),
  vi = Be(),
  Fi = Be(),
  L0 = Be(),
  tu = Be(L0),
  Th = Be(),
  Pe = {
    comment: Sh,
    lineComment: Be(Sh),
    blockComment: Be(Sh),
    docComment: Be(Sh),
    name: Ls,
    variableName: Be(Ls),
    typeName: Bx,
    tagName: Be(Bx),
    propertyName: Ix,
    attributeName: Be(Ix),
    className: Be(Ls),
    labelName: Be(Ls),
    namespace: Be(Ls),
    macroName: Be(Ls),
    literal: _s,
    string: wh,
    docString: Be(wh),
    character: Be(wh),
    attributeValue: Be(wh),
    number: um,
    integer: Be(um),
    float: Be(um),
    bool: Be(_s),
    regexp: Be(_s),
    escape: Be(_s),
    color: Be(_s),
    url: Be(_s),
    keyword: vi,
    self: Be(vi),
    null: Be(vi),
    atom: Be(vi),
    unit: Be(vi),
    modifier: Be(vi),
    operatorKeyword: Be(vi),
    controlKeyword: Be(vi),
    definitionKeyword: Be(vi),
    moduleKeyword: Be(vi),
    operator: Fi,
    derefOperator: Be(Fi),
    arithmeticOperator: Be(Fi),
    logicOperator: Be(Fi),
    bitwiseOperator: Be(Fi),
    compareOperator: Be(Fi),
    updateOperator: Be(Fi),
    definitionOperator: Be(Fi),
    typeOperator: Be(Fi),
    controlOperator: Be(Fi),
    punctuation: L0,
    separator: Be(L0),
    bracket: tu,
    angleBracket: Be(tu),
    squareBracket: Be(tu),
    paren: Be(tu),
    brace: Be(tu),
    content: Si,
    heading: Mo,
    heading1: Be(Mo),
    heading2: Be(Mo),
    heading3: Be(Mo),
    heading4: Be(Mo),
    heading5: Be(Mo),
    heading6: Be(Mo),
    contentSeparator: Be(Si),
    list: Be(Si),
    quote: Be(Si),
    emphasis: Be(Si),
    strong: Be(Si),
    link: Be(Si),
    monospace: Be(Si),
    strikethrough: Be(Si),
    inserted: Be(),
    deleted: Be(),
    changed: Be(),
    invalid: Be(),
    meta: Th,
    documentMeta: Be(Th),
    annotation: Be(Th),
    processingInstruction: Be(Th),
    definition: ki.defineModifier(),
    constant: ki.defineModifier(),
    function: ki.defineModifier(),
    standard: ki.defineModifier(),
    local: ki.defineModifier(),
    special: ki.defineModifier(),
  };
l2([
  { tag: Pe.link, class: 'tok-link' },
  { tag: Pe.heading, class: 'tok-heading' },
  { tag: Pe.emphasis, class: 'tok-emphasis' },
  { tag: Pe.strong, class: 'tok-strong' },
  { tag: Pe.keyword, class: 'tok-keyword' },
  { tag: Pe.atom, class: 'tok-atom' },
  { tag: Pe.bool, class: 'tok-bool' },
  { tag: Pe.url, class: 'tok-url' },
  { tag: Pe.labelName, class: 'tok-labelName' },
  { tag: Pe.inserted, class: 'tok-inserted' },
  { tag: Pe.deleted, class: 'tok-deleted' },
  { tag: Pe.literal, class: 'tok-literal' },
  { tag: Pe.string, class: 'tok-string' },
  { tag: Pe.number, class: 'tok-number' },
  { tag: [Pe.regexp, Pe.escape, Pe.special(Pe.string)], class: 'tok-string2' },
  { tag: Pe.variableName, class: 'tok-variableName' },
  { tag: Pe.local(Pe.variableName), class: 'tok-variableName tok-local' },
  { tag: Pe.definition(Pe.variableName), class: 'tok-variableName tok-definition' },
  { tag: Pe.special(Pe.variableName), class: 'tok-variableName2' },
  { tag: Pe.definition(Pe.propertyName), class: 'tok-propertyName tok-definition' },
  { tag: Pe.typeName, class: 'tok-typeName' },
  { tag: Pe.namespace, class: 'tok-namespace' },
  { tag: Pe.className, class: 'tok-className' },
  { tag: Pe.macroName, class: 'tok-macroName' },
  { tag: Pe.propertyName, class: 'tok-propertyName' },
  { tag: Pe.operator, class: 'tok-operator' },
  { tag: Pe.comment, class: 'tok-comment' },
  { tag: Pe.meta, class: 'tok-meta' },
  { tag: Pe.invalid, class: 'tok-invalid' },
  { tag: Pe.punctuation, class: 'tok-punctuation' },
]);
var cm;
const Va = new At();
function XI(t) {
  return Ue.define({ combine: t ? (e) => e.concat(t) : void 0 });
}
const GI = new At();
class si {
  constructor(e, r, n = [], i = '') {
    (this.data = e),
      (this.name = i),
      Ct.prototype.hasOwnProperty('tree') ||
        Object.defineProperty(Ct.prototype, 'tree', {
          get() {
            return jr(this);
          },
        }),
      (this.parser = r),
      (this.extension = [
        ao.of(this),
        Ct.languageData.of((s, o, l) => {
          let c = Nx(s, o, l),
            p = c.type.prop(Va);
          if (!p) return [];
          let f = s.facet(p),
            m = c.type.prop(GI);
          if (m) {
            let g = c.resolve(o - c.from, l);
            for (let x of m)
              if (x.test(g, s)) {
                let b = s.facet(x.facet);
                return x.type == 'replace' ? b : b.concat(f);
              }
          }
          return f;
        }),
      ].concat(n));
  }
  isActiveAt(e, r, n = -1) {
    return Nx(e, r, n).type.prop(Va) == this.data;
  }
  findRegions(e) {
    let r = e.facet(ao);
    if ((r == null ? void 0 : r.data) == this.data) return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting) return [];
    let n = [],
      i = (s, o) => {
        if (s.prop(Va) == this.data) {
          n.push({ from: o, to: o + s.length });
          return;
        }
        let l = s.prop(At.mounted);
        if (l) {
          if (l.tree.prop(Va) == this.data) {
            if (l.overlay) for (let c of l.overlay) n.push({ from: c.from + o, to: c.to + o });
            else n.push({ from: o, to: o + s.length });
            return;
          } else if (l.overlay) {
            let c = n.length;
            if ((i(l.tree, l.overlay[0].from + o), n.length > c)) return;
          }
        }
        for (let c = 0; c < s.children.length; c++) {
          let p = s.children[c];
          p instanceof fr && i(p, s.positions[c] + o);
        }
      };
    return i(jr(e), 0), n;
  }
  get allowsNesting() {
    return !0;
  }
}
si.setState = mt.define();
function Nx(t, e, r) {
  let n = t.facet(ao),
    i = jr(t).topNode;
  if (!n || n.allowsNesting) for (let s = i; s; s = s.enter(e, r, wr.ExcludeBuffers)) s.type.isTop && (i = s);
  return i;
}
class Ep extends si {
  constructor(e, r, n) {
    super(e, r, [], n), (this.parser = r);
  }
  static define(e) {
    let r = XI(e.languageData);
    return new Ep(r, e.parser.configure({ props: [Va.add((n) => (n.isTop ? r : void 0))] }), e.name);
  }
  configure(e, r) {
    return new Ep(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function jr(t) {
  let e = t.field(si.state, !1);
  return e ? e.tree : fr.empty;
}
class YI {
  constructor(e) {
    (this.doc = e), (this.cursorPos = 0), (this.string = ''), (this.cursor = e.iter());
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return (
      (this.string = this.cursor.next(e - this.cursorPos).value),
      (this.cursorPos = e + this.string.length),
      this.cursorPos - this.string.length
    );
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let n = this.cursorPos - this.string.length;
    return e < n || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - n, r - n);
  }
}
let ru = null;
class vp {
  constructor(e, r, n = [], i, s, o, l, c) {
    (this.parser = e),
      (this.state = r),
      (this.fragments = n),
      (this.tree = i),
      (this.treeLen = s),
      (this.viewport = o),
      (this.skipped = l),
      (this.scheduleOn = c),
      (this.parse = null),
      (this.tempSkipped = []);
  }
  static create(e, r, n) {
    return new vp(e, r, [], fr.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new YI(this.state.doc), this.fragments);
  }
  work(e, r) {
    return (
      r != null && r >= this.state.doc.length && (r = void 0),
      this.tree != fr.empty && this.isDone(r ?? this.state.doc.length)
        ? (this.takeTree(), !0)
        : this.withContext(() => {
            var n;
            if (typeof e == 'number') {
              let i = Date.now() + e;
              e = () => Date.now() > i;
            }
            for (
              this.parse || (this.parse = this.startParse()),
                r != null &&
                  (this.parse.stoppedAt == null || this.parse.stoppedAt > r) &&
                  r < this.state.doc.length &&
                  this.parse.stopAt(r);
              ;

            ) {
              let i = this.parse.advance();
              if (i)
                if (
                  ((this.fragments = this.withoutTempSkipped(
                    Yo.addTree(i, this.fragments, this.parse.stoppedAt != null),
                  )),
                  (this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length),
                  (this.tree = i),
                  (this.parse = null),
                  this.treeLen < (r ?? this.state.doc.length))
                )
                  this.parse = this.startParse();
                else return !0;
              if (e()) return !1;
            }
          })
    );
  }
  takeTree() {
    let e, r;
    this.parse &&
      (e = this.parse.parsedPos) >= this.treeLen &&
      ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e),
      this.withContext(() => {
        for (; !(r = this.parse.advance()); );
      }),
      (this.treeLen = e),
      (this.tree = r),
      (this.fragments = this.withoutTempSkipped(Yo.addTree(this.tree, this.fragments, !0))),
      (this.parse = null));
  }
  withContext(e) {
    let r = ru;
    ru = this;
    try {
      return e();
    } finally {
      ru = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; (r = this.tempSkipped.pop()); ) e = Mx(e, r.from, r.to);
    return e;
  }
  changes(e, r) {
    let { fragments: n, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if ((this.takeTree(), !e.empty)) {
      let c = [];
      if (
        (e.iterChangedRanges((p, f, m, g) => c.push({ fromA: p, toA: f, fromB: m, toB: g })),
        (n = Yo.applyChanges(n, c)),
        (i = fr.empty),
        (s = 0),
        (o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }),
        this.skipped.length)
      ) {
        l = [];
        for (let p of this.skipped) {
          let f = e.mapPos(p.from, 1),
            m = e.mapPos(p.to, -1);
          f < m && l.push({ from: f, to: m });
        }
      }
    }
    return new vp(this.parser, r, n, i, s, o, l, this.scheduleOn);
  }
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to) return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: i, to: s } = this.skipped[n];
      i < e.to && s > e.from && ((this.fragments = Mx(this.fragments, i, s)), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), (this.parse = null));
  }
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  static getSkippingParser(e) {
    return new (class extends s2 {
      createParse(r, n, i) {
        let s = i[0].from,
          o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let c = ru;
            if (c) {
              for (let p of i) c.tempSkipped.push(p);
              e && (c.scheduleOn = c.scheduleOn ? Promise.all([c.scheduleOn, e]) : e);
            }
            return (this.parsedPos = o), new fr(xn.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {},
        };
      }
    })();
  }
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  static get() {
    return ru;
  }
}
function Mx(t, e, r) {
  return Yo.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class ll {
  constructor(e) {
    (this.context = e), (this.tree = e.tree);
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree) return this;
    let r = this.context.changes(e.changes, e.state),
      n =
        this.context.treeLen == e.startState.doc.length
          ? void 0
          : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, n) || r.takeTree(), new ll(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length),
      n = vp.create(e.facet(ao).parser, e, { from: 0, to: r });
    return n.work(20, r) || n.takeTree(), new ll(n);
  }
}
si.state = vr.define({
  create: ll.init,
  update(t, e) {
    for (let r of e.effects) if (r.is(si.setState)) return r.value;
    return e.startState.facet(ao) != e.state.facet(ao) ? ll.init(e.state) : t.apply(e);
  },
});
let u2 = (t) => {
  let e = setTimeout(() => t(), 500);
  return () => clearTimeout(e);
};
typeof requestIdleCallback < 'u' &&
  (u2 = (t) => {
    let e = -1,
      r = setTimeout(() => {
        e = requestIdleCallback(t, { timeout: 500 - 100 });
      }, 100);
    return () => (e < 0 ? clearTimeout(r) : cancelIdleCallback(e));
  });
const hm =
    typeof navigator < 'u' && !((cm = navigator.scheduling) === null || cm === void 0) && cm.isInputPending
      ? () => navigator.scheduling.isInputPending()
      : null,
  QI = ar.fromClass(
    class {
      constructor(e) {
        (this.view = e),
          (this.working = null),
          (this.workScheduled = 0),
          (this.chunkEnd = -1),
          (this.chunkBudget = -1),
          (this.work = this.work.bind(this)),
          this.scheduleWork();
      }
      update(e) {
        let r = this.view.state.field(si.state).context;
        (r.updateViewport(e.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(),
          (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()),
          this.checkAsyncSchedule(r);
      }
      scheduleWork() {
        if (this.working) return;
        let { state: e } = this.view,
          r = e.field(si.state);
        (r.tree != r.context.tree || !r.context.isDone(e.doc.length)) && (this.working = u2(this.work));
      }
      work(e) {
        this.working = null;
        let r = Date.now();
        if (
          (this.chunkEnd < r &&
            (this.chunkEnd < 0 || this.view.hasFocus) &&
            ((this.chunkEnd = r + 3e4), (this.chunkBudget = 3e3)),
          this.chunkBudget <= 0)
        )
          return;
        let {
            state: n,
            viewport: { to: i },
          } = this.view,
          s = n.field(si.state);
        if (s.tree == s.context.tree && s.context.isDone(i + 1e5)) return;
        let o = Date.now() + Math.min(this.chunkBudget, 100, e && !hm ? Math.max(25, e.timeRemaining() - 5) : 1e9),
          l = s.context.treeLen < i && n.doc.length > i + 1e3,
          c = s.context.work(() => (hm && hm()) || Date.now() > o, i + (l ? 0 : 1e5));
        (this.chunkBudget -= Date.now() - r),
          (c || this.chunkBudget <= 0) &&
            (s.context.takeTree(), this.view.dispatch({ effects: si.setState.of(new ll(s.context)) })),
          this.chunkBudget > 0 && !(c && !l) && this.scheduleWork(),
          this.checkAsyncSchedule(s.context);
      }
      checkAsyncSchedule(e) {
        e.scheduleOn &&
          (this.workScheduled++,
          e.scheduleOn
            .then(() => this.scheduleWork())
            .catch((r) => Vn(this.view.state, r))
            .then(() => this.workScheduled--),
          (e.scheduleOn = null));
      }
      destroy() {
        this.working && this.working();
      }
      isWorking() {
        return !!(this.working || this.workScheduled > 0);
      }
    },
    {
      eventHandlers: {
        focus() {
          this.scheduleWork();
        },
      },
    },
  ),
  ao = Ue.define({
    combine(t) {
      return t.length ? t[0] : null;
    },
    enables: (t) => [
      si.state,
      QI,
      ze.contentAttributes.compute([t], (e) => {
        let r = e.facet(t);
        return r && r.name ? { 'data-language': r.name } : {};
      }),
    ],
  });
class ZI {
  constructor(e, r = []) {
    (this.language = e), (this.support = r), (this.extension = [e, r]);
  }
}
const eN = Ue.define(),
  vf = Ue.define({
    combine: (t) => {
      if (!t.length) return '  ';
      let e = t[0];
      if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
        throw new Error('Invalid indent unit: ' + JSON.stringify(t[0]));
      return e;
    },
  });
function Fp(t) {
  let e = t.facet(vf);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function Gu(t, e) {
  let r = '',
    n = t.tabSize,
    i = t.facet(vf)[0];
  if (i == '	') {
    for (; e >= n; ) (r += '	'), (e -= n);
    i = ' ';
  }
  for (let s = 0; s < e; s++) r += i;
  return r;
}
function iy(t, e) {
  t instanceof Ct && (t = new Ff(t));
  for (let n of t.state.facet(eN)) {
    let i = n(t, e);
    if (i !== void 0) return i;
  }
  let r = jr(t.state);
  return r.length >= e ? tN(t, r, e) : null;
}
class Ff {
  constructor(e, r = {}) {
    (this.state = e), (this.options = r), (this.unit = Fp(e));
  }
  lineAt(e, r = 1) {
    let n = this.state.doc.lineAt(e),
      { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= n.from && i <= n.to
      ? s && i == e
        ? { text: '', from: e }
        : (r < 0 ? i < e : i <= e)
        ? { text: n.text.slice(i - n.from), from: i }
        : { text: n.text.slice(0, i - n.from), from: n.from }
      : n;
  }
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak) return '';
    let { text: n, from: i } = this.lineAt(e, r);
    return n.slice(e - i, Math.min(n.length, e + 100 - i));
  }
  column(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r),
      s = this.countColumn(n, e - i),
      o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(n, n.search(/\S|$/))), s;
  }
  countColumn(e, r = e.length) {
    return Cl(e, this.state.tabSize, r);
  }
  lineIndent(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r),
      s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1) return o;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const c2 = new At();
function tN(t, e, r) {
  let n = e.resolveStack(r),
    i = n.node.enterUnfinishedNodesBefore(r);
  if (i != n.node) {
    let s = [];
    for (let o = i; o != n.node; o = o.parent) s.push(o);
    for (let o = s.length - 1; o >= 0; o--) n = { node: s[o], next: n };
  }
  return h2(n, t, r);
}
function h2(t, e, r) {
  for (let n = t; n; n = n.next) {
    let i = nN(n.node);
    if (i) return i(sy.create(e, r, n));
  }
  return 0;
}
function rN(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function nN(t) {
  let e = t.type.prop(c2);
  if (e) return e;
  let r = t.firstChild,
    n;
  if (r && (n = r.type.prop(At.closedBy))) {
    let i = t.lastChild,
      s = i && n.indexOf(i.name) > -1;
    return (o) => aN(o, !0, 1, void 0, s && !rN(o) ? i.from : void 0);
  }
  return t.parent == null ? iN : null;
}
function iN() {
  return 0;
}
class sy extends Ff {
  constructor(e, r, n) {
    super(e.state, e.options), (this.base = e), (this.pos = r), (this.context = n);
  }
  get node() {
    return this.context.node;
  }
  static create(e, r, n) {
    return new sy(e, r, n);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (;;) {
      let n = e.resolve(r.from);
      for (; n.parent && n.parent.from == n.from; ) n = n.parent;
      if (sN(n, e)) break;
      r = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(r.from);
  }
  continue() {
    return h2(this.context.next, this.base, this.pos);
  }
}
function sN(t, e) {
  for (let r = e; r; r = r.parent) if (t == r) return !0;
  return !1;
}
function oN(t) {
  let e = t.node,
    r = e.childAfter(e.from),
    n = e.lastChild;
  if (!r) return null;
  let i = t.options.simulateBreak,
    s = t.state.doc.lineAt(r.from),
    o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = r.to; ; ) {
    let c = e.childAfter(l);
    if (!c || c == n) return null;
    if (!c.type.isSkipped) return c.from < o ? r : null;
    l = c.to;
  }
}
function aN(t, e, r, n, i) {
  let s = t.textAfter,
    o = s.match(/^\s*/)[0].length,
    l = (n && s.slice(o, o + n.length) == n) || i == t.pos + o,
    c = e ? oN(t) : null;
  return c ? (l ? t.column(c.from) : t.column(c.to)) : t.baseIndent + (l ? 0 : t.unit * r);
}
function Ox({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let n = t && t.test(r.textAfter);
    return r.baseIndent + (n ? 0 : e * r.unit);
  };
}
const lN = 200;
function uN() {
  return Ct.transactionFilter.of((t) => {
    if (!t.docChanged || (!t.isUserEvent('input.type') && !t.isUserEvent('input.complete'))) return t;
    let e = t.startState.languageDataAt('indentOnInput', t.startState.selection.main.head);
    if (!e.length) return t;
    let r = t.newDoc,
      { head: n } = t.newSelection.main,
      i = r.lineAt(n);
    if (n > i.from + lN) return t;
    let s = r.sliceString(i.from, n);
    if (!e.some((p) => p.test(s))) return t;
    let { state: o } = t,
      l = -1,
      c = [];
    for (let { head: p } of o.selection.ranges) {
      let f = o.doc.lineAt(p);
      if (f.from == l) continue;
      l = f.from;
      let m = iy(o, f.from);
      if (m == null) continue;
      let g = /^\s*/.exec(f.text)[0],
        x = Gu(o, m);
      g != x && c.push({ from: f.from, to: f.from + g.length, insert: x });
    }
    return c.length ? [t, { changes: c, sequential: !0 }] : t;
  });
}
const cN = Ue.define(),
  p2 = new At();
function hN(t) {
  let e = t.firstChild,
    r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
function pN(t, e, r) {
  let n = jr(t);
  if (n.length < r) return null;
  let i = n.resolveStack(r, 1),
    s = null;
  for (let o = i; o; o = o.next) {
    let l = o.node;
    if (l.to <= r || l.from > r) continue;
    if (s && l.from < e) break;
    let c = l.type.prop(p2);
    if (c && (l.to < n.length - 50 || n.length == t.doc.length || !fN(l))) {
      let p = c(l, t);
      p && p.from <= r && p.from >= e && p.to > r && (s = p);
    }
  }
  return s;
}
function fN(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function Sp(t, e, r) {
  for (let n of t.facet(cN)) {
    let i = n(t, e, r);
    if (i) return i;
  }
  return pN(t, e, r);
}
function f2(t, e) {
  let r = e.mapPos(t.from, 1),
    n = e.mapPos(t.to, -1);
  return r >= n ? void 0 : { from: r, to: n };
}
const Sf = mt.define({ map: f2 }),
  hc = mt.define({ map: f2 });
function d2(t) {
  let e = [];
  for (let { head: r } of t.state.selection.ranges) e.some((n) => n.from <= r && n.to >= r) || e.push(t.lineBlockAt(r));
  return e;
}
const ra = vr.define({
  create() {
    return it.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let r of e.effects)
      if (r.is(Sf) && !dN(t, r.value.from, r.value.to)) {
        let { preparePlaceholder: n } = e.state.facet(oy),
          i = n ? it.replace({ widget: new bN(n(e.state, r.value)) }) : Lx;
        t = t.update({ add: [i.range(r.value.from, r.value.to)] });
      } else
        r.is(hc) &&
          (t = t.update({
            filter: (n, i) => r.value.from != n || r.value.to != i,
            filterFrom: r.value.from,
            filterTo: r.value.to,
          }));
    if (e.selection) {
      let r = !1,
        { head: n } = e.selection.main;
      t.between(n, n, (i, s) => {
        i < n && s > n && (r = !0);
      }),
        r && (t = t.update({ filterFrom: n, filterTo: n, filter: (i, s) => s <= n || i >= n }));
    }
    return t;
  },
  provide: (t) => ze.decorations.from(t),
  toJSON(t, e) {
    let r = [];
    return (
      t.between(0, e.doc.length, (n, i) => {
        r.push(n, i);
      }),
      r
    );
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2) throw new RangeError('Invalid JSON for fold state');
    let e = [];
    for (let r = 0; r < t.length; ) {
      let n = t[r++],
        i = t[r++];
      if (typeof n != 'number' || typeof i != 'number') throw new RangeError('Invalid JSON for fold state');
      e.push(Lx.range(n, i));
    }
    return it.set(e, !0);
  },
});
function wp(t, e, r) {
  var n;
  let i = null;
  return (
    (n = t.field(ra, !1)) === null ||
      n === void 0 ||
      n.between(e, r, (s, o) => {
        (!i || i.from > s) && (i = { from: s, to: o });
      }),
    i
  );
}
function dN(t, e, r) {
  let n = !1;
  return (
    t.between(e, e, (i, s) => {
      i == e && s == r && (n = !0);
    }),
    n
  );
}
function m2(t, e) {
  return t.field(ra, !1) ? e : e.concat(mt.appendConfig.of(y2()));
}
const mN = (t) => {
    for (let e of d2(t)) {
      let r = Sp(t.state, e.from, e.to);
      if (r) return t.dispatch({ effects: m2(t.state, [Sf.of(r), g2(t, r)]) }), !0;
    }
    return !1;
  },
  gN = (t) => {
    if (!t.state.field(ra, !1)) return !1;
    let e = [];
    for (let r of d2(t)) {
      let n = wp(t.state, r.from, r.to);
      n && e.push(hc.of(n), g2(t, n, !1));
    }
    return e.length && t.dispatch({ effects: e }), e.length > 0;
  };
function g2(t, e, r = !0) {
  let n = t.state.doc.lineAt(e.from).number,
    i = t.state.doc.lineAt(e.to).number;
  return ze.announce.of(`${t.state.phrase(r ? 'Folded lines' : 'Unfolded lines')} ${n} ${t.state.phrase('to')} ${i}.`);
}
const yN = (t) => {
    let { state: e } = t,
      r = [];
    for (let n = 0; n < e.doc.length; ) {
      let i = t.lineBlockAt(n),
        s = Sp(e, i.from, i.to);
      s && r.push(Sf.of(s)), (n = (s ? t.lineBlockAt(s.to) : i).to + 1);
    }
    return r.length && t.dispatch({ effects: m2(t.state, r) }), !!r.length;
  },
  DN = (t) => {
    let e = t.state.field(ra, !1);
    if (!e || !e.size) return !1;
    let r = [];
    return (
      e.between(0, t.state.doc.length, (n, i) => {
        r.push(hc.of({ from: n, to: i }));
      }),
      t.dispatch({ effects: r }),
      !0
    );
  },
  xN = [
    { key: 'Ctrl-Shift-[', mac: 'Cmd-Alt-[', run: mN },
    { key: 'Ctrl-Shift-]', mac: 'Cmd-Alt-]', run: gN },
    { key: 'Ctrl-Alt-[', run: yN },
    { key: 'Ctrl-Alt-]', run: DN },
  ],
  CN = { placeholderDOM: null, preparePlaceholder: null, placeholderText: '…' },
  oy = Ue.define({
    combine(t) {
      return Wi(t, CN);
    },
  });
function y2(t) {
  let e = [ra, vN];
  return t && e.push(oy.of(t)), e;
}
function D2(t, e) {
  let { state: r } = t,
    n = r.facet(oy),
    i = (o) => {
      let l = t.lineBlockAt(t.posAtDOM(o.target)),
        c = wp(t.state, l.from, l.to);
      c && t.dispatch({ effects: hc.of(c) }), o.preventDefault();
    };
  if (n.placeholderDOM) return n.placeholderDOM(t, i, e);
  let s = document.createElement('span');
  return (
    (s.textContent = n.placeholderText),
    s.setAttribute('aria-label', r.phrase('folded code')),
    (s.title = r.phrase('unfold')),
    (s.className = 'cm-foldPlaceholder'),
    (s.onclick = i),
    s
  );
}
const Lx = it.replace({
  widget: new (class extends gs {
    toDOM(t) {
      return D2(t, null);
    }
  })(),
});
class bN extends gs {
  constructor(e) {
    super(), (this.value = e);
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return D2(e, this.value);
  }
}
const AN = { openText: '⌄', closedText: '›', markerDOM: null, domEventHandlers: {}, foldingChanged: () => !1 };
class pm extends us {
  constructor(e, r) {
    super(), (this.config = e), (this.open = r);
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let r = document.createElement('span');
    return (
      (r.textContent = this.open ? this.config.openText : this.config.closedText),
      (r.title = e.state.phrase(this.open ? 'Fold line' : 'Unfold line')),
      r
    );
  }
}
function EN(t = {}) {
  let e = Object.assign(Object.assign({}, AN), t),
    r = new pm(e, !0),
    n = new pm(e, !1),
    i = ar.fromClass(
      class {
        constructor(o) {
          (this.from = o.viewport.from), (this.markers = this.buildMarkers(o));
        }
        update(o) {
          (o.docChanged ||
            o.viewportChanged ||
            o.startState.facet(ao) != o.state.facet(ao) ||
            o.startState.field(ra, !1) != o.state.field(ra, !1) ||
            jr(o.startState) != jr(o.state) ||
            e.foldingChanged(o)) &&
            (this.markers = this.buildMarkers(o.view));
        }
        buildMarkers(o) {
          let l = new no();
          for (let c of o.viewportLineBlocks) {
            let p = wp(o.state, c.from, c.to) ? n : Sp(o.state, c.from, c.to) ? r : null;
            p && l.add(c.from, c.from, p);
          }
          return l.finish();
        }
      },
    ),
    { domEventHandlers: s } = e;
  return [
    i,
    vI({
      class: 'cm-foldGutter',
      markers(o) {
        var l;
        return ((l = o.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || _t.empty;
      },
      initialSpacer() {
        return new pm(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), {
        click: (o, l, c) => {
          if (s.click && s.click(o, l, c)) return !0;
          let p = wp(o.state, l.from, l.to);
          if (p) return o.dispatch({ effects: hc.of(p) }), !0;
          let f = Sp(o.state, l.from, l.to);
          return f ? (o.dispatch({ effects: Sf.of(f) }), !0) : !1;
        },
      }),
    }),
    y2(),
  ];
}
const vN = ze.baseTheme({
  '.cm-foldPlaceholder': {
    backgroundColor: '#eee',
    border: '1px solid #ddd',
    color: '#888',
    borderRadius: '.2em',
    margin: '0 1px',
    padding: '0 1px',
    cursor: 'pointer',
  },
  '.cm-foldGutter span': { padding: '0 1px', cursor: 'pointer' },
});
class wf {
  constructor(e, r) {
    this.specs = e;
    let n;
    function i(l) {
      let c = io.newName();
      return ((n || (n = Object.create(null)))['.' + c] = l), c;
    }
    const s = typeof r.all == 'string' ? r.all : r.all ? i(r.all) : void 0,
      o = r.scope;
    (this.scope = o instanceof si ? (l) => l.prop(Va) == o.data : o ? (l) => l == o : void 0),
      (this.style = l2(
        e.map((l) => ({ tag: l.tag, class: l.class || i(Object.assign({}, l, { tag: null })) })),
        { all: s },
      ).style),
      (this.module = n ? new io(n) : null),
      (this.themeType = r.themeType);
  }
  static define(e, r) {
    return new wf(e, r || {});
  }
}
const _0 = Ue.define(),
  x2 = Ue.define({
    combine(t) {
      return t.length ? [t[0]] : null;
    },
  });
function fm(t) {
  let e = t.facet(_0);
  return e.length ? e : t.facet(x2);
}
function FN(t, e) {
  let r = [wN],
    n;
  return (
    t instanceof wf && (t.module && r.push(ze.styleModule.of(t.module)), (n = t.themeType)),
    e != null && e.fallback
      ? r.push(x2.of(t))
      : n
      ? r.push(_0.computeN([ze.darkTheme], (i) => (i.facet(ze.darkTheme) == (n == 'dark') ? [t] : [])))
      : r.push(_0.of(t)),
    r
  );
}
class SN {
  constructor(e) {
    (this.markCache = Object.create(null)),
      (this.tree = jr(e.state)),
      (this.decorations = this.buildDeco(e, fm(e.state)));
  }
  update(e) {
    let r = jr(e.state),
      n = fm(e.state),
      i = n != fm(e.startState);
    r.length < e.view.viewport.to && !i && r.type == this.tree.type
      ? (this.decorations = this.decorations.map(e.changes))
      : (r != this.tree || e.viewportChanged || i) && ((this.tree = r), (this.decorations = this.buildDeco(e.view, n)));
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length) return it.none;
    let n = new no();
    for (let { from: i, to: s } of e.visibleRanges)
      qI(
        this.tree,
        r,
        (o, l, c) => {
          n.add(o, l, this.markCache[c] || (this.markCache[c] = it.mark({ class: c })));
        },
        i,
        s,
      );
    return n.finish();
  }
}
const wN = xl.high(ar.fromClass(SN, { decorations: (t) => t.decorations })),
  TN = wf.define([
    { tag: Pe.meta, color: '#404740' },
    { tag: Pe.link, textDecoration: 'underline' },
    { tag: Pe.heading, textDecoration: 'underline', fontWeight: 'bold' },
    { tag: Pe.emphasis, fontStyle: 'italic' },
    { tag: Pe.strong, fontWeight: 'bold' },
    { tag: Pe.strikethrough, textDecoration: 'line-through' },
    { tag: Pe.keyword, color: '#708' },
    { tag: [Pe.atom, Pe.bool, Pe.url, Pe.contentSeparator, Pe.labelName], color: '#219' },
    { tag: [Pe.literal, Pe.inserted], color: '#164' },
    { tag: [Pe.string, Pe.deleted], color: '#a11' },
    { tag: [Pe.regexp, Pe.escape, Pe.special(Pe.string)], color: '#e40' },
    { tag: Pe.definition(Pe.variableName), color: '#00f' },
    { tag: Pe.local(Pe.variableName), color: '#30a' },
    { tag: [Pe.typeName, Pe.namespace], color: '#085' },
    { tag: Pe.className, color: '#167' },
    { tag: [Pe.special(Pe.variableName), Pe.macroName], color: '#256' },
    { tag: Pe.definition(Pe.propertyName), color: '#00c' },
    { tag: Pe.comment, color: '#940' },
    { tag: Pe.invalid, color: '#f00' },
  ]),
  kN = ze.baseTheme({
    '&.cm-focused .cm-matchingBracket': { backgroundColor: '#328c8252' },
    '&.cm-focused .cm-nonmatchingBracket': { backgroundColor: '#bb555544' },
  }),
  C2 = 1e4,
  b2 = '()[]{}',
  A2 = Ue.define({
    combine(t) {
      return Wi(t, { afterCursor: !0, brackets: b2, maxScanDistance: C2, renderMatch: IN });
    },
  }),
  PN = it.mark({ class: 'cm-matchingBracket' }),
  BN = it.mark({ class: 'cm-nonmatchingBracket' });
function IN(t) {
  let e = [],
    r = t.matched ? PN : BN;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const NN = vr.define({
    create() {
      return it.none;
    },
    update(t, e) {
      if (!e.docChanged && !e.selection) return t;
      let r = [],
        n = e.state.facet(A2);
      for (let i of e.state.selection.ranges) {
        if (!i.empty) continue;
        let s =
          Mi(e.state, i.head, -1, n) ||
          (i.head > 0 && Mi(e.state, i.head - 1, 1, n)) ||
          (n.afterCursor &&
            (Mi(e.state, i.head, 1, n) || (i.head < e.state.doc.length && Mi(e.state, i.head + 1, -1, n))));
        s && (r = r.concat(n.renderMatch(s, e.state)));
      }
      return it.set(r, !0);
    },
    provide: (t) => ze.decorations.from(t),
  }),
  MN = [NN, kN];
function ON(t = {}) {
  return [A2.of(t), MN];
}
const LN = new At();
function R0(t, e, r) {
  let n = t.prop(e < 0 ? At.openedBy : At.closedBy);
  if (n) return n;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0)) return [r[i + e]];
  }
  return null;
}
function j0(t) {
  let e = t.type.prop(LN);
  return e ? e(t.node) : t;
}
function Mi(t, e, r, n = {}) {
  let i = n.maxScanDistance || C2,
    s = n.brackets || b2,
    o = jr(t),
    l = o.resolveInner(e, r);
  for (let c = l; c; c = c.parent) {
    let p = R0(c.type, r, s);
    if (p && c.from < c.to) {
      let f = j0(c);
      if (f && (r > 0 ? e >= f.from && e < f.to : e > f.from && e <= f.to)) return _N(t, e, r, c, f, p, s);
    }
  }
  return RN(t, e, r, o, l.type, i, s);
}
function _N(t, e, r, n, i, s, o) {
  let l = n.parent,
    c = { from: i.from, to: i.to },
    p = 0,
    f = l == null ? void 0 : l.cursor();
  if (f && (r < 0 ? f.childBefore(n.from) : f.childAfter(n.to)))
    do
      if (r < 0 ? f.to <= n.from : f.from >= n.to) {
        if (p == 0 && s.indexOf(f.type.name) > -1 && f.from < f.to) {
          let m = j0(f);
          return { start: c, end: m ? { from: m.from, to: m.to } : void 0, matched: !0 };
        } else if (R0(f.type, r, o)) p++;
        else if (R0(f.type, -r, o)) {
          if (p == 0) {
            let m = j0(f);
            return { start: c, end: m && m.from < m.to ? { from: m.from, to: m.to } : void 0, matched: !1 };
          }
          p--;
        }
      }
    while (r < 0 ? f.prevSibling() : f.nextSibling());
  return { start: c, matched: !1 };
}
function RN(t, e, r, n, i, s, o) {
  let l = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1),
    c = o.indexOf(l);
  if (c < 0 || (c % 2 == 0) != r > 0) return null;
  let p = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e },
    f = t.doc.iterRange(e, r > 0 ? t.doc.length : 0),
    m = 0;
  for (let g = 0; !f.next().done && g <= s; ) {
    let x = f.value;
    r < 0 && (g += x.length);
    let b = e + g * r;
    for (let F = r > 0 ? 0 : x.length - 1, E = r > 0 ? x.length : -1; F != E; F += r) {
      let w = o.indexOf(x[F]);
      if (!(w < 0 || n.resolveInner(b + F, 1).type != i))
        if ((w % 2 == 0) == r > 0) m++;
        else {
          if (m == 1) return { start: p, end: { from: b + F, to: b + F + 1 }, matched: w >> 1 == c >> 1 };
          m--;
        }
    }
    r > 0 && (g += x.length);
  }
  return f.done ? { start: p, matched: !1 } : null;
}
const jN = Object.create(null),
  _x = [xn.none],
  Rx = [],
  $N = Object.create(null);
for (let [t, e] of [
  ['variable', 'variableName'],
  ['variable-2', 'variableName.special'],
  ['string-2', 'string.special'],
  ['def', 'variableName.definition'],
  ['tag', 'tagName'],
  ['attribute', 'attributeName'],
  ['type', 'typeName'],
  ['builtin', 'variableName.standard'],
  ['qualifier', 'modifier'],
  ['error', 'invalid'],
  ['header', 'heading'],
  ['property', 'propertyName'],
])
  $N[t] = VN(jN, e);
function dm(t, e) {
  Rx.indexOf(t) > -1 || (Rx.push(t), console.warn(e));
}
function VN(t, e) {
  let r = null;
  for (let s of e.split('.')) {
    let o = t[s] || Pe[s];
    o
      ? typeof o == 'function'
        ? r
          ? (r = o(r))
          : dm(s, `Modifier ${s} used at start of tag`)
        : r
        ? dm(s, `Tag ${s} used as modifier`)
        : (r = o)
      : dm(s, `Unknown highlighting tag ${s}`);
  }
  if (!r) return 0;
  let n = e.replace(/ /g, '_'),
    i = xn.define({ id: _x.length, name: n, props: [o2({ [n]: r })] });
  return _x.push(i), i.id;
}
const zN = (t) => {
  let { state: e } = t,
    r = e.doc.lineAt(e.selection.main.from),
    n = ly(t.state, r.from);
  return n.line ? HN(t) : n.block ? UN(t) : !1;
};
function ay(t, e) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly) return !1;
    let i = t(e, r);
    return i ? (n(r.update(i)), !0) : !1;
  };
}
const HN = ay(JN, 0),
  WN = ay(E2, 0),
  UN = ay((t, e) => E2(t, e, KN(e)), 0);
function ly(t, e) {
  let r = t.languageDataAt('commentTokens', e);
  return r.length ? r[0] : {};
}
const nu = 50;
function qN(t, { open: e, close: r }, n, i) {
  let s = t.sliceDoc(n - nu, n),
    o = t.sliceDoc(i, i + nu),
    l = /\s*$/.exec(s)[0].length,
    c = /^\s*/.exec(o)[0].length,
    p = s.length - l;
  if (s.slice(p - e.length, p) == e && o.slice(c, c + r.length) == r)
    return { open: { pos: n - l, margin: l && 1 }, close: { pos: i + c, margin: c && 1 } };
  let f, m;
  i - n <= 2 * nu ? (f = m = t.sliceDoc(n, i)) : ((f = t.sliceDoc(n, n + nu)), (m = t.sliceDoc(i - nu, i)));
  let g = /^\s*/.exec(f)[0].length,
    x = /\s*$/.exec(m)[0].length,
    b = m.length - x - r.length;
  return f.slice(g, g + e.length) == e && m.slice(b, b + r.length) == r
    ? {
        open: { pos: n + g + e.length, margin: /\s/.test(f.charAt(g + e.length)) ? 1 : 0 },
        close: { pos: i - x - r.length, margin: /\s/.test(m.charAt(b - 1)) ? 1 : 0 },
      }
    : null;
}
function KN(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let n = t.doc.lineAt(r.from),
      i = r.to <= n.to ? n : t.doc.lineAt(r.to),
      s = e.length - 1;
    s >= 0 && e[s].to > n.from ? (e[s].to = i.to) : e.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: i.to });
  }
  return e;
}
function E2(t, e, r = e.selection.ranges) {
  let n = r.map((s) => ly(e, s.from).block);
  if (!n.every((s) => s)) return null;
  let i = r.map((s, o) => qN(e, n[o], s.from, s.to));
  if (t != 2 && !i.every((s) => s))
    return {
      changes: e.changes(
        r.map((s, o) =>
          i[o]
            ? []
            : [
                { from: s.from, insert: n[o].open + ' ' },
                { from: s.to, insert: ' ' + n[o].close },
              ],
        ),
      ),
    };
  if (t != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if ((l = i[o])) {
        let c = n[o],
          { open: p, close: f } = l;
        s.push(
          { from: p.pos - c.open.length, to: p.pos + p.margin },
          { from: f.pos - f.margin, to: f.pos + c.close.length },
        );
      }
    return { changes: s };
  }
  return null;
}
function JN(t, e, r = e.selection.ranges) {
  let n = [],
    i = -1;
  for (let { from: s, to: o } of r) {
    let l = n.length,
      c = 1e9,
      p = ly(e, s).line;
    if (p) {
      for (let f = s; f <= o; ) {
        let m = e.doc.lineAt(f);
        if (m.from > i && (s == o || o > m.from)) {
          i = m.from;
          let g = /^\s*/.exec(m.text)[0].length,
            x = g == m.length,
            b = m.text.slice(g, g + p.length) == p ? g : -1;
          g < m.text.length && g < c && (c = g),
            n.push({ line: m, comment: b, token: p, indent: g, empty: x, single: !1 });
        }
        f = m.to + 1;
      }
      if (c < 1e9) for (let f = l; f < n.length; f++) n[f].indent < n[f].line.text.length && (n[f].indent = c);
      n.length == l + 1 && (n[l].single = !0);
    }
  }
  if (t != 2 && n.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: c, indent: p, empty: f, single: m } of n)
      (m || !f) && s.push({ from: l.from + p, insert: c + ' ' });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && n.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: c } of n)
      if (l >= 0) {
        let p = o.from + l,
          f = p + c.length;
        o.text[f - o.from] == ' ' && f++, s.push({ from: p, to: f });
      }
    return { changes: s };
  }
  return null;
}
const $0 = ms.define(),
  XN = ms.define(),
  GN = Ue.define(),
  v2 = Ue.define({
    combine(t) {
      return Wi(
        t,
        { minDepth: 100, newGroupDelay: 500, joinToEvent: (e, r) => r },
        { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (e, r) => (n, i) => e(n, i) || r(n, i) },
      );
    },
  });
function YN(t) {
  let e = 0;
  return t.iterChangedRanges((r, n) => (e = n)), e;
}
const F2 = vr.define({
  create() {
    return Oi.empty;
  },
  update(t, e) {
    let r = e.state.facet(v2),
      n = e.annotation($0);
    if (n) {
      let c = e.docChanged ? pe.single(YN(e.changes)) : void 0,
        p = gn.fromTransaction(e, c),
        f = n.side,
        m = f == 0 ? t.undone : t.done;
      return (
        p ? (m = Tp(m, m.length, r.minDepth, p)) : (m = T2(m, e.startState.selection)),
        new Oi(f == 0 ? n.rest : m, f == 0 ? m : n.rest)
      );
    }
    let i = e.annotation(XN);
    if (((i == 'full' || i == 'before') && (t = t.isolate()), e.annotation(Ar.addToHistory) === !1))
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = gn.fromTransaction(e),
      o = e.annotation(Ar.time),
      l = e.annotation(Ar.userEvent);
    return (
      s
        ? (t = t.addChanges(s, o, l, r, e))
        : e.selection && (t = t.addSelection(e.startState.selection, o, l, r.newGroupDelay)),
      (i == 'full' || i == 'after') && (t = t.isolate()),
      t
    );
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Oi(t.done.map(gn.fromJSON), t.undone.map(gn.fromJSON));
  },
});
function QN(t = {}) {
  return [
    F2,
    v2.of(t),
    ze.domEventHandlers({
      beforeinput(e, r) {
        let n = e.inputType == 'historyUndo' ? S2 : e.inputType == 'historyRedo' ? V0 : null;
        return n ? (e.preventDefault(), n(r)) : !1;
      },
    }),
  ];
}
function Tf(t, e) {
  return function ({ state: r, dispatch: n }) {
    if (!e && r.readOnly) return !1;
    let i = r.field(F2, !1);
    if (!i) return !1;
    let s = i.pop(t, r, e);
    return s ? (n(s), !0) : !1;
  };
}
const S2 = Tf(0, !1),
  V0 = Tf(1, !1),
  ZN = Tf(0, !0),
  eM = Tf(1, !0);
class gn {
  constructor(e, r, n, i, s) {
    (this.changes = e), (this.effects = r), (this.mapped = n), (this.startSelection = i), (this.selectionsAfter = s);
  }
  setSelAfter(e) {
    return new gn(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON()),
    };
  }
  static fromJSON(e) {
    return new gn(
      e.changes && Cr.fromJSON(e.changes),
      [],
      e.mapped && _i.fromJSON(e.mapped),
      e.startSelection && pe.fromJSON(e.startSelection),
      e.selectionsAfter.map(pe.fromJSON),
    );
  }
  static fromTransaction(e, r) {
    let n = Rn;
    for (let i of e.startState.facet(GN)) {
      let s = i(e);
      s.length && (n = n.concat(s));
    }
    return !n.length && e.changes.empty
      ? null
      : new gn(e.changes.invert(e.startState.doc), n, void 0, r || e.startState.selection, Rn);
  }
  static selection(e) {
    return new gn(void 0, Rn, void 0, void 0, e);
  }
}
function Tp(t, e, r, n) {
  let i = e + 1 > r + 20 ? e - r - 1 : 0,
    s = t.slice(i, e);
  return s.push(n), s;
}
function tM(t, e) {
  let r = [],
    n = !1;
  return (
    t.iterChangedRanges((i, s) => r.push(i, s)),
    e.iterChangedRanges((i, s, o, l) => {
      for (let c = 0; c < r.length; ) {
        let p = r[c++],
          f = r[c++];
        l >= p && o <= f && (n = !0);
      }
    }),
    n
  );
}
function rM(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, n) => r.empty != e.ranges[n].empty).length === 0;
}
function w2(t, e) {
  return t.length ? (e.length ? t.concat(e) : t) : e;
}
const Rn = [],
  nM = 200;
function T2(t, e) {
  if (t.length) {
    let r = t[t.length - 1],
      n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - nM));
    return n.length && n[n.length - 1].eq(e) ? t : (n.push(e), Tp(t, t.length - 1, 1e9, r.setSelAfter(n)));
  } else return [gn.selection([e])];
}
function iM(t) {
  let e = t[t.length - 1],
    r = t.slice();
  return (r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1))), r;
}
function mm(t, e) {
  if (!t.length) return t;
  let r = t.length,
    n = Rn;
  for (; r; ) {
    let i = sM(t[r - 1], e, n);
    if ((i.changes && !i.changes.empty) || i.effects.length) {
      let s = t.slice(0, r);
      return (s[r - 1] = i), s;
    } else (e = i.mapped), r--, (n = i.selectionsAfter);
  }
  return n.length ? [gn.selection(n)] : Rn;
}
function sM(t, e, r) {
  let n = w2(t.selectionsAfter.length ? t.selectionsAfter.map((l) => l.map(e)) : Rn, r);
  if (!t.changes) return gn.selection(n);
  let i = t.changes.map(e),
    s = e.mapDesc(t.changes, !0),
    o = t.mapped ? t.mapped.composeDesc(s) : s;
  return new gn(i, mt.mapEffects(t.effects, e), o, t.startSelection.map(s), n);
}
const oM = /^(input\.type|delete)($|\.)/;
class Oi {
  constructor(e, r, n = 0, i = void 0) {
    (this.done = e), (this.undone = r), (this.prevTime = n), (this.prevUserEvent = i);
  }
  isolate() {
    return this.prevTime ? new Oi(this.done, this.undone) : this;
  }
  addChanges(e, r, n, i, s) {
    let o = this.done,
      l = o[o.length - 1];
    return (
      l &&
      l.changes &&
      !l.changes.empty &&
      e.changes &&
      (!n || oM.test(n)) &&
      ((!l.selectionsAfter.length &&
        r - this.prevTime < i.newGroupDelay &&
        i.joinToEvent(s, tM(l.changes, e.changes))) ||
        n == 'input.type.compose')
        ? (o = Tp(
            o,
            o.length - 1,
            i.minDepth,
            new gn(e.changes.compose(l.changes), w2(e.effects, l.effects), l.mapped, l.startSelection, Rn),
          ))
        : (o = Tp(o, o.length, i.minDepth, e)),
      new Oi(o, Rn, r, n)
    );
  }
  addSelection(e, r, n, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Rn;
    return s.length > 0 &&
      r - this.prevTime < i &&
      n == this.prevUserEvent &&
      n &&
      /^select($|\.)/.test(n) &&
      rM(s[s.length - 1], e)
      ? this
      : new Oi(T2(this.done, e), this.undone, r, n);
  }
  addMapping(e) {
    return new Oi(mm(this.done, e), mm(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, n) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0) return null;
    let s = i[i.length - 1];
    if (n && s.selectionsAfter.length)
      return r.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: $0.of({ side: e, rest: iM(i) }),
        userEvent: e == 0 ? 'select.undo' : 'select.redo',
        scrollIntoView: !0,
      });
    if (s.changes) {
      let o = i.length == 1 ? Rn : i.slice(0, i.length - 1);
      return (
        s.mapped && (o = mm(o, s.mapped)),
        r.update({
          changes: s.changes,
          selection: s.startSelection,
          effects: s.effects,
          annotations: $0.of({ side: e, rest: o }),
          filter: !1,
          userEvent: e == 0 ? 'undo' : 'redo',
          scrollIntoView: !0,
        })
      );
    } else return null;
  }
}
Oi.empty = new Oi(Rn, Rn);
const aM = [
  { key: 'Mod-z', run: S2, preventDefault: !0 },
  { key: 'Mod-y', mac: 'Mod-Shift-z', run: V0, preventDefault: !0 },
  { linux: 'Ctrl-Shift-z', run: V0, preventDefault: !0 },
  { key: 'Mod-u', run: ZN, preventDefault: !0 },
  { key: 'Alt-u', mac: 'Mod-Shift-u', run: eM, preventDefault: !0 },
];
function bl(t, e) {
  return pe.create(t.ranges.map(e), t.mainIndex);
}
function Ui(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: 'select' });
}
function yi({ state: t, dispatch: e }, r) {
  let n = bl(t.selection, r);
  return n.eq(t.selection) ? !1 : (e(Ui(t, n)), !0);
}
function kf(t, e) {
  return pe.cursor(e ? t.to : t.from);
}
function k2(t, e) {
  return yi(t, (r) => (r.empty ? t.moveByChar(r, e) : kf(r, e)));
}
function Qr(t) {
  return t.textDirectionAt(t.state.selection.main.head) == rr.LTR;
}
const P2 = (t) => k2(t, !Qr(t)),
  B2 = (t) => k2(t, Qr(t));
function I2(t, e) {
  return yi(t, (r) => (r.empty ? t.moveByGroup(r, e) : kf(r, e)));
}
const lM = (t) => I2(t, !Qr(t)),
  uM = (t) => I2(t, Qr(t));
function cM(t, e, r) {
  if (e.type.prop(r)) return !0;
  let n = e.to - e.from;
  return (n && (n > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to)))) || e.firstChild;
}
function Pf(t, e, r) {
  let n = jr(t).resolveInner(e.head),
    i = r ? At.closedBy : At.openedBy;
  for (let c = e.head; ; ) {
    let p = r ? n.childAfter(c) : n.childBefore(c);
    if (!p) break;
    cM(t, p, i) ? (n = p) : (c = r ? p.to : p.from);
  }
  let s = n.type.prop(i),
    o,
    l;
  return (
    s && (o = r ? Mi(t, n.from, 1) : Mi(t, n.to, -1)) && o.matched
      ? (l = r ? o.end.to : o.end.from)
      : (l = r ? n.to : n.from),
    pe.cursor(l, r ? -1 : 1)
  );
}
const hM = (t) => yi(t, (e) => Pf(t.state, e, !Qr(t))),
  pM = (t) => yi(t, (e) => Pf(t.state, e, Qr(t)));
function N2(t, e) {
  return yi(t, (r) => {
    if (!r.empty) return kf(r, e);
    let n = t.moveVertically(r, e);
    return n.head != r.head ? n : t.moveToLineBoundary(r, e);
  });
}
const M2 = (t) => N2(t, !1),
  O2 = (t) => N2(t, !0);
function L2(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2,
    r = 0,
    n = 0,
    i;
  if (e) {
    for (let s of t.state.facet(ze.scrollMargins)) {
      let o = s(t);
      o != null && o.top && (r = Math.max(o == null ? void 0 : o.top, r)),
        o != null && o.bottom && (n = Math.max(o == null ? void 0 : o.bottom, n));
    }
    i = t.scrollDOM.clientHeight - r - n;
  } else i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return { marginTop: r, marginBottom: n, selfScroll: e, height: Math.max(t.defaultLineHeight, i - 5) };
}
function _2(t, e) {
  let r = L2(t),
    { state: n } = t,
    i = bl(n.selection, (o) => (o.empty ? t.moveVertically(o, e, r.height) : kf(o, e)));
  if (i.eq(n.selection)) return !1;
  let s;
  if (r.selfScroll) {
    let o = t.coordsAtPos(n.selection.main.head),
      l = t.scrollDOM.getBoundingClientRect(),
      c = l.top + r.marginTop,
      p = l.bottom - r.marginBottom;
    o && o.top > c && o.bottom < p && (s = ze.scrollIntoView(i.main.head, { y: 'start', yMargin: o.top - c }));
  }
  return t.dispatch(Ui(n, i), { effects: s }), !0;
}
const jx = (t) => _2(t, !1),
  z0 = (t) => _2(t, !0);
function po(t, e, r) {
  let n = t.lineBlockAt(e.head),
    i = t.moveToLineBoundary(e, r);
  if (
    (i.head == e.head && i.head != (r ? n.to : n.from) && (i = t.moveToLineBoundary(e, r, !1)),
    !r && i.head == n.from && n.length)
  ) {
    let s = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    s && e.head != n.from + s && (i = pe.cursor(n.from + s));
  }
  return i;
}
const fM = (t) => yi(t, (e) => po(t, e, !0)),
  dM = (t) => yi(t, (e) => po(t, e, !1)),
  mM = (t) => yi(t, (e) => po(t, e, !Qr(t))),
  gM = (t) => yi(t, (e) => po(t, e, Qr(t))),
  yM = (t) => yi(t, (e) => pe.cursor(t.lineBlockAt(e.head).from, 1)),
  DM = (t) => yi(t, (e) => pe.cursor(t.lineBlockAt(e.head).to, -1));
function xM(t, e, r) {
  let n = !1,
    i = bl(t.selection, (s) => {
      let o =
        Mi(t, s.head, -1) ||
        Mi(t, s.head, 1) ||
        (s.head > 0 && Mi(t, s.head - 1, 1)) ||
        (s.head < t.doc.length && Mi(t, s.head + 1, -1));
      if (!o || !o.end) return s;
      n = !0;
      let l = o.start.from == s.head ? o.end.to : o.end.from;
      return r ? pe.range(s.anchor, l) : pe.cursor(l);
    });
  return n ? (e(Ui(t, i)), !0) : !1;
}
const CM = ({ state: t, dispatch: e }) => xM(t, e, !1);
function Jn(t, e) {
  let r = bl(t.state.selection, (n) => {
    let i = e(n);
    return pe.range(n.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(Ui(t.state, r)), !0);
}
function R2(t, e) {
  return Jn(t, (r) => t.moveByChar(r, e));
}
const j2 = (t) => R2(t, !Qr(t)),
  $2 = (t) => R2(t, Qr(t));
function V2(t, e) {
  return Jn(t, (r) => t.moveByGroup(r, e));
}
const bM = (t) => V2(t, !Qr(t)),
  AM = (t) => V2(t, Qr(t)),
  EM = (t) => Jn(t, (e) => Pf(t.state, e, !Qr(t))),
  vM = (t) => Jn(t, (e) => Pf(t.state, e, Qr(t)));
function z2(t, e) {
  return Jn(t, (r) => t.moveVertically(r, e));
}
const H2 = (t) => z2(t, !1),
  W2 = (t) => z2(t, !0);
function U2(t, e) {
  return Jn(t, (r) => t.moveVertically(r, e, L2(t).height));
}
const $x = (t) => U2(t, !1),
  Vx = (t) => U2(t, !0),
  FM = (t) => Jn(t, (e) => po(t, e, !0)),
  SM = (t) => Jn(t, (e) => po(t, e, !1)),
  wM = (t) => Jn(t, (e) => po(t, e, !Qr(t))),
  TM = (t) => Jn(t, (e) => po(t, e, Qr(t))),
  kM = (t) => Jn(t, (e) => pe.cursor(t.lineBlockAt(e.head).from)),
  PM = (t) => Jn(t, (e) => pe.cursor(t.lineBlockAt(e.head).to)),
  zx = ({ state: t, dispatch: e }) => (e(Ui(t, { anchor: 0 })), !0),
  Hx = ({ state: t, dispatch: e }) => (e(Ui(t, { anchor: t.doc.length })), !0),
  Wx = ({ state: t, dispatch: e }) => (e(Ui(t, { anchor: t.selection.main.anchor, head: 0 })), !0),
  Ux = ({ state: t, dispatch: e }) => (e(Ui(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0),
  BM = ({ state: t, dispatch: e }) => (
    e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: 'select' })), !0
  ),
  IM = ({ state: t, dispatch: e }) => {
    let r = Bf(t).map(({ from: n, to: i }) => pe.range(n, Math.min(i + 1, t.doc.length)));
    return e(t.update({ selection: pe.create(r), userEvent: 'select' })), !0;
  },
  NM = ({ state: t, dispatch: e }) => {
    let r = bl(t.selection, (n) => {
      var i;
      let s = jr(t).resolveStack(n.from, 1);
      for (let o = s; o; o = o.next) {
        let { node: l } = o;
        if (
          ((l.from < n.from && l.to >= n.to) || (l.to > n.to && l.from <= n.from)) &&
          !((i = l.parent) === null || i === void 0) &&
          i.parent
        )
          return pe.range(l.to, l.from);
      }
      return n;
    });
    return e(Ui(t, r)), !0;
  },
  MM = ({ state: t, dispatch: e }) => {
    let r = t.selection,
      n = null;
    return (
      r.ranges.length > 1 ? (n = pe.create([r.main])) : r.main.empty || (n = pe.create([pe.cursor(r.main.head)])),
      n ? (e(Ui(t, n)), !0) : !1
    );
  };
function pc(t, e) {
  if (t.state.readOnly) return !1;
  let r = 'delete.selection',
    { state: n } = t,
    i = n.changeByRange((s) => {
      let { from: o, to: l } = s;
      if (o == l) {
        let c = e(s);
        c < o ? ((r = 'delete.backward'), (c = kh(t, c, !1))) : c > o && ((r = 'delete.forward'), (c = kh(t, c, !0))),
          (o = Math.min(o, c)),
          (l = Math.max(l, c));
      } else (o = kh(t, o, !1)), (l = kh(t, l, !0));
      return o == l ? { range: s } : { changes: { from: o, to: l }, range: pe.cursor(o, o < s.head ? -1 : 1) };
    });
  return i.changes.empty
    ? !1
    : (t.dispatch(
        n.update(i, {
          scrollIntoView: !0,
          userEvent: r,
          effects: r == 'delete.selection' ? ze.announce.of(n.phrase('Selection deleted')) : void 0,
        }),
      ),
      !0);
}
function kh(t, e, r) {
  if (t instanceof ze)
    for (let n of t.state.facet(ze.atomicRanges).map((i) => i(t)))
      n.between(e, e, (i, s) => {
        i < e && s > e && (e = r ? s : i);
      });
  return e;
}
const q2 = (t, e) =>
    pc(t, (r) => {
      let n = r.from,
        { state: i } = t,
        s = i.doc.lineAt(n),
        o,
        l;
      if (!e && n > s.from && n < s.from + 200 && !/[^ \t]/.test((o = s.text.slice(0, n - s.from)))) {
        if (o[o.length - 1] == '	') return n - 1;
        let c = Cl(o, i.tabSize),
          p = c % Fp(i) || Fp(i);
        for (let f = 0; f < p && o[o.length - 1 - f] == ' '; f++) n--;
        l = n;
      } else
        (l = Yr(s.text, n - s.from, e, e) + s.from), l == n && s.number != (e ? i.doc.lines : 1) && (l += e ? 1 : -1);
      return l;
    }),
  H0 = (t) => q2(t, !1),
  K2 = (t) => q2(t, !0),
  J2 = (t, e) =>
    pc(t, (r) => {
      let n = r.head,
        { state: i } = t,
        s = i.doc.lineAt(n),
        o = i.charCategorizer(n);
      for (let l = null; ; ) {
        if (n == (e ? s.to : s.from)) {
          n == r.head && s.number != (e ? i.doc.lines : 1) && (n += e ? 1 : -1);
          break;
        }
        let c = Yr(s.text, n - s.from, e) + s.from,
          p = s.text.slice(Math.min(n, c) - s.from, Math.max(n, c) - s.from),
          f = o(p);
        if (l != null && f != l) break;
        (p != ' ' || n != r.head) && (l = f), (n = c);
      }
      return n;
    }),
  X2 = (t) => J2(t, !1),
  OM = (t) => J2(t, !0),
  LM = (t) =>
    pc(t, (e) => {
      let r = t.lineBlockAt(e.head).to;
      return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
    }),
  _M = (t) =>
    pc(t, (e) => {
      let r = t.moveToLineBoundary(e, !1).head;
      return e.head > r ? r : Math.max(0, e.head - 1);
    }),
  RM = (t) =>
    pc(t, (e) => {
      let r = t.moveToLineBoundary(e, !0).head;
      return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
    }),
  jM = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let r = t.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: Ot.of(['', '']) },
      range: pe.cursor(n.from),
    }));
    return e(t.update(r, { scrollIntoView: !0, userEvent: 'input' })), !0;
  },
  $M = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let r = t.changeByRange((n) => {
      if (!n.empty || n.from == 0 || n.from == t.doc.length) return { range: n };
      let i = n.from,
        s = t.doc.lineAt(i),
        o = i == s.from ? i - 1 : Yr(s.text, i - s.from, !1) + s.from,
        l = i == s.to ? i + 1 : Yr(s.text, i - s.from, !0) + s.from;
      return { changes: { from: o, to: l, insert: t.doc.slice(i, l).append(t.doc.slice(o, i)) }, range: pe.cursor(l) };
    });
    return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: 'move.character' })), !0);
  };
function Bf(t) {
  let e = [],
    r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from),
      s = t.doc.lineAt(n.to);
    if ((!n.empty && n.to == s.from && (s = t.doc.lineAt(n.to - 1)), r >= i.number)) {
      let o = e[e.length - 1];
      (o.to = s.to), o.ranges.push(n);
    } else e.push({ from: i.from, to: s.to, ranges: [n] });
    r = s.number + 1;
  }
  return e;
}
function G2(t, e, r) {
  if (t.readOnly) return !1;
  let n = [],
    i = [];
  for (let s of Bf(t)) {
    if (r ? s.to == t.doc.length : s.from == 0) continue;
    let o = t.doc.lineAt(r ? s.to + 1 : s.from - 1),
      l = o.length + 1;
    if (r) {
      n.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + t.lineBreak });
      for (let c of s.ranges)
        i.push(pe.range(Math.min(t.doc.length, c.anchor + l), Math.min(t.doc.length, c.head + l)));
    } else {
      n.push({ from: o.from, to: s.from }, { from: s.to, insert: t.lineBreak + o.text });
      for (let c of s.ranges) i.push(pe.range(c.anchor - l, c.head - l));
    }
  }
  return n.length
    ? (e(
        t.update({
          changes: n,
          scrollIntoView: !0,
          selection: pe.create(i, t.selection.mainIndex),
          userEvent: 'move.line',
        }),
      ),
      !0)
    : !1;
}
const VM = ({ state: t, dispatch: e }) => G2(t, e, !1),
  zM = ({ state: t, dispatch: e }) => G2(t, e, !0);
function Y2(t, e, r) {
  if (t.readOnly) return !1;
  let n = [];
  for (let i of Bf(t))
    r
      ? n.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak })
      : n.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: n, scrollIntoView: !0, userEvent: 'input.copyline' })), !0;
}
const HM = ({ state: t, dispatch: e }) => Y2(t, e, !1),
  WM = ({ state: t, dispatch: e }) => Y2(t, e, !0),
  UM = (t) => {
    if (t.state.readOnly) return !1;
    let { state: e } = t,
      r = e.changes(Bf(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))),
      n = bl(e.selection, (i) => t.moveVertically(i, !0)).map(r);
    return t.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: 'delete.line' }), !0;
  };
function qM(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1))) return { from: e, to: e };
  let r = jr(t).resolveInner(e),
    n = r.childBefore(e),
    i = r.childAfter(e),
    s;
  return n &&
    i &&
    n.to <= e &&
    i.from >= e &&
    (s = n.type.prop(At.closedBy)) &&
    s.indexOf(i.name) > -1 &&
    t.doc.lineAt(n.to).from == t.doc.lineAt(i.from).from &&
    !/\S/.test(t.sliceDoc(n.to, i.from))
    ? { from: n.to, to: i.from }
    : null;
}
const KM = Q2(!1),
  JM = Q2(!0);
function Q2(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly) return !1;
    let n = e.changeByRange((i) => {
      let { from: s, to: o } = i,
        l = e.doc.lineAt(s),
        c = !t && s == o && qM(e, s);
      t && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let p = new Ff(e, { simulateBreak: s, simulateDoubleBreak: !!c }),
        f = iy(p, s);
      for (
        f == null && (f = Cl(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize));
        o < l.to && /\s/.test(l.text[o - l.from]);

      )
        o++;
      c ? ({ from: s, to: o } = c) : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let m = ['', Gu(e, f)];
      return (
        c && m.push(Gu(e, p.lineIndent(l.from, -1))),
        { changes: { from: s, to: o, insert: Ot.of(m) }, range: pe.cursor(s + 1 + m[1].length) }
      );
    });
    return r(e.update(n, { scrollIntoView: !0, userEvent: 'input' })), !0;
  };
}
function uy(t, e) {
  let r = -1;
  return t.changeByRange((n) => {
    let i = [];
    for (let o = n.from; o <= n.to; ) {
      let l = t.doc.lineAt(o);
      l.number > r && (n.empty || n.to > l.from) && (e(l, i, n), (r = l.number)), (o = l.to + 1);
    }
    let s = t.changes(i);
    return { changes: i, range: pe.range(s.mapPos(n.anchor, 1), s.mapPos(n.head, 1)) };
  });
}
const XM = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let r = Object.create(null),
      n = new Ff(t, {
        overrideIndentation: (s) => {
          let o = r[s];
          return o ?? -1;
        },
      }),
      i = uy(t, (s, o, l) => {
        let c = iy(n, s.from);
        if (c == null) return;
        /\S/.test(s.text) || (c = 0);
        let p = /^\s*/.exec(s.text)[0],
          f = Gu(t, c);
        (p != f || l.from < s.from + p.length) &&
          ((r[s.from] = c), o.push({ from: s.from, to: s.from + p.length, insert: f }));
      });
    return i.changes.empty || e(t.update(i, { userEvent: 'indent' })), !0;
  },
  Z2 = ({ state: t, dispatch: e }) =>
    t.readOnly
      ? !1
      : (e(
          t.update(
            uy(t, (r, n) => {
              n.push({ from: r.from, insert: t.facet(vf) });
            }),
            { userEvent: 'input.indent' },
          ),
        ),
        !0),
  ev = ({ state: t, dispatch: e }) =>
    t.readOnly
      ? !1
      : (e(
          t.update(
            uy(t, (r, n) => {
              let i = /^\s*/.exec(r.text)[0];
              if (!i) return;
              let s = Cl(i, t.tabSize),
                o = 0,
                l = Gu(t, Math.max(0, s - Fp(t)));
              for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); ) o++;
              n.push({ from: r.from + o, to: r.from + i.length, insert: l.slice(o) });
            }),
            { userEvent: 'delete.dedent' },
          ),
        ),
        !0),
  GM = [
    { key: 'Ctrl-b', run: P2, shift: j2, preventDefault: !0 },
    { key: 'Ctrl-f', run: B2, shift: $2 },
    { key: 'Ctrl-p', run: M2, shift: H2 },
    { key: 'Ctrl-n', run: O2, shift: W2 },
    { key: 'Ctrl-a', run: yM, shift: kM },
    { key: 'Ctrl-e', run: DM, shift: PM },
    { key: 'Ctrl-d', run: K2 },
    { key: 'Ctrl-h', run: H0 },
    { key: 'Ctrl-k', run: LM },
    { key: 'Ctrl-Alt-h', run: X2 },
    { key: 'Ctrl-o', run: jM },
    { key: 'Ctrl-t', run: $M },
    { key: 'Ctrl-v', run: z0 },
  ],
  YM = [
    { key: 'ArrowLeft', run: P2, shift: j2, preventDefault: !0 },
    { key: 'Mod-ArrowLeft', mac: 'Alt-ArrowLeft', run: lM, shift: bM, preventDefault: !0 },
    { mac: 'Cmd-ArrowLeft', run: mM, shift: wM, preventDefault: !0 },
    { key: 'ArrowRight', run: B2, shift: $2, preventDefault: !0 },
    { key: 'Mod-ArrowRight', mac: 'Alt-ArrowRight', run: uM, shift: AM, preventDefault: !0 },
    { mac: 'Cmd-ArrowRight', run: gM, shift: TM, preventDefault: !0 },
    { key: 'ArrowUp', run: M2, shift: H2, preventDefault: !0 },
    { mac: 'Cmd-ArrowUp', run: zx, shift: Wx },
    { mac: 'Ctrl-ArrowUp', run: jx, shift: $x },
    { key: 'ArrowDown', run: O2, shift: W2, preventDefault: !0 },
    { mac: 'Cmd-ArrowDown', run: Hx, shift: Ux },
    { mac: 'Ctrl-ArrowDown', run: z0, shift: Vx },
    { key: 'PageUp', run: jx, shift: $x },
    { key: 'PageDown', run: z0, shift: Vx },
    { key: 'Home', run: dM, shift: SM, preventDefault: !0 },
    { key: 'Mod-Home', run: zx, shift: Wx },
    { key: 'End', run: fM, shift: FM, preventDefault: !0 },
    { key: 'Mod-End', run: Hx, shift: Ux },
    { key: 'Enter', run: KM },
    { key: 'Mod-a', run: BM },
    { key: 'Backspace', run: H0, shift: H0 },
    { key: 'Delete', run: K2 },
    { key: 'Mod-Backspace', mac: 'Alt-Backspace', run: X2 },
    { key: 'Mod-Delete', mac: 'Alt-Delete', run: OM },
    { mac: 'Mod-Backspace', run: _M },
    { mac: 'Mod-Delete', run: RM },
  ].concat(GM.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))),
  QM = [
    { key: 'Alt-ArrowLeft', mac: 'Ctrl-ArrowLeft', run: hM, shift: EM },
    { key: 'Alt-ArrowRight', mac: 'Ctrl-ArrowRight', run: pM, shift: vM },
    { key: 'Alt-ArrowUp', run: VM },
    { key: 'Shift-Alt-ArrowUp', run: HM },
    { key: 'Alt-ArrowDown', run: zM },
    { key: 'Shift-Alt-ArrowDown', run: WM },
    { key: 'Escape', run: MM },
    { key: 'Mod-Enter', run: JM },
    { key: 'Alt-l', mac: 'Ctrl-l', run: IM },
    { key: 'Mod-i', run: NM, preventDefault: !0 },
    { key: 'Mod-[', run: ev },
    { key: 'Mod-]', run: Z2 },
    { key: 'Mod-Alt-\\', run: XM },
    { key: 'Shift-Mod-k', run: UM },
    { key: 'Shift-Mod-\\', run: CM },
    { key: 'Mod-/', run: zN },
    { key: 'Alt-A', run: WN },
  ].concat(YM),
  ZM = { key: 'Tab', run: Z2, shift: ev };
function Ht() {
  var t = arguments[0];
  typeof t == 'string' && (t = document.createElement(t));
  var e = 1,
    r = arguments[1];
  if (r && typeof r == 'object' && r.nodeType == null && !Array.isArray(r)) {
    for (var n in r)
      if (Object.prototype.hasOwnProperty.call(r, n)) {
        var i = r[n];
        typeof i == 'string' ? t.setAttribute(n, i) : i != null && (t[n] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++) tv(t, arguments[e]);
  return t;
}
function tv(t, e) {
  if (typeof e == 'string') t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null) t.appendChild(e);
    else if (Array.isArray(e)) for (var r = 0; r < e.length; r++) tv(t, e[r]);
    else throw new RangeError('Unsupported child node: ' + e);
}
const qx = typeof String.prototype.normalize == 'function' ? (t) => t.normalize('NFKD') : (t) => t;
class ul {
  constructor(e, r, n = 0, i = e.length, s, o) {
    (this.test = o),
      (this.value = { from: 0, to: 0 }),
      (this.done = !1),
      (this.matches = []),
      (this.buffer = ''),
      (this.bufferPos = 0),
      (this.iter = e.iterRange(n, i)),
      (this.bufferStart = n),
      (this.normalize = s ? (l) => s(qx(l)) : qx),
      (this.query = this.normalize(r));
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (((this.bufferStart += this.buffer.length), this.iter.next(), this.iter.done)) return -1;
      (this.bufferPos = 0), (this.buffer = this.iter.value);
    }
    return Nr(this.buffer, this.bufferPos);
  }
  next() {
    for (; this.matches.length; ) this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (;;) {
      let e = this.peek();
      if (e < 0) return (this.done = !0), this;
      let r = Hg(e),
        n = this.bufferStart + this.bufferPos;
      this.bufferPos += _n(e);
      let i = this.normalize(r);
      for (let s = 0, o = n; ; s++) {
        let l = i.charCodeAt(s),
          c = this.match(l, o);
        if (s == i.length - 1) {
          if (c) return (this.value = c), this;
          break;
        }
        o == n && s < r.length && r.charCodeAt(s) == l && o++;
      }
    }
  }
  match(e, r) {
    let n = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let s = this.matches[i],
        o = !1;
      this.query.charCodeAt(s) == e &&
        (s == this.query.length - 1 ? (n = { from: this.matches[i + 1], to: r + 1 }) : (this.matches[i]++, (o = !0))),
        o || (this.matches.splice(i, 2), (i -= 2));
    }
    return (
      this.query.charCodeAt(0) == e &&
        (this.query.length == 1 ? (n = { from: r, to: r + 1 }) : this.matches.push(1, r)),
      n && this.test && !this.test(n.from, n.to, this.buffer, this.bufferStart) && (n = null),
      n
    );
  }
}
typeof Symbol < 'u' &&
  (ul.prototype[Symbol.iterator] = function () {
    return this;
  });
const rv = { from: -1, to: -1, match: /.*/.exec('') },
  cy = 'gm' + (/x/.unicode == null ? '' : 'u');
class nv {
  constructor(e, r, n, i = 0, s = e.length) {
    if (
      ((this.text = e),
      (this.to = s),
      (this.curLine = ''),
      (this.done = !1),
      (this.value = rv),
      /\\[sWDnr]|\n|\r|\[\^/.test(r))
    )
      return new iv(e, r, n, i, s);
    (this.re = new RegExp(r, cy + (n != null && n.ignoreCase ? 'i' : ''))),
      (this.test = n == null ? void 0 : n.test),
      (this.iter = e.iter());
    let o = e.lineAt(i);
    (this.curLineStart = o.from), (this.matchPos = kp(e, i)), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e),
      this.iter.lineBreak
        ? (this.curLine = '')
        : ((this.curLine = this.iter.value),
          this.curLineStart + this.curLine.length > this.to &&
            (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)),
          this.iter.next());
  }
  nextLine() {
    (this.curLineStart = this.curLineStart + this.curLine.length + 1),
      this.curLineStart > this.to ? (this.curLine = '') : this.getLine(0);
  }
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let n = this.curLineStart + r.index,
          i = n + r[0].length;
        if (
          ((this.matchPos = kp(this.text, i + (n == i ? 1 : 0))),
          n == this.curLineStart + this.curLine.length && this.nextLine(),
          (n < i || n > this.value.to) && (!this.test || this.test(n, i, r)))
        )
          return (this.value = { from: n, to: i, match: r }), this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) this.nextLine(), (e = 0);
      else return (this.done = !0), this;
    }
  }
}
const gm = new WeakMap();
class Ga {
  constructor(e, r) {
    (this.from = e), (this.text = r);
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, n) {
    let i = gm.get(e);
    if (!i || i.from >= n || i.to <= r) {
      let l = new Ga(r, e.sliceString(r, n));
      return gm.set(e, l), l;
    }
    if (i.from == r && i.to == n) return i;
    let { text: s, from: o } = i;
    return (
      o > r && ((s = e.sliceString(r, o) + s), (o = r)),
      i.to < n && (s += e.sliceString(i.to, n)),
      gm.set(e, new Ga(o, s)),
      new Ga(r, s.slice(r - o, n - o))
    );
  }
}
class iv {
  constructor(e, r, n, i, s) {
    (this.text = e),
      (this.to = s),
      (this.done = !1),
      (this.value = rv),
      (this.matchPos = kp(e, i)),
      (this.re = new RegExp(r, cy + (n != null && n.ignoreCase ? 'i' : ''))),
      (this.test = n == null ? void 0 : n.test),
      (this.flat = Ga.get(e, i, this.chunkEnd(i + 5e3)));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (;;) {
      let e = (this.re.lastIndex = this.matchPos - this.flat.from),
        r = this.re.exec(this.flat.text);
      if ((r && !r[0] && r.index == e && ((this.re.lastIndex = e + 1), (r = this.re.exec(this.flat.text))), r)) {
        let n = this.flat.from + r.index,
          i = n + r[0].length;
        if (
          (this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) &&
          (!this.test || this.test(n, i, r))
        )
          return (
            (this.value = { from: n, to: i, match: r }), (this.matchPos = kp(this.text, i + (n == i ? 1 : 0))), this
          );
      }
      if (this.flat.to == this.to) return (this.done = !0), this;
      this.flat = Ga.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < 'u' &&
  (nv.prototype[Symbol.iterator] = iv.prototype[Symbol.iterator] =
    function () {
      return this;
    });
function eO(t) {
  try {
    return new RegExp(t, cy), !0;
  } catch {
    return !1;
  }
}
function kp(t, e) {
  if (e >= t.length) return e;
  let r = t.lineAt(e),
    n;
  for (; e < r.to && (n = r.text.charCodeAt(e - r.from)) >= 56320 && n < 57344; ) e++;
  return e;
}
function W0(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number),
    r = Ht('input', { class: 'cm-textfield', name: 'line', value: e }),
    n = Ht(
      'form',
      {
        class: 'cm-gotoLine',
        onkeydown: (s) => {
          s.keyCode == 27
            ? (s.preventDefault(), t.dispatch({ effects: Pp.of(!1) }), t.focus())
            : s.keyCode == 13 && (s.preventDefault(), i());
        },
        onsubmit: (s) => {
          s.preventDefault(), i();
        },
      },
      Ht('label', t.state.phrase('Go to line'), ': ', r),
      ' ',
      Ht('button', { class: 'cm-button', type: 'submit' }, t.state.phrase('go')),
    );
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!s) return;
    let { state: o } = t,
      l = o.doc.lineAt(o.selection.main.head),
      [, c, p, f, m] = s,
      g = f ? +f.slice(1) : 0,
      x = p ? +p : l.number;
    if (p && m) {
      let E = x / 100;
      c && (E = E * (c == '-' ? -1 : 1) + l.number / o.doc.lines), (x = Math.round(o.doc.lines * E));
    } else p && c && (x = x * (c == '-' ? -1 : 1) + l.number);
    let b = o.doc.line(Math.max(1, Math.min(o.doc.lines, x))),
      F = pe.cursor(b.from + Math.max(0, Math.min(g, b.length)));
    t.dispatch({ effects: [Pp.of(!1), ze.scrollIntoView(F.from, { y: 'center' })], selection: F }), t.focus();
  }
  return { dom: n };
}
const Pp = mt.define(),
  Kx = vr.define({
    create() {
      return !0;
    },
    update(t, e) {
      for (let r of e.effects) r.is(Pp) && (t = r.value);
      return t;
    },
    provide: (t) => Ju.from(t, (e) => (e ? W0 : null)),
  }),
  tO = (t) => {
    let e = Ku(t, W0);
    if (!e) {
      let r = [Pp.of(!0)];
      t.state.field(Kx, !1) == null && r.push(mt.appendConfig.of([Kx, rO])),
        t.dispatch({ effects: r }),
        (e = Ku(t, W0));
    }
    return e && e.dom.querySelector('input').select(), !0;
  },
  rO = ze.baseTheme({ '.cm-panel.cm-gotoLine': { 'padding': '2px 6px 4px', '& label': { fontSize: '80%' } } }),
  nO = { highlightWordAroundCursor: !1, minSelectionLength: 1, maxMatches: 100, wholeWords: !1 },
  sv = Ue.define({
    combine(t) {
      return Wi(t, nO, {
        highlightWordAroundCursor: (e, r) => e || r,
        minSelectionLength: Math.min,
        maxMatches: Math.min,
      });
    },
  });
function iO(t) {
  let e = [uO, lO];
  return t && e.push(sv.of(t)), e;
}
const sO = it.mark({ class: 'cm-selectionMatch' }),
  oO = it.mark({ class: 'cm-selectionMatch cm-selectionMatch-main' });
function Jx(t, e, r, n) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != er.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != er.Word);
}
function aO(t, e, r, n) {
  return t(e.sliceDoc(r, r + 1)) == er.Word && t(e.sliceDoc(n - 1, n)) == er.Word;
}
const lO = ar.fromClass(
    class {
      constructor(t) {
        this.decorations = this.getDeco(t);
      }
      update(t) {
        (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
      }
      getDeco(t) {
        let e = t.state.facet(sv),
          { state: r } = t,
          n = r.selection;
        if (n.ranges.length > 1) return it.none;
        let i = n.main,
          s,
          o = null;
        if (i.empty) {
          if (!e.highlightWordAroundCursor) return it.none;
          let c = r.wordAt(i.head);
          if (!c) return it.none;
          (o = r.charCategorizer(i.head)), (s = r.sliceDoc(c.from, c.to));
        } else {
          let c = i.to - i.from;
          if (c < e.minSelectionLength || c > 200) return it.none;
          if (e.wholeWords) {
            if (
              ((s = r.sliceDoc(i.from, i.to)),
              (o = r.charCategorizer(i.head)),
              !(Jx(o, r, i.from, i.to) && aO(o, r, i.from, i.to)))
            )
              return it.none;
          } else if (((s = r.sliceDoc(i.from, i.to).trim()), !s)) return it.none;
        }
        let l = [];
        for (let c of t.visibleRanges) {
          let p = new ul(r.doc, s, c.from, c.to);
          for (; !p.next().done; ) {
            let { from: f, to: m } = p.value;
            if (
              (!o || Jx(o, r, f, m)) &&
              (i.empty && f <= i.from && m >= i.to
                ? l.push(oO.range(f, m))
                : (f >= i.to || m <= i.from) && l.push(sO.range(f, m)),
              l.length > e.maxMatches)
            )
              return it.none;
          }
        }
        return it.set(l);
      }
    },
    { decorations: (t) => t.decorations },
  ),
  uO = ze.baseTheme({
    '.cm-selectionMatch': { backgroundColor: '#99ff7780' },
    '.cm-searchMatch .cm-selectionMatch': { backgroundColor: 'transparent' },
  }),
  cO = ({ state: t, dispatch: e }) => {
    let { selection: r } = t,
      n = pe.create(
        r.ranges.map((i) => t.wordAt(i.head) || pe.cursor(i.head)),
        r.mainIndex,
      );
    return n.eq(r) ? !1 : (e(t.update({ selection: n })), !0);
  };
function hO(t, e) {
  let { main: r, ranges: n } = t.selection,
    i = t.wordAt(r.head),
    s = i && i.from == r.from && i.to == r.to;
  for (let o = !1, l = new ul(t.doc, e, n[n.length - 1].to); ; )
    if ((l.next(), l.done)) {
      if (o) return null;
      (l = new ul(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1))), (o = !0);
    } else {
      if (o && n.some((c) => c.from == l.value.from)) continue;
      if (s) {
        let c = t.wordAt(l.value.from);
        if (!c || c.from != l.value.from || c.to != l.value.to) continue;
      }
      return l.value;
    }
}
const pO = ({ state: t, dispatch: e }) => {
    let { ranges: r } = t.selection;
    if (r.some((s) => s.from === s.to)) return cO({ state: t, dispatch: e });
    let n = t.sliceDoc(r[0].from, r[0].to);
    if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != n)) return !1;
    let i = hO(t, n);
    return i
      ? (e(t.update({ selection: t.selection.addRange(pe.range(i.from, i.to), !1), effects: ze.scrollIntoView(i.to) })),
        !0)
      : !1;
  },
  Al = Ue.define({
    combine(t) {
      return Wi(t, {
        top: !1,
        caseSensitive: !1,
        literal: !1,
        regexp: !1,
        wholeWord: !1,
        createPanel: (e) => new vO(e),
        scrollToMatch: (e) => ze.scrollIntoView(e),
      });
    },
  });
class ov {
  constructor(e) {
    (this.search = e.search),
      (this.caseSensitive = !!e.caseSensitive),
      (this.literal = !!e.literal),
      (this.regexp = !!e.regexp),
      (this.replace = e.replace || ''),
      (this.valid = !!this.search && (!this.regexp || eO(this.search))),
      (this.unquoted = this.unquote(this.search)),
      (this.wholeWord = !!e.wholeWord);
  }
  unquote(e) {
    return this.literal
      ? e
      : e.replace(/\\([nrt\\])/g, (r, n) =>
          n == 'n'
            ? `
`
            : n == 'r'
            ? '\r'
            : n == 't'
            ? '	'
            : '\\',
        );
  }
  eq(e) {
    return (
      this.search == e.search &&
      this.replace == e.replace &&
      this.caseSensitive == e.caseSensitive &&
      this.regexp == e.regexp &&
      this.wholeWord == e.wholeWord
    );
  }
  create() {
    return this.regexp ? new gO(this) : new dO(this);
  }
  getCursor(e, r = 0, n) {
    let i = e.doc ? e : Ct.create({ doc: e });
    return n == null && (n = i.doc.length), this.regexp ? La(this, i, r, n) : Oa(this, i, r, n);
  }
}
class av {
  constructor(e) {
    this.spec = e;
  }
}
function Oa(t, e, r, n) {
  return new ul(
    e.doc,
    t.unquoted,
    r,
    n,
    t.caseSensitive ? void 0 : (i) => i.toLowerCase(),
    t.wholeWord ? fO(e.doc, e.charCategorizer(e.selection.main.head)) : void 0,
  );
}
function fO(t, e) {
  return (r, n, i, s) => (
    (s > r || s + i.length < n) && ((s = Math.max(0, r - 2)), (i = t.sliceString(s, Math.min(t.length, n + 2)))),
    (e(Bp(i, r - s)) != er.Word || e(Ip(i, r - s)) != er.Word) &&
      (e(Ip(i, n - s)) != er.Word || e(Bp(i, n - s)) != er.Word)
  );
}
class dO extends av {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, n) {
    let i = Oa(this.spec, e, n, e.doc.length).nextOverlapping();
    return i.done && (i = Oa(this.spec, e, 0, r).nextOverlapping()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = n; ; ) {
      let s = Math.max(r, i - 1e4 - this.spec.unquoted.length),
        o = Oa(this.spec, e, s, i),
        l = null;
      for (; !o.nextOverlapping().done; ) l = o.value;
      if (l) return l;
      if (s == r) return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let n = Oa(this.spec, e, 0, e.doc.length),
      i = [];
    for (; !n.next().done; ) {
      if (i.length >= r) return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = Oa(
      this.spec,
      e,
      Math.max(0, r - this.spec.unquoted.length),
      Math.min(n + this.spec.unquoted.length, e.doc.length),
    );
    for (; !s.next().done; ) i(s.value.from, s.value.to);
  }
}
function La(t, e, r, n) {
  return new nv(
    e.doc,
    t.search,
    { ignoreCase: !t.caseSensitive, test: t.wholeWord ? mO(e.charCategorizer(e.selection.main.head)) : void 0 },
    r,
    n,
  );
}
function Bp(t, e) {
  return t.slice(Yr(t, e, !1), e);
}
function Ip(t, e) {
  return t.slice(e, Yr(t, e));
}
function mO(t) {
  return (e, r, n) =>
    !n[0].length ||
    ((t(Bp(n.input, n.index)) != er.Word || t(Ip(n.input, n.index)) != er.Word) &&
      (t(Ip(n.input, n.index + n[0].length)) != er.Word || t(Bp(n.input, n.index + n[0].length)) != er.Word));
}
class gO extends av {
  nextMatch(e, r, n) {
    let i = La(this.spec, e, n, e.doc.length).next();
    return i.done && (i = La(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = 1; ; i++) {
      let s = Math.max(r, n - i * 1e4),
        o = La(this.spec, e, s, n),
        l = null;
      for (; !o.next().done; ) l = o.value;
      if (l && (s == r || l.from > s + 10)) return l;
      if (s == r) return null;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(
      this.spec.replace.replace(/\$([$&\d+])/g, (r, n) =>
        n == '$' ? '$' : n == '&' ? e.match[0] : n != '0' && +n < e.match.length ? e.match[n] : r,
      ),
    );
  }
  matchAll(e, r) {
    let n = La(this.spec, e, 0, e.doc.length),
      i = [];
    for (; !n.next().done; ) {
      if (i.length >= r) return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = La(this.spec, e, Math.max(0, r - 250), Math.min(n + 250, e.doc.length));
    for (; !s.next().done; ) i(s.value.from, s.value.to);
  }
}
const Yu = mt.define(),
  hy = mt.define(),
  Gs = vr.define({
    create(t) {
      return new ym(U0(t).create(), null);
    },
    update(t, e) {
      for (let r of e.effects)
        r.is(Yu) ? (t = new ym(r.value.create(), t.panel)) : r.is(hy) && (t = new ym(t.query, r.value ? py : null));
      return t;
    },
    provide: (t) => Ju.from(t, (e) => e.panel),
  });
class ym {
  constructor(e, r) {
    (this.query = e), (this.panel = r);
  }
}
const yO = it.mark({ class: 'cm-searchMatch' }),
  DO = it.mark({ class: 'cm-searchMatch cm-searchMatch-selected' }),
  xO = ar.fromClass(
    class {
      constructor(t) {
        (this.view = t), (this.decorations = this.highlight(t.state.field(Gs)));
      }
      update(t) {
        let e = t.state.field(Gs);
        (e != t.startState.field(Gs) || t.docChanged || t.selectionSet || t.viewportChanged) &&
          (this.decorations = this.highlight(e));
      }
      highlight({ query: t, panel: e }) {
        if (!e || !t.spec.valid) return it.none;
        let { view: r } = this,
          n = new no();
        for (let i = 0, s = r.visibleRanges, o = s.length; i < o; i++) {
          let { from: l, to: c } = s[i];
          for (; i < o - 1 && c > s[i + 1].from - 2 * 250; ) c = s[++i].to;
          t.highlight(r.state, l, c, (p, f) => {
            let m = r.state.selection.ranges.some((g) => g.from == p && g.to == f);
            n.add(p, f, m ? DO : yO);
          });
        }
        return n.finish();
      }
    },
    { decorations: (t) => t.decorations },
  );
function fc(t) {
  return (e) => {
    let r = e.state.field(Gs, !1);
    return r && r.query.spec.valid ? t(e, r) : cv(e);
  };
}
const Np = fc((t, { query: e }) => {
    let { to: r } = t.state.selection.main,
      n = e.nextMatch(t.state, r, r);
    if (!n) return !1;
    let i = pe.single(n.from, n.to),
      s = t.state.facet(Al);
    return (
      t.dispatch({ selection: i, effects: [fy(t, n), s.scrollToMatch(i.main, t)], userEvent: 'select.search' }),
      uv(t),
      !0
    );
  }),
  Mp = fc((t, { query: e }) => {
    let { state: r } = t,
      { from: n } = r.selection.main,
      i = e.prevMatch(r, n, n);
    if (!i) return !1;
    let s = pe.single(i.from, i.to),
      o = t.state.facet(Al);
    return (
      t.dispatch({ selection: s, effects: [fy(t, i), o.scrollToMatch(s.main, t)], userEvent: 'select.search' }),
      uv(t),
      !0
    );
  }),
  CO = fc((t, { query: e }) => {
    let r = e.matchAll(t.state, 1e3);
    return !r || !r.length
      ? !1
      : (t.dispatch({ selection: pe.create(r.map((n) => pe.range(n.from, n.to))), userEvent: 'select.search.matches' }),
        !0);
  }),
  bO = ({ state: t, dispatch: e }) => {
    let r = t.selection;
    if (r.ranges.length > 1 || r.main.empty) return !1;
    let { from: n, to: i } = r.main,
      s = [],
      o = 0;
    for (let l = new ul(t.doc, t.sliceDoc(n, i)); !l.next().done; ) {
      if (s.length > 1e3) return !1;
      l.value.from == n && (o = s.length), s.push(pe.range(l.value.from, l.value.to));
    }
    return e(t.update({ selection: pe.create(s, o), userEvent: 'select.search.matches' })), !0;
  },
  Xx = fc((t, { query: e }) => {
    let { state: r } = t,
      { from: n, to: i } = r.selection.main;
    if (r.readOnly) return !1;
    let s = e.nextMatch(r, n, n);
    if (!s) return !1;
    let o = [],
      l,
      c,
      p = [];
    if (
      (s.from == n &&
        s.to == i &&
        ((c = r.toText(e.getReplacement(s))),
        o.push({ from: s.from, to: s.to, insert: c }),
        (s = e.nextMatch(r, s.from, s.to)),
        p.push(ze.announce.of(r.phrase('replaced match on line $', r.doc.lineAt(n).number) + '.'))),
      s)
    ) {
      let f = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - c.length;
      (l = pe.single(s.from - f, s.to - f)), p.push(fy(t, s)), p.push(r.facet(Al).scrollToMatch(l.main, t));
    }
    return t.dispatch({ changes: o, selection: l, effects: p, userEvent: 'input.replace' }), !0;
  }),
  AO = fc((t, { query: e }) => {
    if (t.state.readOnly) return !1;
    let r = e.matchAll(t.state, 1e9).map((i) => {
      let { from: s, to: o } = i;
      return { from: s, to: o, insert: e.getReplacement(i) };
    });
    if (!r.length) return !1;
    let n = t.state.phrase('replaced $ matches', r.length) + '.';
    return t.dispatch({ changes: r, effects: ze.announce.of(n), userEvent: 'input.replace.all' }), !0;
  });
function py(t) {
  return t.state.facet(Al).createPanel(t);
}
function U0(t, e) {
  var r, n, i, s, o;
  let l = t.selection.main,
    c = l.empty || l.to > l.from + 100 ? '' : t.sliceDoc(l.from, l.to);
  if (e && !c) return e;
  let p = t.facet(Al);
  return new ov({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : p.literal)
      ? c
      : c.replace(/\n/g, '\\n'),
    caseSensitive: (n = e == null ? void 0 : e.caseSensitive) !== null && n !== void 0 ? n : p.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : p.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : p.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : p.wholeWord,
  });
}
function lv(t) {
  let e = Ku(t, py);
  return e && e.dom.querySelector('[main-field]');
}
function uv(t) {
  let e = lv(t);
  e && e == t.root.activeElement && e.select();
}
const cv = (t) => {
    let e = t.state.field(Gs, !1);
    if (e && e.panel) {
      let r = lv(t);
      if (r && r != t.root.activeElement) {
        let n = U0(t.state, e.query.spec);
        n.valid && t.dispatch({ effects: Yu.of(n) }), r.focus(), r.select();
      }
    } else t.dispatch({ effects: [hy.of(!0), e ? Yu.of(U0(t.state, e.query.spec)) : mt.appendConfig.of(SO)] });
    return !0;
  },
  hv = (t) => {
    let e = t.state.field(Gs, !1);
    if (!e || !e.panel) return !1;
    let r = Ku(t, py);
    return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: hy.of(!1) }), !0;
  },
  EO = [
    { key: 'Mod-f', run: cv, scope: 'editor search-panel' },
    { key: 'F3', run: Np, shift: Mp, scope: 'editor search-panel', preventDefault: !0 },
    { key: 'Mod-g', run: Np, shift: Mp, scope: 'editor search-panel', preventDefault: !0 },
    { key: 'Escape', run: hv, scope: 'editor search-panel' },
    { key: 'Mod-Shift-l', run: bO },
    { key: 'Alt-g', run: tO },
    { key: 'Mod-d', run: pO, preventDefault: !0 },
  ];
class vO {
  constructor(e) {
    this.view = e;
    let r = (this.query = e.state.field(Gs).query.spec);
    (this.commit = this.commit.bind(this)),
      (this.searchField = Ht('input', {
        'value': r.search,
        'placeholder': bn(e, 'Find'),
        'aria-label': bn(e, 'Find'),
        'class': 'cm-textfield',
        'name': 'search',
        'form': '',
        'main-field': 'true',
        'onchange': this.commit,
        'onkeyup': this.commit,
      })),
      (this.replaceField = Ht('input', {
        'value': r.replace,
        'placeholder': bn(e, 'Replace'),
        'aria-label': bn(e, 'Replace'),
        'class': 'cm-textfield',
        'name': 'replace',
        'form': '',
        'onchange': this.commit,
        'onkeyup': this.commit,
      })),
      (this.caseField = Ht('input', {
        type: 'checkbox',
        name: 'case',
        form: '',
        checked: r.caseSensitive,
        onchange: this.commit,
      })),
      (this.reField = Ht('input', {
        type: 'checkbox',
        name: 're',
        form: '',
        checked: r.regexp,
        onchange: this.commit,
      })),
      (this.wordField = Ht('input', {
        type: 'checkbox',
        name: 'word',
        form: '',
        checked: r.wholeWord,
        onchange: this.commit,
      }));
    function n(i, s, o) {
      return Ht('button', { class: 'cm-button', name: i, onclick: s, type: 'button' }, o);
    }
    this.dom = Ht('div', { onkeydown: (i) => this.keydown(i), class: 'cm-search' }, [
      this.searchField,
      n('next', () => Np(e), [bn(e, 'next')]),
      n('prev', () => Mp(e), [bn(e, 'previous')]),
      n('select', () => CO(e), [bn(e, 'all')]),
      Ht('label', null, [this.caseField, bn(e, 'match case')]),
      Ht('label', null, [this.reField, bn(e, 'regexp')]),
      Ht('label', null, [this.wordField, bn(e, 'by word')]),
      ...(e.state.readOnly
        ? []
        : [
            Ht('br'),
            this.replaceField,
            n('replace', () => Xx(e), [bn(e, 'replace')]),
            n('replaceAll', () => AO(e), [bn(e, 'replace all')]),
          ]),
      Ht('button', { 'name': 'close', 'onclick': () => hv(e), 'aria-label': bn(e, 'close'), 'type': 'button' }, ['×']),
    ]);
  }
  commit() {
    let e = new ov({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value,
    });
    e.eq(this.query) || ((this.query = e), this.view.dispatch({ effects: Yu.of(e) }));
  }
  keydown(e) {
    M6(this.view, e, 'search-panel')
      ? e.preventDefault()
      : e.keyCode == 13 && e.target == this.searchField
      ? (e.preventDefault(), (e.shiftKey ? Mp : Np)(this.view))
      : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Xx(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let n of r.effects) n.is(Yu) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    (this.query = e),
      (this.searchField.value = e.search),
      (this.replaceField.value = e.replace),
      (this.caseField.checked = e.caseSensitive),
      (this.reField.checked = e.regexp),
      (this.wordField.checked = e.wholeWord);
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Al).top;
  }
}
function bn(t, e) {
  return t.state.phrase(e);
}
const Ph = 30,
  Bh = /[\s\.,:;?!]/;
function fy(t, { from: e, to: r }) {
  let n = t.state.doc.lineAt(e),
    i = t.state.doc.lineAt(r).to,
    s = Math.max(n.from, e - Ph),
    o = Math.min(i, r + Ph),
    l = t.state.sliceDoc(s, o);
  if (s != n.from) {
    for (let c = 0; c < Ph; c++)
      if (!Bh.test(l[c + 1]) && Bh.test(l[c])) {
        l = l.slice(c);
        break;
      }
  }
  if (o != i) {
    for (let c = l.length - 1; c > l.length - Ph; c--)
      if (!Bh.test(l[c - 1]) && Bh.test(l[c])) {
        l = l.slice(0, c);
        break;
      }
  }
  return ze.announce.of(`${t.state.phrase('current match')}. ${l} ${t.state.phrase('on line')} ${n.number}.`);
}
const FO = ze.baseTheme({
    '.cm-panel.cm-search': {
      'padding': '2px 6px 4px',
      'position': 'relative',
      '& [name=close]': {
        position: 'absolute',
        top: '0',
        right: '4px',
        backgroundColor: 'inherit',
        border: 'none',
        font: 'inherit',
        padding: 0,
        margin: 0,
      },
      '& input, & button, & label': { margin: '.2em .6em .2em 0' },
      '& input[type=checkbox]': { marginRight: '.2em' },
      '& label': { fontSize: '80%', whiteSpace: 'pre' },
    },
    '&light .cm-searchMatch': { backgroundColor: '#ffff0054' },
    '&dark .cm-searchMatch': { backgroundColor: '#00ffff8a' },
    '&light .cm-searchMatch-selected': { backgroundColor: '#ff6a0054' },
    '&dark .cm-searchMatch-selected': { backgroundColor: '#ff00ff8a' },
  }),
  SO = [Gs, xl.low(xO), FO];
class pv {
  constructor(e, r, n) {
    (this.state = e), (this.pos = r), (this.explicit = n), (this.abortListeners = []);
  }
  tokenBefore(e) {
    let r = jr(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; ) r = r.parent;
    return r ? { from: r.from, to: this.pos, text: this.state.sliceDoc(r.from, this.pos), type: r.type } : null;
  }
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos),
      n = Math.max(r.from, this.pos - 250),
      i = r.text.slice(n - r.from, this.pos - r.from),
      s = i.search(fv(e, !1));
    return s < 0 ? null : { from: n + s, to: this.pos, text: i.slice(s) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(e, r) {
    e == 'abort' && this.abortListeners && this.abortListeners.push(r);
  }
}
function Gx(t) {
  let e = Object.keys(t).join(''),
    r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, '')), `[${r ? '\\w' : ''}${e.replace(/[^\w\s]/g, '\\$&')}]`;
}
function wO(t) {
  let e = Object.create(null),
    r = Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++) r[i[s]] = !0;
  }
  let n = Gx(e) + Gx(r) + '*$';
  return [new RegExp('^' + n), new RegExp(n)];
}
function TO(t) {
  let e = t.map((i) => (typeof i == 'string' ? { label: i } : i)),
    [r, n] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : wO(e);
  return (i) => {
    let s = i.matchBefore(n);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: r } : null;
  };
}
class Yx {
  constructor(e, r, n, i) {
    (this.completion = e), (this.source = r), (this.match = n), (this.score = i);
  }
}
function Ys(t) {
  return t.selection.main.from;
}
function fv(t, e) {
  var r;
  let { source: n } = t,
    i = e && n[0] != '^',
    s = n[n.length - 1] != '$';
  return !i && !s
    ? t
    : new RegExp(
        `${i ? '^' : ''}(?:${n})${s ? '$' : ''}`,
        (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? 'i' : '',
      );
}
const kO = ms.define();
function PO(t, e, r, n) {
  let { main: i } = t.selection,
    s = r - i.from,
    o = n - i.from;
  return Object.assign(
    Object.assign(
      {},
      t.changeByRange((l) =>
        l != i && r != n && t.sliceDoc(l.from + s, l.from + o) != t.sliceDoc(r, n)
          ? { range: l }
          : {
              changes: { from: l.from + s, to: n == i.from ? l.to : l.from + o, insert: e },
              range: pe.cursor(l.from + s + e.length),
            },
      ),
    ),
    { scrollIntoView: !0, userEvent: 'input.complete' },
  );
}
const Qx = new WeakMap();
function BO(t) {
  if (!Array.isArray(t)) return t;
  let e = Qx.get(t);
  return e || Qx.set(t, (e = TO(t))), e;
}
const dy = mt.define(),
  Qu = mt.define();
class IO {
  constructor(e) {
    (this.pattern = e),
      (this.chars = []),
      (this.folded = []),
      (this.any = []),
      (this.precise = []),
      (this.byWord = []),
      (this.score = 0),
      (this.matched = []);
    for (let r = 0; r < e.length; ) {
      let n = Nr(e, r),
        i = _n(n);
      this.chars.push(n);
      let s = e.slice(r, r + i),
        o = s.toUpperCase();
      this.folded.push(Nr(o == s ? s.toLowerCase() : o, 0)), (r += i);
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return (this.score = e), (this.matched = r), !0;
  }
  match(e) {
    if (this.pattern.length == 0) return this.ret(-100, []);
    if (e.length < this.pattern.length) return !1;
    let { chars: r, folded: n, any: i, precise: s, byWord: o } = this;
    if (r.length == 1) {
      let I = Nr(e, 0),
        T = _n(I),
        j = T == e.length ? 0 : -100;
      if (I != r[0])
        if (I == n[0]) j += -200;
        else return !1;
      return this.ret(j, [0, T]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0) return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let c = r.length,
      p = 0;
    if (l < 0) {
      for (let I = 0, T = Math.min(e.length, 200); I < T && p < c; ) {
        let j = Nr(e, I);
        (j == r[p] || j == n[p]) && (i[p++] = I), (I += _n(j));
      }
      if (p < c) return !1;
    }
    let f = 0,
      m = 0,
      g = !1,
      x = 0,
      b = -1,
      F = -1,
      E = /[a-z]/.test(e),
      w = !0;
    for (let I = 0, T = Math.min(e.length, 200), j = 0; I < T && m < c; ) {
      let $ = Nr(e, I);
      l < 0 &&
        (f < c && $ == r[f] && (s[f++] = I),
        x < c && ($ == r[x] || $ == n[x] ? (x == 0 && (b = I), (F = I + 1), x++) : (x = 0)));
      let L,
        se =
          $ < 255
            ? ($ >= 48 && $ <= 57) || ($ >= 97 && $ <= 122)
              ? 2
              : $ >= 65 && $ <= 90
              ? 1
              : 0
            : (L = Hg($)) != L.toLowerCase()
            ? 1
            : L != L.toUpperCase()
            ? 2
            : 0;
      (!I || (se == 1 && E) || (j == 0 && se != 0)) &&
        (r[m] == $ || (n[m] == $ && (g = !0)) ? (o[m++] = I) : o.length && (w = !1)),
        (j = se),
        (I += _n($));
    }
    return m == c && o[0] == 0 && w
      ? this.result(-100 + (g ? -200 : 0), o, e)
      : x == c && b == 0
      ? this.ret(-200 - e.length + (F == e.length ? 0 : -100), [0, F])
      : l > -1
      ? this.ret(-700 - e.length, [l, l + this.pattern.length])
      : x == c
      ? this.ret(-200 + -700 - e.length, [b, F])
      : m == c
      ? this.result(-100 + (g ? -200 : 0) + -700 + (w ? 0 : -1100), o, e)
      : r.length == 2
      ? !1
      : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, n) {
    let i = [],
      s = 0;
    for (let o of r) {
      let l = o + (this.astral ? _n(Nr(n, o)) : 1);
      s && i[s - 1] == o ? (i[s - 1] = l) : ((i[s++] = o), (i[s++] = l));
    }
    return this.ret(e - n.length, i);
  }
}
const Gr = Ue.define({
  combine(t) {
    return Wi(
      t,
      {
        activateOnTyping: !0,
        selectOnOpen: !0,
        override: null,
        closeOnBlur: !0,
        maxRenderedOptions: 100,
        defaultKeymap: !0,
        tooltipClass: () => '',
        optionClass: () => '',
        aboveCursor: !1,
        icons: !0,
        addToOptions: [],
        positionInfo: NO,
        compareCompletions: (e, r) => e.label.localeCompare(r.label),
        interactionDelay: 75,
        updateSyncTime: 100,
      },
      {
        defaultKeymap: (e, r) => e && r,
        closeOnBlur: (e, r) => e && r,
        icons: (e, r) => e && r,
        tooltipClass: (e, r) => (n) => Zx(e(n), r(n)),
        optionClass: (e, r) => (n) => Zx(e(n), r(n)),
        addToOptions: (e, r) => e.concat(r),
      },
    );
  },
});
function Zx(t, e) {
  return t ? (e ? t + ' ' + e : t) : e;
}
function NO(t, e, r, n, i, s) {
  let o = t.textDirection == rr.RTL,
    l = o,
    c = !1,
    p = 'top',
    f,
    m,
    g = e.left - i.left,
    x = i.right - e.right,
    b = n.right - n.left,
    F = n.bottom - n.top;
  if ((l && g < Math.min(b, x) ? (l = !1) : !l && x < Math.min(b, g) && (l = !0), b <= (l ? g : x)))
    (f = Math.max(i.top, Math.min(r.top, i.bottom - F)) - e.top), (m = Math.min(400, l ? g : x));
  else {
    (c = !0), (m = Math.min(400, (o ? e.right : i.right - e.left) - 30));
    let I = i.bottom - e.bottom;
    I >= F || I > e.top ? (f = r.bottom - e.top) : ((p = 'bottom'), (f = e.bottom - r.top));
  }
  let E = (e.bottom - e.top) / s.offsetHeight,
    w = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${p}: ${f / E}px; max-width: ${m / w}px`,
    class: 'cm-completionInfo-' + (c ? (o ? 'left-narrow' : 'right-narrow') : l ? 'left' : 'right'),
  };
}
function MO(t) {
  let e = t.addToOptions.slice();
  return (
    t.icons &&
      e.push({
        render(r) {
          let n = document.createElement('div');
          return (
            n.classList.add('cm-completionIcon'),
            r.type && n.classList.add(...r.type.split(/\s+/g).map((i) => 'cm-completionIcon-' + i)),
            n.setAttribute('aria-hidden', 'true'),
            n
          );
        },
        position: 20,
      }),
    e.push(
      {
        render(r, n, i) {
          let s = document.createElement('span');
          s.className = 'cm-completionLabel';
          let o = r.displayLabel || r.label,
            l = 0;
          for (let c = 0; c < i.length; ) {
            let p = i[c++],
              f = i[c++];
            p > l && s.appendChild(document.createTextNode(o.slice(l, p)));
            let m = s.appendChild(document.createElement('span'));
            m.appendChild(document.createTextNode(o.slice(p, f))), (m.className = 'cm-completionMatchedText'), (l = f);
          }
          return l < o.length && s.appendChild(document.createTextNode(o.slice(l))), s;
        },
        position: 50,
      },
      {
        render(r) {
          if (!r.detail) return null;
          let n = document.createElement('span');
          return (n.className = 'cm-completionDetail'), (n.textContent = r.detail), n;
        },
        position: 80,
      },
    ),
    e.sort((r, n) => r.position - n.position).map((r) => r.render)
  );
}
function Dm(t, e, r) {
  if (t <= r) return { from: 0, to: t };
  if ((e < 0 && (e = 0), e <= t >> 1)) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let n = Math.floor((t - e) / r);
  return { from: t - (n + 1) * r, to: t - n * r };
}
class OO {
  constructor(e, r, n) {
    (this.view = e),
      (this.stateField = r),
      (this.applyCompletion = n),
      (this.info = null),
      (this.infoDestroy = null),
      (this.placeInfoReq = { read: () => this.measureInfo(), write: (c) => this.placeInfo(c), key: this }),
      (this.space = null),
      (this.currentClass = '');
    let i = e.state.field(r),
      { options: s, selected: o } = i.open,
      l = e.state.facet(Gr);
    (this.optionContent = MO(l)),
      (this.optionClass = l.optionClass),
      (this.tooltipClass = l.tooltipClass),
      (this.range = Dm(s.length, o, l.maxRenderedOptions)),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-tooltip-autocomplete'),
      this.updateTooltipClass(e.state),
      this.dom.addEventListener('mousedown', (c) => {
        let { options: p } = e.state.field(r).open;
        for (let f = c.target, m; f && f != this.dom; f = f.parentNode)
          if (f.nodeName == 'LI' && (m = /-(\d+)$/.exec(f.id)) && +m[1] < p.length) {
            this.applyCompletion(e, p[+m[1]]), c.preventDefault();
            return;
          }
      }),
      this.dom.addEventListener('focusout', (c) => {
        let p = e.state.field(this.stateField, !1);
        p &&
          p.tooltip &&
          e.state.facet(Gr).closeOnBlur &&
          c.relatedTarget != e.contentDOM &&
          e.dispatch({ effects: Qu.of(null) });
      }),
      this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(),
      (this.list = this.dom.appendChild(this.createListBox(e, r, this.range))),
      this.list.addEventListener('scroll', () => {
        this.info && this.view.requestMeasure(this.placeInfoReq);
      });
  }
  update(e) {
    var r;
    let n = e.state.field(this.stateField),
      i = e.startState.field(this.stateField);
    if ((this.updateTooltipClass(e.state), n != i)) {
      let { options: s, selected: o, disabled: l } = n.open;
      (!i.open || i.open.options != s) &&
        ((this.range = Dm(s.length, o, e.state.facet(Gr).maxRenderedOptions)), this.showOptions(s, n.id)),
        this.updateSel(),
        l != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) &&
          this.dom.classList.toggle('cm-tooltip-autocomplete-disabled', !!l);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let n of this.currentClass.split(' ')) n && this.dom.classList.remove(n);
      for (let n of r.split(' ')) n && this.dom.classList.add(n);
      this.currentClass = r;
    }
  }
  positioned(e) {
    (this.space = e), this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField),
      r = e.open;
    if (
      (((r.selected > -1 && r.selected < this.range.from) || r.selected >= this.range.to) &&
        ((this.range = Dm(r.options.length, r.selected, this.view.state.facet(Gr).maxRenderedOptions)),
        this.showOptions(r.options, e.id)),
      this.updateSelectedOption(r.selected))
    ) {
      this.destroyInfo();
      let { completion: n } = r.options[r.selected],
        { info: i } = n;
      if (!i) return;
      let s = typeof i == 'string' ? document.createTextNode(i) : i(n);
      if (!s) return;
      'then' in s
        ? s
            .then((o) => {
              o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, n);
            })
            .catch((o) => Vn(this.view.state, o, 'completion info'))
        : this.addInfoPane(s, n);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let n = (this.info = document.createElement('div'));
    if (((n.className = 'cm-tooltip cm-completionInfo'), e.nodeType != null))
      n.appendChild(e), (this.infoDestroy = null);
    else {
      let { dom: i, destroy: s } = e;
      n.appendChild(i), (this.infoDestroy = s || null);
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let n = this.list.firstChild, i = this.range.from; n; n = n.nextSibling, i++)
      n.nodeName != 'LI' || !n.id
        ? i--
        : i == e
        ? n.hasAttribute('aria-selected') || (n.setAttribute('aria-selected', 'true'), (r = n))
        : n.hasAttribute('aria-selected') && n.removeAttribute('aria-selected');
    return r && _O(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector('[aria-selected]');
    if (!e || !this.info) return null;
    let r = this.dom.getBoundingClientRect(),
      n = this.info.getBoundingClientRect(),
      i = e.getBoundingClientRect(),
      s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return i.top > Math.min(s.bottom, r.bottom) - 10 || i.bottom < Math.max(s.top, r.top) + 10
      ? null
      : this.view.state.facet(Gr).positionInfo(this.view, r, i, n, s, this.dom);
  }
  placeInfo(e) {
    this.info &&
      (e
        ? (e.style && (this.info.style.cssText = e.style),
          (this.info.className = 'cm-tooltip cm-completionInfo ' + (e.class || '')))
        : (this.info.style.cssText = 'top: -1e6px'));
  }
  createListBox(e, r, n) {
    const i = document.createElement('ul');
    (i.id = r),
      i.setAttribute('role', 'listbox'),
      i.setAttribute('aria-expanded', 'true'),
      i.setAttribute('aria-label', this.view.state.phrase('Completions'));
    let s = null;
    for (let o = n.from; o < n.to; o++) {
      let { completion: l, match: c } = e[o],
        { section: p } = l;
      if (p) {
        let g = typeof p == 'string' ? p : p.name;
        if (g != s && (o > n.from || n.from == 0))
          if (((s = g), typeof p != 'string' && p.header)) i.appendChild(p.header(p));
          else {
            let x = i.appendChild(document.createElement('completion-section'));
            x.textContent = g;
          }
      }
      const f = i.appendChild(document.createElement('li'));
      (f.id = r + '-' + o), f.setAttribute('role', 'option');
      let m = this.optionClass(l);
      m && (f.className = m);
      for (let g of this.optionContent) {
        let x = g(l, this.view.state, c);
        x && f.appendChild(x);
      }
    }
    return (
      n.from && i.classList.add('cm-completionListIncompleteTop'),
      n.to < e.length && i.classList.add('cm-completionListIncompleteBottom'),
      i
    );
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), (this.info = null));
  }
  destroy() {
    this.destroyInfo();
  }
}
function LO(t, e) {
  return (r) => new OO(r, t, e);
}
function _O(t, e) {
  let r = t.getBoundingClientRect(),
    n = e.getBoundingClientRect(),
    i = r.height / t.offsetHeight;
  n.top < r.top
    ? (t.scrollTop -= (r.top - n.top) / i)
    : n.bottom > r.bottom && (t.scrollTop += (n.bottom - r.bottom) / i);
}
function eC(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function RO(t, e) {
  let r = [],
    n = null,
    i = (c) => {
      r.push(c);
      let { section: p } = c.completion;
      if (p) {
        n || (n = []);
        let f = typeof p == 'string' ? p : p.name;
        n.some((m) => m.name == f) || n.push(typeof p == 'string' ? { name: f } : p);
      }
    };
  for (let c of t)
    if (c.hasResult()) {
      let p = c.result.getMatch;
      if (c.result.filter === !1) for (let f of c.result.options) i(new Yx(f, c.source, p ? p(f) : [], 1e9 - r.length));
      else {
        let f = new IO(e.sliceDoc(c.from, c.to));
        for (let m of c.result.options)
          if (f.match(m.label)) {
            let g = m.displayLabel ? (p ? p(m, f.matched) : []) : f.matched;
            i(new Yx(m, c.source, g, f.score + (m.boost || 0)));
          }
      }
    }
  if (n) {
    let c = Object.create(null),
      p = 0,
      f = (m, g) => {
        var x, b;
        return (
          ((x = m.rank) !== null && x !== void 0 ? x : 1e9) - ((b = g.rank) !== null && b !== void 0 ? b : 1e9) ||
          (m.name < g.name ? -1 : 1)
        );
      };
    for (let m of n.sort(f)) (p -= 1e5), (c[m.name] = p);
    for (let m of r) {
      let { section: g } = m.completion;
      g && (m.score += c[typeof g == 'string' ? g : g.name]);
    }
  }
  let s = [],
    o = null,
    l = e.facet(Gr).compareCompletions;
  for (let c of r.sort((p, f) => f.score - p.score || l(p.completion, f.completion))) {
    let p = c.completion;
    !o ||
    o.label != p.label ||
    o.detail != p.detail ||
    (o.type != null && p.type != null && o.type != p.type) ||
    o.apply != p.apply ||
    o.boost != p.boost
      ? s.push(c)
      : eC(c.completion) > eC(o) && (s[s.length - 1] = c),
      (o = c.completion);
  }
  return s;
}
class za {
  constructor(e, r, n, i, s, o) {
    (this.options = e),
      (this.attrs = r),
      (this.tooltip = n),
      (this.timestamp = i),
      (this.selected = s),
      (this.disabled = o);
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length
      ? this
      : new za(this.options, tC(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, n, i, s) {
    let o = RO(e, r);
    if (!o.length)
      return i && e.some((c) => c.state == 1)
        ? new za(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0)
        : null;
    let l = r.facet(Gr).selectOnOpen ? 0 : -1;
    if (i && i.selected != l && i.selected != -1) {
      let c = i.options[i.selected].completion;
      for (let p = 0; p < o.length; p++)
        if (o[p].completion == c) {
          l = p;
          break;
        }
    }
    return new za(
      o,
      tC(n, l),
      { pos: e.reduce((c, p) => (p.hasResult() ? Math.min(c, p.from) : c), 1e8), create: HO, above: s.aboveCursor },
      i ? i.timestamp : Date.now(),
      l,
      !1,
    );
  }
  map(e) {
    return new za(
      this.options,
      this.attrs,
      Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }),
      this.timestamp,
      this.selected,
      this.disabled,
    );
  }
}
class Op {
  constructor(e, r, n) {
    (this.active = e), (this.id = r), (this.open = n);
  }
  static start() {
    return new Op(VO, 'cm-ac-' + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e,
      n = r.facet(Gr),
      s = (n.override || r.languageDataAt('autocomplete', Ys(r)).map(BO)).map((l) =>
        (this.active.find((p) => p.source == l) || new mn(l, this.active.some((p) => p.state != 0) ? 1 : 0)).update(
          e,
          n,
        ),
      );
    s.length == this.active.length && s.every((l, c) => l == this.active[c]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)),
      e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !jO(s, this.active)
        ? (o = za.build(s, r, this.id, o, n))
        : o && o.disabled && !s.some((l) => l.state == 1) && (o = null),
      !o &&
        s.every((l) => l.state != 1) &&
        s.some((l) => l.hasResult()) &&
        (s = s.map((l) => (l.hasResult() ? new mn(l.source, 0) : l)));
    for (let l of e.effects) l.is(mv) && (o = o && o.setSelected(l.value, this.id));
    return s == this.active && o == this.open ? this : new Op(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : $O;
  }
}
function jO(t, e) {
  if (t == e) return !0;
  for (let r = 0, n = 0; ; ) {
    for (; r < t.length && !t[r].hasResult; ) r++;
    for (; n < e.length && !e[n].hasResult; ) n++;
    let i = r == t.length,
      s = n == e.length;
    if (i || s) return i == s;
    if (t[r++].result != e[n++].result) return !1;
  }
}
const $O = { 'aria-autocomplete': 'list' };
function tC(t, e) {
  let r = { 'aria-autocomplete': 'list', 'aria-haspopup': 'listbox', 'aria-controls': t };
  return e > -1 && (r['aria-activedescendant'] = t + '-' + e), r;
}
const VO = [];
function q0(t) {
  return t.isUserEvent('input.type') ? 'input' : t.isUserEvent('delete.backward') ? 'delete' : null;
}
class mn {
  constructor(e, r, n = -1) {
    (this.source = e), (this.state = r), (this.explicitPos = n);
  }
  hasResult() {
    return !1;
  }
  update(e, r) {
    let n = q0(e),
      i = this;
    n
      ? (i = i.handleUserEvent(e, n, r))
      : e.docChanged
      ? (i = i.handleChange(e))
      : e.selection && i.state != 0 && (i = new mn(i.source, 0));
    for (let s of e.effects)
      if (s.is(dy)) i = new mn(i.source, 1, s.value ? Ys(e.state) : -1);
      else if (s.is(Qu)) i = new mn(i.source, 0);
      else if (s.is(dv)) for (let o of s.value) o.source == i.source && (i = o);
    return i;
  }
  handleUserEvent(e, r, n) {
    return r == 'delete' || !n.activateOnTyping ? this.map(e.changes) : new mn(this.source, 1);
  }
  handleChange(e) {
    return e.changes.touchesRange(Ys(e.startState)) ? new mn(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new mn(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Ya extends mn {
  constructor(e, r, n, i, s) {
    super(e, 2, r), (this.result = n), (this.from = i), (this.to = s);
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, r, n) {
    var i;
    let s = e.changes.mapPos(this.from),
      o = e.changes.mapPos(this.to, 1),
      l = Ys(e.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > o || (r == 'delete' && Ys(e.startState) == this.from))
      return new mn(this.source, r == 'input' && n.activateOnTyping ? 1 : 0);
    let c = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos),
      p;
    return zO(this.result.validFor, e.state, s, o)
      ? new Ya(this.source, c, this.result, s, o)
      : this.result.update && (p = this.result.update(this.result, s, o, new pv(e.state, l, c >= 0)))
      ? new Ya(this.source, c, p, p.from, (i = p.to) !== null && i !== void 0 ? i : Ys(e.state))
      : new mn(this.source, 1, c);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new mn(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty
      ? this
      : new Ya(
          this.source,
          this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos),
          this.result,
          e.mapPos(this.from),
          e.mapPos(this.to, 1),
        );
  }
}
function zO(t, e, r, n) {
  if (!t) return !1;
  let i = e.sliceDoc(r, n);
  return typeof t == 'function' ? t(i, r, n, e) : fv(t, !0).test(i);
}
const dv = mt.define({
    map(t, e) {
      return t.map((r) => r.map(e));
    },
  }),
  mv = mt.define(),
  Fn = vr.define({
    create() {
      return Op.start();
    },
    update(t, e) {
      return t.update(e);
    },
    provide: (t) => [Qg.from(t, (e) => e.tooltip), ze.contentAttributes.from(t, (e) => e.attrs)],
  });
function gv(t, e) {
  const r = e.completion.apply || e.completion.label;
  let n = t.state.field(Fn).active.find((i) => i.source == e.source);
  return n instanceof Ya
    ? (typeof r == 'string'
        ? t.dispatch(
            Object.assign(Object.assign({}, PO(t.state, r, n.from, n.to)), { annotations: kO.of(e.completion) }),
          )
        : r(t, e.completion, n.from, n.to),
      !0)
    : !1;
}
const HO = LO(Fn, gv);
function Ih(t, e = 'option') {
  return (r) => {
    let n = r.state.field(Fn, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < r.state.facet(Gr).interactionDelay)
      return !1;
    let i = 1,
      s;
    e == 'page' &&
      (s = YE(r, n.open.tooltip)) &&
      (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector('li').offsetHeight) - 1));
    let { length: o } = n.open.options,
      l = n.open.selected > -1 ? n.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
    return (
      l < 0 ? (l = e == 'page' ? 0 : o - 1) : l >= o && (l = e == 'page' ? o - 1 : 0),
      r.dispatch({ effects: mv.of(l) }),
      !0
    );
  };
}
const WO = (t) => {
    let e = t.state.field(Fn, !1);
    return t.state.readOnly ||
      !e ||
      !e.open ||
      e.open.selected < 0 ||
      e.open.disabled ||
      Date.now() - e.open.timestamp < t.state.facet(Gr).interactionDelay
      ? !1
      : gv(t, e.open.options[e.open.selected]);
  },
  UO = (t) => (t.state.field(Fn, !1) ? (t.dispatch({ effects: dy.of(!0) }), !0) : !1),
  qO = (t) => {
    let e = t.state.field(Fn, !1);
    return !e || !e.active.some((r) => r.state != 0) ? !1 : (t.dispatch({ effects: Qu.of(null) }), !0);
  };
class KO {
  constructor(e, r) {
    (this.active = e), (this.context = r), (this.time = Date.now()), (this.updates = []), (this.done = void 0);
  }
}
const JO = 50,
  XO = 1e3,
  GO = ar.fromClass(
    class {
      constructor(t) {
        (this.view = t),
          (this.debounceUpdate = -1),
          (this.running = []),
          (this.debounceAccept = -1),
          (this.composing = 0);
        for (let e of t.state.field(Fn).active) e.state == 1 && this.startQuery(e);
      }
      update(t) {
        let e = t.state.field(Fn);
        if (!t.selectionSet && !t.docChanged && t.startState.field(Fn) == e) return;
        let r = t.transactions.some((n) => (n.selection || n.docChanged) && !q0(n));
        for (let n = 0; n < this.running.length; n++) {
          let i = this.running[n];
          if (r || (i.updates.length + t.transactions.length > JO && Date.now() - i.time > XO)) {
            for (let s of i.context.abortListeners)
              try {
                s();
              } catch (o) {
                Vn(this.view.state, o);
              }
            (i.context.abortListeners = null), this.running.splice(n--, 1);
          } else i.updates.push(...t.transactions);
        }
        if (
          (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
          (this.debounceUpdate = e.active.some(
            (n) => n.state == 1 && !this.running.some((i) => i.active.source == n.source),
          )
            ? setTimeout(() => this.startUpdate(), 50)
            : -1),
          this.composing != 0)
        )
          for (let n of t.transactions)
            q0(n) == 'input' ? (this.composing = 2) : this.composing == 2 && n.selection && (this.composing = 3);
      }
      startUpdate() {
        this.debounceUpdate = -1;
        let { state: t } = this.view,
          e = t.field(Fn);
        for (let r of e.active)
          r.state == 1 && !this.running.some((n) => n.active.source == r.source) && this.startQuery(r);
      }
      startQuery(t) {
        let { state: e } = this.view,
          r = Ys(e),
          n = new pv(e, r, t.explicitPos == r),
          i = new KO(t, n);
        this.running.push(i),
          Promise.resolve(t.source(n)).then(
            (s) => {
              i.context.aborted || ((i.done = s || null), this.scheduleAccept());
            },
            (s) => {
              this.view.dispatch({ effects: Qu.of(null) }), Vn(this.view.state, s);
            },
          );
      }
      scheduleAccept() {
        this.running.every((t) => t.done !== void 0)
          ? this.accept()
          : this.debounceAccept < 0 &&
            (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Gr).updateSyncTime));
      }
      accept() {
        var t;
        this.debounceAccept > -1 && clearTimeout(this.debounceAccept), (this.debounceAccept = -1);
        let e = [],
          r = this.view.state.facet(Gr);
        for (let n = 0; n < this.running.length; n++) {
          let i = this.running[n];
          if (i.done === void 0) continue;
          if ((this.running.splice(n--, 1), i.done)) {
            let o = new Ya(
              i.active.source,
              i.active.explicitPos,
              i.done,
              i.done.from,
              (t = i.done.to) !== null && t !== void 0
                ? t
                : Ys(i.updates.length ? i.updates[0].startState : this.view.state),
            );
            for (let l of i.updates) o = o.update(l, r);
            if (o.hasResult()) {
              e.push(o);
              continue;
            }
          }
          let s = this.view.state.field(Fn).active.find((o) => o.source == i.active.source);
          if (s && s.state == 1)
            if (i.done == null) {
              let o = new mn(i.active.source, 0);
              for (let l of i.updates) o = o.update(l, r);
              o.state != 1 && e.push(o);
            } else this.startQuery(s);
        }
        e.length && this.view.dispatch({ effects: dv.of(e) });
      }
    },
    {
      eventHandlers: {
        blur(t) {
          let e = this.view.state.field(Fn, !1);
          if (e && e.tooltip && this.view.state.facet(Gr).closeOnBlur) {
            let r = e.open && YE(this.view, e.open.tooltip);
            (!r || !r.dom.contains(t.relatedTarget)) && this.view.dispatch({ effects: Qu.of(null) });
          }
        },
        compositionstart() {
          this.composing = 1;
        },
        compositionend() {
          this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: dy.of(!1) }), 20), (this.composing = 0);
        },
      },
    },
  ),
  YO = ze.baseTheme({
    '.cm-tooltip.cm-tooltip-autocomplete': {
      '& > ul': {
        'fontFamily': 'monospace',
        'whiteSpace': 'nowrap',
        'overflow': 'hidden auto',
        'maxWidth_fallback': '700px',
        'maxWidth': 'min(700px, 95vw)',
        'minWidth': '250px',
        'maxHeight': '10em',
        'height': '100%',
        'listStyle': 'none',
        'margin': 0,
        'padding': 0,
        '& > li, & > completion-section': { padding: '1px 3px', lineHeight: 1.2 },
        '& > li': { overflowX: 'hidden', textOverflow: 'ellipsis', cursor: 'pointer' },
        '& > completion-section': {
          display: 'list-item',
          borderBottom: '1px solid silver',
          paddingLeft: '0.5em',
          opacity: 0.7,
        },
      },
    },
    '&light .cm-tooltip-autocomplete ul li[aria-selected]': { background: '#17c', color: 'white' },
    '&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]': { background: '#777' },
    '&dark .cm-tooltip-autocomplete ul li[aria-selected]': { background: '#347', color: 'white' },
    '&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]': { background: '#444' },
    '.cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after': {
      content: '"···"',
      opacity: 0.5,
      display: 'block',
      textAlign: 'center',
    },
    '.cm-tooltip.cm-completionInfo': {
      position: 'absolute',
      padding: '3px 9px',
      width: 'max-content',
      maxWidth: '400px',
      boxSizing: 'border-box',
    },
    '.cm-completionInfo.cm-completionInfo-left': { right: '100%' },
    '.cm-completionInfo.cm-completionInfo-right': { left: '100%' },
    '.cm-completionInfo.cm-completionInfo-left-narrow': { right: '30px' },
    '.cm-completionInfo.cm-completionInfo-right-narrow': { left: '30px' },
    '&light .cm-snippetField': { backgroundColor: '#00000022' },
    '&dark .cm-snippetField': { backgroundColor: '#ffffff22' },
    '.cm-snippetFieldPosition': {
      verticalAlign: 'text-top',
      width: 0,
      height: '1.15em',
      display: 'inline-block',
      margin: '0 -0.7px -.7em',
      borderLeft: '1.4px dotted #888',
    },
    '.cm-completionMatchedText': { textDecoration: 'underline' },
    '.cm-completionDetail': { marginLeft: '0.5em', fontStyle: 'italic' },
    '.cm-completionIcon': {
      fontSize: '90%',
      width: '.8em',
      display: 'inline-block',
      textAlign: 'center',
      paddingRight: '.6em',
      opacity: '0.6',
      boxSizing: 'content-box',
    },
    '.cm-completionIcon-function, .cm-completionIcon-method': { '&:after': { content: "'ƒ'" } },
    '.cm-completionIcon-class': { '&:after': { content: "'○'" } },
    '.cm-completionIcon-interface': { '&:after': { content: "'◌'" } },
    '.cm-completionIcon-variable': { '&:after': { content: "'𝑥'" } },
    '.cm-completionIcon-constant': { '&:after': { content: "'𝐶'" } },
    '.cm-completionIcon-type': { '&:after': { content: "'𝑡'" } },
    '.cm-completionIcon-enum': { '&:after': { content: "'∪'" } },
    '.cm-completionIcon-property': { '&:after': { content: "'□'" } },
    '.cm-completionIcon-keyword': { '&:after': { content: "'🔑︎'" } },
    '.cm-completionIcon-namespace': { '&:after': { content: "'▢'" } },
    '.cm-completionIcon-text': { '&:after': { content: "'abc'", fontSize: '50%', verticalAlign: 'middle' } },
  }),
  Zu = { brackets: ['(', '[', '{', "'", '"'], before: ')]}:;>', stringPrefixes: [] },
  qo = mt.define({
    map(t, e) {
      let r = e.mapPos(t, -1, sn.TrackAfter);
      return r ?? void 0;
    },
  }),
  my = new (class extends ea {})();
my.startSide = 1;
my.endSide = -1;
const yv = vr.define({
  create() {
    return _t.empty;
  },
  update(t, e) {
    if (e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head).from,
        n = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      r != e.changes.mapPos(n, -1) && (t = _t.empty);
    }
    t = t.map(e.changes);
    for (let r of e.effects) r.is(qo) && (t = t.update({ add: [my.range(r.value, r.value + 1)] }));
    return t;
  },
});
function QO() {
  return [e9, yv];
}
const xm = '()[]{}<>';
function Dv(t) {
  for (let e = 0; e < xm.length; e += 2) if (xm.charCodeAt(e) == t) return xm.charAt(e + 1);
  return Hg(t < 128 ? t : t + 1);
}
function xv(t, e) {
  return t.languageDataAt('closeBrackets', e)[0] || Zu;
}
const ZO = typeof navigator == 'object' && /Android\b/.test(navigator.userAgent),
  e9 = ze.inputHandler.of((t, e, r, n) => {
    if ((ZO ? t.composing : t.compositionStarted) || t.state.readOnly) return !1;
    let i = t.state.selection.main;
    if (n.length > 2 || (n.length == 2 && _n(Nr(n, 0)) == 1) || e != i.from || r != i.to) return !1;
    let s = n9(t.state, n);
    return s ? (t.dispatch(s), !0) : !1;
  }),
  t9 = ({ state: t, dispatch: e }) => {
    if (t.readOnly) return !1;
    let n = xv(t, t.selection.main.head).brackets || Zu.brackets,
      i = null,
      s = t.changeByRange((o) => {
        if (o.empty) {
          let l = i9(t.doc, o.head);
          for (let c of n)
            if (c == l && If(t.doc, o.head) == Dv(Nr(c, 0)))
              return {
                changes: { from: o.head - c.length, to: o.head + c.length },
                range: pe.cursor(o.head - c.length),
              };
        }
        return { range: (i = o) };
      });
    return i || e(t.update(s, { scrollIntoView: !0, userEvent: 'delete.backward' })), !i;
  },
  r9 = [{ key: 'Backspace', run: t9 }];
function n9(t, e) {
  let r = xv(t, t.selection.main.head),
    n = r.brackets || Zu.brackets;
  for (let i of n) {
    let s = Dv(Nr(i, 0));
    if (e == i) return s == i ? a9(t, i, n.indexOf(i + i + i) > -1, r) : s9(t, i, s, r.before || Zu.before);
    if (e == s && Cv(t, t.selection.main.from)) return o9(t, i, s);
  }
  return null;
}
function Cv(t, e) {
  let r = !1;
  return (
    t.field(yv).between(0, t.doc.length, (n) => {
      n == e && (r = !0);
    }),
    r
  );
}
function If(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, _n(Nr(r, 0)));
}
function i9(t, e) {
  let r = t.sliceString(e - 2, e);
  return _n(Nr(r, 0)) == r.length ? r : r.slice(1);
}
function s9(t, e, r, n) {
  let i = null,
    s = t.changeByRange((o) => {
      if (!o.empty)
        return {
          changes: [
            { insert: e, from: o.from },
            { insert: r, from: o.to },
          ],
          effects: qo.of(o.to + e.length),
          range: pe.range(o.anchor + e.length, o.head + e.length),
        };
      let l = If(t.doc, o.head);
      return !l || /\s/.test(l) || n.indexOf(l) > -1
        ? {
            changes: { insert: e + r, from: o.head },
            effects: qo.of(o.head + e.length),
            range: pe.cursor(o.head + e.length),
          }
        : { range: (i = o) };
    });
  return i ? null : t.update(s, { scrollIntoView: !0, userEvent: 'input.type' });
}
function o9(t, e, r) {
  let n = null,
    i = t.changeByRange((s) =>
      s.empty && If(t.doc, s.head) == r
        ? { changes: { from: s.head, to: s.head + r.length, insert: r }, range: pe.cursor(s.head + r.length) }
        : (n = { range: s }),
    );
  return n ? null : t.update(i, { scrollIntoView: !0, userEvent: 'input.type' });
}
function a9(t, e, r, n) {
  let i = n.stringPrefixes || Zu.stringPrefixes,
    s = null,
    o = t.changeByRange((l) => {
      if (!l.empty)
        return {
          changes: [
            { insert: e, from: l.from },
            { insert: e, from: l.to },
          ],
          effects: qo.of(l.to + e.length),
          range: pe.range(l.anchor + e.length, l.head + e.length),
        };
      let c = l.head,
        p = If(t.doc, c),
        f;
      if (p == e) {
        if (rC(t, c))
          return { changes: { insert: e + e, from: c }, effects: qo.of(c + e.length), range: pe.cursor(c + e.length) };
        if (Cv(t, c)) {
          let g = r && t.sliceDoc(c, c + e.length * 3) == e + e + e ? e + e + e : e;
          return { changes: { from: c, to: c + g.length, insert: g }, range: pe.cursor(c + g.length) };
        }
      } else {
        if (r && t.sliceDoc(c - 2 * e.length, c) == e + e && (f = nC(t, c - 2 * e.length, i)) > -1 && rC(t, f))
          return {
            changes: { insert: e + e + e + e, from: c },
            effects: qo.of(c + e.length),
            range: pe.cursor(c + e.length),
          };
        if (t.charCategorizer(c)(p) != er.Word && nC(t, c, i) > -1 && !l9(t, c, e, i))
          return { changes: { insert: e + e, from: c }, effects: qo.of(c + e.length), range: pe.cursor(c + e.length) };
      }
      return { range: (s = l) };
    });
  return s ? null : t.update(o, { scrollIntoView: !0, userEvent: 'input.type' });
}
function rC(t, e) {
  let r = jr(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function l9(t, e, r, n) {
  let i = jr(t).resolveInner(e, -1),
    s = n.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + s)),
      c = l.indexOf(r);
    if (!c || (c > -1 && n.indexOf(l.slice(0, c)) > -1)) {
      let f = i.firstChild;
      for (; f && f.from == i.from && f.to - f.from > r.length + c; ) {
        if (t.sliceDoc(f.to - r.length, f.to) == r) return !1;
        f = f.firstChild;
      }
      return !0;
    }
    let p = i.to == e && i.parent;
    if (!p) break;
    i = p;
  }
  return !1;
}
function nC(t, e, r) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != er.Word) return e;
  for (let i of r) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && n(t.sliceDoc(s - 1, s)) != er.Word) return s;
  }
  return -1;
}
function u9(t = {}) {
  return [Fn, Gr.of(t), GO, c9, YO];
}
const bv = [
    { key: 'Ctrl-Space', run: UO },
    { key: 'Escape', run: qO },
    { key: 'ArrowDown', run: Ih(!0) },
    { key: 'ArrowUp', run: Ih(!1) },
    { key: 'PageDown', run: Ih(!0, 'page') },
    { key: 'PageUp', run: Ih(!1, 'page') },
    { key: 'Enter', run: WO },
  ],
  c9 = xl.highest(Ef.computeN([Gr], (t) => (t.facet(Gr).defaultKeymap ? [bv] : [])));
class h9 {
  constructor(e, r, n) {
    (this.from = e), (this.to = r), (this.diagnostic = n);
  }
}
class Vo {
  constructor(e, r, n) {
    (this.diagnostics = e), (this.panel = r), (this.selected = n);
  }
  static init(e, r, n) {
    let i = e,
      s = n.facet(Ko).markerFilter;
    s && (i = s(i));
    let o = it.set(
      i.map((l) =>
        l.from == l.to || (l.from == l.to - 1 && n.doc.lineAt(l.from).to == l.from)
          ? it.widget({ widget: new A9(l), diagnostic: l }).range(l.from)
          : it
              .mark({
                attributes: {
                  class: 'cm-lintRange cm-lintRange-' + l.severity + (l.markClass ? ' ' + l.markClass : ''),
                },
                diagnostic: l,
              })
              .range(l.from, l.to),
      ),
      !0,
    );
    return new Vo(o, r, cl(o));
  }
}
function cl(t, e = null, r = 0) {
  let n = null;
  return (
    t.between(r, 1e9, (i, s, { spec: o }) => {
      if (!(e && o.diagnostic != e)) return (n = new h9(i, s, o.diagnostic)), !1;
    }),
    n
  );
}
function p9(t, e) {
  let r = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((n) => n.is(gy)) || t.changes.touchesRange(r.from, r.to));
}
function Av(t, e) {
  return t.field(wn, !1) ? e : e.concat(mt.appendConfig.of(Sv));
}
function f9(t, e) {
  return { effects: Av(t, [gy.of(e)]) };
}
const gy = mt.define(),
  yy = mt.define(),
  Ev = mt.define(),
  wn = vr.define({
    create() {
      return new Vo(it.none, null, null);
    },
    update(t, e) {
      if (e.docChanged) {
        let r = t.diagnostics.map(e.changes),
          n = null;
        if (t.selected) {
          let i = e.changes.mapPos(t.selected.from, 1);
          n = cl(r, t.selected.diagnostic, i) || cl(r, null, i);
        }
        t = new Vo(r, t.panel, n);
      }
      for (let r of e.effects)
        r.is(gy)
          ? (t = Vo.init(r.value, t.panel, e.state))
          : r.is(yy)
          ? (t = new Vo(t.diagnostics, r.value ? Nf.open : null, t.selected))
          : r.is(Ev) && (t = new Vo(t.diagnostics, t.panel, r.value));
      return t;
    },
    provide: (t) => [Ju.from(t, (e) => e.panel), ze.decorations.from(t, (e) => e.diagnostics)],
  }),
  d9 = it.mark({ class: 'cm-lintRange cm-lintRange-active' });
function m9(t, e, r) {
  let { diagnostics: n } = t.state.field(wn),
    i = [],
    s = 2e8,
    o = 0;
  n.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (c, p, { spec: f }) => {
    e >= c &&
      e <= p &&
      (c == p || ((e > c || r > 0) && (e < p || r < 0))) &&
      (i.push(f.diagnostic), (s = Math.min(c, s)), (o = Math.max(p, o)));
  });
  let l = t.state.facet(Ko).tooltipFilter;
  return (
    l && (i = l(i)),
    i.length
      ? {
          pos: s,
          end: o,
          above: t.state.doc.lineAt(s).to < o,
          create() {
            return { dom: g9(t, i) };
          },
        }
      : null
  );
}
function g9(t, e) {
  return Ht(
    'ul',
    { class: 'cm-tooltip-lint' },
    e.map((r) => Fv(t, r, !1)),
  );
}
const y9 = (t) => {
    let e = t.state.field(wn, !1);
    (!e || !e.panel) && t.dispatch({ effects: Av(t.state, [yy.of(!0)]) });
    let r = Ku(t, Nf.open);
    return r && r.dom.querySelector('.cm-panel-lint ul').focus(), !0;
  },
  iC = (t) => {
    let e = t.state.field(wn, !1);
    return !e || !e.panel ? !1 : (t.dispatch({ effects: yy.of(!1) }), !0);
  },
  D9 = (t) => {
    let e = t.state.field(wn, !1);
    if (!e) return !1;
    let r = t.state.selection.main,
      n = e.diagnostics.iter(r.to + 1);
    return !n.value && ((n = e.diagnostics.iter(0)), !n.value || (n.from == r.from && n.to == r.to))
      ? !1
      : (t.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0 }), !0);
  },
  x9 = [
    { key: 'Mod-Shift-m', run: y9, preventDefault: !0 },
    { key: 'F8', run: D9 },
  ],
  C9 = ar.fromClass(
    class {
      constructor(t) {
        (this.view = t), (this.timeout = -1), (this.set = !0);
        let { delay: e } = t.state.facet(Ko);
        (this.lintTime = Date.now() + e), (this.run = this.run.bind(this)), (this.timeout = setTimeout(this.run, e));
      }
      run() {
        let t = Date.now();
        if (t < this.lintTime - 10) this.timeout = setTimeout(this.run, this.lintTime - t);
        else {
          this.set = !1;
          let { state: e } = this.view,
            { sources: r } = e.facet(Ko);
          Promise.all(r.map((n) => Promise.resolve(n(this.view)))).then(
            (n) => {
              let i = n.reduce((s, o) => s.concat(o));
              this.view.state.doc == e.doc && this.view.dispatch(f9(this.view.state, i));
            },
            (n) => {
              Vn(this.view.state, n);
            },
          );
        }
      }
      update(t) {
        let e = t.state.facet(Ko);
        (t.docChanged || e != t.startState.facet(Ko) || (e.needsRefresh && e.needsRefresh(t))) &&
          ((this.lintTime = Date.now() + e.delay),
          this.set || ((this.set = !0), (this.timeout = setTimeout(this.run, e.delay))));
      }
      force() {
        this.set && ((this.lintTime = Date.now()), this.run());
      }
      destroy() {
        clearTimeout(this.timeout);
      }
    },
  ),
  Ko = Ue.define({
    combine(t) {
      return Object.assign(
        { sources: t.map((e) => e.source) },
        Wi(
          t.map((e) => e.config),
          { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null },
          { needsRefresh: (e, r) => (e ? (r ? (n) => e(n) || r(n) : e) : r) },
        ),
      );
    },
  });
function b9(t, e = {}) {
  return [Ko.of({ source: t, config: e }), C9, Sv];
}
function vv(t) {
  let e = [];
  if (t)
    e: for (let { name: r } of t) {
      for (let n = 0; n < r.length; n++) {
        let i = r[n];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push('');
    }
  return e;
}
function Fv(t, e, r) {
  var n;
  let i = r ? vv(e.actions) : [];
  return Ht(
    'li',
    { class: 'cm-diagnostic cm-diagnostic-' + e.severity },
    Ht('span', { class: 'cm-diagnosticText' }, e.renderMessage ? e.renderMessage() : e.message),
    (n = e.actions) === null || n === void 0
      ? void 0
      : n.map((s, o) => {
          let l = !1,
            c = (g) => {
              if ((g.preventDefault(), l)) return;
              l = !0;
              let x = cl(t.state.field(wn).diagnostics, e);
              x && s.apply(t, x.from, x.to);
            },
            { name: p } = s,
            f = i[o] ? p.indexOf(i[o]) : -1,
            m = f < 0 ? p : [p.slice(0, f), Ht('u', p.slice(f, f + 1)), p.slice(f + 1)];
          return Ht(
            'button',
            {
              'type': 'button',
              'class': 'cm-diagnosticAction',
              'onclick': c,
              'onmousedown': c,
              'aria-label': ` Action: ${p}${f < 0 ? '' : ` (access key "${i[o]})"`}.`,
            },
            m,
          );
        }),
    e.source && Ht('div', { class: 'cm-diagnosticSource' }, e.source),
  );
}
class A9 extends gs {
  constructor(e) {
    super(), (this.diagnostic = e);
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Ht('span', { class: 'cm-lintPoint cm-lintPoint-' + this.diagnostic.severity });
  }
}
class sC {
  constructor(e, r) {
    (this.diagnostic = r),
      (this.id = 'item_' + Math.floor(Math.random() * 4294967295).toString(16)),
      (this.dom = Fv(e, r, !0)),
      (this.dom.id = this.id),
      this.dom.setAttribute('role', 'option');
  }
}
class Nf {
  constructor(e) {
    (this.view = e), (this.items = []);
    let r = (i) => {
        if (i.keyCode == 27) iC(this.view), this.view.focus();
        else if (i.keyCode == 38 || i.keyCode == 33)
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        else if (i.keyCode == 40 || i.keyCode == 34) this.moveSelection((this.selectedIndex + 1) % this.items.length);
        else if (i.keyCode == 36) this.moveSelection(0);
        else if (i.keyCode == 35) this.moveSelection(this.items.length - 1);
        else if (i.keyCode == 13) this.view.focus();
        else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic: s } = this.items[this.selectedIndex],
            o = vv(s.actions);
          for (let l = 0; l < o.length; l++)
            if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
              let c = cl(this.view.state.field(wn).diagnostics, s);
              c && s.actions[l].apply(e, c.from, c.to);
            }
        } else return;
        i.preventDefault();
      },
      n = (i) => {
        for (let s = 0; s < this.items.length; s++) this.items[s].dom.contains(i.target) && this.moveSelection(s);
      };
    (this.list = Ht('ul', {
      'tabIndex': 0,
      'role': 'listbox',
      'aria-label': this.view.state.phrase('Diagnostics'),
      'onkeydown': r,
      'onclick': n,
    })),
      (this.dom = Ht(
        'div',
        { class: 'cm-panel-lint' },
        this.list,
        Ht(
          'button',
          {
            'type': 'button',
            'name': 'close',
            'aria-label': this.view.state.phrase('close'),
            'onclick': () => iC(this.view),
          },
          '×',
        ),
      )),
      this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(wn).selected;
    if (!e) return -1;
    for (let r = 0; r < this.items.length; r++) if (this.items[r].diagnostic == e.diagnostic) return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(wn),
      n = 0,
      i = !1,
      s = null;
    for (
      e.between(0, this.view.state.doc.length, (o, l, { spec: c }) => {
        let p = -1,
          f;
        for (let m = n; m < this.items.length; m++)
          if (this.items[m].diagnostic == c.diagnostic) {
            p = m;
            break;
          }
        p < 0
          ? ((f = new sC(this.view, c.diagnostic)), this.items.splice(n, 0, f), (i = !0))
          : ((f = this.items[p]), p > n && (this.items.splice(n, p - n), (i = !0))),
          r && f.diagnostic == r.diagnostic
            ? f.dom.hasAttribute('aria-selected') || (f.dom.setAttribute('aria-selected', 'true'), (s = f))
            : f.dom.hasAttribute('aria-selected') && f.dom.removeAttribute('aria-selected'),
          n++;
      });
      n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0);

    )
      (i = !0), this.items.pop();
    this.items.length == 0 &&
      (this.items.push(
        new sC(this.view, { from: -1, to: -1, severity: 'info', message: this.view.state.phrase('No diagnostics') }),
      ),
      (i = !0)),
      s
        ? (this.list.setAttribute('aria-activedescendant', s.id),
          this.view.requestMeasure({
            key: this,
            read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
            write: ({ sel: o, panel: l }) => {
              let c = l.height / this.list.offsetHeight;
              o.top < l.top
                ? (this.list.scrollTop -= (l.top - o.top) / c)
                : o.bottom > l.bottom && (this.list.scrollTop += (o.bottom - l.bottom) / c);
            },
          }))
        : this.selectedIndex < 0 && this.list.removeAttribute('aria-activedescendant'),
      i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let n = e;
      (e = n.nextSibling), n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; ) r();
        e = n.dom.nextSibling;
      } else this.list.insertBefore(n.dom, e);
    for (; e; ) r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0) return;
    let r = this.view.state.field(wn),
      n = cl(r.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0, effects: Ev.of(n) });
  }
  static open(e) {
    return new Nf(e);
  }
}
function E9(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Nh(t) {
  return E9(
    `<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`,
    'width="6" height="3"',
  );
}
const v9 = ze.baseTheme({
    '.cm-diagnostic': { padding: '3px 6px 3px 8px', marginLeft: '-1px', display: 'block', whiteSpace: 'pre-wrap' },
    '.cm-diagnostic-error': { borderLeft: '5px solid #d11' },
    '.cm-diagnostic-warning': { borderLeft: '5px solid orange' },
    '.cm-diagnostic-info': { borderLeft: '5px solid #999' },
    '.cm-diagnostic-hint': { borderLeft: '5px solid #66d' },
    '.cm-diagnosticAction': {
      font: 'inherit',
      border: 'none',
      padding: '2px 4px',
      backgroundColor: '#444',
      color: 'white',
      borderRadius: '3px',
      marginLeft: '8px',
      cursor: 'pointer',
    },
    '.cm-diagnosticSource': { fontSize: '70%', opacity: 0.7 },
    '.cm-lintRange': { backgroundPosition: 'left bottom', backgroundRepeat: 'repeat-x', paddingBottom: '0.7px' },
    '.cm-lintRange-error': { backgroundImage: Nh('#d11') },
    '.cm-lintRange-warning': { backgroundImage: Nh('orange') },
    '.cm-lintRange-info': { backgroundImage: Nh('#999') },
    '.cm-lintRange-hint': { backgroundImage: Nh('#66d') },
    '.cm-lintRange-active': { backgroundColor: '#ffdd9980' },
    '.cm-tooltip-lint': { padding: 0, margin: 0 },
    '.cm-lintPoint': {
      'position': 'relative',
      '&:after': {
        content: '""',
        position: 'absolute',
        bottom: 0,
        left: '-2px',
        borderLeft: '3px solid transparent',
        borderRight: '3px solid transparent',
        borderBottom: '4px solid #d11',
      },
    },
    '.cm-lintPoint-warning': { '&:after': { borderBottomColor: 'orange' } },
    '.cm-lintPoint-info': { '&:after': { borderBottomColor: '#999' } },
    '.cm-lintPoint-hint': { '&:after': { borderBottomColor: '#66d' } },
    '.cm-panel.cm-panel-lint': {
      'position': 'relative',
      '& ul': {
        'maxHeight': '100px',
        'overflowY': 'auto',
        '& [aria-selected]': { 'backgroundColor': '#ddd', '& u': { textDecoration: 'underline' } },
        '&:focus [aria-selected]': {
          background_fallback: '#bdf',
          backgroundColor: 'Highlight',
          color_fallback: 'white',
          color: 'HighlightText',
        },
        '& u': { textDecoration: 'none' },
        'padding': 0,
        'margin': 0,
      },
      '& [name=close]': {
        position: 'absolute',
        top: '0',
        right: '2px',
        background: 'inherit',
        border: 'none',
        font: 'inherit',
        padding: 0,
        margin: 0,
      },
    },
  }),
  Sv = [
    wn,
    ze.decorations.compute([wn], (t) => {
      let { selected: e, panel: r } = t.field(wn);
      return !e || !r || e.from == e.to ? it.none : it.set([d9.range(e.from, e.to)]);
    }),
    bI(m9, { hideOn: p9 }),
    v9,
  ],
  F9 = (() => [
    PI(),
    NI(),
    Y6(),
    QN(),
    EN(),
    $6(),
    U6(),
    Ct.allowMultipleSelections.of(!0),
    uN(),
    FN(TN, { fallback: !0 }),
    ON(),
    QO(),
    u9(),
    hI(),
    dI(),
    nI(),
    iO(),
    Ef.of([...r9, ...QM, ...EO, ...aM, ...xN, ...bv, ...x9]),
  ])();
/*!
 * VueCodemirror v6.1.1
 * Copyright (c) Surmon. All rights reserved.
 * Released under the MIT License.
 * Surmon
 */ var S9 = Object.freeze({
    autofocus: !1,
    disabled: !1,
    indentWithTab: !0,
    tabSize: 2,
    placeholder: '',
    autoDestroy: !0,
    extensions: [F9],
  }),
  w9 = Symbol('vue-codemirror-global-config'),
  nn,
  T9 = function (t) {
    var e = t.onUpdate,
      r = t.onChange,
      n = t.onFocus,
      i = t.onBlur,
      s = (function (o, l) {
        var c = {};
        for (var p in o) Object.prototype.hasOwnProperty.call(o, p) && l.indexOf(p) < 0 && (c[p] = o[p]);
        if (o != null && typeof Object.getOwnPropertySymbols == 'function') {
          var f = 0;
          for (p = Object.getOwnPropertySymbols(o); f < p.length; f++)
            l.indexOf(p[f]) < 0 && Object.prototype.propertyIsEnumerable.call(o, p[f]) && (c[p[f]] = o[p[f]]);
        }
        return c;
      })(t, ['onUpdate', 'onChange', 'onFocus', 'onBlur']);
    return Ct.create({
      doc: s.doc,
      selection: s.selection,
      extensions: (Array.isArray(s.extensions) ? s.extensions : [s.extensions]).concat([
        ze.updateListener.of(function (o) {
          e(o), o.docChanged && r(o.state.doc.toString(), o), o.focusChanged && (o.view.hasFocus ? n(o) : i(o));
        }),
      ]),
    });
  },
  _a = function (t) {
    var e = new ac();
    return {
      compartment: e,
      run: function (r) {
        e.get(t.state)
          ? t.dispatch({ effects: e.reconfigure(r) })
          : t.dispatch({ effects: mt.appendConfig.of(e.of(r)) });
      },
    };
  },
  oC = function (t, e) {
    var r = _a(t),
      n = r.compartment,
      i = r.run;
    return function (s) {
      var o = n.get(t.state);
      i(s ?? o !== e ? e : []);
    };
  },
  Mh = { type: Boolean, default: void 0 },
  k9 = {
    autofocus: Mh,
    disabled: Mh,
    indentWithTab: Mh,
    tabSize: Number,
    placeholder: String,
    style: Object,
    autoDestroy: Mh,
    phrases: Object,
    root: Object,
    extensions: Array,
    selection: Object,
  },
  P9 = { modelValue: { type: String, default: '' } },
  B9 = Object.assign(Object.assign({}, k9), P9);
(function (t) {
  (t.Change = 'change'),
    (t.Update = 'update'),
    (t.Focus = 'focus'),
    (t.Blur = 'blur'),
    (t.Ready = 'ready'),
    (t.ModelUpdate = 'update:modelValue');
})(nn || (nn = {}));
var zo = {};
(zo[nn.Change] = function (t, e) {
  return !0;
}),
  (zo[nn.Update] = function (t) {
    return !0;
  }),
  (zo[nn.Focus] = function (t) {
    return !0;
  }),
  (zo[nn.Blur] = function (t) {
    return !0;
  }),
  (zo[nn.Ready] = function (t) {
    return !0;
  });
var wv = {};
wv[nn.ModelUpdate] = zo[nn.Change];
var I9 = Object.assign(Object.assign({}, zo), wv),
  N9 = St({
    name: 'VueCodemirror',
    props: Object.assign({}, B9),
    emits: Object.assign({}, I9),
    setup: function (t, e) {
      var r = Ua(),
        n = Ua(),
        i = Ua(),
        s = Object.assign(Object.assign({}, S9), kn(w9, {})),
        o = nt(function () {
          var l = {};
          return (
            Object.keys(bt(t)).forEach(function (c) {
              var p;
              c !== 'modelValue' && (l[c] = (p = t[c]) !== null && p !== void 0 ? p : s[c]);
            }),
            l
          );
        });
      return (
        Dl(function () {
          var l;
          (n.value = T9({
            doc: t.modelValue,
            selection: o.value.selection,
            extensions: (l = s.extensions) !== null && l !== void 0 ? l : [],
            onFocus: function (p) {
              return e.emit(nn.Focus, p);
            },
            onBlur: function (p) {
              return e.emit(nn.Blur, p);
            },
            onUpdate: function (p) {
              return e.emit(nn.Update, p);
            },
            onChange: function (p, f) {
              p !== t.modelValue && (e.emit(nn.Change, p, f), e.emit(nn.ModelUpdate, p, f));
            },
          })),
            (i.value = (function (p) {
              return new ze(Object.assign({}, p));
            })({ state: n.value, parent: r.value, root: o.value.root }));
          var c = (function (p) {
            var f = function () {
                return p.state.doc.toString();
              },
              m = _a(p).run,
              g = oC(p, [ze.editable.of(!1), Ct.readOnly.of(!0)]),
              x = oC(p, Ef.of([ZM])),
              b = _a(p).run,
              F = _a(p).run,
              E = _a(p).run,
              w = _a(p).run;
            return {
              focus: function () {
                return p.focus();
              },
              getDoc: f,
              setDoc: function (I) {
                I !== f() && p.dispatch({ changes: { from: 0, to: p.state.doc.length, insert: I } });
              },
              reExtensions: m,
              toggleDisabled: g,
              toggleIndentWithTab: x,
              setTabSize: function (I) {
                b([Ct.tabSize.of(I), vf.of(' '.repeat(I))]);
              },
              setPhrases: function (I) {
                F([Ct.phrases.of(I)]);
              },
              setPlaceholder: function (I) {
                E(aI(I));
              },
              setStyle: function (I) {
                I === void 0 && (I = {}), w(ze.theme({ '&': Object.assign({}, I) }));
              },
            };
          })(i.value);
          Zt(
            function () {
              return t.modelValue;
            },
            function (p) {
              p !== c.getDoc() && c.setDoc(p);
            },
          ),
            Zt(
              function () {
                return t.extensions;
              },
              function (p) {
                return c.reExtensions(p || []);
              },
              { immediate: !0 },
            ),
            Zt(
              function () {
                return o.value.disabled;
              },
              function (p) {
                return c.toggleDisabled(p);
              },
              { immediate: !0 },
            ),
            Zt(
              function () {
                return o.value.indentWithTab;
              },
              function (p) {
                return c.toggleIndentWithTab(p);
              },
              { immediate: !0 },
            ),
            Zt(
              function () {
                return o.value.tabSize;
              },
              function (p) {
                return c.setTabSize(p);
              },
              { immediate: !0 },
            ),
            Zt(
              function () {
                return o.value.phrases;
              },
              function (p) {
                return c.setPhrases(p || {});
              },
              { immediate: !0 },
            ),
            Zt(
              function () {
                return o.value.placeholder;
              },
              function (p) {
                return c.setPlaceholder(p);
              },
              { immediate: !0 },
            ),
            Zt(
              function () {
                return o.value.style;
              },
              function (p) {
                return c.setStyle(p);
              },
              { immediate: !0 },
            ),
            o.value.autofocus && c.focus(),
            e.emit(nn.Ready, { state: n.value, view: i.value, container: r.value });
        }),
        Bg(function () {
          o.value.autoDestroy &&
            i.value &&
            (function (l) {
              l.destroy();
            })(i.value);
        }),
        function () {
          return pf('div', { class: 'v-codemirror', style: { display: 'contents' }, ref: r });
        }
      );
    },
  }),
  M9 = N9,
  O9 = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  L9 =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,
  _9 =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
  Cm = { Space_Separator: O9, ID_Start: L9, ID_Continue: _9 },
  cr = {
    isSpaceSeparator(t) {
      return typeof t == 'string' && Cm.Space_Separator.test(t);
    },
    isIdStartChar(t) {
      return (
        typeof t == 'string' &&
        ((t >= 'a' && t <= 'z') || (t >= 'A' && t <= 'Z') || t === '$' || t === '_' || Cm.ID_Start.test(t))
      );
    },
    isIdContinueChar(t) {
      return (
        typeof t == 'string' &&
        ((t >= 'a' && t <= 'z') ||
          (t >= 'A' && t <= 'Z') ||
          (t >= '0' && t <= '9') ||
          t === '$' ||
          t === '_' ||
          t === '‌' ||
          t === '‍' ||
          Cm.ID_Continue.test(t))
      );
    },
    isDigit(t) {
      return typeof t == 'string' && /[0-9]/.test(t);
    },
    isHexDigit(t) {
      return typeof t == 'string' && /[0-9A-Fa-f]/.test(t);
    },
  };
let K0, on, rs, Lp, lo, ui, Sr, Dy, Fu;
var R9 = function (e, r) {
  (K0 = String(e)),
    (on = 'start'),
    (rs = []),
    (Lp = 0),
    (lo = 1),
    (ui = 0),
    (Sr = void 0),
    (Dy = void 0),
    (Fu = void 0);
  do (Sr = j9()), z9[on]();
  while (Sr.type !== 'eof');
  return typeof r == 'function' ? J0({ '': Fu }, '', r) : Fu;
};
function J0(t, e, r) {
  const n = t[e];
  if (n != null && typeof n == 'object')
    if (Array.isArray(n))
      for (let i = 0; i < n.length; i++) {
        const s = String(i),
          o = J0(n, s, r);
        o === void 0
          ? delete n[s]
          : Object.defineProperty(n, s, { value: o, writable: !0, enumerable: !0, configurable: !0 });
      }
    else
      for (const i in n) {
        const s = J0(n, i, r);
        s === void 0
          ? delete n[i]
          : Object.defineProperty(n, i, { value: s, writable: !0, enumerable: !0, configurable: !0 });
      }
  return r.call(t, e, n);
}
let dt, ut, fu, Zi, xt;
function j9() {
  for (dt = 'default', ut = '', fu = !1, Zi = 1; ; ) {
    xt = is();
    const t = Tv[dt]();
    if (t) return t;
  }
}
function is() {
  if (K0[Lp]) return String.fromCodePoint(K0.codePointAt(Lp));
}
function me() {
  const t = is();
  return (
    t ===
    `
`
      ? (lo++, (ui = 0))
      : t
      ? (ui += t.length)
      : ui++,
    t && (Lp += t.length),
    t
  );
}
const Tv = {
  default() {
    switch (xt) {
      case '	':
      case '\v':
      case '\f':
      case ' ':
      case ' ':
      case '\uFEFF':
      case `
`:
      case '\r':
      case '\u2028':
      case '\u2029':
        me();
        return;
      case '/':
        me(), (dt = 'comment');
        return;
      case void 0:
        return me(), Ut('eof');
    }
    if (cr.isSpaceSeparator(xt)) {
      me();
      return;
    }
    return Tv[on]();
  },
  comment() {
    switch (xt) {
      case '*':
        me(), (dt = 'multiLineComment');
        return;
      case '/':
        me(), (dt = 'singleLineComment');
        return;
    }
    throw qt(me());
  },
  multiLineComment() {
    switch (xt) {
      case '*':
        me(), (dt = 'multiLineCommentAsterisk');
        return;
      case void 0:
        throw qt(me());
    }
    me();
  },
  multiLineCommentAsterisk() {
    switch (xt) {
      case '*':
        me();
        return;
      case '/':
        me(), (dt = 'default');
        return;
      case void 0:
        throw qt(me());
    }
    me(), (dt = 'multiLineComment');
  },
  singleLineComment() {
    switch (xt) {
      case `
`:
      case '\r':
      case '\u2028':
      case '\u2029':
        me(), (dt = 'default');
        return;
      case void 0:
        return me(), Ut('eof');
    }
    me();
  },
  value() {
    switch (xt) {
      case '{':
      case '[':
        return Ut('punctuator', me());
      case 'n':
        return me(), Oo('ull'), Ut('null', null);
      case 't':
        return me(), Oo('rue'), Ut('boolean', !0);
      case 'f':
        return me(), Oo('alse'), Ut('boolean', !1);
      case '-':
      case '+':
        me() === '-' && (Zi = -1), (dt = 'sign');
        return;
      case '.':
        (ut = me()), (dt = 'decimalPointLeading');
        return;
      case '0':
        (ut = me()), (dt = 'zero');
        return;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        (ut = me()), (dt = 'decimalInteger');
        return;
      case 'I':
        return me(), Oo('nfinity'), Ut('numeric', 1 / 0);
      case 'N':
        return me(), Oo('aN'), Ut('numeric', NaN);
      case '"':
      case "'":
        (fu = me() === '"'), (ut = ''), (dt = 'string');
        return;
    }
    throw qt(me());
  },
  identifierNameStartEscape() {
    if (xt !== 'u') throw qt(me());
    me();
    const t = X0();
    switch (t) {
      case '$':
      case '_':
        break;
      default:
        if (!cr.isIdStartChar(t)) throw aC();
        break;
    }
    (ut += t), (dt = 'identifierName');
  },
  identifierName() {
    switch (xt) {
      case '$':
      case '_':
      case '‌':
      case '‍':
        ut += me();
        return;
      case '\\':
        me(), (dt = 'identifierNameEscape');
        return;
    }
    if (cr.isIdContinueChar(xt)) {
      ut += me();
      return;
    }
    return Ut('identifier', ut);
  },
  identifierNameEscape() {
    if (xt !== 'u') throw qt(me());
    me();
    const t = X0();
    switch (t) {
      case '$':
      case '_':
      case '‌':
      case '‍':
        break;
      default:
        if (!cr.isIdContinueChar(t)) throw aC();
        break;
    }
    (ut += t), (dt = 'identifierName');
  },
  sign() {
    switch (xt) {
      case '.':
        (ut = me()), (dt = 'decimalPointLeading');
        return;
      case '0':
        (ut = me()), (dt = 'zero');
        return;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        (ut = me()), (dt = 'decimalInteger');
        return;
      case 'I':
        return me(), Oo('nfinity'), Ut('numeric', Zi * (1 / 0));
      case 'N':
        return me(), Oo('aN'), Ut('numeric', NaN);
    }
    throw qt(me());
  },
  zero() {
    switch (xt) {
      case '.':
        (ut += me()), (dt = 'decimalPoint');
        return;
      case 'e':
      case 'E':
        (ut += me()), (dt = 'decimalExponent');
        return;
      case 'x':
      case 'X':
        (ut += me()), (dt = 'hexadecimal');
        return;
    }
    return Ut('numeric', Zi * 0);
  },
  decimalInteger() {
    switch (xt) {
      case '.':
        (ut += me()), (dt = 'decimalPoint');
        return;
      case 'e':
      case 'E':
        (ut += me()), (dt = 'decimalExponent');
        return;
    }
    if (cr.isDigit(xt)) {
      ut += me();
      return;
    }
    return Ut('numeric', Zi * Number(ut));
  },
  decimalPointLeading() {
    if (cr.isDigit(xt)) {
      (ut += me()), (dt = 'decimalFraction');
      return;
    }
    throw qt(me());
  },
  decimalPoint() {
    switch (xt) {
      case 'e':
      case 'E':
        (ut += me()), (dt = 'decimalExponent');
        return;
    }
    if (cr.isDigit(xt)) {
      (ut += me()), (dt = 'decimalFraction');
      return;
    }
    return Ut('numeric', Zi * Number(ut));
  },
  decimalFraction() {
    switch (xt) {
      case 'e':
      case 'E':
        (ut += me()), (dt = 'decimalExponent');
        return;
    }
    if (cr.isDigit(xt)) {
      ut += me();
      return;
    }
    return Ut('numeric', Zi * Number(ut));
  },
  decimalExponent() {
    switch (xt) {
      case '+':
      case '-':
        (ut += me()), (dt = 'decimalExponentSign');
        return;
    }
    if (cr.isDigit(xt)) {
      (ut += me()), (dt = 'decimalExponentInteger');
      return;
    }
    throw qt(me());
  },
  decimalExponentSign() {
    if (cr.isDigit(xt)) {
      (ut += me()), (dt = 'decimalExponentInteger');
      return;
    }
    throw qt(me());
  },
  decimalExponentInteger() {
    if (cr.isDigit(xt)) {
      ut += me();
      return;
    }
    return Ut('numeric', Zi * Number(ut));
  },
  hexadecimal() {
    if (cr.isHexDigit(xt)) {
      (ut += me()), (dt = 'hexadecimalInteger');
      return;
    }
    throw qt(me());
  },
  hexadecimalInteger() {
    if (cr.isHexDigit(xt)) {
      ut += me();
      return;
    }
    return Ut('numeric', Zi * Number(ut));
  },
  string() {
    switch (xt) {
      case '\\':
        me(), (ut += $9());
        return;
      case '"':
        if (fu) return me(), Ut('string', ut);
        ut += me();
        return;
      case "'":
        if (!fu) return me(), Ut('string', ut);
        ut += me();
        return;
      case `
`:
      case '\r':
        throw qt(me());
      case '\u2028':
      case '\u2029':
        H9(xt);
        break;
      case void 0:
        throw qt(me());
    }
    ut += me();
  },
  start() {
    switch (xt) {
      case '{':
      case '[':
        return Ut('punctuator', me());
    }
    dt = 'value';
  },
  beforePropertyName() {
    switch (xt) {
      case '$':
      case '_':
        (ut = me()), (dt = 'identifierName');
        return;
      case '\\':
        me(), (dt = 'identifierNameStartEscape');
        return;
      case '}':
        return Ut('punctuator', me());
      case '"':
      case "'":
        (fu = me() === '"'), (dt = 'string');
        return;
    }
    if (cr.isIdStartChar(xt)) {
      (ut += me()), (dt = 'identifierName');
      return;
    }
    throw qt(me());
  },
  afterPropertyName() {
    if (xt === ':') return Ut('punctuator', me());
    throw qt(me());
  },
  beforePropertyValue() {
    dt = 'value';
  },
  afterPropertyValue() {
    switch (xt) {
      case ',':
      case '}':
        return Ut('punctuator', me());
    }
    throw qt(me());
  },
  beforeArrayValue() {
    if (xt === ']') return Ut('punctuator', me());
    dt = 'value';
  },
  afterArrayValue() {
    switch (xt) {
      case ',':
      case ']':
        return Ut('punctuator', me());
    }
    throw qt(me());
  },
  end() {
    throw qt(me());
  },
};
function Ut(t, e) {
  return { type: t, value: e, line: lo, column: ui };
}
function Oo(t) {
  for (const e of t) {
    if (is() !== e) throw qt(me());
    me();
  }
}
function $9() {
  switch (is()) {
    case 'b':
      return me(), '\b';
    case 'f':
      return me(), '\f';
    case 'n':
      return (
        me(),
        `
`
      );
    case 'r':
      return me(), '\r';
    case 't':
      return me(), '	';
    case 'v':
      return me(), '\v';
    case '0':
      if ((me(), cr.isDigit(is()))) throw qt(me());
      return '\0';
    case 'x':
      return me(), V9();
    case 'u':
      return me(), X0();
    case `
`:
    case '\u2028':
    case '\u2029':
      return me(), '';
    case '\r':
      return (
        me(),
        is() ===
          `
` && me(),
        ''
      );
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      throw qt(me());
    case void 0:
      throw qt(me());
  }
  return me();
}
function V9() {
  let t = '',
    e = is();
  if (!cr.isHexDigit(e) || ((t += me()), (e = is()), !cr.isHexDigit(e))) throw qt(me());
  return (t += me()), String.fromCodePoint(parseInt(t, 16));
}
function X0() {
  let t = '',
    e = 4;
  for (; e-- > 0; ) {
    const r = is();
    if (!cr.isHexDigit(r)) throw qt(me());
    t += me();
  }
  return String.fromCodePoint(parseInt(t, 16));
}
const z9 = {
  start() {
    if (Sr.type === 'eof') throw Lo();
    bm();
  },
  beforePropertyName() {
    switch (Sr.type) {
      case 'identifier':
      case 'string':
        (Dy = Sr.value), (on = 'afterPropertyName');
        return;
      case 'punctuator':
        Oh();
        return;
      case 'eof':
        throw Lo();
    }
  },
  afterPropertyName() {
    if (Sr.type === 'eof') throw Lo();
    on = 'beforePropertyValue';
  },
  beforePropertyValue() {
    if (Sr.type === 'eof') throw Lo();
    bm();
  },
  beforeArrayValue() {
    if (Sr.type === 'eof') throw Lo();
    if (Sr.type === 'punctuator' && Sr.value === ']') {
      Oh();
      return;
    }
    bm();
  },
  afterPropertyValue() {
    if (Sr.type === 'eof') throw Lo();
    switch (Sr.value) {
      case ',':
        on = 'beforePropertyName';
        return;
      case '}':
        Oh();
    }
  },
  afterArrayValue() {
    if (Sr.type === 'eof') throw Lo();
    switch (Sr.value) {
      case ',':
        on = 'beforeArrayValue';
        return;
      case ']':
        Oh();
    }
  },
  end() {},
};
function bm() {
  let t;
  switch (Sr.type) {
    case 'punctuator':
      switch (Sr.value) {
        case '{':
          t = {};
          break;
        case '[':
          t = [];
          break;
      }
      break;
    case 'null':
    case 'boolean':
    case 'numeric':
    case 'string':
      t = Sr.value;
      break;
  }
  if (Fu === void 0) Fu = t;
  else {
    const e = rs[rs.length - 1];
    Array.isArray(e)
      ? e.push(t)
      : Object.defineProperty(e, Dy, { value: t, writable: !0, enumerable: !0, configurable: !0 });
  }
  if (t !== null && typeof t == 'object')
    rs.push(t), Array.isArray(t) ? (on = 'beforeArrayValue') : (on = 'beforePropertyName');
  else {
    const e = rs[rs.length - 1];
    e == null ? (on = 'end') : Array.isArray(e) ? (on = 'afterArrayValue') : (on = 'afterPropertyValue');
  }
}
function Oh() {
  rs.pop();
  const t = rs[rs.length - 1];
  t == null ? (on = 'end') : Array.isArray(t) ? (on = 'afterArrayValue') : (on = 'afterPropertyValue');
}
function qt(t) {
  return _p(
    t === void 0 ? `JSON5: invalid end of input at ${lo}:${ui}` : `JSON5: invalid character '${kv(t)}' at ${lo}:${ui}`,
  );
}
function Lo() {
  return _p(`JSON5: invalid end of input at ${lo}:${ui}`);
}
function aC() {
  return (ui -= 5), _p(`JSON5: invalid identifier character at ${lo}:${ui}`);
}
function H9(t) {
  console.warn(`JSON5: '${kv(t)}' in strings is not valid ECMAScript; consider escaping`);
}
function kv(t) {
  const e = {
    "'": "\\'",
    '"': '\\"',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '	': '\\t',
    '\v': '\\v',
    '\0': '\\0',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029',
  };
  if (e[t]) return e[t];
  if (t < ' ') {
    const r = t.charCodeAt(0).toString(16);
    return '\\x' + ('00' + r).substring(r.length);
  }
  return t;
}
function _p(t) {
  const e = new SyntaxError(t);
  return (e.lineNumber = lo), (e.columnNumber = ui), e;
}
var W9 = function (e, r, n) {
  const i = [];
  let s = '',
    o,
    l,
    c = '',
    p;
  if (
    (r != null && typeof r == 'object' && !Array.isArray(r) && ((n = r.space), (p = r.quote), (r = r.replacer)),
    typeof r == 'function')
  )
    l = r;
  else if (Array.isArray(r)) {
    o = [];
    for (const F of r) {
      let E;
      typeof F == 'string'
        ? (E = F)
        : (typeof F == 'number' || F instanceof String || F instanceof Number) && (E = String(F)),
        E !== void 0 && o.indexOf(E) < 0 && o.push(E);
    }
  }
  return (
    n instanceof Number ? (n = Number(n)) : n instanceof String && (n = String(n)),
    typeof n == 'number'
      ? n > 0 && ((n = Math.min(10, Math.floor(n))), (c = '          '.substr(0, n)))
      : typeof n == 'string' && (c = n.substr(0, 10)),
    f('', { '': e })
  );
  function f(F, E) {
    let w = E[F];
    switch (
      (w != null &&
        (typeof w.toJSON5 == 'function' ? (w = w.toJSON5(F)) : typeof w.toJSON == 'function' && (w = w.toJSON(F))),
      l && (w = l.call(E, F, w)),
      w instanceof Number
        ? (w = Number(w))
        : w instanceof String
        ? (w = String(w))
        : w instanceof Boolean && (w = w.valueOf()),
      w)
    ) {
      case null:
        return 'null';
      case !0:
        return 'true';
      case !1:
        return 'false';
    }
    if (typeof w == 'string') return m(w);
    if (typeof w == 'number') return String(w);
    if (typeof w == 'object') return Array.isArray(w) ? b(w) : g(w);
  }
  function m(F) {
    const E = { "'": 0.1, '"': 0.2 },
      w = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '	': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029',
      };
    let I = '';
    for (let j = 0; j < F.length; j++) {
      const $ = F[j];
      switch ($) {
        case "'":
        case '"':
          E[$]++, (I += $);
          continue;
        case '\0':
          if (cr.isDigit(F[j + 1])) {
            I += '\\x00';
            continue;
          }
      }
      if (w[$]) {
        I += w[$];
        continue;
      }
      if ($ < ' ') {
        let L = $.charCodeAt(0).toString(16);
        I += '\\x' + ('00' + L).substring(L.length);
        continue;
      }
      I += $;
    }
    const T = p || Object.keys(E).reduce((j, $) => (E[j] < E[$] ? j : $));
    return (I = I.replace(new RegExp(T, 'g'), w[T])), T + I + T;
  }
  function g(F) {
    if (i.indexOf(F) >= 0) throw TypeError('Converting circular structure to JSON5');
    i.push(F);
    let E = s;
    s = s + c;
    let w = o || Object.keys(F),
      I = [];
    for (const j of w) {
      const $ = f(j, F);
      if ($ !== void 0) {
        let L = x(j) + ':';
        c !== '' && (L += ' '), (L += $), I.push(L);
      }
    }
    let T;
    if (I.length === 0) T = '{}';
    else {
      let j;
      if (c === '') (j = I.join(',')), (T = '{' + j + '}');
      else {
        let $ =
          `,
` + s;
        (j = I.join($)),
          (T =
            `{
` +
            s +
            j +
            `,
` +
            E +
            '}');
      }
    }
    return i.pop(), (s = E), T;
  }
  function x(F) {
    if (F.length === 0) return m(F);
    const E = String.fromCodePoint(F.codePointAt(0));
    if (!cr.isIdStartChar(E)) return m(F);
    for (let w = E.length; w < F.length; w++)
      if (!cr.isIdContinueChar(String.fromCodePoint(F.codePointAt(w)))) return m(F);
    return F;
  }
  function b(F) {
    if (i.indexOf(F) >= 0) throw TypeError('Converting circular structure to JSON5');
    i.push(F);
    let E = s;
    s = s + c;
    let w = [];
    for (let T = 0; T < F.length; T++) {
      const j = f(String(T), F);
      w.push(j !== void 0 ? j : 'null');
    }
    let I;
    if (w.length === 0) I = '[]';
    else if (c === '') I = '[' + w.join(',') + ']';
    else {
      let T =
          `,
` + s,
        j = w.join(T);
      I =
        `[
` +
        s +
        j +
        `,
` +
        E +
        ']';
    }
    return i.pop(), (s = E), I;
  }
};
const U9 = { parse: R9, stringify: W9 };
var Pv = U9;
class Rp {
  constructor(e, r, n, i, s, o, l, c, p, f = 0, m) {
    (this.p = e),
      (this.stack = r),
      (this.state = n),
      (this.reducePos = i),
      (this.pos = s),
      (this.score = o),
      (this.buffer = l),
      (this.bufferBase = c),
      (this.curContext = p),
      (this.lookAhead = f),
      (this.parent = m);
  }
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${
      this.score ? '!' + this.score : ''
    }`;
  }
  static start(e, r, n = 0) {
    let i = e.parser.context;
    return new Rp(e, [], r, n, n, 0, [], 0, i ? new lC(i, i.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), (this.state = e);
  }
  reduce(e) {
    var r;
    let n = e >> 19,
      i = e & 65535,
      { parser: s } = this.p,
      o = s.dynamicPrecedence(i);
    if ((o && (this.score += o), n == 0)) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos),
        i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0),
        this.reduceContext(i, this.reducePos);
      return;
    }
    let l = this.stack.length - (n - 1) * 3 - (e & 262144 ? 6 : 0),
      c = l ? this.stack[l - 2] : this.p.ranges[0].from,
      p = this.reducePos - c;
    p >= 2e3 &&
      !(!((r = this.p.parser.nodeSet.types[i]) === null || r === void 0) && r.isAnonymous) &&
      (c == this.p.lastBigReductionStart
        ? (this.p.bigReductionCount++, (this.p.lastBigReductionSize = p))
        : this.p.lastBigReductionSize < p &&
          ((this.p.bigReductionCount = 1), (this.p.lastBigReductionStart = c), (this.p.lastBigReductionSize = p)));
    let f = l ? this.stack[l - 1] : 0,
      m = this.bufferBase + this.buffer.length - f;
    if (i < s.minRepeatTerm || e & 131072) {
      let g = s.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(i, c, g, m + 4, !0);
    }
    if (e & 262144) this.state = this.stack[l];
    else {
      let g = this.stack[l - 3];
      this.state = s.getGoto(g, i, !0);
    }
    for (; this.stack.length > l; ) this.stack.pop();
    this.reduceContext(i, c);
  }
  storeNode(e, r, n, i = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this,
        l = this.buffer.length;
      if (
        (l == 0 && o.parent && ((l = o.bufferBase - o.parent.bufferBase), (o = o.parent)),
        l > 0 && o.buffer[l - 4] == 0 && o.buffer[l - 1] > -1)
      ) {
        if (r == n) return;
        if (o.buffer[l - 2] >= r) {
          o.buffer[l - 2] = n;
          return;
        }
      }
    }
    if (!s || this.pos == n) this.buffer.push(e, r, n, i);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > n; )
          (this.buffer[o] = this.buffer[o - 4]),
            (this.buffer[o + 1] = this.buffer[o - 3]),
            (this.buffer[o + 2] = this.buffer[o - 2]),
            (this.buffer[o + 3] = this.buffer[o - 1]),
            (o -= 4),
            i > 4 && (i -= 4);
      (this.buffer[o] = e), (this.buffer[o + 1] = r), (this.buffer[o + 2] = n), (this.buffer[o + 3] = i);
    }
  }
  shift(e, r, n, i) {
    if (e & 131072) this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      (this.pos = i), this.shiftContext(r, n), r <= this.p.parser.maxNode && this.buffer.push(r, n, i, 4);
    else {
      let s = e,
        { parser: o } = this.p;
      (i > this.pos || r <= o.maxNode) && ((this.pos = i), o.stateFlag(s, 1) || (this.reducePos = i)),
        this.pushState(s, n),
        this.shiftContext(r, n),
        r <= o.maxNode && this.buffer.push(r, n, i, 4);
    }
  }
  apply(e, r, n, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, n, i);
  }
  useNode(e, r) {
    let n = this.p.reused.length - 1;
    (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
    let i = this.pos;
    (this.reducePos = this.pos = i + e.length),
      this.pushState(r, i),
      this.buffer.push(n, i, this.reducePos, -1),
      this.curContext &&
        this.updateContext(
          this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)),
        );
  }
  split() {
    let e = this,
      r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; ) r -= 4;
    let n = e.buffer.slice(r),
      i = e.bufferBase + r;
    for (; e && i == e.bufferBase; ) e = e.parent;
    return new Rp(
      this.p,
      this.stack.slice(),
      this.state,
      this.reducePos,
      this.pos,
      this.score,
      n,
      i,
      this.curContext,
      this.lookAhead,
      e,
    );
  }
  recoverByDelete(e, r) {
    let n = e <= this.p.parser.maxNode;
    n && this.storeNode(e, this.pos, r, 4),
      this.storeNode(0, this.pos, r, n ? 8 : 4),
      (this.pos = this.reducePos = r),
      (this.score -= 190);
  }
  canShift(e) {
    for (let r = new q9(this); ; ) {
      let n = this.p.parser.stateSlot(r.state, 4) || this.p.parser.hasAction(r.state, e);
      if (n == 0) return !1;
      if (!(n & 65536)) return !0;
      r.reduce(n);
    }
  }
  recoverByInsert(e) {
    if (this.stack.length >= 300) return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let s = 0, o; s < r.length; s += 2)
        (o = r[s + 1]) != this.state && this.p.parser.hasAction(o, e) && i.push(r[s], o);
      if (this.stack.length < 120)
        for (let s = 0; i.length < 8 && s < r.length; s += 2) {
          let o = r[s + 1];
          i.some((l, c) => c & 1 && l == o) || i.push(r[s], o);
        }
      r = i;
    }
    let n = [];
    for (let i = 0; i < r.length && n.length < 4; i += 2) {
      let s = r[i + 1];
      if (s == this.state) continue;
      let o = this.split();
      o.pushState(s, this.pos),
        o.storeNode(0, o.pos, o.pos, 4, !0),
        o.shiftContext(r[i], this.pos),
        (o.reducePos = this.pos),
        (o.score -= 200),
        n.push(o);
    }
    return n;
  }
  forceReduce() {
    let { parser: e } = this.p,
      r = e.stateSlot(this.state, 5);
    if (!(r & 65536)) return !1;
    if (!e.validAction(this.state, r)) {
      let n = r >> 19,
        i = r & 65535,
        s = this.stack.length - n * 3;
      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null) return !1;
        r = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), (this.score -= 100);
    }
    return (this.reducePos = this.pos), this.reduce(r), !0;
  }
  findForcedReduction() {
    let { parser: e } = this.p,
      r = [],
      n = (i, s) => {
        if (!r.includes(i))
          return (
            r.push(i),
            e.allActions(i, (o) => {
              if (!(o & 393216))
                if (o & 65536) {
                  let l = (o >> 19) - s;
                  if (l > 1) {
                    let c = o & 65535,
                      p = this.stack.length - l * 3;
                    if (p >= 0 && e.getGoto(this.stack[p], c, !1) >= 0) return (l << 19) | 65536 | c;
                  }
                } else {
                  let l = n(o, s + 1);
                  if (l != null) return l;
                }
            })
          );
      };
    return n(this.state, 0);
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3) return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(this.state, 1)] == 65535 && !e.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), (this.state = this.stack[0]), (this.stack.length = 0);
  }
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length) return !1;
    for (let r = 0; r < this.stack.length; r += 3) if (this.stack[r] != e.stack[r]) return !1;
    return !0;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext &&
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext &&
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new lC(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), (this.curContext = r);
    }
  }
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), (this.lookAhead = e));
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class lC {
  constructor(e, r) {
    (this.tracker = e), (this.context = r), (this.hash = e.strict ? e.hash(r) : 0);
  }
}
class q9 {
  constructor(e) {
    (this.start = e), (this.state = e.state), (this.stack = e.stack), (this.base = this.stack.length);
  }
  reduce(e) {
    let r = e & 65535,
      n = e >> 19;
    n == 0
      ? (this.stack == this.start.stack && (this.stack = this.stack.slice()),
        this.stack.push(this.state, 0, 0),
        (this.base += 3))
      : (this.base -= (n - 1) * 3);
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = i;
  }
}
class jp {
  constructor(e, r, n) {
    (this.stack = e), (this.pos = r), (this.index = n), (this.buffer = e.buffer), this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new jp(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && ((this.index = this.stack.bufferBase - e.bufferBase), (this.stack = e), (this.buffer = e.buffer));
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    (this.index -= 4), (this.pos -= 4), this.index == 0 && this.maybeNext();
  }
  fork() {
    return new jp(this.stack, this.pos, this.index);
  }
}
function Lh(t, e = Uint16Array) {
  if (typeof t != 'string') return t;
  let r = null;
  for (let n = 0, i = 0; n < t.length; ) {
    let s = 0;
    for (;;) {
      let o = t.charCodeAt(n++),
        l = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let c = o - 32;
      if ((c >= 46 && ((c -= 46), (l = !0)), (s += c), l)) break;
      s *= 46;
    }
    r ? (r[i++] = s) : (r = new e(s));
  }
  return r;
}
class tp {
  constructor() {
    (this.start = -1),
      (this.value = -1),
      (this.end = -1),
      (this.extended = -1),
      (this.lookAhead = 0),
      (this.mask = 0),
      (this.context = 0);
  }
}
const uC = new tp();
class K9 {
  constructor(e, r) {
    (this.input = e),
      (this.ranges = r),
      (this.chunk = ''),
      (this.chunkOff = 0),
      (this.chunk2 = ''),
      (this.chunk2Pos = 0),
      (this.next = -1),
      (this.token = uC),
      (this.rangeIndex = 0),
      (this.pos = this.chunkPos = r[0].from),
      (this.range = r[0]),
      (this.end = r[r.length - 1].to),
      this.readNext();
  }
  resolveOffset(e, r) {
    let n = this.range,
      i = this.rangeIndex,
      s = this.pos + e;
    for (; s < n.from; ) {
      if (!i) return null;
      let o = this.ranges[--i];
      (s -= n.from - o.to), (n = o);
    }
    for (; r < 0 ? s > n.to : s >= n.to; ) {
      if (i == this.ranges.length - 1) return null;
      let o = this.ranges[++i];
      (s += o.from - n.to), (n = o);
    }
    return s;
  }
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to) return e;
    for (let r of this.ranges) if (r.to > e) return Math.max(e, r.from);
    return this.end;
  }
  peek(e) {
    let r = this.chunkOff + e,
      n,
      i;
    if (r >= 0 && r < this.chunk.length) (n = this.pos + e), (i = this.chunk.charCodeAt(r));
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null) return -1;
      if (((n = s), n >= this.chunk2Pos && n < this.chunk2Pos + this.chunk2.length))
        i = this.chunk2.charCodeAt(n - this.chunk2Pos);
      else {
        let o = this.rangeIndex,
          l = this.range;
        for (; l.to <= n; ) l = this.ranges[++o];
        (this.chunk2 = this.input.chunk((this.chunk2Pos = n))),
          n + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - n)),
          (i = this.chunk2.charCodeAt(0));
      }
    }
    return n >= this.token.lookAhead && (this.token.lookAhead = n + 1), i;
  }
  acceptToken(e, r = 0) {
    let n = r ? this.resolveOffset(r, -1) : this.pos;
    if (n == null || n < this.token.start) throw new RangeError('Token end out of bounds');
    (this.token.value = e), (this.token.end = n);
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      (this.chunk = this.chunk2),
        (this.chunkPos = this.chunk2Pos),
        (this.chunk2 = e),
        (this.chunk2Pos = r),
        (this.chunkOff = this.pos - this.chunkPos);
    } else {
      (this.chunk2 = this.chunk), (this.chunk2Pos = this.chunkPos);
      let e = this.input.chunk(this.pos),
        r = this.pos + e.length;
      (this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e),
        (this.chunkPos = this.pos),
        (this.chunkOff = 0);
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length)
      ? (this.next = -1)
      : (this.next = this.chunk.charCodeAt(this.chunkOff));
  }
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
      (e -= this.range.to - this.pos), (this.range = this.ranges[++this.rangeIndex]), (this.pos = this.range.from);
    }
    return (this.pos += e), this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return (
      (this.pos = this.chunkPos = this.end),
      (this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]),
      (this.chunk = ''),
      (this.next = -1)
    );
  }
  reset(e, r) {
    if (
      (r ? ((this.token = r), (r.start = e), (r.lookAhead = e + 1), (r.value = r.extended = -1)) : (this.token = uC),
      this.pos != e)
    ) {
      if (((this.pos = e), e == this.end)) return this.setDone(), this;
      for (; e < this.range.from; ) this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; ) this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length
        ? (this.chunkOff = e - this.chunkPos)
        : ((this.chunk = ''), (this.chunkOff = 0)),
        this.readNext();
    }
    return this;
  }
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to) return this.input.read(e, r);
    let n = '';
    for (let i of this.ranges) {
      if (i.from >= r) break;
      i.to > e && (n += this.input.read(Math.max(i.from, e), Math.min(i.to, r)));
    }
    return n;
  }
}
class Qa {
  constructor(e, r) {
    (this.data = e), (this.id = r);
  }
  token(e, r) {
    let { parser: n } = r.p;
    J9(this.data, e, r, this.id, n.data, n.tokenPrecTable);
  }
}
Qa.prototype.contextual = Qa.prototype.fallback = Qa.prototype.extend = !1;
Qa.prototype.fallback = Qa.prototype.extend = !1;
function J9(t, e, r, n, i, s) {
  let o = 0,
    l = 1 << n,
    { dialect: c } = r.p.parser;
  e: for (; l & t[o]; ) {
    let p = t[o + 1];
    for (let x = o + 3; x < p; x += 2)
      if ((t[x + 1] & l) > 0) {
        let b = t[x];
        if (c.allows(b) && (e.token.value == -1 || e.token.value == b || X9(b, e.token.value, i, s))) {
          e.acceptToken(b);
          break;
        }
      }
    let f = e.next,
      m = 0,
      g = t[o + 2];
    if (e.next < 0 && g > m && t[p + g * 3 - 3] == 65535 && t[p + g * 3 - 3] == 65535) {
      o = t[p + g * 3 - 1];
      continue e;
    }
    for (; m < g; ) {
      let x = (m + g) >> 1,
        b = p + x + (x << 1),
        F = t[b],
        E = t[b + 1] || 65536;
      if (f < F) g = x;
      else if (f >= E) m = x + 1;
      else {
        (o = t[b + 2]), e.advance();
        continue e;
      }
    }
    break;
  }
}
function cC(t, e, r) {
  for (let n = e, i; (i = t[n]) != 65535; n++) if (i == r) return n - e;
  return -1;
}
function X9(t, e, r, n) {
  let i = cC(r, n, e);
  return i < 0 || cC(r, n, t) < i;
}
const An = typeof process < 'u' && process.env && /\bparse\b/.test({}.LOG);
let Am = null;
function hC(t, e, r) {
  let n = t.cursor(wr.IncludeAnonymous);
  for (n.moveTo(e); ; )
    if (!(r < 0 ? n.childBefore(e) : n.childAfter(e)))
      for (;;) {
        if ((r < 0 ? n.to < e : n.from > e) && !n.type.isError)
          return r < 0 ? Math.max(0, Math.min(n.to - 1, e - 25)) : Math.min(t.length, Math.max(n.from + 1, e + 25));
        if (r < 0 ? n.prevSibling() : n.nextSibling()) break;
        if (!n.parent()) return r < 0 ? 0 : t.length;
      }
}
class G9 {
  constructor(e, r) {
    (this.fragments = e),
      (this.nodeSet = r),
      (this.i = 0),
      (this.fragment = null),
      (this.safeFrom = -1),
      (this.safeTo = -1),
      (this.trees = []),
      (this.start = []),
      (this.index = []),
      this.nextFragment();
  }
  nextFragment() {
    let e = (this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]);
    if (e) {
      for (
        this.safeFrom = e.openStart ? hC(e.tree, e.from + e.offset, 1) - e.offset : e.from,
          this.safeTo = e.openEnd ? hC(e.tree, e.to + e.offset, -1) - e.offset : e.to;
        this.trees.length;

      )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), (this.nextStart = this.safeFrom);
    } else this.nextStart = 1e9;
  }
  nodeAt(e) {
    if (e < this.nextStart) return null;
    for (; this.fragment && this.safeTo <= e; ) this.nextFragment();
    if (!this.fragment) return null;
    for (;;) {
      let r = this.trees.length - 1;
      if (r < 0) return this.nextFragment(), null;
      let n = this.trees[r],
        i = this.index[r];
      if (i == n.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = n.children[i],
        o = this.start[r] + n.positions[i];
      if (o > e) return (this.nextStart = o), null;
      if (s instanceof fr) {
        if (o == e) {
          if (o < this.safeFrom) return null;
          let l = o + s.length;
          if (l <= this.safeTo) {
            let c = s.prop(At.lookAhead);
            if (!c || l + c < this.fragment.to) return s;
          }
        }
        this.index[r]++,
          o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else this.index[r]++, (this.nextStart = o + s.length);
    }
  }
}
class Y9 {
  constructor(e, r) {
    (this.stream = r),
      (this.tokens = []),
      (this.mainToken = null),
      (this.actions = []),
      (this.tokens = e.tokenizers.map((n) => new tp()));
  }
  getActions(e) {
    let r = 0,
      n = null,
      { parser: i } = e.p,
      { tokenizers: s } = i,
      o = i.stateSlot(e.state, 3),
      l = e.curContext ? e.curContext.hash : 0,
      c = 0;
    for (let p = 0; p < s.length; p++) {
      if (!((1 << p) & o)) continue;
      let f = s[p],
        m = this.tokens[p];
      if (
        !(n && !f.fallback) &&
        ((f.contextual || m.start != e.pos || m.mask != o || m.context != l) &&
          (this.updateCachedToken(m, f, e), (m.mask = o), (m.context = l)),
        m.lookAhead > m.end + 25 && (c = Math.max(m.lookAhead, c)),
        m.value != 0)
      ) {
        let g = r;
        if (
          (m.extended > -1 && (r = this.addActions(e, m.extended, m.end, r)),
          (r = this.addActions(e, m.value, m.end, r)),
          !f.extend && ((n = m), r > g))
        )
          break;
      }
    }
    for (; this.actions.length > r; ) this.actions.pop();
    return (
      c && e.setLookAhead(c),
      !n &&
        e.pos == this.stream.end &&
        ((n = new tp()),
        (n.value = e.p.parser.eofTerm),
        (n.start = n.end = e.pos),
        (r = this.addActions(e, n.value, n.end, r))),
      (this.mainToken = n),
      this.actions
    );
  }
  getMainToken(e) {
    if (this.mainToken) return this.mainToken;
    let r = new tp(),
      { pos: n, p: i } = e;
    return (
      (r.start = n), (r.end = Math.min(n + 1, i.stream.end)), (r.value = n == i.stream.end ? i.parser.eofTerm : 0), r
    );
  }
  updateCachedToken(e, r, n) {
    let i = this.stream.clipPos(n.pos);
    if ((r.token(this.stream.reset(i, e), n), e.value > -1)) {
      let { parser: s } = n.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let l = s.specializers[o](this.stream.read(e.start, e.end), n);
          if (l >= 0 && n.p.parser.dialect.allows(l >> 1)) {
            l & 1 ? (e.extended = l >> 1) : (e.value = l >> 1);
            break;
          }
        }
    } else (e.value = 0), (e.end = this.stream.clipPos(i + 1));
  }
  putAction(e, r, n, i) {
    for (let s = 0; s < i; s += 3) if (this.actions[s] == e) return i;
    return (this.actions[i++] = e), (this.actions[i++] = r), (this.actions[i++] = n), i;
  }
  addActions(e, r, n, i) {
    let { state: s } = e,
      { parser: o } = e.p,
      { data: l } = o;
    for (let c = 0; c < 2; c++)
      for (let p = o.stateSlot(s, c ? 2 : 1); ; p += 3) {
        if (l[p] == 65535)
          if (l[p + 1] == 1) p = ts(l, p + 2);
          else {
            i == 0 && l[p + 1] == 2 && (i = this.putAction(ts(l, p + 2), r, n, i));
            break;
          }
        l[p] == r && (i = this.putAction(ts(l, p + 1), r, n, i));
      }
    return i;
  }
}
class Q9 {
  constructor(e, r, n, i) {
    (this.parser = e),
      (this.input = r),
      (this.ranges = i),
      (this.recovering = 0),
      (this.nextStackID = 9812),
      (this.minStackPos = 0),
      (this.reused = []),
      (this.stoppedAt = null),
      (this.lastBigReductionStart = -1),
      (this.lastBigReductionSize = 0),
      (this.bigReductionCount = 0),
      (this.stream = new K9(r, i)),
      (this.tokens = new Y9(e, this.stream)),
      (this.topTerm = e.top[1]);
    let { from: s } = i[0];
    (this.stacks = [Rp.start(this, e.top[0], s)]),
      (this.fragments = n.length && this.stream.end - s > e.bufferLength * 4 ? new G9(n, e.nodeSet) : null);
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let e = this.stacks,
      r = this.minStackPos,
      n = (this.stacks = []),
      i,
      s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; );
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      for (;;) {
        if (((this.tokens.mainToken = null), l.pos > r)) n.push(l);
        else {
          if (this.advanceStack(l, n, e)) continue;
          {
            i || ((i = []), (s = [])), i.push(l);
            let c = this.tokens.getMainToken(l);
            s.push(c.value, c.end);
          }
        }
        break;
      }
    }
    if (!n.length) {
      let o = i && e7(i);
      if (o) return An && console.log('Finish with ' + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw (
          (An &&
            i &&
            console.log(
              'Stuck with token ' + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : 'none'),
            ),
          new SyntaxError('No parse at ' + r))
        );
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let o = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, n);
      if (o) return An && console.log('Force-finish ' + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n.length > o) for (n.sort((l, c) => c.score - l.score); n.length > o; ) n.pop();
      n.some((l) => l.reducePos > r) && this.recovering--;
    } else if (n.length > 1) {
      e: for (let o = 0; o < n.length - 1; o++) {
        let l = n[o];
        for (let c = o + 1; c < n.length; c++) {
          let p = n[c];
          if (l.sameState(p) || (l.buffer.length > 500 && p.buffer.length > 500))
            if ((l.score - p.score || l.buffer.length - p.buffer.length) > 0) n.splice(c--, 1);
            else {
              n.splice(o--, 1);
              continue e;
            }
        }
      }
      n.length > 12 && n.splice(12, n.length - 12);
    }
    this.minStackPos = n[0].pos;
    for (let o = 1; o < n.length; o++) n[o].pos < this.minStackPos && (this.minStackPos = n[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  advanceStack(e, r, n) {
    let i = e.pos,
      { parser: s } = this,
      o = An ? this.stackID(e) + ' -> ' : '';
    if (this.stoppedAt != null && i > this.stoppedAt) return e.forceReduce() ? e : null;
    if (this.fragments) {
      let p = e.curContext && e.curContext.tracker.strict,
        f = p ? e.curContext.hash : 0;
      for (let m = this.fragments.nodeAt(i); m; ) {
        let g = this.parser.nodeSet.types[m.type.id] == m.type ? s.getGoto(e.state, m.type.id) : -1;
        if (g > -1 && m.length && (!p || (m.prop(At.contextHash) || 0) == f))
          return (
            e.useNode(m, g), An && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(m.type.id)})`), !0
          );
        if (!(m instanceof fr) || m.children.length == 0 || m.positions[0] > 0) break;
        let x = m.children[0];
        if (x instanceof fr && m.positions[0] == 0) m = x;
        else break;
      }
    }
    let l = s.stateSlot(e.state, 4);
    if (l > 0)
      return e.reduce(l), An && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(l & 65535)})`), !0;
    if (e.stack.length >= 9e3) for (; e.stack.length > 6e3 && e.forceReduce(); );
    let c = this.tokens.getActions(e);
    for (let p = 0; p < c.length; ) {
      let f = c[p++],
        m = c[p++],
        g = c[p++],
        x = p == c.length || !n,
        b = x ? e : e.split(),
        F = this.tokens.mainToken;
      if (
        (b.apply(f, m, F ? F.start : b.pos, g),
        An &&
          console.log(
            o +
              this.stackID(b) +
              ` (via ${f & 65536 ? `reduce of ${s.getName(f & 65535)}` : 'shift'} for ${s.getName(m)} @ ${i}${
                b == e ? '' : ', split'
              })`,
          ),
        x)
      )
        return !0;
      b.pos > i ? r.push(b) : n.push(b);
    }
    return !1;
  }
  advanceFully(e, r) {
    let n = e.pos;
    for (;;) {
      if (!this.advanceStack(e, null, null)) return !1;
      if (e.pos > n) return pC(e, r), !0;
    }
  }
  runRecovery(e, r, n) {
    let i = null,
      s = !1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o],
        c = r[o << 1],
        p = r[(o << 1) + 1],
        f = An ? this.stackID(l) + ' -> ' : '';
      if (
        l.deadEnd &&
        (s || ((s = !0), l.restart(), An && console.log(f + this.stackID(l) + ' (restarted)'), this.advanceFully(l, n)))
      )
        continue;
      let m = l.split(),
        g = f;
      for (
        let x = 0;
        m.forceReduce() &&
        x < 10 &&
        (An && console.log(g + this.stackID(m) + ' (via force-reduce)'), !this.advanceFully(m, n));
        x++
      )
        An && (g = this.stackID(m) + ' -> ');
      for (let x of l.recoverByInsert(c))
        An && console.log(f + this.stackID(x) + ' (via recover-insert)'), this.advanceFully(x, n);
      this.stream.end > l.pos
        ? (p == l.pos && (p++, (c = 0)),
          l.recoverByDelete(c, p),
          An && console.log(f + this.stackID(l) + ` (via recover-delete ${this.parser.getName(c)})`),
          pC(l, n))
        : (!i || i.score < l.score) && (i = l);
    }
    return i;
  }
  stackToTree(e) {
    return (
      e.close(),
      fr.build({
        buffer: jp.create(e),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: e.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm,
      })
    );
  }
  stackID(e) {
    let r = (Am || (Am = new WeakMap())).get(e);
    return r || Am.set(e, (r = String.fromCodePoint(this.nextStackID++))), r + e;
  }
}
function pC(t, e) {
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    if (n.pos == t.pos && n.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class Z9 {
  constructor(e, r, n) {
    (this.source = e), (this.flags = r), (this.disabled = n);
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
class $p extends s2 {
  constructor(e) {
    if ((super(), (this.wrappers = []), e.version != 14))
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(' ');
    this.minRepeatTerm = r.length;
    for (let l = 0; l < e.repeatNodeCount; l++) r.push('');
    let n = Object.keys(e.topRules).map((l) => e.topRules[l][1]),
      i = [];
    for (let l = 0; l < r.length; l++) i.push([]);
    function s(l, c, p) {
      i[l].push([c, c.deserialize(String(p))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let c = l[0];
        typeof c == 'string' && (c = At[c]);
        for (let p = 1; p < l.length; ) {
          let f = l[p++];
          if (f >= 0) s(f, c, l[p++]);
          else {
            let m = l[p + -f];
            for (let g = -f; g > 0; g--) s(l[p++], c, m);
            p++;
          }
        }
      }
    (this.nodeSet = new ey(
      r.map((l, c) =>
        xn.define({
          name: c >= this.minRepeatTerm ? void 0 : l,
          id: c,
          props: i[c],
          top: n.indexOf(c) > -1,
          error: c == 0,
          skipped: e.skippedNodes && e.skippedNodes.indexOf(c) > -1,
        }),
      ),
    )),
      e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)),
      (this.strict = !1),
      (this.bufferLength = t2);
    let o = Lh(e.tokenData);
    (this.context = e.context),
      (this.specializerSpecs = e.specialized || []),
      (this.specialized = new Uint16Array(this.specializerSpecs.length));
    for (let l = 0; l < this.specializerSpecs.length; l++) this.specialized[l] = this.specializerSpecs[l].term;
    (this.specializers = this.specializerSpecs.map(fC)),
      (this.states = Lh(e.states, Uint32Array)),
      (this.data = Lh(e.stateData)),
      (this.goto = Lh(e.goto)),
      (this.maxTerm = e.maxTerm),
      (this.tokenizers = e.tokenizers.map((l) => (typeof l == 'number' ? new Qa(o, l) : l))),
      (this.topRules = e.topRules),
      (this.dialects = e.dialects || {}),
      (this.dynamicPrecedences = e.dynamicPrecedences || null),
      (this.tokenPrecTable = e.tokenPrec),
      (this.termNames = e.termNames || null),
      (this.maxNode = this.nodeSet.types.length - 1),
      (this.dialect = this.parseDialect()),
      (this.top = this.topRules[Object.keys(this.topRules)[0]]);
  }
  createParse(e, r, n) {
    let i = new Q9(this, e, r, n);
    for (let s of this.wrappers) i = s(i, e, r, n);
    return i;
  }
  getGoto(e, r, n = !1) {
    let i = this.goto;
    if (r >= i[0]) return -1;
    for (let s = i[r + 1]; ; ) {
      let o = i[s++],
        l = o & 1,
        c = i[s++];
      if (l && n) return c;
      for (let p = s + (o >> 1); s < p; s++) if (i[s] == e) return c;
      if (l) return -1;
    }
  }
  hasAction(e, r) {
    let n = this.data;
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(e, i ? 2 : 1), o; ; s += 3) {
        if ((o = n[s]) == 65535)
          if (n[s + 1] == 1) o = n[(s = ts(n, s + 2))];
          else {
            if (n[s + 1] == 2) return ts(n, s + 2);
            break;
          }
        if (o == r || o == 0) return ts(n, s + 1);
      }
    return 0;
  }
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  stateFlag(e, r) {
    return (this.stateSlot(e, 0) & r) > 0;
  }
  validAction(e, r) {
    return !!this.allActions(e, (n) => (n == r ? !0 : null));
  }
  allActions(e, r) {
    let n = this.stateSlot(e, 4),
      i = n ? r(n) : void 0;
    for (let s = this.stateSlot(e, 1); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1) s = ts(this.data, s + 2);
        else break;
      i = r(ts(this.data, s + 1));
    }
    return i;
  }
  nextStates(e) {
    let r = [];
    for (let n = this.stateSlot(e, 1); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1) n = ts(this.data, n + 2);
        else break;
      if (!(this.data[n + 2] & 1)) {
        let i = this.data[n + 1];
        r.some((s, o) => o & 1 && s == i) || r.push(this.data[n], i);
      }
    }
    return r;
  }
  configure(e) {
    let r = Object.assign(Object.create($p.prototype), this);
    if ((e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top)) {
      let n = this.topRules[e.top];
      if (!n) throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = n;
    }
    return (
      e.tokenizers &&
        (r.tokenizers = this.tokenizers.map((n) => {
          let i = e.tokenizers.find((s) => s.from == n);
          return i ? i.to : n;
        })),
      e.specializers &&
        ((r.specializers = this.specializers.slice()),
        (r.specializerSpecs = this.specializerSpecs.map((n, i) => {
          let s = e.specializers.find((l) => l.from == n.external);
          if (!s) return n;
          let o = Object.assign(Object.assign({}, n), { external: s.to });
          return (r.specializers[i] = fC(o)), o;
        }))),
      e.contextTracker && (r.context = e.contextTracker),
      e.dialect && (r.dialect = this.parseDialect(e.dialect)),
      e.strict != null && (r.strict = e.strict),
      e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)),
      e.bufferLength != null && (r.bufferLength = e.bufferLength),
      r
    );
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(e) {
    return this.termNames ? this.termNames[e] : String((e <= this.maxNode && this.nodeSet.types[e].name) || e);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  parseDialect(e) {
    let r = Object.keys(this.dialects),
      n = r.map(() => !1);
    if (e)
      for (let s of e.split(' ')) {
        let o = r.indexOf(s);
        o >= 0 && (n[o] = !0);
      }
    let i = null;
    for (let s = 0; s < r.length; s++)
      if (!n[s])
        for (let o = this.dialects[r[s]], l; (l = this.data[o++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new Z9(e, n, i);
  }
  static deserialize(e) {
    return new $p(e);
  }
}
function ts(t, e) {
  return t[e] | (t[e + 1] << 16);
}
function e7(t) {
  let e = null;
  for (let r of t) {
    let n = r.p.stoppedAt;
    (r.pos == r.p.stream.end || (n != null && r.pos > n)) &&
      r.p.parser.stateFlag(r.state, 2) &&
      (!e || e.score < r.score) &&
      (e = r);
  }
  return e;
}
function fC(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, n) => (t.external(r, n) << 1) | e;
  }
  return t.get;
}
const t7 = $p.deserialize({
  version: 14,
  states:
    "%WO`QPOOOwQQO'#CbO!SQPO'#ChOOQO'#Cj'#CjOOQO'#Ct'#CtQOQPOOOOQO'#Cd'#CdO!ZQPO'#CcOOQO,58|,58|O!`QPO,58|OOQO,59S,59SO!hQPO,59SO`QPO,58}O!pQQO1G.hO!{QPO1G.hOOQO1G.h1G.hO#TQPO1G.nO#[QPO1G.nOOQO1G.n1G.nOOQO1G.i1G.iOOQO,59Y,59YOOQO7+$S7+$SO#dQQO7+$SOOQO-E6l-E6lOOQO,59Z,59ZOOQO7+$Y7+$YO#oQPO7+$YOOQO-E6m-E6mOOQO<<Gn<<GnPzQQO'#CnOOQO<<Gt<<GtP`QPO'#Co",
  stateData:
    '#x~OPOSQOSfOSgOS~OTPOZQO]SO_SO`SOaSOiRO~OSWOiUOjUO~OYYO~P`OX[O~OS_Ok]O~OYbOk`O~OSeOiUOjUO~OSeOkfO~OYiO~P`OYiOkjO~OSlOiUOjUO~OYnO~P`Oj~',
  goto: '!liPPPPPPjrzPPPjPjPPP!Q!WPPPP!^]SOQ[`joQXPVd]fmXVP]fmQ^XRg^QaZRkaQTOQZQQc[Vh`jo',
  nodeNames:
    '⚠ LineComment BlockComment File } { Object Property PropertyName PropertyColon ] [ Array Number String Null True False',
  maxTerm: 27,
  nodeProps: [
    ['openedBy', 4, '{', 10, '['],
    ['closedBy', 5, '}', 11, ']'],
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 2,
  tokenData:
    ">X~R!TXY$bYZ%YZ[$b[]$b]^%Ypq$brs%_tu&owx'W{|(c|},O}!O(c!O!P(r!P!Q,T!Q!R)l!R![*l![!]-d!c!k&o!k!l-i!l!p&o!p!q2g!q!}&o!}#O3p#P#Q3u#R#S&o#T#Y&o#Y#Z3z#Z#b&o#b#c6z#c#h&o#h#i9`#i#o&o#o#p;t#q#r;y$f$g$b$g#BY&o#BY#BZ<O#BZ$IS&o$IS$I_<O$I_$I|&o$I|$I}=n$I}$JO=n$JO$JT&o$JT$JU<O$JU$KV&o$KV$KW<O$KW&FU&o&FU&FV<O&FV?HT&o?HT?HU<O?HU~&o~$gZf~XY$bZ[$b[]$bpq$b$f$g$b#BY#BZ$b$IS$I_$b$JT$JU$b$KV$KW$b&FU&FV$b?HT?HU$b~%_Og~~%bTOr%_rs%qs#O%_#O#P%v#P~%_~%vOi~~%y[YZ%_]^%_rs%_#O#P%_#U#V%_#Y#Z%_#b#c%_#f#g%_#h#i%_#j#k%_$I|$I}%_$I}$JO%_Q&tUjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&o~'ZTOw'Wwx%qx#O'W#O#P'j#P~'W~'m[YZ'W]^'Wwx'W#O#P'W#U#V'W#Y#Z'W#b#c'W#f#g'W#h#i'W#j#k'W$I|$I}'W$I}$JO'WP(fS!O!P(r!Q!R)l!R![*l!k!l*}P(wR]P!Q![(r!g!h)Q#X#Y)QP)TR{|)^}!O)^!Q![)dP)aP!Q![)dP)iP]P!Q![)dP)qT]P!O!P(r!g!h)Q!z!{*Q#X#Y)Q#l#m*QP*TR!Q![*^!c!i*^#T#Z*^P*cR]P!Q![*^!c!i*^#T#Z*^P*qS]P!O!P(r!Q![*l!g!h)Q#X#Y)QP+QP#b#c+TP+WP#Y#Z+ZP+^P#]#^+aP+dP#b#c+gP+jP#]#^+mP+pP#h#i+sP+vP#m#n+yP,OO]P~,TOk~~,WQz{,^!P!Q-R~,aROz,^z{,j{~,^~,mTOz,^z{,j{!P,^!P!Q,|!Q~,^~-ROQ~~-WSP~OY-RZ]-R^$I|-R$JO~-R~-iOX~R-nWjQtu&o!Q![&o!c!}&o#R#S&o#T#b&o#b#c.W#c#o&o$g~&oR.]WjQtu&o!Q![&o!c!}&o#R#S&o#T#Y&o#Y#Z.u#Z#o&o$g~&oR.zWjQtu&o!Q![&o!c!}&o#R#S&o#T#]&o#]#^/d#^#o&o$g~&oR/iWjQtu&o!Q![&o!c!}&o#R#S&o#T#b&o#b#c0R#c#o&o$g~&oR0WWjQtu&o!Q![&o!c!}&o#R#S&o#T#]&o#]#^0p#^#o&o$g~&oR0uWjQtu&o!Q![&o!c!}&o#R#S&o#T#h&o#h#i1_#i#o&o$g~&oR1dWjQtu&o!Q![&o!c!}&o#R#S&o#T#m&o#m#n1|#n#o&o$g~&oR2TU]PjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&oR2lVjQtu&o!Q![&o!c!}&o#R#S&o#T#U3R#U#o&o$g~&oR3WWjQtu&o!Q![&o!c!p&o!p!q1|!q!}&o#R#S&o#T#o&o$g~&o~3uOZ~~3zOY~R4PVjQtu&o!Q![&o!c!}&o#R#S&o#T#U4f#U#o&o$g~&oR4kWjQtu&o!Q![&o!c!}&o#R#S&o#T#`&o#`#a5T#a#o&o$g~&oR5YWjQtu&o!Q![&o!c!}&o#R#S&o#T#g&o#g#h5r#h#o&o$g~&oR5wWjQtu&o!Q![&o!c!}&o#R#S&o#T#X&o#X#Y6a#Y#o&o$g~&oR6hUaPjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&oR7PWjQtu&o!Q![&o!c!}&o#R#S&o#T#i&o#i#j7i#j#o&o$g~&oR7nWjQtu&o!Q![&o!c!}&o#R#S&o#T#`&o#`#a8W#a#o&o$g~&oR8]WjQtu&o!Q![&o!c!}&o#R#S&o#T#`&o#`#a8u#a#o&o$g~&oR8|U_PjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&oR9eWjQtu&o!Q![&o!c!}&o#R#S&o#T#f&o#f#g9}#g#o&o$g~&oR:SWjQtu&o!Q![&o!c!}&o#R#S&o#T#i&o#i#j:l#j#o&o$g~&oR:qWjQtu&o!Q![&o!c!}&o#R#S&o#T#X&o#X#Y;Z#Y#o&o$g~&oR;bU`PjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&o~;yOT~~<OOS~~<Vgf~jQXY$bZ[$b[]$bpq$btu&o!Q![&o!c!}&o#R#S&o#T#o&o$f$g$b$g#BY&o#BY#BZ<O#BZ$IS&o$IS$I_<O$I_$JT&o$JT$JU<O$JU$KV&o$KV$KW<O$KW&FU&o&FU&FV<O&FV?HT&o?HT?HU<O?HU~&o~=uUg~jQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&o",
  tokenizers: [0, 1],
  topRules: { File: [0, 3] },
  tokenPrec: 130,
});
function r7(t) {
  let e = t[0],
    r = t[t.length - 1];
  return ((e === "'" && r === "'") || (e === '"' && r === '"')) && (t = t.slice(1, -1)), t;
}
function n7(t, e) {
  if (e.name !== 'Property') return null;
  let r = e.getChild('PropertyName');
  return r ? r7(t.sliceDoc(r.from, r.to)) : null;
}
function i7(t) {
  var e;
  let r = (e = t.parent) === null || e === void 0 ? void 0 : e.cursor();
  if (!r) return null;
  for (; r.node.name !== 'Property' && r.node.name !== 'Array'; ) if (!r.parent()) return null;
  return r.node;
}
function s7(t, e) {
  let r = [];
  for (;;) {
    let n = i7(e);
    if (!n) break;
    if (n.name === 'Array') {
      let i = e.from,
        s = n.firstChild,
        o = 0;
      for (; s && s.to < i; ) (s = o7(s.nextSibling)), (o += 1);
      r.unshift(o);
    } else {
      let i = n7(t, n);
      i && r.unshift(i);
    }
    e = n;
  }
  return r;
}
function o7(t) {
  for (; t && /Comment/.test(t.name); ) t = t.nextSibling;
  return t;
}
function a7(t, e) {
  let n = jr(t).resolveInner(e, -1);
  for (; n; ) {
    let i = n.childBefore(e);
    if (!i) break;
    n = i;
  }
  return n;
}
const l7 = Ep.define({
  parser: t7.configure({
    props: [
      c2.add({ Object: Ox({ except: /^\s*\}/ }), Array: Ox({ except: /^\s*\]/ }) }),
      p2.add({ 'Object Array': hN }),
      o2({
        'String': Pe.string,
        'PropertyName!': Pe.propertyName,
        'Number': Pe.number,
        'True False': Pe.bool,
        'Null': Pe.null,
        'LineComment': Pe.lineComment,
        'BlockComment': Pe.blockComment,
        ', PropertyColon': Pe.separator,
        '[ ]': Pe.squareBracket,
        '{ }': Pe.brace,
      }),
    ],
  }),
  languageData: {
    closeBrackets: { brackets: ['[', '{', '"', "'"] },
    indentOnInput: /^\s*[}\]]$/,
    commentTokens: { line: '//', block: { open: '/*', clone: '*/' } },
  },
});
function u7() {
  return new ZI(l7, [Bv.extension, h7.extension]);
}
function dC(t, e) {
  let r = 0;
  return (
    'lineNumber' in e &&
      'columnNumber' in e &&
      (r = Math.min(t.line(e.lineNumber).from + e.columnNumber - 1, t.length)),
    [{ from: r, to: r, message: e.message, severity: 'error' }]
  );
}
function c7(t) {
  return (e) => {
    var r, n;
    let i = e.state.doc,
      s = e.state.field(Bv, !1);
    if (s) {
      if (s.err) return dC(i, s.err);
      if (s.obj !== void 0) return (r = t == null ? void 0 : t(e, s.obj)) !== null && r !== void 0 ? r : [];
    }
    try {
      let o = Pv.parse(i.toString());
      return (n = t == null ? void 0 : t(e, o)) !== null && n !== void 0 ? n : [];
    } catch (o) {
      return dC(i, o);
    }
  };
}
const Bv = vr.define({
    create() {
      return null;
    },
    update(t, e) {
      if (!e.docChanged) return t;
      try {
        return { err: null, obj: Pv.parse(e.newDoc.toString()) };
      } catch (r) {
        return { err: r, obj: t == null ? void 0 : t.obj };
      }
    },
  }),
  h7 = vr.define({
    create() {
      return { path: null, node: null };
    },
    update(t, e) {
      let r = e.state.selection.main.to,
        n = a7(e.state, r),
        i = n ? s7(e.state, n) : null;
      return { path: i ?? null, node: n };
    },
  }),
  p7 = ze.theme({
    '&': { height: '100%', minHeight: '0', flex: '1' },
    '&.cm-focused': { outline: 'none' },
    '.cm-scroller': { fontFamily: 'SFMono-Regular, Consolas, Menlo, monospace', fontSize: '14px' },
    '.cm-gutters': { backgroundColor: 'white', borderRight: 'none' },
    '.cm-activeLine': { backgroundColor: 'hsl(var(--b2)/0.6)' },
    '.cm-activeLineGutter': { backgroundColor: 'hsl(var(--b2))' },
    '&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection':
      { backgroundColor: 'hsl(var(--pc)/0.9)' },
  }),
  mC = [u7(), b9(c7()), p7];
var Iv = { exports: {} };
(function (t, e) {
  (function (r) {
    function n() {
      var i = r();
      return i.default || i;
    }
    t.exports = n();
  })(function () {
    var r = Object.create,
      n = Object.defineProperty,
      i = Object.getOwnPropertyDescriptor,
      s = Object.getOwnPropertyNames,
      o = Object.getPrototypeOf,
      l = Object.prototype.hasOwnProperty,
      c = (y, C) => () => (y && (C = y((y = 0))), C),
      p = (y, C) => () => (C || y((C = { exports: {} }).exports, C), C.exports),
      f = (y, C) => {
        for (var v in C) n(y, v, { get: C[v], enumerable: !0 });
      },
      m = (y, C, v, S) => {
        if ((C && typeof C == 'object') || typeof C == 'function')
          for (let k of s(C))
            !l.call(y, k) && k !== v && n(y, k, { get: () => C[k], enumerable: !(S = i(C, k)) || S.enumerable });
        return y;
      },
      g = (y, C, v) => (
        (v = y != null ? r(o(y)) : {}),
        m(C || !y || !y.__esModule ? n(v, 'default', { value: y, enumerable: !0 }) : v, y)
      ),
      x = (y) => m(n({}, '__esModule', { value: !0 }), y),
      b = (y, C, v) => {
        if (!C.has(y)) throw TypeError('Cannot ' + v);
      },
      F = (y, C, v) => {
        if (C.has(y)) throw TypeError('Cannot add the same private member more than once');
        C instanceof WeakSet ? C.add(y) : C.set(y, v);
      },
      E = (y, C, v) => (b(y, C, 'access private method'), v),
      w = p((y) => {
        Object.defineProperty(y, '__esModule', { value: !0 }), (y.default = C);
        function C() {}
        C.prototype = {
          diff: function (k, B) {
            var O = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
              H = O.callback;
            typeof O == 'function' && ((H = O), (O = {})), (this.options = O);
            var K = this;
            function Z(ct) {
              return H
                ? (setTimeout(function () {
                    H(void 0, ct);
                  }, 0),
                  !0)
                : ct;
            }
            (k = this.castInput(k)),
              (B = this.castInput(B)),
              (k = this.removeEmpty(this.tokenize(k))),
              (B = this.removeEmpty(this.tokenize(B)));
            var ne = B.length,
              be = k.length,
              ee = 1,
              Ce = ne + be;
            O.maxEditLength && (Ce = Math.min(Ce, O.maxEditLength));
            var le = [{ newPos: -1, components: [] }],
              Oe = this.extractCommon(le[0], B, k, 0);
            if (le[0].newPos + 1 >= ne && Oe + 1 >= be) return Z([{ value: this.join(B), count: B.length }]);
            function Xe() {
              for (var ct = -1 * ee; ct <= ee; ct += 2) {
                var Dt = void 0,
                  Ft = le[ct - 1],
                  Rt = le[ct + 1],
                  Ur = (Rt ? Rt.newPos : 0) - ct;
                Ft && (le[ct - 1] = void 0);
                var Br = Ft && Ft.newPos + 1 < ne,
                  en = Rt && 0 <= Ur && Ur < be;
                if (!Br && !en) {
                  le[ct] = void 0;
                  continue;
                }
                if (
                  (!Br || (en && Ft.newPos < Rt.newPos)
                    ? ((Dt = S(Rt)), K.pushComponent(Dt.components, void 0, !0))
                    : ((Dt = Ft), Dt.newPos++, K.pushComponent(Dt.components, !0, void 0)),
                  (Ur = K.extractCommon(Dt, B, k, ct)),
                  Dt.newPos + 1 >= ne && Ur + 1 >= be)
                )
                  return Z(v(K, Dt.components, B, k, K.useLongestToken));
                le[ct] = Dt;
              }
              ee++;
            }
            if (H)
              (function ct() {
                setTimeout(function () {
                  if (ee > Ce) return H();
                  Xe() || ct();
                }, 0);
              })();
            else
              for (; ee <= Ce; ) {
                var ft = Xe();
                if (ft) return ft;
              }
          },
          pushComponent: function (k, B, O) {
            var H = k[k.length - 1];
            H && H.added === B && H.removed === O
              ? (k[k.length - 1] = { count: H.count + 1, added: B, removed: O })
              : k.push({ count: 1, added: B, removed: O });
          },
          extractCommon: function (k, B, O, H) {
            for (
              var K = B.length, Z = O.length, ne = k.newPos, be = ne - H, ee = 0;
              ne + 1 < K && be + 1 < Z && this.equals(B[ne + 1], O[be + 1]);

            )
              ne++, be++, ee++;
            return ee && k.components.push({ count: ee }), (k.newPos = ne), be;
          },
          equals: function (k, B) {
            return this.options.comparator
              ? this.options.comparator(k, B)
              : k === B || (this.options.ignoreCase && k.toLowerCase() === B.toLowerCase());
          },
          removeEmpty: function (k) {
            for (var B = [], O = 0; O < k.length; O++) k[O] && B.push(k[O]);
            return B;
          },
          castInput: function (k) {
            return k;
          },
          tokenize: function (k) {
            return k.split('');
          },
          join: function (k) {
            return k.join('');
          },
        };
        function v(k, B, O, H, K) {
          for (var Z = 0, ne = B.length, be = 0, ee = 0; Z < ne; Z++) {
            var Ce = B[Z];
            if (Ce.removed) {
              if (((Ce.value = k.join(H.slice(ee, ee + Ce.count))), (ee += Ce.count), Z && B[Z - 1].added)) {
                var le = B[Z - 1];
                (B[Z - 1] = B[Z]), (B[Z] = le);
              }
            } else {
              if (!Ce.added && K) {
                var Oe = O.slice(be, be + Ce.count);
                (Oe = Oe.map(function (ft, ct) {
                  var Dt = H[ee + ct];
                  return Dt.length > ft.length ? Dt : ft;
                })),
                  (Ce.value = k.join(Oe));
              } else Ce.value = k.join(O.slice(be, be + Ce.count));
              (be += Ce.count), Ce.added || (ee += Ce.count);
            }
          }
          var Xe = B[ne - 1];
          return (
            ne > 1 &&
              typeof Xe.value == 'string' &&
              (Xe.added || Xe.removed) &&
              k.equals('', Xe.value) &&
              ((B[ne - 2].value += Xe.value), B.pop()),
            B
          );
        }
        function S(k) {
          return { newPos: k.newPos, components: k.components.slice(0) };
        }
      }),
      I = p((y) => {
        Object.defineProperty(y, '__esModule', { value: !0 }), (y.diffArrays = k), (y.arrayDiff = void 0);
        var C = v(w());
        function v(B) {
          return B && B.__esModule ? B : { default: B };
        }
        var S = new C.default();
        (y.arrayDiff = S),
          (S.tokenize = function (B) {
            return B.slice();
          }),
          (S.join = S.removeEmpty =
            function (B) {
              return B;
            });
        function k(B, O, H) {
          return S.diff(B, O, H);
        }
      }),
      T = p((y, C) => {
        var v = new Proxy(String, { get: () => v });
        C.exports = v;
      }),
      j = {};
    f(j, { default: () => L, shouldHighlight: () => $ });
    var $,
      L,
      se = c(() => {
        ($ = () => !1), (L = String);
      }),
      Y = p((y) => {
        Object.defineProperty(y, '__esModule', { value: !0 }), (y.codeFrameColumns = ne), (y.default = be);
        var C = (se(), x(j)),
          v = T(),
          S = v,
          k;
        function B(ee) {
          return ee ? (k != null || (k = new S.constructor({ enabled: !0, level: 1 })), k) : S;
        }
        var O = !1;
        function H(ee) {
          return { gutter: ee.grey, marker: ee.red.bold, message: ee.red.bold };
        }
        var K = /\r\n|[\n\r\u2028\u2029]/;
        function Z(ee, Ce, le) {
          let Oe = Object.assign({ column: 0, line: -1 }, ee.start),
            Xe = Object.assign({}, Oe, ee.end),
            { linesAbove: ft = 2, linesBelow: ct = 3 } = le || {},
            Dt = Oe.line,
            Ft = Oe.column,
            Rt = Xe.line,
            Ur = Xe.column,
            Br = Math.max(Dt - (ft + 1), 0),
            en = Math.min(Ce.length, Rt + ct);
          Dt === -1 && (Br = 0), Rt === -1 && (en = Ce.length);
          let Ci = Rt - Dt,
            qr = {};
          if (Ci)
            for (let Zn = 0; Zn <= Ci; Zn++) {
              let bi = Zn + Dt;
              if (!Ft) qr[bi] = !0;
              else if (Zn === 0) {
                let To = Ce[bi - 1].length;
                qr[bi] = [Ft, To - Ft + 1];
              } else if (Zn === Ci) qr[bi] = [0, Ur];
              else {
                let To = Ce[bi - Zn].length;
                qr[bi] = [0, To];
              }
            }
          else Ft === Ur ? (Ft ? (qr[Dt] = [Ft, 0]) : (qr[Dt] = !0)) : (qr[Dt] = [Ft, Ur - Ft]);
          return { start: Br, end: en, markerLines: qr };
        }
        function ne(ee, Ce, le = {}) {
          let Oe = (le.highlightCode || le.forceColor) && (0, C.shouldHighlight)(le),
            Xe = B(le.forceColor),
            ft = H(Xe),
            ct = (qr, Zn) => (Oe ? qr(Zn) : Zn),
            Dt = ee.split(K),
            { start: Ft, end: Rt, markerLines: Ur } = Z(Ce, Dt, le),
            Br = Ce.start && typeof Ce.start.column == 'number',
            en = String(Rt).length,
            Ci = (Oe ? (0, C.default)(ee, le) : ee)
              .split(K, Rt)
              .slice(Ft, Rt)
              .map((qr, Zn) => {
                let bi = Ft + 1 + Zn,
                  To = ` ${` ${bi}`.slice(-en)} |`,
                  ih = Ur[bi],
                  gT = !Ur[bi + 1];
                if (ih) {
                  let Ld = '';
                  if (Array.isArray(ih)) {
                    let yT = qr.slice(0, Math.max(ih[0] - 1, 0)).replace(/[^\t]/g, ' '),
                      DT = ih[1] || 1;
                    (Ld = [
                      `
 `,
                      ct(ft.gutter, To.replace(/\d/g, ' ')),
                      ' ',
                      yT,
                      ct(ft.marker, '^').repeat(DT),
                    ].join('')),
                      gT && le.message && (Ld += ' ' + ct(ft.message, le.message));
                  }
                  return [ct(ft.marker, '>'), ct(ft.gutter, To), qr.length > 0 ? ` ${qr}` : '', Ld].join('');
                } else return ` ${ct(ft.gutter, To)}${qr.length > 0 ? ` ${qr}` : ''}`;
              }).join(`
`);
          return (
            le.message &&
              !Br &&
              (Ci = `${' '.repeat(en + 1)}${le.message}
${Ci}`),
            Oe ? Xe.reset(Ci) : Ci
          );
        }
        function be(ee, Ce, le, Oe = {}) {
          if (!O) {
            O = !0;
            let Xe =
              'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.';
            {
              let ft = new Error(Xe);
              (ft.name = 'DeprecationWarning'), console.warn(new Error(Xe));
            }
          }
          return (le = Math.max(le, 0)), ne(ee, { start: { column: le, line: Ce } }, Oe);
        }
      }),
      W = {};
    f(W, {
      __debug: () => mT,
      check: () => fT,
      doc: () => gD,
      format: () => DD,
      formatWithCursor: () => yD,
      getSupportInfo: () => dT,
      util: () => mD,
      version: () => pT,
    });
    var X = (y, C, v, S) => {
        if (!(y && C == null))
          return C.replaceAll ? C.replaceAll(v, S) : v.global ? C.replace(v, S) : C.split(v).join(S);
      },
      q = X,
      xe = g(I(), 1),
      Re = 'string',
      re = 'array',
      ie = 'cursor',
      Q = 'indent',
      ce = 'align',
      G = 'trim',
      ge = 'group',
      we = 'fill',
      je = 'if-break',
      Qe = 'indent-if-break',
      ot = 'line-suffix',
      pt = 'line-suffix-boundary',
      gt = 'line',
      yt = 'label',
      U = 'break-parent',
      he = new Set([ie, Q, ce, G, ge, we, je, Qe, ot, pt, gt, yt, U]);
    function Te(y) {
      if (typeof y == 'string') return Re;
      if (Array.isArray(y)) return re;
      if (!y) return;
      let { type: C } = y;
      if (he.has(C)) return C;
    }
    var fe = Te,
      at = (y) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(y);
    function M(y) {
      let C = y === null ? 'null' : typeof y;
      if (C !== 'string' && C !== 'object')
        return `Unexpected doc '${C}', 
Expected it to be 'string' or 'object'.`;
      if (fe(y)) throw new Error('doc is valid.');
      let v = Object.prototype.toString.call(y);
      if (v !== '[object Object]') return `Unexpected doc '${v}'.`;
      let S = at([...he].map((k) => `'${k}'`));
      return `Unexpected doc.type '${y.type}'.
Expected it to be ${S}.`;
    }
    var V = class extends Error {
        constructor(C) {
          super(M(C));
          ko(this, 'name', 'InvalidDocError');
          this.doc = C;
        }
      },
      J = V,
      ae = {};
    function de(y, C, v, S) {
      let k = [y];
      for (; k.length > 0; ) {
        let B = k.pop();
        if (B === ae) {
          v(k.pop());
          continue;
        }
        v && k.push(B, ae);
        let O = fe(B);
        if (!O) throw new J(B);
        if ((C == null ? void 0 : C(B)) !== !1)
          switch (O) {
            case re:
            case we: {
              let H = O === re ? B : B.parts;
              for (let K = H.length, Z = K - 1; Z >= 0; --Z) k.push(H[Z]);
              break;
            }
            case je:
              k.push(B.flatContents, B.breakContents);
              break;
            case ge:
              if (S && B.expandedStates)
                for (let H = B.expandedStates.length, K = H - 1; K >= 0; --K) k.push(B.expandedStates[K]);
              else k.push(B.contents);
              break;
            case ce:
            case Q:
            case Qe:
            case yt:
            case ot:
              k.push(B.contents);
              break;
            case Re:
            case ie:
            case G:
            case pt:
            case gt:
            case U:
              break;
            default:
              throw new J(B);
          }
      }
    }
    var ye = de,
      Le = () => {},
      Fe = Le;
    function ke(y) {
      return { type: Q, contents: y };
    }
    function De(y, C) {
      return { type: ce, contents: C, n: y };
    }
    function Ge(y, C = {}) {
      return (
        Fe(C.expandedStates),
        { type: ge, id: C.id, contents: y, break: !!C.shouldBreak, expandedStates: C.expandedStates }
      );
    }
    function He(y) {
      return De(Number.NEGATIVE_INFINITY, y);
    }
    function Ze(y) {
      return De({ type: 'root' }, y);
    }
    function et(y) {
      return De(-1, y);
    }
    function lt(y, C) {
      return Ge(y[0], { ...C, expandedStates: y });
    }
    function Mt(y) {
      return { type: we, parts: y };
    }
    function Et(y, C = '', v = {}) {
      return { type: je, breakContents: y, flatContents: C, groupId: v.groupId };
    }
    function Pt(y, C) {
      return { type: Qe, contents: y, groupId: C.groupId, negate: C.negate };
    }
    function gr(y) {
      return { type: ot, contents: y };
    }
    var Xn = { type: pt },
      qi = { type: U },
      Ki = { type: G },
      Ji = { type: gt, hard: !0 },
      Fr = { type: gt, hard: !0, literal: !0 },
      Pr = { type: gt },
      hn = { type: gt, soft: !0 },
      pn = [Ji, qi],
      ga = [Fr, qi],
      Il = { type: ie };
    function Cc(y, C) {
      let v = [];
      for (let S = 0; S < C.length; S++) S !== 0 && v.push(y), v.push(C[S]);
      return v;
    }
    function bc(y, C, v) {
      let S = y;
      if (C > 0) {
        for (let k = 0; k < Math.floor(C / v); ++k) S = ke(S);
        (S = De(C % v, S)), (S = De(Number.NEGATIVE_INFINITY, S));
      }
      return S;
    }
    function Ac(y, C) {
      return y ? { type: yt, label: y, contents: C } : C;
    }
    var Ec = (y, C, v) => {
        if (!(y && C == null)) return Array.isArray(C) || typeof C == 'string' ? C[v < 0 ? C.length + v : v] : C.at(v);
      },
      lr = Ec;
    function vc(y) {
      let C = y.indexOf('\r');
      return C >= 0
        ? y.charAt(C + 1) ===
          `
`
          ? 'crlf'
          : 'cr'
        : 'lf';
    }
    function Nl(y) {
      switch (y) {
        case 'cr':
          return '\r';
        case 'crlf':
          return `\r
`;
        default:
          return `
`;
      }
    }
    function Fc(y, C) {
      let v;
      switch (C) {
        case `
`:
          v = /\n/g;
          break;
        case '\r':
          v = /\r/g;
          break;
        case `\r
`:
          v = /\r\n/g;
          break;
        default:
          throw new Error(`Unexpected "eol" ${JSON.stringify(C)}.`);
      }
      let S = y.match(v);
      return S ? S.length : 0;
    }
    function Wf(y) {
      return q(
        !1,
        y,
        /\r\n?/g,
        `
`,
      );
    }
    var Uf = () =>
        /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g,
      Ml = {
        eastAsianWidth(y) {
          var C = y.charCodeAt(0),
            v = y.length == 2 ? y.charCodeAt(1) : 0,
            S = C;
          return (
            55296 <= C &&
              C <= 56319 &&
              56320 <= v &&
              v <= 57343 &&
              ((C &= 1023), (v &= 1023), (S = (C << 10) | v), (S += 65536)),
            S == 12288 || (65281 <= S && S <= 65376) || (65504 <= S && S <= 65510)
              ? 'F'
              : (4352 <= S && S <= 4447) ||
                (4515 <= S && S <= 4519) ||
                (4602 <= S && S <= 4607) ||
                (9001 <= S && S <= 9002) ||
                (11904 <= S && S <= 11929) ||
                (11931 <= S && S <= 12019) ||
                (12032 <= S && S <= 12245) ||
                (12272 <= S && S <= 12283) ||
                (12289 <= S && S <= 12350) ||
                (12353 <= S && S <= 12438) ||
                (12441 <= S && S <= 12543) ||
                (12549 <= S && S <= 12589) ||
                (12593 <= S && S <= 12686) ||
                (12688 <= S && S <= 12730) ||
                (12736 <= S && S <= 12771) ||
                (12784 <= S && S <= 12830) ||
                (12832 <= S && S <= 12871) ||
                (12880 <= S && S <= 13054) ||
                (13056 <= S && S <= 19903) ||
                (19968 <= S && S <= 42124) ||
                (42128 <= S && S <= 42182) ||
                (43360 <= S && S <= 43388) ||
                (44032 <= S && S <= 55203) ||
                (55216 <= S && S <= 55238) ||
                (55243 <= S && S <= 55291) ||
                (63744 <= S && S <= 64255) ||
                (65040 <= S && S <= 65049) ||
                (65072 <= S && S <= 65106) ||
                (65108 <= S && S <= 65126) ||
                (65128 <= S && S <= 65131) ||
                (110592 <= S && S <= 110593) ||
                (127488 <= S && S <= 127490) ||
                (127504 <= S && S <= 127546) ||
                (127552 <= S && S <= 127560) ||
                (127568 <= S && S <= 127569) ||
                (131072 <= S && S <= 194367) ||
                (177984 <= S && S <= 196605) ||
                (196608 <= S && S <= 262141)
              ? 'W'
              : 'N'
          );
        },
      },
      Ol = /[^\x20-\x7F]/;
    function qf(y) {
      if (!y) return 0;
      if (!Ol.test(y)) return y.length;
      y = y.replace(Uf(), '  ');
      let C = 0;
      for (let v of y) {
        let S = v.codePointAt(0);
        if (S <= 31 || (S >= 127 && S <= 159) || (S >= 768 && S <= 879)) continue;
        let k = Ml.eastAsianWidth(v);
        C += k === 'F' || k === 'W' ? 2 : 1;
      }
      return C;
    }
    var Ll = qf,
      Kf = (y) => {
        if (Array.isArray(y)) return y;
        if (y.type !== we) throw new Error(`Expect doc to be 'array' or '${we}'.`);
        return y.parts;
      };
    function xo(y, C) {
      if (typeof y == 'string') return C(y);
      let v = new Map();
      return S(y);
      function S(B) {
        if (v.has(B)) return v.get(B);
        let O = k(B);
        return v.set(B, O), O;
      }
      function k(B) {
        switch (fe(B)) {
          case re:
            return C(B.map(S));
          case we:
            return C({ ...B, parts: B.parts.map(S) });
          case je:
            return C({ ...B, breakContents: S(B.breakContents), flatContents: S(B.flatContents) });
          case ge: {
            let { expandedStates: O, contents: H } = B;
            return O ? ((O = O.map(S)), (H = O[0])) : (H = S(H)), C({ ...B, contents: H, expandedStates: O });
          }
          case ce:
          case Q:
          case Qe:
          case yt:
          case ot:
            return C({ ...B, contents: S(B.contents) });
          case Re:
          case ie:
          case G:
          case pt:
          case gt:
          case U:
            return C(B);
          default:
            throw new J(B);
        }
      }
    }
    function _l(y, C, v) {
      let S = v,
        k = !1;
      function B(O) {
        if (k) return !1;
        let H = C(O);
        H !== void 0 && ((k = !0), (S = H));
      }
      return ye(y, B), S;
    }
    function Co(y) {
      if ((y.type === ge && y.break) || (y.type === gt && y.hard) || y.type === U) return !0;
    }
    function bo(y) {
      return _l(y, Co, !1);
    }
    function Sc(y) {
      if (y.length > 0) {
        let C = lr(!1, y, -1);
        !C.expandedStates && !C.break && (C.break = 'propagated');
      }
      return null;
    }
    function wc(y) {
      let C = new Set(),
        v = [];
      function S(B) {
        if ((B.type === U && Sc(v), B.type === ge)) {
          if ((v.push(B), C.has(B))) return !1;
          C.add(B);
        }
      }
      function k(B) {
        B.type === ge && v.pop().break && Sc(v);
      }
      ye(y, S, k, !0);
    }
    function ya(y) {
      return y.type === gt && !y.hard ? (y.soft ? '' : ' ') : y.type === je ? y.flatContents : y;
    }
    function Ao(y) {
      return xo(y, ya);
    }
    function Da(y) {
      for (y = [...y]; y.length >= 2 && lr(!1, y, -2).type === gt && lr(!1, y, -1).type === U; ) y.length -= 2;
      if (y.length > 0) {
        let C = Di(lr(!1, y, -1));
        y[y.length - 1] = C;
      }
      return y;
    }
    function Di(y) {
      switch (fe(y)) {
        case ce:
        case Q:
        case Qe:
        case ge:
        case ot:
        case yt: {
          let C = Di(y.contents);
          return { ...y, contents: C };
        }
        case je:
          return { ...y, breakContents: Di(y.breakContents), flatContents: Di(y.flatContents) };
        case we:
          return { ...y, parts: Da(y.parts) };
        case re:
          return Da(y);
        case Re:
          return y.replace(/[\n\r]*$/, '');
        case ie:
        case G:
        case pt:
        case gt:
        case U:
          break;
        default:
          throw new J(y);
      }
      return y;
    }
    function Rl(y) {
      return Di(Xf(y));
    }
    function Jf(y) {
      switch (fe(y)) {
        case we:
          if (y.parts.every((C) => C === '')) return '';
          break;
        case ge:
          if (!y.contents && !y.id && !y.break && !y.expandedStates) return '';
          if (
            y.contents.type === ge &&
            y.contents.id === y.id &&
            y.contents.break === y.break &&
            y.contents.expandedStates === y.expandedStates
          )
            return y.contents;
          break;
        case ce:
        case Q:
        case Qe:
        case ot:
          if (!y.contents) return '';
          break;
        case je:
          if (!y.flatContents && !y.breakContents) return '';
          break;
        case re: {
          let C = [];
          for (let v of y) {
            if (!v) continue;
            let [S, ...k] = Array.isArray(v) ? v : [v];
            typeof S == 'string' && typeof lr(!1, C, -1) == 'string' ? (C[C.length - 1] += S) : C.push(S), C.push(...k);
          }
          return C.length === 0 ? '' : C.length === 1 ? C[0] : C;
        }
        case Re:
        case ie:
        case G:
        case pt:
        case gt:
        case yt:
        case U:
          break;
        default:
          throw new J(y);
      }
      return y;
    }
    function Xf(y) {
      return xo(y, (C) => Jf(C));
    }
    function Gf(y, C = ga) {
      return xo(y, (v) =>
        typeof v == 'string'
          ? Cc(
              C,
              v.split(`
`),
            )
          : v,
      );
    }
    function Tc(y) {
      if (y.type === gt) return !0;
    }
    function xa(y) {
      return _l(y, Tc, !1);
    }
    function jl(y, C) {
      return y.type === yt ? { ...y, contents: C(y.contents) } : C(y);
    }
    var Hr = Symbol('MODE_BREAK'),
      Mn = Symbol('MODE_FLAT'),
      Xi = Symbol('cursor');
    function $l() {
      return { value: '', length: 0, queue: [] };
    }
    function kc(y, C) {
      return Vl(y, { type: 'indent' }, C);
    }
    function Yf(y, C, v) {
      return C === Number.NEGATIVE_INFINITY
        ? y.root || $l()
        : C < 0
        ? Vl(y, { type: 'dedent' }, v)
        : C
        ? C.type === 'root'
          ? { ...y, root: y }
          : Vl(y, { type: typeof C == 'string' ? 'stringAlign' : 'numberAlign', n: C }, v)
        : y;
    }
    function Vl(y, C, v) {
      let S = C.type === 'dedent' ? y.queue.slice(0, -1) : [...y.queue, C],
        k = '',
        B = 0,
        O = 0,
        H = 0;
      for (let le of S)
        switch (le.type) {
          case 'indent':
            ne(), v.useTabs ? K(1) : Z(v.tabWidth);
            break;
          case 'stringAlign':
            ne(), (k += le.n), (B += le.n.length);
            break;
          case 'numberAlign':
            (O += 1), (H += le.n);
            break;
          default:
            throw new Error(`Unexpected type '${le.type}'`);
        }
      return ee(), { ...y, value: k, length: B, queue: S };
      function K(le) {
        (k += '	'.repeat(le)), (B += v.tabWidth * le);
      }
      function Z(le) {
        (k += ' '.repeat(le)), (B += le);
      }
      function ne() {
        v.useTabs ? be() : ee();
      }
      function be() {
        O > 0 && K(O), Ce();
      }
      function ee() {
        H > 0 && Z(H), Ce();
      }
      function Ce() {
        (O = 0), (H = 0);
      }
    }
    function Gi(y) {
      let C = 0,
        v = 0,
        S = y.length;
      e: for (; S--; ) {
        let k = y[S];
        if (k === Xi) {
          v++;
          continue;
        }
        for (let B = k.length - 1; B >= 0; B--) {
          let O = k[B];
          if (O === ' ' || O === '	') C++;
          else {
            y[S] = k.slice(0, B + 1);
            break e;
          }
        }
      }
      if (C > 0 || v > 0) for (y.length = S + 1; v-- > 0; ) y.push(Xi);
      return C;
    }
    function Ca(y, C, v, S, k, B) {
      if (v === Number.POSITIVE_INFINITY) return !0;
      let O = C.length,
        H = [y],
        K = [];
      for (; v >= 0; ) {
        if (H.length === 0) {
          if (O === 0) return !0;
          H.push(C[--O]);
          continue;
        }
        let { mode: Z, doc: ne } = H.pop();
        switch (fe(ne)) {
          case Re:
            K.push(ne), (v -= Ll(ne));
            break;
          case re:
          case we: {
            let be = Kf(ne);
            for (let ee = be.length - 1; ee >= 0; ee--) H.push({ mode: Z, doc: be[ee] });
            break;
          }
          case Q:
          case ce:
          case Qe:
          case yt:
            H.push({ mode: Z, doc: ne.contents });
            break;
          case G:
            v += Gi(K);
            break;
          case ge: {
            if (B && ne.break) return !1;
            let be = ne.break ? Hr : Z,
              ee = ne.expandedStates && be === Hr ? lr(!1, ne.expandedStates, -1) : ne.contents;
            H.push({ mode: be, doc: ee });
            break;
          }
          case je: {
            let be = (ne.groupId ? k[ne.groupId] || Mn : Z) === Hr ? ne.breakContents : ne.flatContents;
            be && H.push({ mode: Z, doc: be });
            break;
          }
          case gt:
            if (Z === Hr || ne.hard) return !0;
            ne.soft || (K.push(' '), v--);
            break;
          case ot:
            S = !0;
            break;
          case pt:
            if (S) return !1;
            break;
        }
      }
      return !1;
    }
    function Cn(y, C) {
      let v = {},
        S = C.printWidth,
        k = Nl(C.endOfLine),
        B = 0,
        O = [{ ind: $l(), mode: Hr, doc: y }],
        H = [],
        K = !1,
        Z = [],
        ne = 0;
      for (wc(y); O.length > 0; ) {
        let { ind: ee, mode: Ce, doc: le } = O.pop();
        switch (fe(le)) {
          case Re: {
            let Oe =
              k !==
              `
`
                ? q(
                    !1,
                    le,
                    `
`,
                    k,
                  )
                : le;
            H.push(Oe), O.length > 0 && (B += Ll(Oe));
            break;
          }
          case re:
            for (let Oe = le.length - 1; Oe >= 0; Oe--) O.push({ ind: ee, mode: Ce, doc: le[Oe] });
            break;
          case ie:
            if (ne >= 2) throw new Error("There are too many 'cursor' in doc.");
            H.push(Xi), ne++;
            break;
          case Q:
            O.push({ ind: kc(ee, C), mode: Ce, doc: le.contents });
            break;
          case ce:
            O.push({ ind: Yf(ee, le.n, C), mode: Ce, doc: le.contents });
            break;
          case G:
            B -= Gi(H);
            break;
          case ge:
            switch (Ce) {
              case Mn:
                if (!K) {
                  O.push({ ind: ee, mode: le.break ? Hr : Mn, doc: le.contents });
                  break;
                }
              case Hr: {
                K = !1;
                let Oe = { ind: ee, mode: Mn, doc: le.contents },
                  Xe = S - B,
                  ft = Z.length > 0;
                if (!le.break && Ca(Oe, O, Xe, ft, v)) O.push(Oe);
                else if (le.expandedStates) {
                  let ct = lr(!1, le.expandedStates, -1);
                  if (le.break) {
                    O.push({ ind: ee, mode: Hr, doc: ct });
                    break;
                  } else
                    for (let Dt = 1; Dt < le.expandedStates.length + 1; Dt++)
                      if (Dt >= le.expandedStates.length) {
                        O.push({ ind: ee, mode: Hr, doc: ct });
                        break;
                      } else {
                        let Ft = le.expandedStates[Dt],
                          Rt = { ind: ee, mode: Mn, doc: Ft };
                        if (Ca(Rt, O, Xe, ft, v)) {
                          O.push(Rt);
                          break;
                        }
                      }
                } else O.push({ ind: ee, mode: Hr, doc: le.contents });
                break;
              }
            }
            le.id && (v[le.id] = lr(!1, O, -1).mode);
            break;
          case we: {
            let Oe = S - B,
              { parts: Xe } = le;
            if (Xe.length === 0) break;
            let [ft, ct] = Xe,
              Dt = { ind: ee, mode: Mn, doc: ft },
              Ft = { ind: ee, mode: Hr, doc: ft },
              Rt = Ca(Dt, [], Oe, Z.length > 0, v, !0);
            if (Xe.length === 1) {
              Rt ? O.push(Dt) : O.push(Ft);
              break;
            }
            let Ur = { ind: ee, mode: Mn, doc: ct },
              Br = { ind: ee, mode: Hr, doc: ct };
            if (Xe.length === 2) {
              Rt ? O.push(Ur, Dt) : O.push(Br, Ft);
              break;
            }
            Xe.splice(0, 2);
            let en = { ind: ee, mode: Ce, doc: Mt(Xe) },
              Ci = Xe[0];
            Ca({ ind: ee, mode: Mn, doc: [ft, ct, Ci] }, [], Oe, Z.length > 0, v, !0)
              ? O.push(en, Ur, Dt)
              : Rt
              ? O.push(en, Br, Dt)
              : O.push(en, Br, Ft);
            break;
          }
          case je:
          case Qe: {
            let Oe = le.groupId ? v[le.groupId] : Ce;
            if (Oe === Hr) {
              let Xe = le.type === je ? le.breakContents : le.negate ? le.contents : ke(le.contents);
              Xe && O.push({ ind: ee, mode: Ce, doc: Xe });
            }
            if (Oe === Mn) {
              let Xe = le.type === je ? le.flatContents : le.negate ? ke(le.contents) : le.contents;
              Xe && O.push({ ind: ee, mode: Ce, doc: Xe });
            }
            break;
          }
          case ot:
            Z.push({ ind: ee, mode: Ce, doc: le.contents });
            break;
          case pt:
            Z.length > 0 && O.push({ ind: ee, mode: Ce, doc: Ji });
            break;
          case gt:
            switch (Ce) {
              case Mn:
                if (le.hard) K = !0;
                else {
                  le.soft || (H.push(' '), (B += 1));
                  break;
                }
              case Hr:
                if (Z.length > 0) {
                  O.push({ ind: ee, mode: Ce, doc: le }, ...Z.reverse()), (Z.length = 0);
                  break;
                }
                le.literal
                  ? ee.root
                    ? (H.push(k, ee.root.value), (B = ee.root.length))
                    : (H.push(k), (B = 0))
                  : ((B -= Gi(H)), H.push(k + ee.value), (B = ee.length));
                break;
            }
            break;
          case yt:
            O.push({ ind: ee, mode: Ce, doc: le.contents });
            break;
          case U:
            break;
          default:
            throw new J(le);
        }
        O.length === 0 && Z.length > 0 && (O.push(...Z.reverse()), (Z.length = 0));
      }
      let be = H.indexOf(Xi);
      if (be !== -1) {
        let ee = H.indexOf(Xi, be + 1),
          Ce = H.slice(0, be).join(''),
          le = H.slice(be + 1, ee).join(''),
          Oe = H.slice(ee + 1).join('');
        return { formatted: Ce + le + Oe, cursorNodeStart: Ce.length, cursorNodeText: le };
      }
      return { formatted: H.join('') };
    }
    function Gn(y) {
      var C;
      if (!y) return '';
      if (Array.isArray(y)) {
        let v = [];
        for (let S of y)
          if (Array.isArray(S)) v.push(...Gn(S));
          else {
            let k = Gn(S);
            k !== '' && v.push(k);
          }
        return v;
      }
      return y.type === je
        ? { ...y, breakContents: Gn(y.breakContents), flatContents: Gn(y.flatContents) }
        : y.type === ge
        ? { ...y, contents: Gn(y.contents), expandedStates: (C = y.expandedStates) == null ? void 0 : C.map(Gn) }
        : y.type === we
        ? { type: 'fill', parts: y.parts.map(Gn) }
        : y.contents
        ? { ...y, contents: Gn(y.contents) }
        : y;
    }
    function Qf(y) {
      let C = Object.create(null),
        v = new Set();
      return S(Gn(y));
      function S(B, O, H) {
        var K, Z;
        if (typeof B == 'string') return JSON.stringify(B);
        if (Array.isArray(B)) {
          let ne = B.map(S).filter(Boolean);
          return ne.length === 1 ? ne[0] : `[${ne.join(', ')}]`;
        }
        if (B.type === gt) {
          let ne = ((K = H == null ? void 0 : H[O + 1]) == null ? void 0 : K.type) === U;
          return B.literal
            ? ne
              ? 'literalline'
              : 'literallineWithoutBreakParent'
            : B.hard
            ? ne
              ? 'hardline'
              : 'hardlineWithoutBreakParent'
            : B.soft
            ? 'softline'
            : 'line';
        }
        if (B.type === U)
          return ((Z = H == null ? void 0 : H[O - 1]) == null ? void 0 : Z.type) === gt && H[O - 1].hard
            ? void 0
            : 'breakParent';
        if (B.type === G) return 'trim';
        if (B.type === Q) return 'indent(' + S(B.contents) + ')';
        if (B.type === ce)
          return B.n === Number.NEGATIVE_INFINITY
            ? 'dedentToRoot(' + S(B.contents) + ')'
            : B.n < 0
            ? 'dedent(' + S(B.contents) + ')'
            : B.n.type === 'root'
            ? 'markAsRoot(' + S(B.contents) + ')'
            : 'align(' + JSON.stringify(B.n) + ', ' + S(B.contents) + ')';
        if (B.type === je)
          return (
            'ifBreak(' +
            S(B.breakContents) +
            (B.flatContents ? ', ' + S(B.flatContents) : '') +
            (B.groupId ? (B.flatContents ? '' : ', ""') + `, { groupId: ${k(B.groupId)} }` : '') +
            ')'
          );
        if (B.type === Qe) {
          let ne = [];
          B.negate && ne.push('negate: true'), B.groupId && ne.push(`groupId: ${k(B.groupId)}`);
          let be = ne.length > 0 ? `, { ${ne.join(', ')} }` : '';
          return `indentIfBreak(${S(B.contents)}${be})`;
        }
        if (B.type === ge) {
          let ne = [];
          B.break && B.break !== 'propagated' && ne.push('shouldBreak: true'), B.id && ne.push(`id: ${k(B.id)}`);
          let be = ne.length > 0 ? `, { ${ne.join(', ')} }` : '';
          return B.expandedStates
            ? `conditionalGroup([${B.expandedStates.map((ee) => S(ee)).join(',')}]${be})`
            : `group(${S(B.contents)}${be})`;
        }
        if (B.type === we) return `fill([${B.parts.map((ne) => S(ne)).join(', ')}])`;
        if (B.type === ot) return 'lineSuffix(' + S(B.contents) + ')';
        if (B.type === pt) return 'lineSuffixBoundary';
        if (B.type === yt) return `label(${JSON.stringify(B.label)}, ${S(B.contents)})`;
        throw new Error('Unknown doc type ' + B.type);
      }
      function k(B) {
        if (typeof B != 'symbol') return JSON.stringify(String(B));
        if (B in C) return C[B];
        let O = B.description || 'symbol';
        for (let H = 0; ; H++) {
          let K = O + (H > 0 ? ` #${H}` : '');
          if (!v.has(K)) return v.add(K), (C[B] = `Symbol.for(${JSON.stringify(K)})`);
        }
      }
    }
    function Zf(y, C, v = 0) {
      let S = 0;
      for (let k = v; k < y.length; ++k) y[k] === '	' ? (S = S + C - (S % C)) : S++;
      return S;
    }
    var xs = Zf,
      zl = class extends Error {
        constructor() {
          super(...arguments);
          ko(this, 'name', 'ConfigError');
        }
      },
      Pc = class extends Error {
        constructor() {
          super(...arguments);
          ko(this, 'name', 'UndefinedParserError');
        }
      },
      ed = {
        cursorOffset: {
          category: 'Special',
          type: 'int',
          default: -1,
          range: { start: -1, end: 1 / 0, step: 1 },
          description: `Print (to stderr) where a cursor at the given position would move to after formatting.
This option cannot be used with --range-start and --range-end.`,
          cliCategory: 'Editor',
        },
        endOfLine: {
          category: 'Global',
          type: 'choice',
          default: 'lf',
          description: 'Which end of line characters to apply.',
          choices: [
            { value: 'lf', description: 'Line Feed only (\\n), common on Linux and macOS as well as inside git repos' },
            { value: 'crlf', description: 'Carriage Return + Line Feed characters (\\r\\n), common on Windows' },
            { value: 'cr', description: 'Carriage Return character only (\\r), used very rarely' },
            {
              value: 'auto',
              description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)`,
            },
          ],
        },
        filepath: {
          category: 'Special',
          type: 'path',
          description: 'Specify the input filepath. This will be used to do parser inference.',
          cliName: 'stdin-filepath',
          cliCategory: 'Other',
          cliDescription: 'Path to the file to pretend that stdin comes from.',
        },
        insertPragma: {
          category: 'Special',
          type: 'boolean',
          default: !1,
          description: "Insert @format pragma into file's first docblock comment.",
          cliCategory: 'Other',
        },
        parser: {
          category: 'Global',
          type: 'choice',
          default: void 0,
          description: 'Which parser to use.',
          exception: (y) => typeof y == 'string' || typeof y == 'function',
          choices: [
            { value: 'flow', description: 'Flow' },
            { value: 'babel', description: 'JavaScript' },
            { value: 'babel-flow', description: 'Flow' },
            { value: 'babel-ts', description: 'TypeScript' },
            { value: 'typescript', description: 'TypeScript' },
            { value: 'acorn', description: 'JavaScript' },
            { value: 'espree', description: 'JavaScript' },
            { value: 'meriyah', description: 'JavaScript' },
            { value: 'css', description: 'CSS' },
            { value: 'less', description: 'Less' },
            { value: 'scss', description: 'SCSS' },
            { value: 'json', description: 'JSON' },
            { value: 'json5', description: 'JSON5' },
            { value: 'json-stringify', description: 'JSON.stringify' },
            { value: 'graphql', description: 'GraphQL' },
            { value: 'markdown', description: 'Markdown' },
            { value: 'mdx', description: 'MDX' },
            { value: 'vue', description: 'Vue' },
            { value: 'yaml', description: 'YAML' },
            { value: 'glimmer', description: 'Ember / Handlebars' },
            { value: 'html', description: 'HTML' },
            { value: 'angular', description: 'Angular' },
            { value: 'lwc', description: 'Lightning Web Components' },
          ],
        },
        plugins: {
          type: 'path',
          array: !0,
          default: [{ value: [] }],
          category: 'Global',
          description: 'Add a plugin. Multiple plugins can be passed as separate `--plugin`s.',
          exception: (y) => typeof y == 'string' || typeof y == 'object',
          cliName: 'plugin',
          cliCategory: 'Config',
        },
        printWidth: {
          category: 'Global',
          type: 'int',
          default: 80,
          description: 'The line length where Prettier will try wrap.',
          range: { start: 0, end: 1 / 0, step: 1 },
        },
        rangeEnd: {
          category: 'Special',
          type: 'int',
          default: 1 / 0,
          range: { start: 0, end: 1 / 0, step: 1 },
          description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.
This option cannot be used with --cursor-offset.`,
          cliCategory: 'Editor',
        },
        rangeStart: {
          category: 'Special',
          type: 'int',
          default: 0,
          range: { start: 0, end: 1 / 0, step: 1 },
          description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.
This option cannot be used with --cursor-offset.`,
          cliCategory: 'Editor',
        },
        requirePragma: {
          category: 'Special',
          type: 'boolean',
          default: !1,
          description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`,
          cliCategory: 'Other',
        },
        tabWidth: {
          type: 'int',
          category: 'Global',
          default: 2,
          description: 'Number of spaces per indentation level.',
          range: { start: 0, end: 1 / 0, step: 1 },
        },
        useTabs: {
          category: 'Global',
          type: 'boolean',
          default: !1,
          description: 'Indent with tabs instead of spaces.',
        },
        embeddedLanguageFormatting: {
          category: 'Global',
          type: 'choice',
          default: 'auto',
          description: 'Control how Prettier formats quoted code embedded in the file.',
          choices: [
            { value: 'auto', description: 'Format embedded code if Prettier can automatically identify it.' },
            { value: 'off', description: 'Never automatically format embedded code.' },
          ],
        },
      };
    function Bc({ plugins: y = [], showDeprecated: C = !1 } = {}) {
      let v = y.flatMap((k) => k.languages ?? []),
        S = [];
      for (let k of Ic(Object.assign({}, ...y.map(({ options: B }) => B), ed)))
        (!C && k.deprecated) ||
          (Array.isArray(k.choices) &&
            (C || (k.choices = k.choices.filter((B) => !B.deprecated)),
            k.name === 'parser' && (k.choices = [...k.choices, ...td(k.choices, v, y)])),
          (k.pluginDefaults = Object.fromEntries(
            y
              .filter((B) => {
                var O;
                return ((O = B.defaultOptions) == null ? void 0 : O[k.name]) !== void 0;
              })
              .map((B) => [B.name, B.defaultOptions[k.name]]),
          )),
          S.push(k));
      return { languages: v, options: S };
    }
    function* td(y, C, v) {
      let S = new Set(y.map((k) => k.value));
      for (let k of C)
        if (k.parsers) {
          for (let B of k.parsers)
            if (!S.has(B)) {
              S.add(B);
              let O = v.find((K) => K.parsers && Object.prototype.hasOwnProperty.call(K.parsers, B)),
                H = k.name;
              O != null && O.name && (H += ` (plugin: ${O.name})`), yield { value: B, description: H };
            }
        }
    }
    function Ic(y) {
      let C = [];
      for (let [v, S] of Object.entries(y)) {
        let k = { name: v, ...S };
        Array.isArray(k.default) && (k.default = lr(!1, k.default, -1).value), C.push(k);
      }
      return C;
    }
    var Cs = (y) => y.split(/[/\\]/).pop();
    function Hl(y, C) {
      if (!C) return;
      let v = Cs(C).toLowerCase();
      return y.find((S) => {
        var k, B;
        return (
          ((k = S.extensions) == null ? void 0 : k.some((O) => v.endsWith(O))) ||
          ((B = S.filenames) == null ? void 0 : B.some((O) => O.toLowerCase() === v))
        );
      });
    }
    function ba(y, C) {
      if (C)
        return (
          y.find(({ name: v }) => v.toLowerCase() === C) ??
          y.find(({ aliases: v }) => (v == null ? void 0 : v.includes(C))) ??
          y.find(({ extensions: v }) => (v == null ? void 0 : v.includes(`.${C}`)))
        );
    }
    function Nc(y, C) {
      let v = y.plugins.flatMap((k) => k.languages ?? []),
        S = ba(v, C.language) ?? Hl(v, C.physicalFile) ?? Hl(v, C.file) ?? (C.physicalFile, void 0);
      return S == null ? void 0 : S.parsers[0];
    }
    var bs = Nc,
      As = {
        key: (y) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(y) ? y : JSON.stringify(y)),
        value(y) {
          if (y === null || typeof y != 'object') return JSON.stringify(y);
          if (Array.isArray(y)) return `[${y.map((v) => As.value(v)).join(', ')}]`;
          let C = Object.keys(y);
          return C.length === 0 ? '{}' : `{ ${C.map((v) => `${As.key(v)}: ${As.value(y[v])}`).join(', ')} }`;
        },
        pair: ({ key: y, value: C }) => As.value({ [y]: C }),
      },
      Eo = g(T(), 1),
      rd = (y, C, { descriptor: v }) => {
        let S = [`${Eo.default.yellow(typeof y == 'string' ? v.key(y) : v.pair(y))} is deprecated`];
        return (
          C && S.push(`we now treat it as ${Eo.default.blue(typeof C == 'string' ? v.key(C) : v.pair(C))}`),
          S.join('; ') + '.'
        );
      },
      Yn = g(T(), 1),
      vo = Symbol.for('vnopts.VALUE_NOT_EXIST'),
      Es = Symbol.for('vnopts.VALUE_UNCHANGED'),
      Mc = ' '.repeat(2),
      Qn = (y, C, v) => {
        let { text: S, list: k } = v.normalizeExpectedResult(v.schemas[y].expected(v)),
          B = [];
        return (
          S && B.push(Oc(y, C, S, v.descriptor)),
          k &&
            B.push(
              [Oc(y, C, k.title, v.descriptor)].concat(k.values.map((O) => Lc(O, v.loggerPrintWidth))).join(`
`),
            ),
          _c(B, v.loggerPrintWidth)
        );
      };
    function Oc(y, C, v, S) {
      return [
        `Invalid ${Yn.default.red(S.key(y))} value.`,
        `Expected ${Yn.default.blue(v)},`,
        `but received ${C === vo ? Yn.default.gray('nothing') : Yn.default.red(S.value(C))}.`,
      ].join(' ');
    }
    function Lc({ text: y, list: C }, v) {
      let S = [];
      return (
        y && S.push(`- ${Yn.default.blue(y)}`),
        C &&
          S.push(
            [`- ${Yn.default.blue(C.title)}:`].concat(
              C.values.map((k) => Lc(k, v - Mc.length).replace(/^|\n/g, `$&${Mc}`)),
            ).join(`
`),
          ),
        _c(S, v)
      );
    }
    function _c(y, C) {
      if (y.length === 1) return y[0];
      let [v, S] = y,
        [k, B] = y.map(
          (O) =>
            O.split(
              `
`,
              1,
            )[0].length,
        );
      return k > C && k > B ? S : v;
    }
    var Ye = g(T(), 1),
      Wl = [],
      Ul = [];
    function nd(y, C) {
      if (y === C) return 0;
      let v = y;
      y.length > C.length && ((y = C), (C = v));
      let S = y.length,
        k = C.length;
      for (; S > 0 && y.charCodeAt(~-S) === C.charCodeAt(~-k); ) S--, k--;
      let B = 0;
      for (; B < S && y.charCodeAt(B) === C.charCodeAt(B); ) B++;
      if (((S -= B), (k -= B), S === 0)) return k;
      let O,
        H,
        K,
        Z,
        ne = 0,
        be = 0;
      for (; ne < S; ) (Ul[ne] = y.charCodeAt(B + ne)), (Wl[ne] = ++ne);
      for (; be < k; )
        for (O = C.charCodeAt(B + be), K = be++, H = be, ne = 0; ne < S; ne++)
          (Z = O === Ul[ne] ? K : K + 1), (K = Wl[ne]), (H = Wl[ne] = K > H ? (Z > H ? H + 1 : Z) : Z > K ? K + 1 : Z);
      return H;
    }
    var Rc = (y, C, { descriptor: v, logger: S, schemas: k }) => {
        let B = [`Ignored unknown option ${Ye.default.yellow(v.pair({ key: y, value: C }))}.`],
          O = Object.keys(k)
            .sort()
            .find((H) => nd(y, H) < 3);
        O && B.push(`Did you mean ${Ye.default.blue(v.key(O))}?`), S.warn(B.join(' '));
      },
      id = [
        'default',
        'expected',
        'validate',
        'deprecated',
        'forward',
        'redirect',
        'overlap',
        'preprocess',
        'postprocess',
      ];
    function sd(y, C) {
      let v = new y(C),
        S = Object.create(v);
      for (let k of id) k in C && (S[k] = xi(C[k], v, Wr.prototype[k].length));
      return S;
    }
    var Wr = class {
      static create(y) {
        return sd(this, y);
      }
      constructor(y) {
        this.name = y.name;
      }
      default(y) {}
      expected(y) {
        return 'nothing';
      }
      validate(y, C) {
        return !1;
      }
      deprecated(y, C) {
        return !1;
      }
      forward(y, C) {}
      redirect(y, C) {}
      overlap(y, C, v) {
        return y;
      }
      preprocess(y, C) {
        return y;
      }
      postprocess(y, C) {
        return Es;
      }
    };
    function xi(y, C, v) {
      return typeof y == 'function' ? (...S) => y(...S.slice(0, v - 1), C, ...S.slice(v - 1)) : () => y;
    }
    var vs = class extends Wr {
        constructor(y) {
          super(y), (this._sourceName = y.sourceName);
        }
        expected(y) {
          return y.schemas[this._sourceName].expected(y);
        }
        validate(y, C) {
          return C.schemas[this._sourceName].validate(y, C);
        }
        redirect(y, C) {
          return this._sourceName;
        }
      },
      od = class extends Wr {
        expected() {
          return 'anything';
        }
        validate() {
          return !0;
        }
      },
      ad = class extends Wr {
        constructor({ valueSchema: y, name: C = y.name, ...v }) {
          super({ ...v, name: C }), (this._valueSchema = y);
        }
        expected(y) {
          let { text: C, list: v } = y.normalizeExpectedResult(this._valueSchema.expected(y));
          return {
            text: C && `an array of ${C}`,
            list: v && { title: 'an array of the following values', values: [{ list: v }] },
          };
        }
        validate(y, C) {
          if (!Array.isArray(y)) return !1;
          let v = [];
          for (let S of y) {
            let k = C.normalizeValidateResult(this._valueSchema.validate(S, C), S);
            k !== !0 && v.push(k.value);
          }
          return v.length === 0 ? !0 : { value: v };
        }
        deprecated(y, C) {
          let v = [];
          for (let S of y) {
            let k = C.normalizeDeprecatedResult(this._valueSchema.deprecated(S, C), S);
            k !== !1 && v.push(...k.map(({ value: B }) => ({ value: [B] })));
          }
          return v;
        }
        forward(y, C) {
          let v = [];
          for (let S of y) {
            let k = C.normalizeForwardResult(this._valueSchema.forward(S, C), S);
            v.push(...k.map(jc));
          }
          return v;
        }
        redirect(y, C) {
          let v = [],
            S = [];
          for (let k of y) {
            let B = C.normalizeRedirectResult(this._valueSchema.redirect(k, C), k);
            'remain' in B && v.push(B.remain), S.push(...B.redirect.map(jc));
          }
          return v.length === 0 ? { redirect: S } : { redirect: S, remain: v };
        }
        overlap(y, C) {
          return y.concat(C);
        }
      };
    function jc({ from: y, to: C }) {
      return { from: [y], to: C };
    }
    var ld = class extends Wr {
      expected() {
        return 'true or false';
      }
      validate(y) {
        return typeof y == 'boolean';
      }
    };
    function $c(y, C) {
      let v = Object.create(null);
      for (let S of y) {
        let k = S[C];
        if (v[k]) throw new Error(`Duplicate ${C} ${JSON.stringify(k)}`);
        v[k] = S;
      }
      return v;
    }
    function ud(y, C) {
      let v = new Map();
      for (let S of y) {
        let k = S[C];
        if (v.has(k)) throw new Error(`Duplicate ${C} ${JSON.stringify(k)}`);
        v.set(k, S);
      }
      return v;
    }
    function cd() {
      let y = Object.create(null);
      return (C) => {
        let v = JSON.stringify(C);
        return y[v] ? !0 : ((y[v] = !0), !1);
      };
    }
    function hd(y, C) {
      let v = [],
        S = [];
      for (let k of y) C(k) ? v.push(k) : S.push(k);
      return [v, S];
    }
    function Vc(y) {
      return y === Math.floor(y);
    }
    function Ve(y, C) {
      if (y === C) return 0;
      let v = typeof y,
        S = typeof C,
        k = ['undefined', 'object', 'boolean', 'number', 'string'];
      return v !== S ? k.indexOf(v) - k.indexOf(S) : v !== 'string' ? Number(y) - Number(C) : y.localeCompare(C);
    }
    function pd(y) {
      return (...C) => {
        let v = y(...C);
        return typeof v == 'string' ? new Error(v) : v;
      };
    }
    function ql(y) {
      return y === void 0 ? {} : y;
    }
    function zc(y) {
      if (typeof y == 'string') return { text: y };
      let { text: C, list: v } = y;
      return (
        Kc((C || v) !== void 0, 'Unexpected `expected` result, there should be at least one field.'),
        v ? { text: C, list: { title: v.title, values: v.values.map(zc) } } : { text: C }
      );
    }
    function Hc(y, C) {
      return y === !0 ? !0 : y === !1 ? { value: C } : y;
    }
    function Wc(y, C, v = !1) {
      return y === !1 ? !1 : y === !0 ? (v ? !0 : [{ value: C }]) : 'value' in y ? [y] : y.length === 0 ? !1 : y;
    }
    function Uc(y, C) {
      return typeof y == 'string' || 'key' in y
        ? { from: C, to: y }
        : 'from' in y
        ? { from: y.from, to: y.to }
        : { from: C, to: y.to };
    }
    function Aa(y, C) {
      return y === void 0 ? [] : Array.isArray(y) ? y.map((v) => Uc(v, C)) : [Uc(y, C)];
    }
    function qc(y, C) {
      let v = Aa(typeof y == 'object' && 'redirect' in y ? y.redirect : y, C);
      return v.length === 0
        ? { remain: C, redirect: v }
        : typeof y == 'object' && 'remain' in y
        ? { remain: y.remain, redirect: v }
        : { redirect: v };
    }
    function Kc(y, C) {
      if (!y) throw new Error(C);
    }
    var Jc = class extends Wr {
        constructor(y) {
          super(y),
            (this._choices = ud(
              y.choices.map((C) => (C && typeof C == 'object' ? C : { value: C })),
              'value',
            ));
        }
        expected({ descriptor: y }) {
          let C = Array.from(this._choices.keys())
              .map((k) => this._choices.get(k))
              .filter(({ hidden: k }) => !k)
              .map((k) => k.value)
              .sort(Ve)
              .map(y.value),
            v = C.slice(0, -2),
            S = C.slice(-2);
          return {
            text: v.concat(S.join(' or ')).join(', '),
            list: { title: 'one of the following values', values: C },
          };
        }
        validate(y) {
          return this._choices.has(y);
        }
        deprecated(y) {
          let C = this._choices.get(y);
          return C && C.deprecated ? { value: y } : !1;
        }
        forward(y) {
          let C = this._choices.get(y);
          return C ? C.forward : void 0;
        }
        redirect(y) {
          let C = this._choices.get(y);
          return C ? C.redirect : void 0;
        }
      },
      fd = class extends Wr {
        expected() {
          return 'a number';
        }
        validate(y, C) {
          return typeof y == 'number';
        }
      },
      dd = class extends fd {
        expected() {
          return 'an integer';
        }
        validate(y, C) {
          return C.normalizeValidateResult(super.validate(y, C), y) === !0 && Vc(y);
        }
      },
      sr = class extends Wr {
        expected() {
          return 'a string';
        }
        validate(y) {
          return typeof y == 'string';
        }
      },
      Yi = As,
      Xc = Rc,
      Gc = Qn,
      Yc = rd,
      md = class {
        constructor(y, C) {
          let {
            logger: v = console,
            loggerPrintWidth: S = 80,
            descriptor: k = Yi,
            unknown: B = Xc,
            invalid: O = Gc,
            deprecated: H = Yc,
            missing: K = () => !1,
            required: Z = () => !1,
            preprocess: ne = (ee) => ee,
            postprocess: be = () => Es,
          } = C || {};
          (this._utils = {
            descriptor: k,
            logger: v || { warn: () => {} },
            loggerPrintWidth: S,
            schemas: $c(y, 'name'),
            normalizeDefaultResult: ql,
            normalizeExpectedResult: zc,
            normalizeDeprecatedResult: Wc,
            normalizeForwardResult: Aa,
            normalizeRedirectResult: qc,
            normalizeValidateResult: Hc,
          }),
            (this._unknownHandler = B),
            (this._invalidHandler = pd(O)),
            (this._deprecatedHandler = H),
            (this._identifyMissing = (ee, Ce) => !(ee in Ce) || K(ee, Ce)),
            (this._identifyRequired = Z),
            (this._preprocess = ne),
            (this._postprocess = be),
            this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = cd();
        }
        normalize(y) {
          let C = {},
            v = [this._preprocess(y, this._utils)],
            S = () => {
              for (; v.length !== 0; ) {
                let k = v.shift(),
                  B = this._applyNormalization(k, C);
                v.push(...B);
              }
            };
          S();
          for (let k of Object.keys(this._utils.schemas)) {
            let B = this._utils.schemas[k];
            if (!(k in C)) {
              let O = ql(B.default(this._utils));
              'value' in O && v.push({ [k]: O.value });
            }
          }
          S();
          for (let k of Object.keys(this._utils.schemas)) {
            if (!(k in C)) continue;
            let B = this._utils.schemas[k],
              O = C[k],
              H = B.postprocess(O, this._utils);
            H !== Es && (this._applyValidation(H, k, B), (C[k] = H));
          }
          return this._applyPostprocess(C), this._applyRequiredCheck(C), C;
        }
        _applyNormalization(y, C) {
          let v = [],
            { knownKeys: S, unknownKeys: k } = this._partitionOptionKeys(y);
          for (let B of S) {
            let O = this._utils.schemas[B],
              H = O.preprocess(y[B], this._utils);
            this._applyValidation(H, B, O);
            let K = ({ from: be, to: ee }) => {
                v.push(typeof ee == 'string' ? { [ee]: be } : { [ee.key]: ee.value });
              },
              Z = ({ value: be, redirectTo: ee }) => {
                let Ce = Wc(O.deprecated(be, this._utils), H, !0);
                if (Ce !== !1)
                  if (Ce === !0)
                    this._hasDeprecationWarned(B) ||
                      this._utils.logger.warn(this._deprecatedHandler(B, ee, this._utils));
                  else
                    for (let { value: le } of Ce) {
                      let Oe = { key: B, value: le };
                      if (!this._hasDeprecationWarned(Oe)) {
                        let Xe = typeof ee == 'string' ? { key: ee, value: le } : ee;
                        this._utils.logger.warn(this._deprecatedHandler(Oe, Xe, this._utils));
                      }
                    }
              };
            Aa(O.forward(H, this._utils), H).forEach(K);
            let ne = qc(O.redirect(H, this._utils), H);
            if ((ne.redirect.forEach(K), 'remain' in ne)) {
              let be = ne.remain;
              (C[B] = B in C ? O.overlap(C[B], be, this._utils) : be), Z({ value: be });
            }
            for (let { from: be, to: ee } of ne.redirect) Z({ value: be, redirectTo: ee });
          }
          for (let B of k) {
            let O = y[B];
            this._applyUnknownHandler(B, O, C, (H, K) => {
              v.push({ [H]: K });
            });
          }
          return v;
        }
        _applyRequiredCheck(y) {
          for (let C of Object.keys(this._utils.schemas))
            if (this._identifyMissing(C, y) && this._identifyRequired(C))
              throw this._invalidHandler(C, vo, this._utils);
        }
        _partitionOptionKeys(y) {
          let [C, v] = hd(
            Object.keys(y).filter((S) => !this._identifyMissing(S, y)),
            (S) => S in this._utils.schemas,
          );
          return { knownKeys: C, unknownKeys: v };
        }
        _applyValidation(y, C, v) {
          let S = Hc(v.validate(y, this._utils), y);
          if (S !== !0) throw this._invalidHandler(C, S.value, this._utils);
        }
        _applyUnknownHandler(y, C, v, S) {
          let k = this._unknownHandler(y, C, this._utils);
          if (k)
            for (let B of Object.keys(k)) {
              if (this._identifyMissing(B, k)) continue;
              let O = k[B];
              B in this._utils.schemas ? S(B, O) : (v[B] = O);
            }
        }
        _applyPostprocess(y) {
          let C = this._postprocess(y, this._utils);
          if (C !== Es) {
            if (C.delete) for (let v of C.delete) delete y[v];
            if (C.override) {
              let { knownKeys: v, unknownKeys: S } = this._partitionOptionKeys(C.override);
              for (let k of v) {
                let B = C.override[k];
                this._applyValidation(B, k, this._utils.schemas[k]), (y[k] = B);
              }
              for (let k of S) {
                let B = C.override[k];
                this._applyUnknownHandler(k, B, y, (O, H) => {
                  let K = this._utils.schemas[O];
                  this._applyValidation(H, O, K), (y[O] = H);
                });
              }
            }
          }
        }
      },
      Ea;
    function gd(y, C, { logger: v = !1, isCLI: S = !1, passThrough: k = !1, FlagSchema: B, descriptor: O } = {}) {
      if (S) {
        if (!B) throw new Error("'FlagSchema' option is required.");
        if (!O) throw new Error("'descriptor' option is required.");
      } else O = As;
      let H = k
          ? Array.isArray(k)
            ? (ee, Ce) => (k.includes(ee) ? { [ee]: Ce } : void 0)
            : (ee, Ce) => ({ [ee]: Ce })
          : (ee, Ce, le) => {
              let { _: Oe, ...Xe } = le.schemas;
              return Rc(ee, Ce, { ...le, schemas: Xe });
            },
        K = Kl(C, { isCLI: S, FlagSchema: B }),
        Z = new md(K, { logger: v, unknown: H, descriptor: O }),
        ne = v !== !1;
      ne && Ea && (Z._hasDeprecationWarned = Ea);
      let be = Z.normalize(y);
      return ne && (Ea = Z._hasDeprecationWarned), be;
    }
    function Kl(y, { isCLI: C, FlagSchema: v }) {
      let S = [];
      C && S.push(od.create({ name: '_' }));
      for (let k of y)
        S.push(yd(k, { isCLI: C, optionInfos: y, FlagSchema: v })),
          k.alias && C && S.push(vs.create({ name: k.alias, sourceName: k.name }));
      return S;
    }
    function yd(y, { isCLI: C, optionInfos: v, FlagSchema: S }) {
      let { name: k } = y,
        B = { name: k },
        O,
        H = {};
      switch (y.type) {
        case 'int':
          (O = dd), C && (B.preprocess = Number);
          break;
        case 'string':
          O = sr;
          break;
        case 'choice':
          (O = Jc),
            (B.choices = y.choices.map((K) =>
              K != null && K.redirect ? { ...K, redirect: { to: { key: y.name, value: K.redirect } } } : K,
            ));
          break;
        case 'boolean':
          O = ld;
          break;
        case 'flag':
          (O = S),
            (B.flags = v.flatMap((K) =>
              [K.alias, K.description && K.name, K.oppositeDescription && `no-${K.name}`].filter(Boolean),
            ));
          break;
        case 'path':
          O = sr;
          break;
        default:
          throw new Error(`Unexpected type ${y.type}`);
      }
      if (
        (y.exception
          ? (B.validate = (K, Z, ne) => y.exception(K) || Z.validate(K, ne))
          : (B.validate = (K, Z, ne) => K === void 0 || Z.validate(K, ne)),
        y.redirect && (H.redirect = (K) => (K ? { to: { key: y.redirect.option, value: y.redirect.value } } : void 0)),
        y.deprecated && (H.deprecated = !0),
        C && !y.array)
      ) {
        let K = B.preprocess || ((Z) => Z);
        B.preprocess = (Z, ne, be) => ne.preprocess(K(Array.isArray(Z) ? lr(!1, Z, -1) : Z), be);
      }
      return y.array
        ? ad.create({
            ...(C ? { preprocess: (K) => (Array.isArray(K) ? K : [K]) } : {}),
            ...H,
            valueSchema: O.create(B),
          })
        : O.create({ ...B, ...H });
    }
    var Dd = gd;
    function va(y, C) {
      if (!C) throw new Error('parserName is required.');
      for (let S = y.length - 1; S >= 0; S--) {
        let k = y[S];
        if (k.parsers && Object.prototype.hasOwnProperty.call(k.parsers, C)) return k;
      }
      let v = `Couldn't resolve parser "${C}".`;
      throw ((v += ' Plugins must be explicitly added to the standalone bundle.'), new zl(v));
    }
    function xd(y, C) {
      if (!C) throw new Error('astFormat is required.');
      for (let S = y.length - 1; S >= 0; S--) {
        let k = y[S];
        if (k.printers && Object.prototype.hasOwnProperty.call(k.printers, C)) return k;
      }
      let v = `Couldn't find plugin for AST format "${C}".`;
      throw ((v += ' Plugins must be explicitly added to the standalone bundle.'), new zl(v));
    }
    function Qc({ plugins: y, parser: C }) {
      let v = va(y, C);
      return Fa(v, C);
    }
    function Fa(y, C) {
      let v = y.parsers[C];
      return typeof v == 'function' ? v() : v;
    }
    function Cd(y, C) {
      let v = y.printers[C];
      return typeof v == 'function' ? v() : v;
    }
    var Zc = { astFormat: 'estree', printer: {}, originalText: void 0, locStart: null, locEnd: null };
    async function eh(y, C = {}) {
      var v;
      let S = { ...y };
      if (!S.parser)
        if (S.filepath) {
          if (((S.parser = bs(S, { physicalFile: S.filepath })), !S.parser))
            throw new Pc(`No parser could be inferred for file "${S.filepath}".`);
        } else throw new Pc("No parser and no file path given, couldn't infer a parser.");
      let k = Bc({ plugins: y.plugins, showDeprecated: !0 }).options,
        B = {
          ...Zc,
          ...Object.fromEntries(k.filter((ee) => ee.default !== void 0).map((ee) => [ee.name, ee.default])),
        },
        O = va(S.plugins, S.parser),
        H = await Fa(O, S.parser);
      (S.astFormat = H.astFormat), (S.locEnd = H.locEnd), (S.locStart = H.locStart);
      let K = (v = O.printers) != null && v[H.astFormat] ? O : xd(S.plugins, H.astFormat),
        Z = await Cd(K, H.astFormat);
      S.printer = Z;
      let ne = K.defaultOptions
          ? Object.fromEntries(Object.entries(K.defaultOptions).filter(([, ee]) => ee !== void 0))
          : {},
        be = { ...B, ...ne };
      for (let [ee, Ce] of Object.entries(be)) (S[ee] === null || S[ee] === void 0) && (S[ee] = Ce);
      return S.parser === 'json' && (S.trailingComma = 'none'), Dd(S, k, { passThrough: Object.keys(Zc), ...C });
    }
    var Fs = eh,
      th = new Set(['tokens', 'comments', 'parent', 'enclosingNode', 'precedingNode', 'followingNode']),
      bd = (y) => Object.keys(y).filter((C) => !th.has(C));
    function Ad(y) {
      return y ? (C) => y(C, th) : bd;
    }
    var Sa = Ad;
    function Fo(y, C) {
      let {
        printer: { massageAstNode: v, getVisitorKeys: S },
      } = C;
      if (!v) return y;
      let k = Sa(S),
        B = v.ignoredProperties ?? new Set();
      return O(y);
      function O(H, K) {
        if (!(H !== null && typeof H == 'object')) return H;
        if (Array.isArray(H)) return H.map((ee) => O(ee, K)).filter(Boolean);
        let Z = {},
          ne = new Set(k(H));
        for (let ee in H)
          !Object.prototype.hasOwnProperty.call(H, ee) ||
            B.has(ee) ||
            (ne.has(ee) ? (Z[ee] = O(H[ee], H)) : (Z[ee] = H[ee]));
        let be = v(H, Z, K);
        if (be !== null) return be ?? Z;
      }
    }
    var rh = Fo,
      Ed = g(Y(), 1);
    async function u(y, C) {
      let v = await Qc(C),
        S = v.preprocess ? v.preprocess(y, C) : y;
      C.originalText = S;
      let k;
      try {
        k = await v.parse(S, C, C);
      } catch (B) {
        a(B, y);
      }
      return { text: S, ast: k };
    }
    function a(y, C) {
      let { loc: v } = y;
      if (v) {
        let S = (0, Ed.codeFrameColumns)(C, v, { highlightCode: !0 });
        throw (
          ((y.message +=
            `
` + S),
          (y.codeFrame = S),
          y)
        );
      }
      throw y;
    }
    var h = u,
      d,
      D,
      A,
      P,
      N = class {
        constructor(y) {
          F(this, d), F(this, A), (this.stack = [y]);
        }
        get key() {
          let { stack: y, siblings: C } = this;
          return lr(!1, y, C === null ? -2 : -4) ?? null;
        }
        get index() {
          return this.siblings === null ? null : lr(!1, this.stack, -2);
        }
        get node() {
          return lr(!1, this.stack, -1);
        }
        get parent() {
          return this.getNode(1);
        }
        get grandparent() {
          return this.getNode(2);
        }
        get isInArray() {
          return this.siblings !== null;
        }
        get siblings() {
          let { stack: y } = this,
            C = lr(!1, y, -3);
          return Array.isArray(C) ? C : null;
        }
        get next() {
          let { siblings: y } = this;
          return y === null ? null : y[this.index + 1];
        }
        get previous() {
          let { siblings: y } = this;
          return y === null ? null : y[this.index - 1];
        }
        get isFirst() {
          return this.index === 0;
        }
        get isLast() {
          let { siblings: y, index: C } = this;
          return y !== null && C === y.length - 1;
        }
        get isRoot() {
          return this.stack.length === 1;
        }
        get root() {
          return this.stack[0];
        }
        get ancestors() {
          return [...E(this, A, P).call(this)];
        }
        getName() {
          let { stack: y } = this,
            { length: C } = y;
          return C > 1 ? lr(!1, y, -2) : null;
        }
        getValue() {
          return lr(!1, this.stack, -1);
        }
        getNode(y = 0) {
          let C = E(this, d, D).call(this, y);
          return C === -1 ? null : this.stack[C];
        }
        getParentNode(y = 0) {
          return this.getNode(y + 1);
        }
        call(y, ...C) {
          let { stack: v } = this,
            { length: S } = v,
            k = lr(!1, v, -1);
          for (let B of C) (k = k[B]), v.push(B, k);
          try {
            return y(this);
          } finally {
            v.length = S;
          }
        }
        callParent(y, C = 0) {
          let v = E(this, d, D).call(this, C + 1),
            S = this.stack.splice(v + 1);
          try {
            return y(this);
          } finally {
            this.stack.push(...S);
          }
        }
        each(y, ...C) {
          let { stack: v } = this,
            { length: S } = v,
            k = lr(!1, v, -1);
          for (let B of C) (k = k[B]), v.push(B, k);
          try {
            for (let B = 0; B < k.length; ++B) v.push(B, k[B]), y(this, B, k), (v.length -= 2);
          } finally {
            v.length = S;
          }
        }
        map(y, ...C) {
          let v = [];
          return (
            this.each(
              (S, k, B) => {
                v[k] = y(S, k, B);
              },
              ...C,
            ),
            v
          );
        }
        match(...y) {
          let C = this.stack.length - 1,
            v = null,
            S = this.stack[C--];
          for (let k of y) {
            if (S === void 0) return !1;
            let B = null;
            if ((typeof v == 'number' && ((B = v), (v = this.stack[C--]), (S = this.stack[C--])), k && !k(S, v, B)))
              return !1;
            (v = this.stack[C--]), (S = this.stack[C--]);
          }
          return !0;
        }
        findAncestor(y) {
          for (let C of E(this, A, P).call(this)) if (y(C)) return C;
        }
        hasAncestor(y) {
          for (let C of E(this, A, P).call(this)) if (y(C)) return !0;
          return !1;
        }
      };
    (d = new WeakSet()),
      (D = function (y) {
        let { stack: C } = this;
        for (let v = C.length - 1; v >= 0; v -= 2) if (!Array.isArray(C[v]) && --y < 0) return v;
        return -1;
      }),
      (A = new WeakSet()),
      (P = function* () {
        let { stack: y } = this;
        for (let C = y.length - 3; C >= 0; C -= 2) {
          let v = y[C];
          Array.isArray(v) || (yield v);
        }
      });
    var R = N,
      _ = new Proxy(() => {}, { get: () => _ }),
      ue = _;
    function ve(y) {
      return (C, v, S) => {
        let k = !!(S != null && S.backwards);
        if (v === !1) return !1;
        let { length: B } = C,
          O = v;
        for (; O >= 0 && O < B; ) {
          let H = C.charAt(O);
          if (y instanceof RegExp) {
            if (!y.test(H)) return O;
          } else if (!y.includes(H)) return O;
          k ? O-- : O++;
        }
        return O === -1 || O === B ? O : !1;
      };
    }
    var Ie = ve(/\s/),
      _e = ve(' 	'),
      Bt = ve(',; 	'),
      wt = ve(/[^\n\r]/);
    function ur(y, C, v) {
      let S = !!(v != null && v.backwards);
      if (C === !1) return !1;
      let k = y.charAt(C);
      if (S) {
        if (
          y.charAt(C - 1) === '\r' &&
          k ===
            `
`
        )
          return C - 2;
        if (
          k ===
            `
` ||
          k === '\r' ||
          k === '\u2028' ||
          k === '\u2029'
        )
          return C - 1;
      } else {
        if (
          k === '\r' &&
          y.charAt(C + 1) ===
            `
`
        )
          return C + 2;
        if (
          k ===
            `
` ||
          k === '\r' ||
          k === '\u2028' ||
          k === '\u2029'
        )
          return C + 1;
      }
      return C;
    }
    var Qt = ur;
    function Zr(y, C, v = {}) {
      let S = _e(y, v.backwards ? C - 1 : C, v),
        k = Qt(y, S, v);
      return S !== k;
    }
    var On = Zr;
    function Jl(y) {
      return Array.isArray(y) && y.length > 0;
    }
    var lw = Jl;
    function uw(y) {
      return y !== null && typeof y == 'object';
    }
    var cw = uw;
    function* Qy(y, C) {
      let { getVisitorKeys: v, filter: S = () => !0 } = C,
        k = (B) => cw(B) && S(B);
      for (let B of v(y)) {
        let O = y[B];
        if (Array.isArray(O)) for (let H of O) k(H) && (yield H);
        else k(O) && (yield O);
      }
    }
    function* hw(y, C) {
      let v = [y];
      for (let S = 0; S < v.length; S++) {
        let k = v[S];
        for (let B of Qy(k, C)) yield B, v.push(B);
      }
    }
    function pw(y) {
      let C = y.type || y.kind || '(unknown type)',
        v = String(
          y.name ||
            (y.id && (typeof y.id == 'object' ? y.id.name : y.id)) ||
            (y.key && (typeof y.key == 'object' ? y.key.name : y.key)) ||
            (y.value && (typeof y.value == 'object' ? '' : String(y.value))) ||
            y.operator ||
            '',
        );
      return v.length > 20 && (v = v.slice(0, 19) + '…'), C + (v ? ' ' + v : '');
    }
    function vd(y, C) {
      (y.comments ?? (y.comments = [])).push(C), (C.printed = !1), (C.nodeDescription = pw(y));
    }
    function wa(y, C) {
      (C.leading = !0), (C.trailing = !1), vd(y, C);
    }
    function So(y, C, v) {
      (C.leading = !1), (C.trailing = !1), v && (C.marker = v), vd(y, C);
    }
    function Ta(y, C) {
      (C.leading = !1), (C.trailing = !0), vd(y, C);
    }
    var Fd = new WeakMap();
    function Sd(y, C) {
      if (Fd.has(y)) return Fd.get(y);
      let {
        printer: { getCommentChildNodes: v, canAttachComment: S, getVisitorKeys: k },
        locStart: B,
        locEnd: O,
      } = C;
      if (!S) return [];
      let H = ((v == null ? void 0 : v(y, C)) ?? [...Qy(y, { getVisitorKeys: Sa(k) })]).flatMap((K) =>
        S(K) ? [K] : Sd(K, C),
      );
      return H.sort((K, Z) => B(K) - B(Z) || O(K) - O(Z)), Fd.set(y, H), H;
    }
    function Zy(y, C, v, S) {
      let { locStart: k, locEnd: B } = v,
        O = k(C),
        H = B(C),
        K = Sd(y, v),
        Z,
        ne,
        be = 0,
        ee = K.length;
      for (; be < ee; ) {
        let Ce = (be + ee) >> 1,
          le = K[Ce],
          Oe = k(le),
          Xe = B(le);
        if (Oe <= O && H <= Xe) return Zy(le, C, v, le);
        if (Xe <= O) {
          (Z = le), (be = Ce + 1);
          continue;
        }
        if (H <= Oe) {
          (ne = le), (ee = Ce);
          continue;
        }
        throw new Error('Comment location overlaps with node location');
      }
      if ((S == null ? void 0 : S.type) === 'TemplateLiteral') {
        let { quasis: Ce } = S,
          le = Td(Ce, C, v);
        Z && Td(Ce, Z, v) !== le && (Z = null), ne && Td(Ce, ne, v) !== le && (ne = null);
      }
      return { enclosingNode: S, precedingNode: Z, followingNode: ne };
    }
    var wd = () => !1;
    function fw(y, C) {
      let { comments: v } = y;
      if ((delete y.comments, !lw(v) || !C.printer.canAttachComment)) return;
      let S = [],
        {
          locStart: k,
          locEnd: B,
          printer: { experimentalFeatures: { avoidAstMutation: O = !1 } = {}, handleComments: H = {} },
          originalText: K,
        } = C,
        { ownLine: Z = wd, endOfLine: ne = wd, remaining: be = wd } = H,
        ee = v.map((Ce, le) => ({
          ...Zy(y, Ce, C),
          comment: Ce,
          text: K,
          options: C,
          ast: y,
          isLastComment: v.length - 1 === le,
        }));
      for (let [Ce, le] of ee.entries()) {
        let {
          comment: Oe,
          precedingNode: Xe,
          enclosingNode: ft,
          followingNode: ct,
          text: Dt,
          options: Ft,
          ast: Rt,
          isLastComment: Ur,
        } = le;
        if (
          Ft.parser === 'json' ||
          Ft.parser === 'json5' ||
          Ft.parser === '__js_expression' ||
          Ft.parser === '__ts_expression' ||
          Ft.parser === '__vue_expression' ||
          Ft.parser === '__vue_ts_expression'
        ) {
          if (k(Oe) - k(Rt) <= 0) {
            wa(Rt, Oe);
            continue;
          }
          if (B(Oe) - B(Rt) >= 0) {
            Ta(Rt, Oe);
            continue;
          }
        }
        let Br;
        if (
          (O
            ? (Br = [le])
            : ((Oe.enclosingNode = ft), (Oe.precedingNode = Xe), (Oe.followingNode = ct), (Br = [Oe, Dt, Ft, Rt, Ur])),
          dw(Dt, Ft, ee, Ce))
        )
          (Oe.placement = 'ownLine'), Z(...Br) || (ct ? wa(ct, Oe) : Xe ? Ta(Xe, Oe) : So(ft || Rt, Oe));
        else if (mw(Dt, Ft, ee, Ce))
          (Oe.placement = 'endOfLine'), ne(...Br) || (Xe ? Ta(Xe, Oe) : ct ? wa(ct, Oe) : So(ft || Rt, Oe));
        else if (((Oe.placement = 'remaining'), !be(...Br)))
          if (Xe && ct) {
            let en = S.length;
            en > 0 && S[en - 1].followingNode !== ct && tD(S, Ft), S.push(le);
          } else Xe ? Ta(Xe, Oe) : ct ? wa(ct, Oe) : So(ft || Rt, Oe);
      }
      if ((tD(S, C), !O)) for (let Ce of v) delete Ce.precedingNode, delete Ce.enclosingNode, delete Ce.followingNode;
    }
    var eD = (y) => !/[\S\n\u2028\u2029]/.test(y);
    function dw(y, C, v, S) {
      let { comment: k, precedingNode: B } = v[S],
        { locStart: O, locEnd: H } = C,
        K = O(k);
      if (B)
        for (let Z = S - 1; Z >= 0; Z--) {
          let { comment: ne, precedingNode: be } = v[Z];
          if (be !== B || !eD(y.slice(H(ne), K))) break;
          K = O(ne);
        }
      return On(y, K, { backwards: !0 });
    }
    function mw(y, C, v, S) {
      let { comment: k, followingNode: B } = v[S],
        { locStart: O, locEnd: H } = C,
        K = H(k);
      if (B)
        for (let Z = S + 1; Z < v.length; Z++) {
          let { comment: ne, followingNode: be } = v[Z];
          if (be !== B || !eD(y.slice(K, O(ne)))) break;
          K = H(ne);
        }
      return On(y, K);
    }
    function tD(y, C) {
      var v, S;
      let k = y.length;
      if (k === 0) return;
      let { precedingNode: B, followingNode: O } = y[0],
        H = C.locStart(O),
        K;
      for (K = k; K > 0; --K) {
        let { comment: Z, precedingNode: ne, followingNode: be } = y[K - 1];
        ue.strictEqual(ne, B), ue.strictEqual(be, O);
        let ee = C.originalText.slice(C.locEnd(Z), H);
        if (((S = (v = C.printer).isGap) == null ? void 0 : S.call(v, ee, C)) ?? /^[\s(]*$/.test(ee)) H = C.locStart(Z);
        else break;
      }
      for (let [Z, { comment: ne }] of y.entries()) Z < K ? Ta(B, ne) : wa(O, ne);
      for (let Z of [B, O])
        Z.comments && Z.comments.length > 1 && Z.comments.sort((ne, be) => C.locStart(ne) - C.locStart(be));
      y.length = 0;
    }
    function Td(y, C, v) {
      let S = v.locStart(C) - 1;
      for (let k = 1; k < y.length; ++k) if (S < v.locStart(y[k])) return k - 1;
      return 0;
    }
    function gw(y, C) {
      let v = C - 1;
      (v = _e(y, v, { backwards: !0 })), (v = Qt(y, v, { backwards: !0 })), (v = _e(y, v, { backwards: !0 }));
      let S = Qt(y, v, { backwards: !0 });
      return v !== S;
    }
    var kd = gw;
    function rD(y, C) {
      let v = y.node;
      return (v.printed = !0), C.printer.printComment(y, C);
    }
    function yw(y, C) {
      var v;
      let S = y.node,
        k = [rD(y, C)],
        { printer: B, originalText: O, locStart: H, locEnd: K } = C;
      if ((v = B.isBlockComment) != null && v.call(B, S)) {
        let ne = On(O, K(S)) ? (On(O, H(S), { backwards: !0 }) ? pn : Pr) : ' ';
        k.push(ne);
      } else k.push(pn);
      let Z = Qt(O, _e(O, K(S)));
      return Z !== !1 && On(O, Z) && k.push(pn), k;
    }
    function Dw(y, C, v) {
      var S;
      let k = y.node,
        B = rD(y, C),
        { printer: O, originalText: H, locStart: K } = C,
        Z = (S = O.isBlockComment) == null ? void 0 : S.call(O, k);
      if ((v != null && v.hasLineSuffix && !(v != null && v.isBlock)) || On(H, K(k), { backwards: !0 })) {
        let ne = kd(H, K(k));
        return { doc: gr([pn, ne ? pn : '', B]), isBlock: Z, hasLineSuffix: !0 };
      }
      return !Z || (v != null && v.hasLineSuffix)
        ? { doc: [gr([' ', B]), qi], isBlock: Z, hasLineSuffix: !0 }
        : { doc: [' ', B], isBlock: Z, hasLineSuffix: !1 };
    }
    function xw(y, C) {
      let v = y.node;
      if (!v) return {};
      let S = C[Symbol.for('printedComments')];
      if ((v.comments || []).filter((H) => !S.has(H)).length === 0) return { leading: '', trailing: '' };
      let k = [],
        B = [],
        O;
      return (
        y.each(() => {
          let H = y.node;
          if (S != null && S.has(H)) return;
          let { leading: K, trailing: Z } = H;
          K ? k.push(yw(y, C)) : Z && ((O = Dw(y, C, O)), B.push(O.doc));
        }, 'comments'),
        { leading: k, trailing: B }
      );
    }
    function Cw(y, C, v) {
      let { leading: S, trailing: k } = xw(y, v);
      return !S && !k ? C : jl(C, (B) => [S, B, k]);
    }
    function bw(y) {
      let { [Symbol.for('comments')]: C, [Symbol.for('printedComments')]: v } = y;
      for (let S of C) {
        if (!S.printed && !v.has(S))
          throw new Error('Comment "' + S.value.trim() + '" was not printed. Please report this error!');
        delete S.printed;
      }
    }
    async function Aw(y, C, v, S, k) {
      let {
        embeddedLanguageFormatting: B,
        printer: { embed: O, hasPrettierIgnore: H = () => !1, getVisitorKeys: K },
      } = v;
      if (!O || B !== 'auto') return;
      if (O.length > 2)
        throw new Error(
          'printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed',
        );
      let Z = Sa(O.getVisitorKeys ?? K),
        ne = [];
      Ce();
      let be = y.stack;
      for (let { print: le, node: Oe, pathStack: Xe } of ne)
        try {
          y.stack = Xe;
          let ft = await le(ee, C, y, v);
          ft && k.set(Oe, ft);
        } catch (ft) {
          if (globalThis.PRETTIER_DEBUG) throw ft;
        }
      y.stack = be;
      function ee(le, Oe) {
        return Ew(le, Oe, v, S);
      }
      function Ce() {
        let { node: le } = y;
        if (le === null || typeof le != 'object' || H(y)) return;
        for (let Xe of Z(le)) Array.isArray(le[Xe]) ? y.each(Ce, Xe) : y.call(Ce, Xe);
        let Oe = O(y, v);
        if (Oe) {
          if (typeof Oe == 'function') {
            ne.push({ print: Oe, node: le, pathStack: [...y.stack] });
            return;
          }
          k.set(le, Oe);
        }
      }
    }
    async function Ew(y, C, v, S) {
      let k = await Fs({ ...v, ...C, parentParser: v.parser, originalText: y }, { passThrough: !0 }),
        { ast: B } = await h(y, k),
        O = await S(B, k);
      return Rl(O);
    }
    function vw(y, C) {
      let {
          originalText: v,
          [Symbol.for('comments')]: S,
          locStart: k,
          locEnd: B,
          [Symbol.for('printedComments')]: O,
        } = C,
        { node: H } = y,
        K = k(H),
        Z = B(H);
      for (let ne of S) k(ne) >= K && B(ne) <= Z && O.add(ne);
      return v.slice(K, Z);
    }
    var Fw = vw;
    async function nh(y, C) {
      ({ ast: y } = await iD(y, C));
      let v = new Map(),
        S = new R(y),
        k = new Map();
      await Aw(S, O, C, nh, k);
      let B = await nD(S, C, O, void 0, k);
      return bw(C), B;
      function O(K, Z) {
        return K === void 0 || K === S ? H(Z) : Array.isArray(K) ? S.call(() => H(Z), ...K) : S.call(() => H(Z), K);
      }
      function H(K) {
        let Z = S.node;
        if (Z == null) return '';
        let ne = Z && typeof Z == 'object' && K === void 0;
        if (ne && v.has(Z)) return v.get(Z);
        let be = nD(S, C, O, K, k);
        return ne && v.set(Z, be), be;
      }
    }
    function nD(y, C, v, S, k) {
      var B;
      let { node: O } = y,
        { printer: H } = C,
        K;
      return (
        (B = H.hasPrettierIgnore) != null && B.call(H, y)
          ? (K = Fw(y, C))
          : k.has(O)
          ? (K = k.get(O))
          : (K = H.print(y, C, v, S)),
        O === C.cursorNode && (K = jl(K, (Z) => [Il, Z, Il])),
        H.printComment && (!H.willPrintOwnComments || !H.willPrintOwnComments(y, C)) && (K = Cw(y, K, C)),
        K
      );
    }
    async function iD(y, C) {
      let v = y.comments ?? [];
      (C[Symbol.for('comments')] = v),
        (C[Symbol.for('tokens')] = y.tokens ?? []),
        (C[Symbol.for('printedComments')] = new Set()),
        fw(y, C);
      let {
        printer: { preprocess: S },
      } = C;
      return (y = S ? await S(y, C) : y), { ast: y, comments: v };
    }
    var Sw = ({ parser: y }) => y === 'json' || y === 'json5' || y === 'json-stringify';
    function ww(y, C) {
      let v = [y.node, ...y.parentNodes],
        S = new Set([C.node, ...C.parentNodes]);
      return v.find((k) => oD.has(k.type) && S.has(k));
    }
    function sD(y) {
      let C = y.length - 1;
      for (;;) {
        let v = y[C];
        if ((v == null ? void 0 : v.type) === 'Program' || (v == null ? void 0 : v.type) === 'File') C--;
        else break;
      }
      return y.slice(0, C + 1);
    }
    function Tw(y, C, { locStart: v, locEnd: S }) {
      let k = y.node,
        B = C.node;
      if (k === B) return { startNode: k, endNode: B };
      let O = v(y.node);
      for (let K of sD(C.parentNodes))
        if (v(K) >= O) B = K;
        else break;
      let H = S(C.node);
      for (let K of sD(y.parentNodes)) {
        if (S(K) <= H) k = K;
        else break;
        if (k === B) break;
      }
      return { startNode: k, endNode: B };
    }
    function Pd(y, C, v, S, k = [], B) {
      let { locStart: O, locEnd: H } = v,
        K = O(y),
        Z = H(y);
      if (!(C > Z || C < K || (B === 'rangeEnd' && C === K) || (B === 'rangeStart' && C === Z))) {
        for (let ne of Sd(y, v)) {
          let be = Pd(ne, C, v, S, [y, ...k], B);
          if (be) return be;
        }
        if (!S || S(y, k[0])) return { node: y, parentNodes: k };
      }
    }
    function kw(y, C) {
      return (
        C !== 'DeclareExportDeclaration' &&
        y !== 'TypeParameterDeclaration' &&
        (y === 'Directive' ||
          y === 'TypeAlias' ||
          y === 'TSExportAssignment' ||
          y.startsWith('Declare') ||
          y.startsWith('TSDeclare') ||
          y.endsWith('Statement') ||
          y.endsWith('Declaration'))
      );
    }
    var oD = new Set([
        'JsonRoot',
        'ObjectExpression',
        'ArrayExpression',
        'StringLiteral',
        'NumericLiteral',
        'BooleanLiteral',
        'NullLiteral',
        'UnaryExpression',
        'TemplateLiteral',
      ]),
      Pw = new Set([
        'OperationDefinition',
        'FragmentDefinition',
        'VariableDefinition',
        'TypeExtensionDefinition',
        'ObjectTypeDefinition',
        'FieldDefinition',
        'DirectiveDefinition',
        'EnumTypeDefinition',
        'EnumValueDefinition',
        'InputValueDefinition',
        'InputObjectTypeDefinition',
        'SchemaDefinition',
        'OperationTypeDefinition',
        'InterfaceTypeDefinition',
        'UnionTypeDefinition',
        'ScalarTypeDefinition',
      ]);
    function aD(y, C, v) {
      if (!C) return !1;
      switch (y.parser) {
        case 'flow':
        case 'babel':
        case 'babel-flow':
        case 'babel-ts':
        case 'typescript':
        case 'acorn':
        case 'espree':
        case 'meriyah':
        case '__babel_estree':
          return kw(C.type, v == null ? void 0 : v.type);
        case 'json':
        case 'json5':
        case 'json-stringify':
          return oD.has(C.type);
        case 'graphql':
          return Pw.has(C.kind);
        case 'vue':
          return C.tag !== 'root';
      }
      return !1;
    }
    function Bw(y, C, v) {
      let { rangeStart: S, rangeEnd: k, locStart: B, locEnd: O } = C;
      ue.ok(k > S);
      let H = y.slice(S, k).search(/\S/),
        K = H === -1;
      if (!K) for (S += H; k > S && !/\S/.test(y[k - 1]); --k);
      let Z = Pd(v, S, C, (Ce, le) => aD(C, Ce, le), [], 'rangeStart'),
        ne = K ? Z : Pd(v, k, C, (Ce) => aD(C, Ce), [], 'rangeEnd');
      if (!Z || !ne) return { rangeStart: 0, rangeEnd: 0 };
      let be, ee;
      if (Sw(C)) {
        let Ce = ww(Z, ne);
        (be = Ce), (ee = Ce);
      } else ({ startNode: be, endNode: ee } = Tw(Z, ne, C));
      return { rangeStart: Math.min(B(be), B(ee)), rangeEnd: Math.max(O(be), O(ee)) };
    }
    function Iw(y, C) {
      let { cursorOffset: v, locStart: S, locEnd: k } = C,
        B = Sa(C.printer.getVisitorKeys),
        O = (K) => S(K) <= v && k(K) >= v,
        H = y;
      for (let K of hw(y, { getVisitorKeys: B, filter: O })) H = K;
      return H;
    }
    var Nw = Iw,
      lD = '\uFEFF',
      uD = Symbol('cursor');
    async function cD(y, C, v = 0) {
      if (!y || y.trim().length === 0) return { formatted: '', cursorOffset: -1, comments: [] };
      let { ast: S, text: k } = await h(y, C);
      C.cursorOffset >= 0 && (C.cursorNode = Nw(S, C));
      let B = await nh(S, C);
      v > 0 && (B = bc([pn, B], v, C.tabWidth));
      let O = Cn(B, C);
      if (v > 0) {
        let K = O.formatted.trim();
        O.cursorNodeStart !== void 0 && (O.cursorNodeStart -= O.formatted.indexOf(K)),
          (O.formatted = K + Nl(C.endOfLine));
      }
      let H = C[Symbol.for('comments')];
      if (C.cursorOffset >= 0) {
        let K, Z, ne, be, ee;
        if (
          (C.cursorNode && O.cursorNodeText
            ? ((K = C.locStart(C.cursorNode)),
              (Z = k.slice(K, C.locEnd(C.cursorNode))),
              (ne = C.cursorOffset - K),
              (be = O.cursorNodeStart),
              (ee = O.cursorNodeText))
            : ((K = 0), (Z = k), (ne = C.cursorOffset), (be = 0), (ee = O.formatted)),
          Z === ee)
        )
          return { formatted: O.formatted, cursorOffset: be + ne, comments: H };
        let Ce = Z.split('');
        Ce.splice(ne, 0, uD);
        let le = ee.split(''),
          Oe = (0, xe.diffArrays)(Ce, le),
          Xe = be;
        for (let ft of Oe)
          if (ft.removed) {
            if (ft.value.includes(uD)) break;
          } else Xe += ft.count;
        return { formatted: O.formatted, cursorOffset: Xe, comments: H };
      }
      return { formatted: O.formatted, cursorOffset: -1, comments: H };
    }
    async function Mw(y, C) {
      let { ast: v, text: S } = await h(y, C),
        { rangeStart: k, rangeEnd: B } = Bw(S, C, v),
        O = S.slice(k, B),
        H = Math.min(
          k,
          S.lastIndexOf(
            `
`,
            k,
          ) + 1,
        ),
        K = S.slice(H, k).match(/^\s*/)[0],
        Z = xs(K, C.tabWidth),
        ne = await cD(
          O,
          {
            ...C,
            rangeStart: 0,
            rangeEnd: Number.POSITIVE_INFINITY,
            cursorOffset: C.cursorOffset > k && C.cursorOffset <= B ? C.cursorOffset - k : -1,
            endOfLine: 'lf',
          },
          Z,
        ),
        be = ne.formatted.trimEnd(),
        { cursorOffset: ee } = C;
      ee > B ? (ee += be.length - O.length) : ne.cursorOffset >= 0 && (ee = ne.cursorOffset + k);
      let Ce = S.slice(0, k) + be + S.slice(B);
      if (C.endOfLine !== 'lf') {
        let le = Nl(C.endOfLine);
        ee >= 0 &&
          le ===
            `\r
` &&
          (ee += Fc(
            Ce.slice(0, ee),
            `
`,
          )),
          (Ce = q(
            !1,
            Ce,
            `
`,
            le,
          ));
      }
      return { formatted: Ce, cursorOffset: ee, comments: ne.comments };
    }
    function Bd(y, C, v) {
      return typeof C != 'number' || Number.isNaN(C) || C < 0 || C > y.length ? v : C;
    }
    function hD(y, C) {
      let { cursorOffset: v, rangeStart: S, rangeEnd: k } = C;
      return (
        (v = Bd(y, v, -1)),
        (S = Bd(y, S, 0)),
        (k = Bd(y, k, y.length)),
        { ...C, cursorOffset: v, rangeStart: S, rangeEnd: k }
      );
    }
    function pD(y, C) {
      let { cursorOffset: v, rangeStart: S, rangeEnd: k, endOfLine: B } = hD(y, C),
        O = y.charAt(0) === lD;
      if ((O && ((y = y.slice(1)), v--, S--, k--), B === 'auto' && (B = vc(y)), y.includes('\r'))) {
        let H = (K) =>
          Fc(
            y.slice(0, Math.max(K, 0)),
            `\r
`,
          );
        (v -= H(v)), (S -= H(S)), (k -= H(k)), (y = Wf(y));
      }
      return {
        hasBOM: O,
        text: y,
        options: hD(y, { ...C, cursorOffset: v, rangeStart: S, rangeEnd: k, endOfLine: B }),
      };
    }
    async function fD(y, C) {
      let v = await Qc(C);
      return !v.hasPragma || v.hasPragma(y);
    }
    async function dD(y, C) {
      let { hasBOM: v, text: S, options: k } = pD(y, await Fs(C));
      if ((k.rangeStart >= k.rangeEnd && S !== '') || (k.requirePragma && !(await fD(S, k))))
        return { formatted: y, cursorOffset: C.cursorOffset, comments: [] };
      let B;
      return (
        k.rangeStart > 0 || k.rangeEnd < S.length
          ? (B = await Mw(S, k))
          : (!k.requirePragma &&
              k.insertPragma &&
              k.printer.insertPragma &&
              !(await fD(S, k)) &&
              (S = k.printer.insertPragma(S)),
            (B = await cD(S, k))),
        v && ((B.formatted = lD + B.formatted), B.cursorOffset >= 0 && B.cursorOffset++),
        B
      );
    }
    async function Ow(y, C, v) {
      let { text: S, options: k } = pD(y, await Fs(C)),
        B = await h(S, k);
      return v && (v.preprocessForPrint && (B.ast = await iD(B.ast, k)), v.massage && (B.ast = rh(B.ast, k))), B;
    }
    async function Lw(y, C) {
      C = await Fs(C);
      let v = await nh(y, C);
      return Cn(v, C);
    }
    async function _w(y, C) {
      let v = Qf(y),
        { formatted: S } = await dD(v, { ...C, parser: '__js_expression' });
      return S;
    }
    async function Rw(y, C) {
      C = await Fs(C);
      let { ast: v } = await h(y, C);
      return nh(v, C);
    }
    async function jw(y, C) {
      return Cn(y, await Fs(C));
    }
    var mD = {};
    f(mD, {
      addDanglingComment: () => So,
      addLeadingComment: () => wa,
      addTrailingComment: () => Ta,
      getAlignmentSize: () => xs,
      getIndentSize: () => Jw,
      getMaxContinuousCount: () => qw,
      getNextNonSpaceNonCommentCharacter: () => eT,
      getNextNonSpaceNonCommentCharacterIndex: () => iT,
      getStringWidth: () => Ll,
      hasNewline: () => On,
      hasNewlineInRange: () => Gw,
      hasSpaces: () => Qw,
      isNextLineEmpty: () => lT,
      isNextLineEmptyAfterIndex: () => Od,
      isPreviousLineEmpty: () => oT,
      makeString: () => rT,
      skip: () => ve,
      skipEverythingButNewLine: () => wt,
      skipInlineComment: () => Id,
      skipNewline: () => Qt,
      skipSpaces: () => _e,
      skipToLineEnd: () => Bt,
      skipTrailingComment: () => Nd,
      skipWhitespace: () => Ie,
    });
    function $w(y, C) {
      if (C === !1) return !1;
      if (y.charAt(C) === '/' && y.charAt(C + 1) === '*') {
        for (let v = C + 2; v < y.length; ++v) if (y.charAt(v) === '*' && y.charAt(v + 1) === '/') return v + 2;
      }
      return C;
    }
    var Id = $w;
    function Vw(y, C) {
      return C === !1 ? !1 : y.charAt(C) === '/' && y.charAt(C + 1) === '/' ? wt(y, C) : C;
    }
    var Nd = Vw;
    function zw(y, C) {
      let v = null,
        S = C;
      for (; S !== v; ) (v = S), (S = _e(y, S)), (S = Id(y, S)), (S = Nd(y, S)), (S = Qt(y, S));
      return S;
    }
    var Md = zw;
    function Hw(y, C) {
      let v = null,
        S = C;
      for (; S !== v; ) (v = S), (S = Bt(y, S)), (S = Id(y, S)), (S = _e(y, S));
      return (S = Nd(y, S)), (S = Qt(y, S)), S !== !1 && On(y, S);
    }
    var Od = Hw;
    function Ww(y) {
      if (typeof y != 'string') throw new TypeError('Expected a string');
      return y.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
    }
    function Uw(y, C) {
      let v = y.match(new RegExp(`(${Ww(C)})+`, 'g'));
      return v === null ? 0 : v.reduce((S, k) => Math.max(S, k.length / C.length), 0);
    }
    var qw = Uw;
    function Kw(y, C) {
      let v = y.lastIndexOf(`
`);
      return v === -1 ? 0 : xs(y.slice(v + 1).match(/^[\t ]*/)[0], C);
    }
    var Jw = Kw;
    function Xw(y, C, v) {
      for (let S = C; S < v; ++S)
        if (
          y.charAt(S) ===
          `
`
        )
          return !0;
      return !1;
    }
    var Gw = Xw;
    function Yw(y, C, v = {}) {
      return _e(y, v.backwards ? C - 1 : C, v) !== C;
    }
    var Qw = Yw;
    function Zw(y, C) {
      let v = Md(y, C);
      return v === !1 ? '' : y.charAt(v);
    }
    var eT = Zw;
    function tT(y, C, v) {
      let S = C === '"' ? "'" : '"',
        k = q(!1, y, /\\(.)|(["'])/gs, (B, O, H) =>
          O === S ? O : H === C ? '\\' + H : H || (v && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(O) ? O : '\\' + O),
        );
      return C + k + C;
    }
    var rT = tT;
    function nT(y, C, v) {
      return Md(y, v(C));
    }
    function iT(y, C) {
      return arguments.length === 2 || typeof C == 'number' ? Md(y, C) : nT(...arguments);
    }
    function sT(y, C, v) {
      return kd(y, v(C));
    }
    function oT(y, C) {
      return arguments.length === 2 || typeof C == 'number' ? kd(y, C) : sT(...arguments);
    }
    function aT(y, C, v) {
      return Od(y, v(C));
    }
    function lT(y, C) {
      return arguments.length === 2 || typeof C == 'number' ? Od(y, C) : aT(...arguments);
    }
    var gD = {};
    f(gD, { builders: () => uT, printer: () => cT, utils: () => hT });
    var uT = {
        join: Cc,
        line: Pr,
        softline: hn,
        hardline: pn,
        literalline: ga,
        group: Ge,
        conditionalGroup: lt,
        fill: Mt,
        lineSuffix: gr,
        lineSuffixBoundary: Xn,
        cursor: Il,
        breakParent: qi,
        ifBreak: Et,
        trim: Ki,
        indent: ke,
        indentIfBreak: Pt,
        align: De,
        addAlignmentToDoc: bc,
        markAsRoot: Ze,
        dedentToRoot: He,
        dedent: et,
        hardlineWithoutBreakParent: Ji,
        literallineWithoutBreakParent: Fr,
        label: Ac,
        concat: (y) => y,
      },
      cT = { printDocToString: Cn },
      hT = {
        willBreak: bo,
        traverseDoc: ye,
        findInDoc: _l,
        mapDoc: xo,
        removeLines: Ao,
        stripTrailingHardline: Rl,
        replaceEndOfLine: Gf,
        canBreak: xa,
      },
      pT = '3.0.2';
    function wo(y, C = 1) {
      return async (...v) => {
        let S = v[C] ?? {},
          k = S.plugins ?? [];
        return (v[C] = { ...S, plugins: Array.isArray(k) ? k : Object.values(k) }), y(...v);
      };
    }
    var yD = wo(dD);
    async function DD(y, C) {
      let { formatted: v } = await yD(y, { ...C, cursorOffset: -1 });
      return v;
    }
    async function fT(y, C) {
      return (await DD(y, C)) === y;
    }
    var dT = wo(Bc, 0),
      mT = { parse: wo(Ow), formatAST: wo(Lw), formatDoc: wo(_w), printToDoc: wo(Rw), printDocToString: wo(jw) };
    return x(W);
  });
})(Iv);
var f7 = Iv.exports,
  d7 = Object.create,
  xy = Object.defineProperty,
  m7 = Object.getOwnPropertyDescriptor,
  g7 = Object.getOwnPropertyNames,
  y7 = Object.getPrototypeOf,
  D7 = Object.prototype.hasOwnProperty,
  Nv = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports),
  x7 = (t, e) => {
    for (var r in e) xy(t, r, { get: e[r], enumerable: !0 });
  },
  C7 = (t, e, r, n) => {
    if ((e && typeof e == 'object') || typeof e == 'function')
      for (let i of g7(e))
        !D7.call(t, i) && i !== r && xy(t, i, { get: () => e[i], enumerable: !(n = m7(e, i)) || n.enumerable });
    return t;
  },
  Cy = (t, e, r) => (
    (r = t != null ? d7(y7(t)) : {}),
    C7(e || !t || !t.__esModule ? xy(r, 'default', { value: t, enumerable: !0 }) : r, t)
  ),
  Mv = Nv((t) => {
    Object.defineProperty(t, '__esModule', { value: !0 });
    function e(u, a) {
      if (u == null) return {};
      var h = {},
        d = Object.keys(u),
        D,
        A;
      for (A = 0; A < d.length; A++) (D = d[A]), !(a.indexOf(D) >= 0) && (h[D] = u[D]);
      return h;
    }
    var r = class {
        constructor(u, a, h) {
          (this.line = void 0),
            (this.column = void 0),
            (this.index = void 0),
            (this.line = u),
            (this.column = a),
            (this.index = h);
        }
      },
      n = class {
        constructor(u, a) {
          (this.start = void 0),
            (this.end = void 0),
            (this.filename = void 0),
            (this.identifierName = void 0),
            (this.start = u),
            (this.end = a);
        }
      };
    function i(u, a) {
      let { line: h, column: d, index: D } = u;
      return new r(h, d + a, D + a);
    }
    var s = {
        SyntaxError: 'BABEL_PARSER_SYNTAX_ERROR',
        SourceTypeModuleError: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
      },
      o = (u, a = u.length - 1) => ({
        get() {
          return u.reduce((h, d) => h[d], this);
        },
        set(h) {
          u.reduce((d, D, A) => (A === a ? (d[D] = h) : d[D]), this);
        },
      }),
      l = (u, a, h) =>
        Object.keys(h)
          .map((d) => [d, h[d]])
          .filter(([, d]) => !!d)
          .map(([d, D]) => [
            d,
            typeof D == 'function'
              ? { value: D, enumerable: !1 }
              : typeof D.reflect == 'string'
              ? Object.assign({}, D, o(D.reflect.split('.')))
              : D,
          ])
          .reduce(
            (d, [D, A]) => Object.defineProperty(d, D, Object.assign({ configurable: !0 }, A)),
            Object.assign(new u(), a),
          ),
      c = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: s.SourceTypeModuleError,
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: s.SourceTypeModuleError,
        },
      },
      p = {
        ArrayPattern: 'array destructuring pattern',
        AssignmentExpression: 'assignment expression',
        AssignmentPattern: 'assignment expression',
        ArrowFunctionExpression: 'arrow function expression',
        ConditionalExpression: 'conditional expression',
        CatchClause: 'catch clause',
        ForOfStatement: 'for-of statement',
        ForInStatement: 'for-in statement',
        ForStatement: 'for-loop',
        FormalParameters: 'function parameter list',
        Identifier: 'identifier',
        ImportSpecifier: 'import specifier',
        ImportDefaultSpecifier: 'import default specifier',
        ImportNamespaceSpecifier: 'import namespace specifier',
        ObjectPattern: 'object destructuring pattern',
        ParenthesizedExpression: 'parenthesized expression',
        RestElement: 'rest element',
        UpdateExpression: { true: 'prefix operation', false: 'postfix operation' },
        VariableDeclarator: 'variable declaration',
        YieldExpression: 'yield expression',
      },
      f = ({ type: u, prefix: a }) => (u === 'UpdateExpression' ? p.UpdateExpression[String(a)] : p[u]),
      m = {
        AccessorIsGenerator: ({ kind: u }) => `A ${u}ter cannot be a generator.`,
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext:
          'Async functions can only be declared at the top level or inside a block.',
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitUsingNotInAsyncContext:
          "'await using' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accessor must not have any formal parameters.",
        BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: 'Class constructor may not be an accessor.',
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({ kind: u }) => `Missing initializer in ${u} declaration.`,
        DecoratorArgumentsOutsideParentheses:
          "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
        DecoratorBeforeExport:
          "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
        DecoratorsBeforeAfterExport:
          "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass:
          "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
        DecoratorSemicolon: 'Decorators must not be followed by a semicolon.',
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: 'Deleting a private field is not allowed.',
        DestructureNamedImport:
          'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
        DuplicateConstructor: 'Duplicate constructor in the same class.',
        DuplicateDefaultExport: 'Only one default export allowed per module.',
        DuplicateExport: ({ exportName: u }) =>
          `\`${u}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: 'Redefinition of __proto__ property.',
        DuplicateRegExpFlags: 'Duplicate regular expression flag.',
        ElementAfterRest: 'Rest element must be last element.',
        EscapedCharNotAnIdentifier: 'Invalid Unicode escape.',
        ExportBindingIsString: ({
          localName: u,
          exportName: a,
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${u}' as '${a}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({ type: u }) =>
          `'${u === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`,
        ForInUsing: "For-in loop may not start with 'using' declaration.",
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.',
        IllegalBreakContinue: ({ type: u }) => `Unsyntactic ${u === 'BreakStatement' ? 'break' : 'continue'}.`,
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportAttributesUseAssert:
          'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.',
        ImportBindingIsString: ({ importName: u }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${u}" as foo }\`?`,
        ImportCallArgumentTrailingComma: 'Trailing comma is disallowed inside import(...) arguments.',
        ImportCallArity: ({ maxArgumentCount: u }) =>
          `\`import()\` requires exactly ${u === 1 ? 'one argument' : 'one or two arguments'}.`,
        ImportCallNotNewExpression: 'Cannot use new with import(...).',
        ImportCallSpreadArgument: '`...` is not allowed in `import()`.',
        ImportJSONBindingNotDefault: 'A JSON module can only be imported with `default`.',
        ImportReflectionHasAssertion: '`import module x` cannot have assertions.',
        ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
        IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: 'Invalid BigIntLiteral.',
        InvalidCodePoint: 'Code point out of bounds.',
        InvalidCoverInitializedName: 'Invalid shorthand property initializer.',
        InvalidDecimal: 'Invalid decimal.',
        InvalidDigit: ({ radix: u }) => `Expected number in radix ${u}.`,
        InvalidEscapeSequence: 'Bad character escape sequence.',
        InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.',
        InvalidEscapedReservedWord: ({ reservedWord: u }) => `Escape sequence in keyword ${u}.`,
        InvalidIdentifier: ({ identifierName: u }) => `Invalid identifier ${u}.`,
        InvalidLhs: ({ ancestor: u }) => `Invalid left-hand side in ${f(u)}.`,
        InvalidLhsBinding: ({ ancestor: u }) => `Binding invalid left-hand side in ${f(u)}.`,
        InvalidNumber: 'Invalid number.',
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({ unexpected: u }) => `Unexpected character '${u}'.`,
        InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.',
        InvalidPrivateFieldResolution: ({ identifierName: u }) => `Private name #${u} is not defined.`,
        InvalidPropertyBindingPattern: 'Binding member expression.',
        InvalidRecordProperty: 'Only properties and spread elements are allowed in record definitions.',
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({ labelName: u }) => `Label '${u}' is already declared.`,
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: 'Invalid regular expression flag.',
        MissingClassName: 'A class name is required.',
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: 'Missing semicolon.',
        MissingPlugin: ({ missingPlugin: u }) =>
          `This experimental syntax requires enabling the parser plugin: ${u
            .map((a) => JSON.stringify(a))
            .join(', ')}.`,
        MissingOneOfPlugins: ({ missingPlugin: u }) =>
          `This experimental syntax requires enabling one of the following parser plugin(s): ${u
            .map((a) => JSON.stringify(a))
            .join(', ')}.`,
        MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.',
        MixingCoalesceWithLogical:
          'Nullish coalescing operator(??) requires parens when mixing with logical operators.',
        ModuleAttributeDifferentFromType: 'The only accepted module attribute is `type`.',
        ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.',
        ModuleAttributesWithDuplicateKeys: ({ key: u }) => `Duplicate key "${u}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: u }) =>
          `An export name cannot include a lone surrogate, found '\\u${u.toString(16)}'.`,
        ModuleExportUndefined: ({ localName: u }) => `Export '${u}' is not defined.`,
        MultipleDefaultsInSwitch: 'Multiple default clauses.',
        NewlineAfterThrow: 'Illegal newline after throw.',
        NoCatchOrFinally: 'Missing catch or finally clause.',
        NumberIdentifier: 'Identifier directly after number.',
        NumericSeparatorInEscapeSequence:
          'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.',
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.',
        OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.',
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: 'Argument name clash.',
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({ identifierName: u }) =>
          `Private names are only allowed in property accesses (\`obj.#${u}\`) or in \`in\` expressions (\`#${u} in obj\`).`,
        PrivateNameRedeclaration: ({ identifierName: u }) => `Duplicate private name #${u}.`,
        RecordExpressionBarIncorrectEndSyntaxType:
          "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType:
          "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType:
          "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: 'Unexpected trailing comma after rest element.',
        SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.',
        SloppyFunctionAnnexB:
          'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.',
        StaticPrototype: 'Classes may not have static property named prototype.',
        SuperNotAllowed:
          "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: 'Decorators must be attached to a class element.',
        TupleExpressionBarIncorrectEndSyntaxType:
          "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType:
          "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType:
          "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.',
        UnexpectedAwaitAfterPipelineBody:
          'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: 'Unexpected digit after hash token.',
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({ keyword: u }) => `Unexpected keyword '${u}'.`,
        UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.',
        UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.',
        UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.',
        UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.',
        UnexpectedPrivateField: 'Unexpected private name.',
        UnexpectedReservedWord: ({ reservedWord: u }) => `Unexpected reserved word '${u}'.`,
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({ expected: u, unexpected: a }) =>
          `Unexpected token${a ? ` '${a}'.` : ''}${u ? `, expected "${u}"` : ''}`,
        UnexpectedTokenUnaryExponentiation:
          'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
        UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script`.',
        UnsupportedBind: 'Binding should be performed on object property.',
        UnsupportedDecoratorExport: 'A decorated export must export a class declaration.',
        UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.',
        UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.',
        UnsupportedMetaProperty: ({ target: u, onlyValidPropertyName: a }) =>
          `The only valid meta property for ${u} is ${u}.${a}.`,
        UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.',
        UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.',
        UnsupportedSuper:
          "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: 'Unterminated comment.',
        UnterminatedRegExp: 'Unterminated regular expression.',
        UnterminatedString: 'Unterminated string constant.',
        UnterminatedTemplate: 'Unterminated template.',
        UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.',
        VarRedeclaration: ({ identifierName: u }) => `Identifier '${u}' has already been declared.`,
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: 'Yield expression is not allowed in formal parameters.',
        ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.',
      },
      g = {
        StrictDelete: 'Deleting local variable in strict mode.',
        StrictEvalArguments: ({ referenceName: u }) => `Assigning to '${u}' in strict mode.`,
        StrictEvalArgumentsBinding: ({ bindingName: u }) => `Binding '${u}' in strict mode.`,
        StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.',
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.',
        StrictWith: "'with' in strict mode.",
      },
      x = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression']),
      b = {
        PipeBodyIsTighter:
          'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.',
        PipeTopicRequiresHackPipes:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.',
        PipeTopicUnconfiguredToken: ({ token: u }) =>
          `Invalid topic token ${u}. In order to use ${u} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${u}" }.`,
        PipeTopicUnused:
          'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.',
        PipeUnparenthesizedBody: ({ type: u }) =>
          `Hack-style pipe body cannot be an unparenthesized ${f({ type: u })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow:
          'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: 'Pipeline body may not be a comma-separated sequence expression.',
        PipelineHeadSequenceExpression: 'Pipeline head should not be a comma-separated sequence expression.',
        PipelineTopicUnused: 'Pipeline is in topic style but does not use topic reference.',
        PrimaryTopicNotAllowed: 'Topic reference was used in a lexical context without topic binding.',
        PrimaryTopicRequiresSmartPipeline:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      },
      F = ['toMessage'],
      E = ['message'];
    function w(u) {
      let { toMessage: a } = u,
        h = e(u, F);
      return function d({ loc: D, details: A }) {
        return l(SyntaxError, Object.assign({}, h, { loc: D }), {
          clone(P = {}) {
            let N = P.loc || {};
            return d({
              loc: new r(
                'line' in N ? N.line : this.loc.line,
                'column' in N ? N.column : this.loc.column,
                'index' in N ? N.index : this.loc.index,
              ),
              details: Object.assign({}, this.details, P.details),
            });
          },
          details: { value: A, enumerable: !1 },
          message: {
            get() {
              return `${a(this.details)} (${this.loc.line}:${this.loc.column})`;
            },
            set(P) {
              Object.defineProperty(this, 'message', { value: P });
            },
          },
          pos: { reflect: 'loc.index', enumerable: !0 },
          missingPlugin: 'missingPlugin' in A && { reflect: 'details.missingPlugin', enumerable: !0 },
        });
      };
    }
    function I(u, a) {
      if (Array.isArray(u)) return (d) => I(d, u[0]);
      let h = {};
      for (let d of Object.keys(u)) {
        let D = u[d],
          A = typeof D == 'string' ? { message: () => D } : typeof D == 'function' ? { message: D } : D,
          { message: P } = A,
          N = e(A, E),
          R = typeof P == 'string' ? () => P : P;
        h[d] = w(Object.assign({ code: s.SyntaxError, reasonCode: d, toMessage: R }, a ? { syntaxPlugin: a } : {}, N));
      }
      return h;
    }
    var T = Object.assign({}, I(c), I(m), I(g), I`pipelineOperator`(b)),
      { defineProperty: j } = Object,
      $ = (u, a) => j(u, a, { enumerable: !1, value: u[a] });
    function L(u) {
      return u.loc.start && $(u.loc.start, 'index'), u.loc.end && $(u.loc.end, 'index'), u;
    }
    var se = (u) =>
        class extends u {
          parse() {
            let a = L(super.parse());
            return this.options.tokens && (a.tokens = a.tokens.map(L)), a;
          }
          parseRegExpLiteral({ pattern: a, flags: h }) {
            let d = null;
            try {
              d = new RegExp(a, h);
            } catch {}
            let D = this.estreeParseLiteral(d);
            return (D.regex = { pattern: a, flags: h }), D;
          }
          parseBigIntLiteral(a) {
            let h;
            try {
              h = BigInt(a);
            } catch {
              h = null;
            }
            let d = this.estreeParseLiteral(h);
            return (d.bigint = String(d.value || a)), d;
          }
          parseDecimalLiteral(a) {
            let h = this.estreeParseLiteral(null);
            return (h.decimal = String(h.value || a)), h;
          }
          estreeParseLiteral(a) {
            return this.parseLiteral(a, 'Literal');
          }
          parseStringLiteral(a) {
            return this.estreeParseLiteral(a);
          }
          parseNumericLiteral(a) {
            return this.estreeParseLiteral(a);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(a) {
            return this.estreeParseLiteral(a);
          }
          directiveToStmt(a) {
            let h = a.value;
            delete a.value, (h.type = 'Literal'), (h.raw = h.extra.raw), (h.value = h.extra.expressionValue);
            let d = a;
            return (
              (d.type = 'ExpressionStatement'), (d.expression = h), (d.directive = h.extra.rawValue), delete h.extra, d
            );
          }
          initFunction(a, h) {
            super.initFunction(a, h), (a.expression = !1);
          }
          checkDeclaration(a) {
            a != null && this.isObjectProperty(a) ? this.checkDeclaration(a.value) : super.checkDeclaration(a);
          }
          getObjectOrClassMethodParams(a) {
            return a.value.params;
          }
          isValidDirective(a) {
            var h;
            return (
              a.type === 'ExpressionStatement' &&
              a.expression.type === 'Literal' &&
              typeof a.expression.value == 'string' &&
              !((h = a.expression.extra) != null && h.parenthesized)
            );
          }
          parseBlockBody(a, h, d, D, A) {
            super.parseBlockBody(a, h, d, D, A);
            let P = a.directives.map((N) => this.directiveToStmt(N));
            (a.body = P.concat(a.body)), delete a.directives;
          }
          pushClassMethod(a, h, d, D, A, P) {
            this.parseMethod(h, d, D, A, P, 'ClassMethod', !0),
              h.typeParameters && ((h.value.typeParameters = h.typeParameters), delete h.typeParameters),
              a.body.push(h);
          }
          parsePrivateName() {
            let a = super.parsePrivateName();
            return this.getPluginOption('estree', 'classFeatures') ? this.convertPrivateNameToPrivateIdentifier(a) : a;
          }
          convertPrivateNameToPrivateIdentifier(a) {
            let h = super.getPrivateNameSV(a);
            return (a = a), delete a.id, (a.name = h), (a.type = 'PrivateIdentifier'), a;
          }
          isPrivateName(a) {
            return this.getPluginOption('estree', 'classFeatures')
              ? a.type === 'PrivateIdentifier'
              : super.isPrivateName(a);
          }
          getPrivateNameSV(a) {
            return this.getPluginOption('estree', 'classFeatures') ? a.name : super.getPrivateNameSV(a);
          }
          parseLiteral(a, h) {
            let d = super.parseLiteral(a, h);
            return (d.raw = d.extra.raw), delete d.extra, d;
          }
          parseFunctionBody(a, h, d = !1) {
            super.parseFunctionBody(a, h, d), (a.expression = a.body.type !== 'BlockStatement');
          }
          parseMethod(a, h, d, D, A, P, N = !1) {
            let R = this.startNode();
            return (
              (R.kind = a.kind),
              (R = super.parseMethod(R, h, d, D, A, P, N)),
              (R.type = 'FunctionExpression'),
              delete R.kind,
              (a.value = R),
              P === 'ClassPrivateMethod' && (a.computed = !1),
              this.finishNode(a, 'MethodDefinition')
            );
          }
          parseClassProperty(...a) {
            let h = super.parseClassProperty(...a);
            return this.getPluginOption('estree', 'classFeatures') && (h.type = 'PropertyDefinition'), h;
          }
          parseClassPrivateProperty(...a) {
            let h = super.parseClassPrivateProperty(...a);
            return (
              this.getPluginOption('estree', 'classFeatures') && ((h.type = 'PropertyDefinition'), (h.computed = !1)), h
            );
          }
          parseObjectMethod(a, h, d, D, A) {
            let P = super.parseObjectMethod(a, h, d, D, A);
            return P && ((P.type = 'Property'), P.kind === 'method' && (P.kind = 'init'), (P.shorthand = !1)), P;
          }
          parseObjectProperty(a, h, d, D) {
            let A = super.parseObjectProperty(a, h, d, D);
            return A && ((A.kind = 'init'), (A.type = 'Property')), A;
          }
          isValidLVal(a, h, d) {
            return a === 'Property' ? 'value' : super.isValidLVal(a, h, d);
          }
          isAssignable(a, h) {
            return a != null && this.isObjectProperty(a) ? this.isAssignable(a.value, h) : super.isAssignable(a, h);
          }
          toAssignable(a, h = !1) {
            if (a != null && this.isObjectProperty(a)) {
              let { key: d, value: D } = a;
              this.isPrivateName(d) && this.classScope.usePrivateName(this.getPrivateNameSV(d), d.loc.start),
                this.toAssignable(D, h);
            } else super.toAssignable(a, h);
          }
          toAssignableObjectExpressionProp(a, h, d) {
            a.kind === 'get' || a.kind === 'set'
              ? this.raise(T.PatternHasAccessor, { at: a.key })
              : a.method
              ? this.raise(T.PatternHasMethod, { at: a.key })
              : super.toAssignableObjectExpressionProp(a, h, d);
          }
          finishCallExpression(a, h) {
            let d = super.finishCallExpression(a, h);
            if (d.callee.type === 'Import') {
              if (
                ((d.type = 'ImportExpression'),
                (d.source = d.arguments[0]),
                this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions'))
              ) {
                var D;
                d.attributes = (D = d.arguments[1]) != null ? D : null;
              }
              delete d.arguments, delete d.callee;
            }
            return d;
          }
          toReferencedArguments(a) {
            a.type !== 'ImportExpression' && super.toReferencedArguments(a);
          }
          parseExport(a, h) {
            let d = this.state.lastTokStartLoc,
              D = super.parseExport(a, h);
            switch (D.type) {
              case 'ExportAllDeclaration':
                D.exported = null;
                break;
              case 'ExportNamedDeclaration':
                D.specifiers.length === 1 &&
                  D.specifiers[0].type === 'ExportNamespaceSpecifier' &&
                  ((D.type = 'ExportAllDeclaration'), (D.exported = D.specifiers[0].exported), delete D.specifiers);
              case 'ExportDefaultDeclaration':
                {
                  var A;
                  let { declaration: P } = D;
                  (P == null ? void 0 : P.type) === 'ClassDeclaration' &&
                    ((A = P.decorators) == null ? void 0 : A.length) > 0 &&
                    P.start === D.start &&
                    this.resetStartLocation(D, d);
                }
                break;
            }
            return D;
          }
          parseSubscript(a, h, d, D) {
            let A = super.parseSubscript(a, h, d, D);
            if (D.optionalChainMember) {
              if (
                ((A.type === 'OptionalMemberExpression' || A.type === 'OptionalCallExpression') &&
                  (A.type = A.type.substring(8)),
                D.stop)
              ) {
                let P = this.startNodeAtNode(A);
                return (P.expression = A), this.finishNode(P, 'ChainExpression');
              }
            } else (A.type === 'MemberExpression' || A.type === 'CallExpression') && (A.optional = !1);
            return A;
          }
          hasPropertyAsPrivateName(a) {
            return a.type === 'ChainExpression' && (a = a.expression), super.hasPropertyAsPrivateName(a);
          }
          isObjectProperty(a) {
            return a.type === 'Property' && a.kind === 'init' && !a.method;
          }
          isObjectMethod(a) {
            return a.method || a.kind === 'get' || a.kind === 'set';
          }
          finishNodeAt(a, h, d) {
            return L(super.finishNodeAt(a, h, d));
          }
          resetStartLocation(a, h) {
            super.resetStartLocation(a, h), L(a);
          }
          resetEndLocation(a, h = this.state.lastTokEndLoc) {
            super.resetEndLocation(a, h), L(a);
          }
        },
      Y = class {
        constructor(u, a) {
          (this.token = void 0), (this.preserveSpace = void 0), (this.token = u), (this.preserveSpace = !!a);
        }
      },
      W = { brace: new Y('{'), j_oTag: new Y('<tag'), j_cTag: new Y('</tag'), j_expr: new Y('<tag>...</tag>', !0) };
    W.template = new Y('`', !0);
    var X = !0,
      q = !0,
      xe = !0,
      Re = !0,
      re = !0,
      ie = !0,
      Q = class {
        constructor(u, a = {}) {
          (this.label = void 0),
            (this.keyword = void 0),
            (this.beforeExpr = void 0),
            (this.startsExpr = void 0),
            (this.rightAssociative = void 0),
            (this.isLoop = void 0),
            (this.isAssign = void 0),
            (this.prefix = void 0),
            (this.postfix = void 0),
            (this.binop = void 0),
            (this.label = u),
            (this.keyword = a.keyword),
            (this.beforeExpr = !!a.beforeExpr),
            (this.startsExpr = !!a.startsExpr),
            (this.rightAssociative = !!a.rightAssociative),
            (this.isLoop = !!a.isLoop),
            (this.isAssign = !!a.isAssign),
            (this.prefix = !!a.prefix),
            (this.postfix = !!a.postfix),
            (this.binop = a.binop != null ? a.binop : null),
            (this.updateContext = null);
        }
      },
      ce = new Map();
    function G(u, a = {}) {
      a.keyword = u;
      let h = U(u, a);
      return ce.set(u, h), h;
    }
    function ge(u, a) {
      return U(u, { beforeExpr: X, binop: a });
    }
    var we = -1,
      je = [],
      Qe = [],
      ot = [],
      pt = [],
      gt = [],
      yt = [];
    function U(u, a = {}) {
      var h, d, D, A;
      return (
        ++we,
        Qe.push(u),
        ot.push((h = a.binop) != null ? h : -1),
        pt.push((d = a.beforeExpr) != null ? d : !1),
        gt.push((D = a.startsExpr) != null ? D : !1),
        yt.push((A = a.prefix) != null ? A : !1),
        je.push(new Q(u, a)),
        we
      );
    }
    function he(u, a = {}) {
      var h, d, D, A;
      return (
        ++we,
        ce.set(u, we),
        Qe.push(u),
        ot.push((h = a.binop) != null ? h : -1),
        pt.push((d = a.beforeExpr) != null ? d : !1),
        gt.push((D = a.startsExpr) != null ? D : !1),
        yt.push((A = a.prefix) != null ? A : !1),
        je.push(new Q('name', a)),
        we
      );
    }
    var Te = {
      bracketL: U('[', { beforeExpr: X, startsExpr: q }),
      bracketHashL: U('#[', { beforeExpr: X, startsExpr: q }),
      bracketBarL: U('[|', { beforeExpr: X, startsExpr: q }),
      bracketR: U(']'),
      bracketBarR: U('|]'),
      braceL: U('{', { beforeExpr: X, startsExpr: q }),
      braceBarL: U('{|', { beforeExpr: X, startsExpr: q }),
      braceHashL: U('#{', { beforeExpr: X, startsExpr: q }),
      braceR: U('}'),
      braceBarR: U('|}'),
      parenL: U('(', { beforeExpr: X, startsExpr: q }),
      parenR: U(')'),
      comma: U(',', { beforeExpr: X }),
      semi: U(';', { beforeExpr: X }),
      colon: U(':', { beforeExpr: X }),
      doubleColon: U('::', { beforeExpr: X }),
      dot: U('.'),
      question: U('?', { beforeExpr: X }),
      questionDot: U('?.'),
      arrow: U('=>', { beforeExpr: X }),
      template: U('template'),
      ellipsis: U('...', { beforeExpr: X }),
      backQuote: U('`', { startsExpr: q }),
      dollarBraceL: U('${', { beforeExpr: X, startsExpr: q }),
      templateTail: U('...`', { startsExpr: q }),
      templateNonTail: U('...${', { beforeExpr: X, startsExpr: q }),
      at: U('@'),
      hash: U('#', { startsExpr: q }),
      interpreterDirective: U('#!...'),
      eq: U('=', { beforeExpr: X, isAssign: Re }),
      assign: U('_=', { beforeExpr: X, isAssign: Re }),
      slashAssign: U('_=', { beforeExpr: X, isAssign: Re }),
      xorAssign: U('_=', { beforeExpr: X, isAssign: Re }),
      moduloAssign: U('_=', { beforeExpr: X, isAssign: Re }),
      incDec: U('++/--', { prefix: re, postfix: ie, startsExpr: q }),
      bang: U('!', { beforeExpr: X, prefix: re, startsExpr: q }),
      tilde: U('~', { beforeExpr: X, prefix: re, startsExpr: q }),
      doubleCaret: U('^^', { startsExpr: q }),
      doubleAt: U('@@', { startsExpr: q }),
      pipeline: ge('|>', 0),
      nullishCoalescing: ge('??', 1),
      logicalOR: ge('||', 1),
      logicalAND: ge('&&', 2),
      bitwiseOR: ge('|', 3),
      bitwiseXOR: ge('^', 4),
      bitwiseAND: ge('&', 5),
      equality: ge('==/!=/===/!==', 6),
      lt: ge('</>/<=/>=', 7),
      gt: ge('</>/<=/>=', 7),
      relational: ge('</>/<=/>=', 7),
      bitShift: ge('<</>>/>>>', 8),
      bitShiftL: ge('<</>>/>>>', 8),
      bitShiftR: ge('<</>>/>>>', 8),
      plusMin: U('+/-', { beforeExpr: X, binop: 9, prefix: re, startsExpr: q }),
      modulo: U('%', { binop: 10, startsExpr: q }),
      star: U('*', { binop: 10 }),
      slash: ge('/', 10),
      exponent: U('**', { beforeExpr: X, binop: 11, rightAssociative: !0 }),
      _in: G('in', { beforeExpr: X, binop: 7 }),
      _instanceof: G('instanceof', { beforeExpr: X, binop: 7 }),
      _break: G('break'),
      _case: G('case', { beforeExpr: X }),
      _catch: G('catch'),
      _continue: G('continue'),
      _debugger: G('debugger'),
      _default: G('default', { beforeExpr: X }),
      _else: G('else', { beforeExpr: X }),
      _finally: G('finally'),
      _function: G('function', { startsExpr: q }),
      _if: G('if'),
      _return: G('return', { beforeExpr: X }),
      _switch: G('switch'),
      _throw: G('throw', { beforeExpr: X, prefix: re, startsExpr: q }),
      _try: G('try'),
      _var: G('var'),
      _const: G('const'),
      _with: G('with'),
      _new: G('new', { beforeExpr: X, startsExpr: q }),
      _this: G('this', { startsExpr: q }),
      _super: G('super', { startsExpr: q }),
      _class: G('class', { startsExpr: q }),
      _extends: G('extends', { beforeExpr: X }),
      _export: G('export'),
      _import: G('import', { startsExpr: q }),
      _null: G('null', { startsExpr: q }),
      _true: G('true', { startsExpr: q }),
      _false: G('false', { startsExpr: q }),
      _typeof: G('typeof', { beforeExpr: X, prefix: re, startsExpr: q }),
      _void: G('void', { beforeExpr: X, prefix: re, startsExpr: q }),
      _delete: G('delete', { beforeExpr: X, prefix: re, startsExpr: q }),
      _do: G('do', { isLoop: xe, beforeExpr: X }),
      _for: G('for', { isLoop: xe }),
      _while: G('while', { isLoop: xe }),
      _as: he('as', { startsExpr: q }),
      _assert: he('assert', { startsExpr: q }),
      _async: he('async', { startsExpr: q }),
      _await: he('await', { startsExpr: q }),
      _from: he('from', { startsExpr: q }),
      _get: he('get', { startsExpr: q }),
      _let: he('let', { startsExpr: q }),
      _meta: he('meta', { startsExpr: q }),
      _of: he('of', { startsExpr: q }),
      _sent: he('sent', { startsExpr: q }),
      _set: he('set', { startsExpr: q }),
      _static: he('static', { startsExpr: q }),
      _using: he('using', { startsExpr: q }),
      _yield: he('yield', { startsExpr: q }),
      _asserts: he('asserts', { startsExpr: q }),
      _checks: he('checks', { startsExpr: q }),
      _exports: he('exports', { startsExpr: q }),
      _global: he('global', { startsExpr: q }),
      _implements: he('implements', { startsExpr: q }),
      _intrinsic: he('intrinsic', { startsExpr: q }),
      _infer: he('infer', { startsExpr: q }),
      _is: he('is', { startsExpr: q }),
      _mixins: he('mixins', { startsExpr: q }),
      _proto: he('proto', { startsExpr: q }),
      _require: he('require', { startsExpr: q }),
      _satisfies: he('satisfies', { startsExpr: q }),
      _keyof: he('keyof', { startsExpr: q }),
      _readonly: he('readonly', { startsExpr: q }),
      _unique: he('unique', { startsExpr: q }),
      _abstract: he('abstract', { startsExpr: q }),
      _declare: he('declare', { startsExpr: q }),
      _enum: he('enum', { startsExpr: q }),
      _module: he('module', { startsExpr: q }),
      _namespace: he('namespace', { startsExpr: q }),
      _interface: he('interface', { startsExpr: q }),
      _type: he('type', { startsExpr: q }),
      _opaque: he('opaque', { startsExpr: q }),
      name: U('name', { startsExpr: q }),
      string: U('string', { startsExpr: q }),
      num: U('num', { startsExpr: q }),
      bigint: U('bigint', { startsExpr: q }),
      decimal: U('decimal', { startsExpr: q }),
      regexp: U('regexp', { startsExpr: q }),
      privateName: U('#name', { startsExpr: q }),
      eof: U('eof'),
      jsxName: U('jsxName'),
      jsxText: U('jsxText', { beforeExpr: !0 }),
      jsxTagStart: U('jsxTagStart', { startsExpr: !0 }),
      jsxTagEnd: U('jsxTagEnd'),
      placeholder: U('%%', { startsExpr: !0 }),
    };
    function fe(u) {
      return u >= 93 && u <= 130;
    }
    function at(u) {
      return u <= 92;
    }
    function M(u) {
      return u >= 58 && u <= 130;
    }
    function V(u) {
      return u >= 58 && u <= 134;
    }
    function J(u) {
      return pt[u];
    }
    function ae(u) {
      return gt[u];
    }
    function de(u) {
      return u >= 29 && u <= 33;
    }
    function ye(u) {
      return u >= 127 && u <= 129;
    }
    function Le(u) {
      return u >= 90 && u <= 92;
    }
    function Fe(u) {
      return u >= 58 && u <= 92;
    }
    function ke(u) {
      return u >= 39 && u <= 59;
    }
    function De(u) {
      return u === 34;
    }
    function Ge(u) {
      return yt[u];
    }
    function He(u) {
      return u >= 119 && u <= 121;
    }
    function Ze(u) {
      return u >= 122 && u <= 128;
    }
    function et(u) {
      return Qe[u];
    }
    function lt(u) {
      return ot[u];
    }
    function Mt(u) {
      return u === 57;
    }
    function Et(u) {
      return u >= 24 && u <= 25;
    }
    function Pt(u) {
      return je[u];
    }
    (je[8].updateContext = (u) => {
      u.pop();
    }),
      (je[5].updateContext =
        je[7].updateContext =
        je[23].updateContext =
          (u) => {
            u.push(W.brace);
          }),
      (je[22].updateContext = (u) => {
        u[u.length - 1] === W.template ? u.pop() : u.push(W.template);
      }),
      (je[140].updateContext = (u) => {
        u.push(W.j_expr, W.j_oTag);
      });
    var gr =
        'ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ',
      Xn =
        '‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿',
      qi = new RegExp('[' + gr + ']'),
      Ki = new RegExp('[' + gr + Xn + ']');
    gr = Xn = null;
    var Ji = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35,
        5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310,
        10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21,
        11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17,
        111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3,
        0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2,
        0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2,
        31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0,
        3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
        264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2,
        33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29,
        19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2,
        6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0,
        3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2,
        30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
        29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2,
        3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6,
        2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541,
        1507, 4938, 6, 4191,
      ],
      Fr = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10,
        50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13,
        9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193,
        17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9,
        71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2,
        7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49,
        6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
        1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2,
        14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9,
        4759, 9, 787719, 239,
      ];
    function Pr(u, a) {
      let h = 65536;
      for (let d = 0, D = a.length; d < D; d += 2) {
        if (((h += a[d]), h > u)) return !1;
        if (((h += a[d + 1]), h >= u)) return !0;
      }
      return !1;
    }
    function hn(u) {
      return u < 65
        ? u === 36
        : u <= 90
        ? !0
        : u < 97
        ? u === 95
        : u <= 122
        ? !0
        : u <= 65535
        ? u >= 170 && qi.test(String.fromCharCode(u))
        : Pr(u, Ji);
    }
    function pn(u) {
      return u < 48
        ? u === 36
        : u < 58
        ? !0
        : u < 65
        ? !1
        : u <= 90
        ? !0
        : u < 97
        ? u === 95
        : u <= 122
        ? !0
        : u <= 65535
        ? u >= 170 && Ki.test(String.fromCharCode(u))
        : Pr(u, Ji) || Pr(u, Fr);
    }
    var ga = {
        keyword: [
          'break',
          'case',
          'catch',
          'continue',
          'debugger',
          'default',
          'do',
          'else',
          'finally',
          'for',
          'function',
          'if',
          'return',
          'switch',
          'throw',
          'try',
          'var',
          'const',
          'while',
          'with',
          'new',
          'this',
          'super',
          'class',
          'extends',
          'export',
          'import',
          'null',
          'true',
          'false',
          'in',
          'instanceof',
          'typeof',
          'void',
          'delete',
        ],
        strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
        strictBind: ['eval', 'arguments'],
      },
      Il = new Set(ga.keyword),
      Cc = new Set(ga.strict),
      bc = new Set(ga.strictBind);
    function Ac(u, a) {
      return (a && u === 'await') || u === 'enum';
    }
    function Ec(u, a) {
      return Ac(u, a) || Cc.has(u);
    }
    function lr(u) {
      return bc.has(u);
    }
    function vc(u, a) {
      return Ec(u, a) || lr(u);
    }
    function Nl(u) {
      return Il.has(u);
    }
    function Fc(u, a, h) {
      return u === 64 && a === 64 && hn(h);
    }
    var Wf = new Set([
      'break',
      'case',
      'catch',
      'continue',
      'debugger',
      'default',
      'do',
      'else',
      'finally',
      'for',
      'function',
      'if',
      'return',
      'switch',
      'throw',
      'try',
      'var',
      'const',
      'while',
      'with',
      'new',
      'this',
      'super',
      'class',
      'extends',
      'export',
      'import',
      'null',
      'true',
      'false',
      'in',
      'instanceof',
      'typeof',
      'void',
      'delete',
      'implements',
      'interface',
      'let',
      'package',
      'private',
      'protected',
      'public',
      'static',
      'yield',
      'eval',
      'arguments',
      'enum',
      'await',
    ]);
    function Uf(u) {
      return Wf.has(u);
    }
    var Ml = class {
        constructor(u) {
          (this.var = new Set()), (this.lexical = new Set()), (this.functions = new Set()), (this.flags = u);
        }
      },
      Ol = class {
        constructor(u, a) {
          (this.parser = void 0),
            (this.scopeStack = []),
            (this.inModule = void 0),
            (this.undefinedExports = new Map()),
            (this.parser = u),
            (this.inModule = a);
        }
        get inTopLevel() {
          return (this.currentScope().flags & 1) > 0;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & 2) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & 16) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & 32) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & 64) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          let u = this.currentThisScopeFlags();
          return (u & 64) > 0 && (u & 2) === 0;
        }
        get inStaticBlock() {
          for (let u = this.scopeStack.length - 1; ; u--) {
            let { flags: a } = this.scopeStack[u];
            if (a & 128) return !0;
            if (a & 451) return !1;
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & 2) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(u) {
          return new Ml(u);
        }
        enter(u) {
          this.scopeStack.push(this.createScope(u));
        }
        exit() {
          return this.scopeStack.pop().flags;
        }
        treatFunctionsAsVarInScope(u) {
          return !!(u.flags & 130 || (!this.parser.inModule && u.flags & 1));
        }
        declareName(u, a, h) {
          let d = this.currentScope();
          if (a & 8 || a & 16)
            this.checkRedeclarationInScope(d, u, a, h),
              a & 16 ? d.functions.add(u) : d.lexical.add(u),
              a & 8 && this.maybeExportDefined(d, u);
          else if (a & 4)
            for (
              let D = this.scopeStack.length - 1;
              D >= 0 &&
              ((d = this.scopeStack[D]),
              this.checkRedeclarationInScope(d, u, a, h),
              d.var.add(u),
              this.maybeExportDefined(d, u),
              !(d.flags & 387));
              --D
            );
          this.parser.inModule && d.flags & 1 && this.undefinedExports.delete(u);
        }
        maybeExportDefined(u, a) {
          this.parser.inModule && u.flags & 1 && this.undefinedExports.delete(a);
        }
        checkRedeclarationInScope(u, a, h, d) {
          this.isRedeclaredInScope(u, a, h) && this.parser.raise(T.VarRedeclaration, { at: d, identifierName: a });
        }
        isRedeclaredInScope(u, a, h) {
          return h & 1
            ? h & 8
              ? u.lexical.has(a) || u.functions.has(a) || u.var.has(a)
              : h & 16
              ? u.lexical.has(a) || (!this.treatFunctionsAsVarInScope(u) && u.var.has(a))
              : (u.lexical.has(a) && !(u.flags & 8 && u.lexical.values().next().value === a)) ||
                (!this.treatFunctionsAsVarInScope(u) && u.functions.has(a))
            : !1;
        }
        checkLocalExport(u) {
          let { name: a } = u,
            h = this.scopeStack[0];
          !h.lexical.has(a) && !h.var.has(a) && !h.functions.has(a) && this.undefinedExports.set(a, u.loc.start);
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let u = this.scopeStack.length - 1; ; u--) {
            let { flags: a } = this.scopeStack[u];
            if (a & 387) return a;
          }
        }
        currentThisScopeFlags() {
          for (let u = this.scopeStack.length - 1; ; u--) {
            let { flags: a } = this.scopeStack[u];
            if (a & 451 && !(a & 4)) return a;
          }
        }
      },
      qf = class extends Ml {
        constructor(...u) {
          super(...u), (this.declareFunctions = new Set());
        }
      },
      Ll = class extends Ol {
        createScope(u) {
          return new qf(u);
        }
        declareName(u, a, h) {
          let d = this.currentScope();
          if (a & 2048) {
            this.checkRedeclarationInScope(d, u, a, h), this.maybeExportDefined(d, u), d.declareFunctions.add(u);
            return;
          }
          super.declareName(u, a, h);
        }
        isRedeclaredInScope(u, a, h) {
          return super.isRedeclaredInScope(u, a, h)
            ? !0
            : h & 2048
            ? !u.declareFunctions.has(a) && (u.lexical.has(a) || u.functions.has(a))
            : !1;
        }
        checkLocalExport(u) {
          this.scopeStack[0].declareFunctions.has(u.name) || super.checkLocalExport(u);
        }
      },
      Kf = class {
        constructor() {
          (this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1);
        }
        hasPlugin(u) {
          if (typeof u == 'string') return this.plugins.has(u);
          {
            let [a, h] = u;
            if (!this.hasPlugin(a)) return !1;
            let d = this.plugins.get(a);
            for (let D of Object.keys(h)) if ((d == null ? void 0 : d[D]) !== h[D]) return !1;
            return !0;
          }
        }
        getPluginOption(u, a) {
          var h;
          return (h = this.plugins.get(u)) == null ? void 0 : h[a];
        }
      };
    function xo(u, a) {
      u.trailingComments === void 0 ? (u.trailingComments = a) : u.trailingComments.unshift(...a);
    }
    function _l(u, a) {
      u.leadingComments === void 0 ? (u.leadingComments = a) : u.leadingComments.unshift(...a);
    }
    function Co(u, a) {
      u.innerComments === void 0 ? (u.innerComments = a) : u.innerComments.unshift(...a);
    }
    function bo(u, a, h) {
      let d = null,
        D = a.length;
      for (; d === null && D > 0; ) d = a[--D];
      d === null || d.start > h.start ? Co(u, h.comments) : xo(d, h.comments);
    }
    var Sc = class extends Kf {
        addComment(u) {
          this.filename && (u.loc.filename = this.filename), this.state.comments.push(u);
        }
        processComment(u) {
          let { commentStack: a } = this.state,
            h = a.length;
          if (h === 0) return;
          let d = h - 1,
            D = a[d];
          D.start === u.end && ((D.leadingNode = u), d--);
          let { start: A } = u;
          for (; d >= 0; d--) {
            let P = a[d],
              N = P.end;
            if (N > A) (P.containingNode = u), this.finalizeComment(P), a.splice(d, 1);
            else {
              N === A && (P.trailingNode = u);
              break;
            }
          }
        }
        finalizeComment(u) {
          let { comments: a } = u;
          if (u.leadingNode !== null || u.trailingNode !== null)
            u.leadingNode !== null && xo(u.leadingNode, a), u.trailingNode !== null && _l(u.trailingNode, a);
          else {
            let { containingNode: h, start: d } = u;
            if (this.input.charCodeAt(d - 1) === 44)
              switch (h.type) {
                case 'ObjectExpression':
                case 'ObjectPattern':
                case 'RecordExpression':
                  bo(h, h.properties, u);
                  break;
                case 'CallExpression':
                case 'OptionalCallExpression':
                  bo(h, h.arguments, u);
                  break;
                case 'FunctionDeclaration':
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                case 'ObjectMethod':
                case 'ClassMethod':
                case 'ClassPrivateMethod':
                  bo(h, h.params, u);
                  break;
                case 'ArrayExpression':
                case 'ArrayPattern':
                case 'TupleExpression':
                  bo(h, h.elements, u);
                  break;
                case 'ExportNamedDeclaration':
                case 'ImportDeclaration':
                  bo(h, h.specifiers, u);
                  break;
                default:
                  Co(h, a);
              }
            else Co(h, a);
          }
        }
        finalizeRemainingComments() {
          let { commentStack: u } = this.state;
          for (let a = u.length - 1; a >= 0; a--) this.finalizeComment(u[a]);
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(u) {
          let { commentStack: a } = this.state,
            { length: h } = a;
          if (h === 0) return;
          let d = a[h - 1];
          d.leadingNode === u && (d.leadingNode = null);
        }
        resetPreviousIdentifierLeadingComments(u) {
          let { commentStack: a } = this.state,
            { length: h } = a;
          h !== 0 &&
            (a[h - 1].trailingNode === u
              ? (a[h - 1].trailingNode = null)
              : h >= 2 && a[h - 2].trailingNode === u && (a[h - 2].trailingNode = null));
        }
        takeSurroundingComments(u, a, h) {
          let { commentStack: d } = this.state,
            D = d.length;
          if (D === 0) return;
          let A = D - 1;
          for (; A >= 0; A--) {
            let P = d[A],
              N = P.end;
            if (P.start === h) P.leadingNode = u;
            else if (N === a) P.trailingNode = u;
            else if (N < a) break;
          }
        }
      },
      wc = /\r\n?|[\n\u2028\u2029]/,
      ya = new RegExp(wc.source, 'g');
    function Ao(u) {
      switch (u) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return !0;
        default:
          return !1;
      }
    }
    var Da = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
      Di = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g,
      Rl = new RegExp('(?=(' + Di.source + '))\\1' + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, 'y');
    function Jf(u) {
      switch (u) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return !0;
        default:
          return !1;
      }
    }
    var Xf = class Ov {
        constructor() {
          (this.strict = void 0),
            (this.curLine = void 0),
            (this.lineStart = void 0),
            (this.startLoc = void 0),
            (this.endLoc = void 0),
            (this.errors = []),
            (this.potentialArrowAt = -1),
            (this.noArrowAt = []),
            (this.noArrowParamsConversionAt = []),
            (this.maybeInArrowParameters = !1),
            (this.inType = !1),
            (this.noAnonFunctionType = !1),
            (this.hasFlowComment = !1),
            (this.isAmbientContext = !1),
            (this.inAbstractClass = !1),
            (this.inDisallowConditionalTypesContext = !1),
            (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }),
            (this.soloAwait = !1),
            (this.inFSharpPipelineDirectBody = !1),
            (this.labels = []),
            (this.comments = []),
            (this.commentStack = []),
            (this.pos = 0),
            (this.type = 137),
            (this.value = null),
            (this.start = 0),
            (this.end = 0),
            (this.lastTokEndLoc = null),
            (this.lastTokStartLoc = null),
            (this.lastTokStart = 0),
            (this.context = [W.brace]),
            (this.canStartJSXElement = !0),
            (this.containsEsc = !1),
            (this.firstInvalidTemplateEscapePos = null),
            (this.strictErrors = new Map()),
            (this.tokensLength = 0);
        }
        init({ strictMode: a, sourceType: h, startLine: d, startColumn: D }) {
          (this.strict = a === !1 ? !1 : a === !0 ? !0 : h === 'module'),
            (this.curLine = d),
            (this.lineStart = -D),
            (this.startLoc = this.endLoc = new r(d, D, 0));
        }
        curPosition() {
          return new r(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(a) {
          let h = new Ov(),
            d = Object.keys(this);
          for (let D = 0, A = d.length; D < A; D++) {
            let P = d[D],
              N = this[P];
            !a && Array.isArray(N) && (N = N.slice()), (h[P] = N);
          }
          return h;
        }
      },
      Gf = function (u) {
        return u >= 48 && u <= 57;
      },
      Tc = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
      xa = {
        bin: (u) => u === 48 || u === 49,
        oct: (u) => u >= 48 && u <= 55,
        dec: (u) => u >= 48 && u <= 57,
        hex: (u) => (u >= 48 && u <= 57) || (u >= 65 && u <= 70) || (u >= 97 && u <= 102),
      };
    function jl(u, a, h, d, D, A) {
      let P = h,
        N = d,
        R = D,
        _ = '',
        ue = null,
        ve = h,
        { length: Ie } = a;
      for (;;) {
        if (h >= Ie) {
          A.unterminated(P, N, R), (_ += a.slice(ve, h));
          break;
        }
        let _e = a.charCodeAt(h);
        if (Hr(u, _e, a, h)) {
          _ += a.slice(ve, h);
          break;
        }
        if (_e === 92) {
          _ += a.slice(ve, h);
          let Bt = Mn(a, h, d, D, u === 'template', A);
          Bt.ch === null && !ue ? (ue = { pos: h, lineStart: d, curLine: D }) : (_ += Bt.ch),
            ({ pos: h, lineStart: d, curLine: D } = Bt),
            (ve = h);
        } else
          _e === 8232 || _e === 8233
            ? (++h, ++D, (d = h))
            : _e === 10 || _e === 13
            ? u === 'template'
              ? ((_ +=
                  a.slice(ve, h) +
                  `
`),
                ++h,
                _e === 13 && a.charCodeAt(h) === 10 && ++h,
                ++D,
                (ve = d = h))
              : A.unterminated(P, N, R)
            : ++h;
      }
      return { pos: h, str: _, firstInvalidLoc: ue, lineStart: d, curLine: D, containsInvalid: !!ue };
    }
    function Hr(u, a, h, d) {
      return u === 'template'
        ? a === 96 || (a === 36 && h.charCodeAt(d + 1) === 123)
        : a === (u === 'double' ? 34 : 39);
    }
    function Mn(u, a, h, d, D, A) {
      let P = !D;
      a++;
      let N = (_) => ({ pos: a, ch: _, lineStart: h, curLine: d }),
        R = u.charCodeAt(a++);
      switch (R) {
        case 110:
          return N(`
`);
        case 114:
          return N('\r');
        case 120: {
          let _;
          return ({ code: _, pos: a } = Xi(u, a, h, d, 2, !1, P, A)), N(_ === null ? null : String.fromCharCode(_));
        }
        case 117: {
          let _;
          return ({ code: _, pos: a } = kc(u, a, h, d, P, A)), N(_ === null ? null : String.fromCodePoint(_));
        }
        case 116:
          return N('	');
        case 98:
          return N('\b');
        case 118:
          return N('\v');
        case 102:
          return N('\f');
        case 13:
          u.charCodeAt(a) === 10 && ++a;
        case 10:
          (h = a), ++d;
        case 8232:
        case 8233:
          return N('');
        case 56:
        case 57:
          if (D) return N(null);
          A.strictNumericEscape(a - 1, h, d);
        default:
          if (R >= 48 && R <= 55) {
            let _ = a - 1,
              ue = u.slice(_, a + 2).match(/^[0-7]+/)[0],
              ve = parseInt(ue, 8);
            ve > 255 && ((ue = ue.slice(0, -1)), (ve = parseInt(ue, 8))), (a += ue.length - 1);
            let Ie = u.charCodeAt(a);
            if (ue !== '0' || Ie === 56 || Ie === 57) {
              if (D) return N(null);
              A.strictNumericEscape(_, h, d);
            }
            return N(String.fromCharCode(ve));
          }
          return N(String.fromCharCode(R));
      }
    }
    function Xi(u, a, h, d, D, A, P, N) {
      let R = a,
        _;
      return (
        ({ n: _, pos: a } = $l(u, a, h, d, 16, D, A, !1, N, !P)),
        _ === null && (P ? N.invalidEscapeSequence(R, h, d) : (a = R - 1)),
        { code: _, pos: a }
      );
    }
    function $l(u, a, h, d, D, A, P, N, R, _) {
      let ue = a,
        ve = D === 16 ? Tc.hex : Tc.decBinOct,
        Ie = D === 16 ? xa.hex : D === 10 ? xa.dec : D === 8 ? xa.oct : xa.bin,
        _e = !1,
        Bt = 0;
      for (let wt = 0, ur = A ?? 1 / 0; wt < ur; ++wt) {
        let Qt = u.charCodeAt(a),
          Zr;
        if (Qt === 95 && N !== 'bail') {
          let On = u.charCodeAt(a - 1),
            Jl = u.charCodeAt(a + 1);
          if (N) {
            if (Number.isNaN(Jl) || !Ie(Jl) || ve.has(On) || ve.has(Jl)) {
              if (_) return { n: null, pos: a };
              R.unexpectedNumericSeparator(a, h, d);
            }
          } else {
            if (_) return { n: null, pos: a };
            R.numericSeparatorInEscapeSequence(a, h, d);
          }
          ++a;
          continue;
        }
        if (
          (Qt >= 97 ? (Zr = Qt - 97 + 10) : Qt >= 65 ? (Zr = Qt - 65 + 10) : Gf(Qt) ? (Zr = Qt - 48) : (Zr = 1 / 0),
          Zr >= D)
        ) {
          if (Zr <= 9 && _) return { n: null, pos: a };
          if (Zr <= 9 && R.invalidDigit(a, h, d, D)) Zr = 0;
          else if (P) (Zr = 0), (_e = !0);
          else break;
        }
        ++a, (Bt = Bt * D + Zr);
      }
      return a === ue || (A != null && a - ue !== A) || _e ? { n: null, pos: a } : { n: Bt, pos: a };
    }
    function kc(u, a, h, d, D, A) {
      let P = u.charCodeAt(a),
        N;
      if (P === 123) {
        if (
          (++a, ({ code: N, pos: a } = Xi(u, a, h, d, u.indexOf('}', a) - a, !0, D, A)), ++a, N !== null && N > 1114111)
        )
          if (D) A.invalidCodePoint(a, h, d);
          else return { code: null, pos: a };
      } else ({ code: N, pos: a } = Xi(u, a, h, d, 4, !1, D, A));
      return { code: N, pos: a };
    }
    var Yf = ['at'],
      Vl = ['at'];
    function Gi(u, a, h) {
      return new r(h, u - a, u);
    }
    var Ca = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
      Cn = class {
        constructor(u) {
          (this.type = u.type),
            (this.value = u.value),
            (this.start = u.start),
            (this.end = u.end),
            (this.loc = new n(u.startLoc, u.endLoc));
        }
      },
      Gn = class extends Sc {
        constructor(u, a) {
          super(),
            (this.isLookahead = void 0),
            (this.tokens = []),
            (this.errorHandlers_readInt = {
              invalidDigit: (h, d, D, A) =>
                this.options.errorRecovery ? (this.raise(T.InvalidDigit, { at: Gi(h, d, D), radix: A }), !0) : !1,
              numericSeparatorInEscapeSequence: this.errorBuilder(T.NumericSeparatorInEscapeSequence),
              unexpectedNumericSeparator: this.errorBuilder(T.UnexpectedNumericSeparator),
            }),
            (this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
              invalidEscapeSequence: this.errorBuilder(T.InvalidEscapeSequence),
              invalidCodePoint: this.errorBuilder(T.InvalidCodePoint),
            })),
            (this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
              strictNumericEscape: (h, d, D) => {
                this.recordStrictModeErrors(T.StrictNumericEscape, { at: Gi(h, d, D) });
              },
              unterminated: (h, d, D) => {
                throw this.raise(T.UnterminatedString, { at: Gi(h - 1, d, D) });
              },
            })),
            (this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
              strictNumericEscape: this.errorBuilder(T.StrictNumericEscape),
              unterminated: (h, d, D) => {
                throw this.raise(T.UnterminatedTemplate, { at: Gi(h, d, D) });
              },
            })),
            (this.state = new Xf()),
            this.state.init(u),
            (this.input = a),
            (this.length = a.length),
            (this.isLookahead = !1);
        }
        pushToken(u) {
          (this.tokens.length = this.state.tokensLength), this.tokens.push(u), ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes(),
            this.options.tokens && this.pushToken(new Cn(this.state)),
            (this.state.lastTokStart = this.state.start),
            (this.state.lastTokEndLoc = this.state.endLoc),
            (this.state.lastTokStartLoc = this.state.startLoc),
            this.nextToken();
        }
        eat(u) {
          return this.match(u) ? (this.next(), !0) : !1;
        }
        match(u) {
          return this.state.type === u;
        }
        createLookaheadState(u) {
          return {
            pos: u.pos,
            value: null,
            type: u.type,
            start: u.start,
            end: u.end,
            context: [this.curContext()],
            inType: u.inType,
            startLoc: u.startLoc,
            lastTokEndLoc: u.lastTokEndLoc,
            curLine: u.curLine,
            lineStart: u.lineStart,
            curPosition: u.curPosition,
          };
        }
        lookahead() {
          let u = this.state;
          (this.state = this.createLookaheadState(u)),
            (this.isLookahead = !0),
            this.nextToken(),
            (this.isLookahead = !1);
          let a = this.state;
          return (this.state = u), a;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(u) {
          return (Da.lastIndex = u), Da.test(this.input) ? Da.lastIndex : u;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        nextTokenInLineStart() {
          return this.nextTokenInLineStartSince(this.state.pos);
        }
        nextTokenInLineStartSince(u) {
          return (Di.lastIndex = u), Di.test(this.input) ? Di.lastIndex : u;
        }
        lookaheadInLineCharCode() {
          return this.input.charCodeAt(this.nextTokenInLineStart());
        }
        codePointAtPos(u) {
          let a = this.input.charCodeAt(u);
          if ((a & 64512) === 55296 && ++u < this.input.length) {
            let h = this.input.charCodeAt(u);
            (h & 64512) === 56320 && (a = 65536 + ((a & 1023) << 10) + (h & 1023));
          }
          return a;
        }
        setStrict(u) {
          (this.state.strict = u),
            u &&
              (this.state.strictErrors.forEach(([a, h]) => this.raise(a, { at: h })), this.state.strictErrors.clear());
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          if (
            (this.skipSpace(),
            (this.state.start = this.state.pos),
            this.isLookahead || (this.state.startLoc = this.state.curPosition()),
            this.state.pos >= this.length)
          ) {
            this.finishToken(137);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment(u) {
          let a;
          this.isLookahead || (a = this.state.curPosition());
          let h = this.state.pos,
            d = this.input.indexOf(u, h + 2);
          if (d === -1) throw this.raise(T.UnterminatedComment, { at: this.state.curPosition() });
          for (this.state.pos = d + u.length, ya.lastIndex = h + 2; ya.test(this.input) && ya.lastIndex <= d; )
            ++this.state.curLine, (this.state.lineStart = ya.lastIndex);
          if (this.isLookahead) return;
          let D = {
            type: 'CommentBlock',
            value: this.input.slice(h + 2, d),
            start: h,
            end: d + u.length,
            loc: new n(a, this.state.curPosition()),
          };
          return this.options.tokens && this.pushToken(D), D;
        }
        skipLineComment(u) {
          let a = this.state.pos,
            h;
          this.isLookahead || (h = this.state.curPosition());
          let d = this.input.charCodeAt((this.state.pos += u));
          if (this.state.pos < this.length)
            for (; !Ao(d) && ++this.state.pos < this.length; ) d = this.input.charCodeAt(this.state.pos);
          if (this.isLookahead) return;
          let D = this.state.pos,
            A = {
              type: 'CommentLine',
              value: this.input.slice(a + u, D),
              start: a,
              end: D,
              loc: new n(h, this.state.curPosition()),
            };
          return this.options.tokens && this.pushToken(A), A;
        }
        skipSpace() {
          let u = this.state.pos,
            a = [];
          e: for (; this.state.pos < this.length; ) {
            let h = this.input.charCodeAt(this.state.pos);
            switch (h) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    let d = this.skipBlockComment('*/');
                    d !== void 0 && (this.addComment(d), this.options.attachComment && a.push(d));
                    break;
                  }
                  case 47: {
                    let d = this.skipLineComment(2);
                    d !== void 0 && (this.addComment(d), this.options.attachComment && a.push(d));
                    break;
                  }
                  default:
                    break e;
                }
                break;
              default:
                if (Jf(h)) ++this.state.pos;
                else if (h === 45 && !this.inModule && this.options.annexB) {
                  let d = this.state.pos;
                  if (
                    this.input.charCodeAt(d + 1) === 45 &&
                    this.input.charCodeAt(d + 2) === 62 &&
                    (u === 0 || this.state.lineStart > u)
                  ) {
                    let D = this.skipLineComment(3);
                    D !== void 0 && (this.addComment(D), this.options.attachComment && a.push(D));
                  } else break e;
                } else if (h === 60 && !this.inModule && this.options.annexB) {
                  let d = this.state.pos;
                  if (
                    this.input.charCodeAt(d + 1) === 33 &&
                    this.input.charCodeAt(d + 2) === 45 &&
                    this.input.charCodeAt(d + 3) === 45
                  ) {
                    let D = this.skipLineComment(4);
                    D !== void 0 && (this.addComment(D), this.options.attachComment && a.push(D));
                  } else break e;
                } else break e;
            }
          }
          if (a.length > 0) {
            let h = this.state.pos,
              d = { start: u, end: h, comments: a, leadingNode: null, trailingNode: null, containingNode: null };
            this.state.commentStack.push(d);
          }
        }
        finishToken(u, a) {
          (this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition());
          let h = this.state.type;
          (this.state.type = u), (this.state.value = a), this.isLookahead || this.updateContext(h);
        }
        replaceToken(u) {
          (this.state.type = u), this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) return;
          let u = this.state.pos + 1,
            a = this.codePointAtPos(u);
          if (a >= 48 && a <= 57) throw this.raise(T.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
          if (a === 123 || (a === 91 && this.hasPlugin('recordAndTuple'))) {
            if ((this.expectPlugin('recordAndTuple'), this.getPluginOption('recordAndTuple', 'syntaxType') === 'bar'))
              throw this.raise(
                a === 123
                  ? T.RecordExpressionHashIncorrectStartSyntaxType
                  : T.TupleExpressionHashIncorrectStartSyntaxType,
                { at: this.state.curPosition() },
              );
            (this.state.pos += 2), a === 123 ? this.finishToken(7) : this.finishToken(1);
          } else
            hn(a)
              ? (++this.state.pos, this.finishToken(136, this.readWord1(a)))
              : a === 92
              ? (++this.state.pos, this.finishToken(136, this.readWord1()))
              : this.finishOp(27, 1);
        }
        readToken_dot() {
          let u = this.input.charCodeAt(this.state.pos + 1);
          if (u >= 48 && u <= 57) {
            this.readNumber(!0);
            return;
          }
          u === 46 && this.input.charCodeAt(this.state.pos + 2) === 46
            ? ((this.state.pos += 3), this.finishToken(21))
            : (++this.state.pos, this.finishToken(16));
        }
        readToken_slash() {
          this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2) return !1;
          let u = this.input.charCodeAt(this.state.pos + 1);
          if (u !== 33) return !1;
          let a = this.state.pos;
          for (this.state.pos += 1; !Ao(u) && ++this.state.pos < this.length; )
            u = this.input.charCodeAt(this.state.pos);
          let h = this.input.slice(a + 2, this.state.pos);
          return this.finishToken(28, h), !0;
        }
        readToken_mult_modulo(u) {
          let a = u === 42 ? 55 : 54,
            h = 1,
            d = this.input.charCodeAt(this.state.pos + 1);
          u === 42 && d === 42 && (h++, (d = this.input.charCodeAt(this.state.pos + 2)), (a = 57)),
            d === 61 && !this.state.inType && (h++, (a = u === 37 ? 33 : 30)),
            this.finishOp(a, h);
        }
        readToken_pipe_amp(u) {
          let a = this.input.charCodeAt(this.state.pos + 1);
          if (a === u) {
            this.input.charCodeAt(this.state.pos + 2) === 61
              ? this.finishOp(30, 3)
              : this.finishOp(u === 124 ? 41 : 42, 2);
            return;
          }
          if (u === 124) {
            if (a === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin('recordAndTuple') && a === 125) {
              if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                throw this.raise(T.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
              (this.state.pos += 2), this.finishToken(9);
              return;
            }
            if (this.hasPlugin('recordAndTuple') && a === 93) {
              if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                throw this.raise(T.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
              (this.state.pos += 2), this.finishToken(4);
              return;
            }
          }
          if (a === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(u === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          let u = this.input.charCodeAt(this.state.pos + 1);
          u === 61 && !this.state.inType
            ? this.finishOp(32, 2)
            : u === 94 && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }])
            ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected())
            : this.finishOp(44, 1);
        }
        readToken_atSign() {
          this.input.charCodeAt(this.state.pos + 1) === 64 &&
          this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }])
            ? this.finishOp(38, 2)
            : this.finishOp(26, 1);
        }
        readToken_plus_min(u) {
          let a = this.input.charCodeAt(this.state.pos + 1);
          if (a === u) {
            this.finishOp(34, 2);
            return;
          }
          a === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
        }
        readToken_lt() {
          let { pos: u } = this.state,
            a = this.input.charCodeAt(u + 1);
          if (a === 60) {
            if (this.input.charCodeAt(u + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (a === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          let { pos: u } = this.state,
            a = this.input.charCodeAt(u + 1);
          if (a === 62) {
            let h = this.input.charCodeAt(u + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(u + h) === 61) {
              this.finishOp(30, h + 1);
              return;
            }
            this.finishOp(52, h);
            return;
          }
          if (a === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(u) {
          let a = this.input.charCodeAt(this.state.pos + 1);
          if (a === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (u === 61 && a === 62) {
            (this.state.pos += 2), this.finishToken(19);
            return;
          }
          this.finishOp(u === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          let u = this.input.charCodeAt(this.state.pos + 1),
            a = this.input.charCodeAt(this.state.pos + 2);
          u === 63
            ? a === 61
              ? this.finishOp(30, 3)
              : this.finishOp(40, 2)
            : u === 46 && !(a >= 48 && a <= 57)
            ? ((this.state.pos += 2), this.finishToken(18))
            : (++this.state.pos, this.finishToken(17));
        }
        getTokenFromCode(u) {
          switch (u) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos, this.finishToken(10);
              return;
            case 41:
              ++this.state.pos, this.finishToken(11);
              return;
            case 59:
              ++this.state.pos, this.finishToken(13);
              return;
            case 44:
              ++this.state.pos, this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                  throw this.raise(T.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                (this.state.pos += 2), this.finishToken(2);
              } else ++this.state.pos, this.finishToken(0);
              return;
            case 93:
              ++this.state.pos, this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                  throw this.raise(T.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                (this.state.pos += 2), this.finishToken(6);
              } else ++this.state.pos, this.finishToken(5);
              return;
            case 125:
              ++this.state.pos, this.finishToken(8);
              return;
            case 58:
              this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58
                ? this.finishOp(15, 2)
                : (++this.state.pos, this.finishToken(14));
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              let a = this.input.charCodeAt(this.state.pos + 1);
              if (a === 120 || a === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (a === 111 || a === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (a === 98 || a === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(!1);
              return;
            case 34:
            case 39:
              this.readString(u);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(u);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(u);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(u);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(u);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (hn(u)) {
                this.readWord(u);
                return;
              }
          }
          throw this.raise(T.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(u),
          });
        }
        finishOp(u, a) {
          let h = this.input.slice(this.state.pos, this.state.pos + a);
          (this.state.pos += a), this.finishToken(u, h);
        }
        readRegexp() {
          let u = this.state.startLoc,
            a = this.state.start + 1,
            h,
            d,
            { pos: D } = this.state;
          for (; ; ++D) {
            if (D >= this.length) throw this.raise(T.UnterminatedRegExp, { at: i(u, 1) });
            let R = this.input.charCodeAt(D);
            if (Ao(R)) throw this.raise(T.UnterminatedRegExp, { at: i(u, 1) });
            if (h) h = !1;
            else {
              if (R === 91) d = !0;
              else if (R === 93 && d) d = !1;
              else if (R === 47 && !d) break;
              h = R === 92;
            }
          }
          let A = this.input.slice(a, D);
          ++D;
          let P = '',
            N = () => i(u, D + 2 - a);
          for (; D < this.length; ) {
            let R = this.codePointAtPos(D),
              _ = String.fromCharCode(R);
            if (Ca.has(R))
              R === 118
                ? P.includes('u') && this.raise(T.IncompatibleRegExpUVFlags, { at: N() })
                : R === 117 && P.includes('v') && this.raise(T.IncompatibleRegExpUVFlags, { at: N() }),
                P.includes(_) && this.raise(T.DuplicateRegExpFlags, { at: N() });
            else if (pn(R) || R === 92) this.raise(T.MalformedRegExpFlags, { at: N() });
            else break;
            ++D, (P += _);
          }
          (this.state.pos = D), this.finishToken(135, { pattern: A, flags: P });
        }
        readInt(u, a, h = !1, d = !0) {
          let { n: D, pos: A } = $l(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            u,
            a,
            h,
            d,
            this.errorHandlers_readInt,
            !1,
          );
          return (this.state.pos = A), D;
        }
        readRadixNumber(u) {
          let a = this.state.curPosition(),
            h = !1;
          this.state.pos += 2;
          let d = this.readInt(u);
          d == null && this.raise(T.InvalidDigit, { at: i(a, 2), radix: u });
          let D = this.input.charCodeAt(this.state.pos);
          if (D === 110) ++this.state.pos, (h = !0);
          else if (D === 109) throw this.raise(T.InvalidDecimal, { at: a });
          if (hn(this.codePointAtPos(this.state.pos)))
            throw this.raise(T.NumberIdentifier, { at: this.state.curPosition() });
          if (h) {
            let A = this.input.slice(a.index, this.state.pos).replace(/[_n]/g, '');
            this.finishToken(133, A);
            return;
          }
          this.finishToken(132, d);
        }
        readNumber(u) {
          let a = this.state.pos,
            h = this.state.curPosition(),
            d = !1,
            D = !1,
            A = !1,
            P = !1,
            N = !1;
          !u && this.readInt(10) === null && this.raise(T.InvalidNumber, { at: this.state.curPosition() });
          let R = this.state.pos - a >= 2 && this.input.charCodeAt(a) === 48;
          if (R) {
            let Ie = this.input.slice(a, this.state.pos);
            if ((this.recordStrictModeErrors(T.StrictOctalLiteral, { at: h }), !this.state.strict)) {
              let _e = Ie.indexOf('_');
              _e > 0 && this.raise(T.ZeroDigitNumericSeparator, { at: i(h, _e) });
            }
            N = R && !/[89]/.test(Ie);
          }
          let _ = this.input.charCodeAt(this.state.pos);
          if (
            (_ === 46 &&
              !N &&
              (++this.state.pos, this.readInt(10), (d = !0), (_ = this.input.charCodeAt(this.state.pos))),
            (_ === 69 || _ === 101) &&
              !N &&
              ((_ = this.input.charCodeAt(++this.state.pos)),
              (_ === 43 || _ === 45) && ++this.state.pos,
              this.readInt(10) === null && this.raise(T.InvalidOrMissingExponent, { at: h }),
              (d = !0),
              (P = !0),
              (_ = this.input.charCodeAt(this.state.pos))),
            _ === 110 && ((d || R) && this.raise(T.InvalidBigIntLiteral, { at: h }), ++this.state.pos, (D = !0)),
            _ === 109 &&
              (this.expectPlugin('decimal', this.state.curPosition()),
              (P || R) && this.raise(T.InvalidDecimal, { at: h }),
              ++this.state.pos,
              (A = !0)),
            hn(this.codePointAtPos(this.state.pos)))
          )
            throw this.raise(T.NumberIdentifier, { at: this.state.curPosition() });
          let ue = this.input.slice(a, this.state.pos).replace(/[_mn]/g, '');
          if (D) {
            this.finishToken(133, ue);
            return;
          }
          if (A) {
            this.finishToken(134, ue);
            return;
          }
          let ve = N ? parseInt(ue, 8) : parseFloat(ue);
          this.finishToken(132, ve);
        }
        readCodePoint(u) {
          let { code: a, pos: h } = kc(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            u,
            this.errorHandlers_readCodePoint,
          );
          return (this.state.pos = h), a;
        }
        readString(u) {
          let {
            str: a,
            pos: h,
            curLine: d,
            lineStart: D,
          } = jl(
            u === 34 ? 'double' : 'single',
            this.input,
            this.state.pos + 1,
            this.state.lineStart,
            this.state.curLine,
            this.errorHandlers_readStringContents_string,
          );
          (this.state.pos = h + 1), (this.state.lineStart = D), (this.state.curLine = d), this.finishToken(131, a);
        }
        readTemplateContinuation() {
          this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
        }
        readTemplateToken() {
          let u = this.input[this.state.pos],
            {
              str: a,
              firstInvalidLoc: h,
              pos: d,
              curLine: D,
              lineStart: A,
            } = jl(
              'template',
              this.input,
              this.state.pos + 1,
              this.state.lineStart,
              this.state.curLine,
              this.errorHandlers_readStringContents_template,
            );
          (this.state.pos = d + 1),
            (this.state.lineStart = A),
            (this.state.curLine = D),
            h && (this.state.firstInvalidTemplateEscapePos = new r(h.curLine, h.pos - h.lineStart, h.pos)),
            this.input.codePointAt(d) === 96
              ? this.finishToken(24, h ? null : u + a + '`')
              : (this.state.pos++, this.finishToken(25, h ? null : u + a + '${'));
        }
        recordStrictModeErrors(u, { at: a }) {
          let h = a.index;
          this.state.strict && !this.state.strictErrors.has(h)
            ? this.raise(u, { at: a })
            : this.state.strictErrors.set(h, [u, a]);
        }
        readWord1(u) {
          this.state.containsEsc = !1;
          let a = '',
            h = this.state.pos,
            d = this.state.pos;
          for (u !== void 0 && (this.state.pos += u <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
            let D = this.codePointAtPos(this.state.pos);
            if (pn(D)) this.state.pos += D <= 65535 ? 1 : 2;
            else if (D === 92) {
              (this.state.containsEsc = !0), (a += this.input.slice(d, this.state.pos));
              let A = this.state.curPosition(),
                P = this.state.pos === h ? hn : pn;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(T.MissingUnicodeEscape, { at: this.state.curPosition() }), (d = this.state.pos - 1);
                continue;
              }
              ++this.state.pos;
              let N = this.readCodePoint(!0);
              N !== null &&
                (P(N) || this.raise(T.EscapedCharNotAnIdentifier, { at: A }), (a += String.fromCodePoint(N))),
                (d = this.state.pos);
            } else break;
          }
          return a + this.input.slice(d, this.state.pos);
        }
        readWord(u) {
          let a = this.readWord1(u),
            h = ce.get(a);
          h !== void 0 ? this.finishToken(h, et(h)) : this.finishToken(130, a);
        }
        checkKeywordEscapes() {
          let { type: u } = this.state;
          Fe(u) &&
            this.state.containsEsc &&
            this.raise(T.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: et(u) });
        }
        raise(u, a) {
          let { at: h } = a,
            d = e(a, Yf),
            D = h instanceof r ? h : h.loc.start,
            A = u({ loc: D, details: d });
          if (!this.options.errorRecovery) throw A;
          return this.isLookahead || this.state.errors.push(A), A;
        }
        raiseOverwrite(u, a) {
          let { at: h } = a,
            d = e(a, Vl),
            D = h instanceof r ? h : h.loc.start,
            A = D.index,
            P = this.state.errors;
          for (let N = P.length - 1; N >= 0; N--) {
            let R = P[N];
            if (R.loc.index === A) return (P[N] = u({ loc: D, details: d }));
            if (R.loc.index < A) break;
          }
          return this.raise(u, a);
        }
        updateContext(u) {}
        unexpected(u, a) {
          throw this.raise(T.UnexpectedToken, { expected: a ? et(a) : null, at: u ?? this.state.startLoc });
        }
        expectPlugin(u, a) {
          if (this.hasPlugin(u)) return !0;
          throw this.raise(T.MissingPlugin, { at: a ?? this.state.startLoc, missingPlugin: [u] });
        }
        expectOnePlugin(u) {
          if (!u.some((a) => this.hasPlugin(a)))
            throw this.raise(T.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: u });
        }
        errorBuilder(u) {
          return (a, h, d) => {
            this.raise(u, { at: Gi(a, h, d) });
          };
        }
      },
      Qf = class {
        constructor() {
          (this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map());
        }
      },
      Zf = class {
        constructor(u) {
          (this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = u);
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new Qf());
        }
        exit() {
          let u = this.stack.pop(),
            a = this.current();
          for (let [h, d] of Array.from(u.undefinedPrivateNames))
            a
              ? a.undefinedPrivateNames.has(h) || a.undefinedPrivateNames.set(h, d)
              : this.parser.raise(T.InvalidPrivateFieldResolution, { at: d, identifierName: h });
        }
        declarePrivateName(u, a, h) {
          let { privateNames: d, loneAccessors: D, undefinedPrivateNames: A } = this.current(),
            P = d.has(u);
          if (a & 3) {
            let N = P && D.get(u);
            if (N) {
              let R = N & 4,
                _ = a & 4,
                ue = N & 3,
                ve = a & 3;
              (P = ue === ve || R !== _), P || D.delete(u);
            } else P || D.set(u, a);
          }
          P && this.parser.raise(T.PrivateNameRedeclaration, { at: h, identifierName: u }), d.add(u), A.delete(u);
        }
        usePrivateName(u, a) {
          let h;
          for (h of this.stack) if (h.privateNames.has(u)) return;
          h
            ? h.undefinedPrivateNames.set(u, a)
            : this.parser.raise(T.InvalidPrivateFieldResolution, { at: a, identifierName: u });
        }
      },
      xs = class {
        constructor(u = 0) {
          this.type = u;
        }
        canBeArrowParameterDeclaration() {
          return this.type === 2 || this.type === 1;
        }
        isCertainlyParameterDeclaration() {
          return this.type === 3;
        }
      },
      zl = class extends xs {
        constructor(u) {
          super(u), (this.declarationErrors = new Map());
        }
        recordDeclarationError(u, { at: a }) {
          let h = a.index;
          this.declarationErrors.set(h, [u, a]);
        }
        clearDeclarationError(u) {
          this.declarationErrors.delete(u);
        }
        iterateErrors(u) {
          this.declarationErrors.forEach(u);
        }
      },
      Pc = class {
        constructor(u) {
          (this.parser = void 0), (this.stack = [new xs()]), (this.parser = u);
        }
        enter(u) {
          this.stack.push(u);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(u, { at: a }) {
          let h = { at: a.loc.start },
            { stack: d } = this,
            D = d.length - 1,
            A = d[D];
          for (; !A.isCertainlyParameterDeclaration(); ) {
            if (A.canBeArrowParameterDeclaration()) A.recordDeclarationError(u, h);
            else return;
            A = d[--D];
          }
          this.parser.raise(u, h);
        }
        recordArrowParameterBindingError(u, { at: a }) {
          let { stack: h } = this,
            d = h[h.length - 1],
            D = { at: a.loc.start };
          if (d.isCertainlyParameterDeclaration()) this.parser.raise(u, D);
          else if (d.canBeArrowParameterDeclaration()) d.recordDeclarationError(u, D);
          else return;
        }
        recordAsyncArrowParametersError({ at: u }) {
          let { stack: a } = this,
            h = a.length - 1,
            d = a[h];
          for (; d.canBeArrowParameterDeclaration(); )
            d.type === 2 && d.recordDeclarationError(T.AwaitBindingIdentifier, { at: u }), (d = a[--h]);
        }
        validateAsPattern() {
          let { stack: u } = this,
            a = u[u.length - 1];
          a.canBeArrowParameterDeclaration() &&
            a.iterateErrors(([h, d]) => {
              this.parser.raise(h, { at: d });
              let D = u.length - 2,
                A = u[D];
              for (; A.canBeArrowParameterDeclaration(); ) A.clearDeclarationError(d.index), (A = u[--D]);
            });
        }
      };
    function ed() {
      return new xs(3);
    }
    function Bc() {
      return new zl(1);
    }
    function td() {
      return new zl(2);
    }
    function Ic() {
      return new xs();
    }
    var Cs = 0,
      Hl = 1,
      ba = 2,
      Nc = 4,
      bs = 8,
      As = class {
        constructor() {
          this.stacks = [];
        }
        enter(u) {
          this.stacks.push(u);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & ba) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & Hl) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & Nc) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & bs) > 0;
        }
      };
    function Eo(u, a) {
      return (u ? ba : 0) | (a ? Hl : 0);
    }
    var rd = class extends Gn {
        addExtra(u, a, h, d = !0) {
          if (!u) return;
          let D = (u.extra = u.extra || {});
          d ? (D[a] = h) : Object.defineProperty(D, a, { enumerable: d, value: h });
        }
        isContextual(u) {
          return this.state.type === u && !this.state.containsEsc;
        }
        isUnparsedContextual(u, a) {
          let h = u + a.length;
          if (this.input.slice(u, h) === a) {
            let d = this.input.charCodeAt(h);
            return !(pn(d) || (d & 64512) === 55296);
          }
          return !1;
        }
        isLookaheadContextual(u) {
          let a = this.nextTokenStart();
          return this.isUnparsedContextual(a, u);
        }
        eatContextual(u) {
          return this.isContextual(u) ? (this.next(), !0) : !1;
        }
        expectContextual(u, a) {
          if (!this.eatContextual(u)) {
            if (a != null) throw this.raise(a, { at: this.state.startLoc });
            this.unexpected(null, u);
          }
        }
        canInsertSemicolon() {
          return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return wc.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          return (Rl.lastIndex = this.state.end), Rl.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(u = !0) {
          (u ? this.isLineTerminator() : this.eat(13)) ||
            this.raise(T.MissingSemicolon, { at: this.state.lastTokEndLoc });
        }
        expect(u, a) {
          this.eat(u) || this.unexpected(a, u);
        }
        tryParse(u, a = this.state.clone()) {
          let h = { node: null };
          try {
            let d = u((D = null) => {
              throw ((h.node = D), h);
            });
            if (this.state.errors.length > a.errors.length) {
              let D = this.state;
              return (
                (this.state = a),
                (this.state.tokensLength = D.tokensLength),
                { node: d, error: D.errors[a.errors.length], thrown: !1, aborted: !1, failState: D }
              );
            }
            return { node: d, error: null, thrown: !1, aborted: !1, failState: null };
          } catch (d) {
            let D = this.state;
            if (((this.state = a), d instanceof SyntaxError))
              return { node: null, error: d, thrown: !0, aborted: !1, failState: D };
            if (d === h) return { node: h.node, error: null, thrown: !1, aborted: !0, failState: D };
            throw d;
          }
        }
        checkExpressionErrors(u, a) {
          if (!u) return !1;
          let { shorthandAssignLoc: h, doubleProtoLoc: d, privateKeyLoc: D, optionalParametersLoc: A } = u,
            P = !!h || !!d || !!A || !!D;
          if (!a) return P;
          h != null && this.raise(T.InvalidCoverInitializedName, { at: h }),
            d != null && this.raise(T.DuplicateProto, { at: d }),
            D != null && this.raise(T.UnexpectedPrivateField, { at: D }),
            A != null && this.unexpected(A);
        }
        isLiteralPropertyName() {
          return V(this.state.type);
        }
        isPrivateName(u) {
          return u.type === 'PrivateName';
        }
        getPrivateNameSV(u) {
          return u.id.name;
        }
        hasPropertyAsPrivateName(u) {
          return (
            (u.type === 'MemberExpression' || u.type === 'OptionalMemberExpression') && this.isPrivateName(u.property)
          );
        }
        isObjectProperty(u) {
          return u.type === 'ObjectProperty';
        }
        isObjectMethod(u) {
          return u.type === 'ObjectMethod';
        }
        initializeScopes(u = this.options.sourceType === 'module') {
          let a = this.state.labels;
          this.state.labels = [];
          let h = this.exportedIdentifiers;
          this.exportedIdentifiers = new Set();
          let d = this.inModule;
          this.inModule = u;
          let D = this.scope,
            A = this.getScopeHandler();
          this.scope = new A(this, u);
          let P = this.prodParam;
          this.prodParam = new As();
          let N = this.classScope;
          this.classScope = new Zf(this);
          let R = this.expressionScope;
          return (
            (this.expressionScope = new Pc(this)),
            () => {
              (this.state.labels = a),
                (this.exportedIdentifiers = h),
                (this.inModule = d),
                (this.scope = D),
                (this.prodParam = P),
                (this.classScope = N),
                (this.expressionScope = R);
            }
          );
        }
        enterInitialScopes() {
          let u = Cs;
          this.inModule && (u |= ba), this.scope.enter(1), this.prodParam.enter(u);
        }
        checkDestructuringPrivate(u) {
          let { privateKeyLoc: a } = u;
          a !== null && this.expectPlugin('destructuringPrivate', a);
        }
      },
      Yn = class {
        constructor() {
          (this.shorthandAssignLoc = null),
            (this.doubleProtoLoc = null),
            (this.privateKeyLoc = null),
            (this.optionalParametersLoc = null);
        }
      },
      vo = class {
        constructor(u, a, h) {
          (this.type = ''),
            (this.start = a),
            (this.end = 0),
            (this.loc = new n(h)),
            u != null && u.options.ranges && (this.range = [a, 0]),
            u != null && u.filename && (this.loc.filename = u.filename);
        }
      },
      Es = vo.prototype;
    Es.__clone = function () {
      let u = new vo(void 0, this.start, this.loc.start),
        a = Object.keys(this);
      for (let h = 0, d = a.length; h < d; h++) {
        let D = a[h];
        D !== 'leadingComments' && D !== 'trailingComments' && D !== 'innerComments' && (u[D] = this[D]);
      }
      return u;
    };
    function Mc(u) {
      return Qn(u);
    }
    function Qn(u) {
      let { type: a, start: h, end: d, loc: D, range: A, extra: P, name: N } = u,
        R = Object.create(Es);
      return (
        (R.type = a),
        (R.start = h),
        (R.end = d),
        (R.loc = D),
        (R.range = A),
        (R.extra = P),
        (R.name = N),
        a === 'Placeholder' && (R.expectedNode = u.expectedNode),
        R
      );
    }
    function Oc(u) {
      let { type: a, start: h, end: d, loc: D, range: A, extra: P } = u;
      if (a === 'Placeholder') return Mc(u);
      let N = Object.create(Es);
      return (
        (N.type = a),
        (N.start = h),
        (N.end = d),
        (N.loc = D),
        (N.range = A),
        u.raw !== void 0 ? (N.raw = u.raw) : (N.extra = P),
        (N.value = u.value),
        N
      );
    }
    var Lc = class extends rd {
        startNode() {
          return new vo(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(u) {
          return new vo(this, u.index, u);
        }
        startNodeAtNode(u) {
          return this.startNodeAt(u.loc.start);
        }
        finishNode(u, a) {
          return this.finishNodeAt(u, a, this.state.lastTokEndLoc);
        }
        finishNodeAt(u, a, h) {
          return (
            (u.type = a),
            (u.end = h.index),
            (u.loc.end = h),
            this.options.ranges && (u.range[1] = h.index),
            this.options.attachComment && this.processComment(u),
            u
          );
        }
        resetStartLocation(u, a) {
          (u.start = a.index), (u.loc.start = a), this.options.ranges && (u.range[0] = a.index);
        }
        resetEndLocation(u, a = this.state.lastTokEndLoc) {
          (u.end = a.index), (u.loc.end = a), this.options.ranges && (u.range[1] = a.index);
        }
        resetStartLocationFromNode(u, a) {
          this.resetStartLocation(u, a.loc.start);
        }
      },
      _c = new Set([
        '_',
        'any',
        'bool',
        'boolean',
        'empty',
        'extends',
        'false',
        'interface',
        'mixed',
        'null',
        'number',
        'static',
        'string',
        'true',
        'typeof',
        'void',
      ]),
      Ye = I`flow`({
        AmbiguousConditionalArrow: 'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.',
        AmbiguousDeclareModuleKind:
          'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.',
        AssignReservedType: ({ reservedType: u }) => `Cannot overwrite reserved type ${u}.`,
        DeclareClassElement: 'The `declare` modifier can only appear on class fields.',
        DeclareClassFieldInitializer: 'Initializers are not allowed in fields with the `declare` modifier.',
        DuplicateDeclareModuleExports: 'Duplicate `declare module.exports` statement.',
        EnumBooleanMemberNotInitialized: ({ memberName: u, enumName: a }) =>
          `Boolean enum members need to be initialized. Use either \`${u} = true,\` or \`${u} = false,\` in enum \`${a}\`.`,
        EnumDuplicateMemberName: ({ memberName: u, enumName: a }) =>
          `Enum member names need to be unique, but the name \`${u}\` has already been used before in enum \`${a}\`.`,
        EnumInconsistentMemberValues: ({ enumName: u }) =>
          `Enum \`${u}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({ invalidEnumType: u, enumName: a }) =>
          `Enum type \`${u}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: u }) =>
          `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${u}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({ enumName: u, memberName: a, explicitType: h }) =>
          `Enum \`${u}\` has type \`${h}\`, so the initializer of \`${a}\` needs to be a ${h} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({ enumName: u, memberName: a }) =>
          `Symbol enum members cannot be initialized. Use \`${a},\` in enum \`${u}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({ enumName: u, memberName: a }) =>
          `The enum member initializer for \`${a}\` needs to be a literal (either a boolean, number, or string) in enum \`${u}\`.`,
        EnumInvalidMemberName: ({ enumName: u, memberName: a, suggestion: h }) =>
          `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${a}\`, consider using \`${h}\`, in enum \`${u}\`.`,
        EnumNumberMemberNotInitialized: ({ enumName: u, memberName: a }) =>
          `Number enum members need to be initialized, e.g. \`${a} = 1\` in enum \`${u}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({ enumName: u }) =>
          `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${u}\`.`,
        GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.',
        ImportReflectionHasImportType: 'An `import module` declaration can not use `type` or `typeof` keyword.',
        ImportTypeShorthandOnlyInPureImport:
          'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.',
        InexactInsideExact: 'Explicit inexact syntax cannot appear inside an explicit exact object type.',
        InexactInsideNonObject: 'Explicit inexact syntax cannot appear in class or interface definitions.',
        InexactVariance: 'Explicit inexact syntax cannot have variance.',
        InvalidNonTypeImportInDeclareModule:
          'Imports within a `declare module` body must always be `import type` or `import typeof`.',
        MissingTypeParamDefault:
          'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.',
        NestedDeclareModule: '`declare module` cannot be used inside another `declare module`.',
        NestedFlowComment: 'Cannot have a flow comment inside another flow comment.',
        PatternIsOptional: Object.assign(
          { message: 'A binding pattern parameter cannot be optional in an implementation signature.' },
          { reasonCode: 'OptionalBindingPattern' },
        ),
        SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.',
        SpreadVariance: 'Spread properties cannot have variance.',
        ThisParamAnnotationRequired: 'A type annotation is required for the `this` parameter.',
        ThisParamBannedInConstructor:
          "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.',
        ThisParamMustBeFirst: 'The `this` parameter must be the first function parameter.',
        ThisParamNoDefault: 'The `this` parameter may not have a default value.',
        TypeBeforeInitializer:
          'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
        TypeCastInPattern: 'The type cast expression is expected to be wrapped with parenthesis.',
        UnexpectedExplicitInexactInObject: 'Explicit inexact syntax must appear at the end of an inexact object.',
        UnexpectedReservedType: ({ reservedType: u }) => `Unexpected reserved type ${u}.`,
        UnexpectedReservedUnderscore: '`_` is only allowed as a type argument to call or new.',
        UnexpectedSpaceBetweenModuloChecks: 'Spaces between `%` and `checks` are not allowed here.',
        UnexpectedSpreadType: 'Spread operator cannot appear in class or interface definitions.',
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: 'Expected an arrow function after this type parameter declaration.',
        UnexpectedTypeParameterBeforeAsyncArrowFunction:
          'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.',
        UnsupportedDeclareExportKind: ({ unsupportedExportKind: u, suggestion: a }) =>
          `\`declare export ${u}\` is not supported. Use \`${a}\` instead.`,
        UnsupportedStatementInDeclareModule: 'Only declares and type imports are allowed inside declare module.',
        UnterminatedFlowComment: 'Unterminated flow-comment.',
      });
    function Wl(u) {
      return (
        u.type === 'DeclareExportAllDeclaration' ||
        (u.type === 'DeclareExportDeclaration' &&
          (!u.declaration || (u.declaration.type !== 'TypeAlias' && u.declaration.type !== 'InterfaceDeclaration')))
      );
    }
    function Ul(u) {
      return u.importKind === 'type' || u.importKind === 'typeof';
    }
    var nd = {
      const: 'declare export var',
      let: 'declare export var',
      type: 'export type',
      interface: 'export interface',
    };
    function Rc(u, a) {
      let h = [],
        d = [];
      for (let D = 0; D < u.length; D++) (a(u[D], D, u) ? h : d).push(u[D]);
      return [h, d];
    }
    var id = /\*?\s*@((?:no)?flow)\b/,
      sd = (u) =>
        class extends u {
          constructor(...a) {
            super(...a), (this.flowPragma = void 0);
          }
          getScopeHandler() {
            return Ll;
          }
          shouldParseTypes() {
            return this.getPluginOption('flow', 'all') || this.flowPragma === 'flow';
          }
          shouldParseEnums() {
            return !!this.getPluginOption('flow', 'enums');
          }
          finishToken(a, h) {
            a !== 131 && a !== 13 && a !== 28 && this.flowPragma === void 0 && (this.flowPragma = null),
              super.finishToken(a, h);
          }
          addComment(a) {
            if (this.flowPragma === void 0) {
              let h = id.exec(a.value);
              if (h)
                if (h[1] === 'flow') this.flowPragma = 'flow';
                else if (h[1] === 'noflow') this.flowPragma = 'noflow';
                else throw new Error('Unexpected flow pragma');
            }
            super.addComment(a);
          }
          flowParseTypeInitialiser(a) {
            let h = this.state.inType;
            (this.state.inType = !0), this.expect(a || 14);
            let d = this.flowParseType();
            return (this.state.inType = h), d;
          }
          flowParsePredicate() {
            let a = this.startNode(),
              h = this.state.startLoc;
            return (
              this.next(),
              this.expectContextual(108),
              this.state.lastTokStart > h.index + 1 && this.raise(Ye.UnexpectedSpaceBetweenModuloChecks, { at: h }),
              this.eat(10)
                ? ((a.value = super.parseExpression()), this.expect(11), this.finishNode(a, 'DeclaredPredicate'))
                : this.finishNode(a, 'InferredPredicate')
            );
          }
          flowParseTypeAndPredicateInitialiser() {
            let a = this.state.inType;
            (this.state.inType = !0), this.expect(14);
            let h = null,
              d = null;
            return (
              this.match(54)
                ? ((this.state.inType = a), (d = this.flowParsePredicate()))
                : ((h = this.flowParseType()),
                  (this.state.inType = a),
                  this.match(54) && (d = this.flowParsePredicate())),
              [h, d]
            );
          }
          flowParseDeclareClass(a) {
            return this.next(), this.flowParseInterfaceish(a, !0), this.finishNode(a, 'DeclareClass');
          }
          flowParseDeclareFunction(a) {
            this.next();
            let h = (a.id = this.parseIdentifier()),
              d = this.startNode(),
              D = this.startNode();
            this.match(47) ? (d.typeParameters = this.flowParseTypeParameterDeclaration()) : (d.typeParameters = null),
              this.expect(10);
            let A = this.flowParseFunctionTypeParams();
            return (
              (d.params = A.params),
              (d.rest = A.rest),
              (d.this = A._this),
              this.expect(11),
              ([d.returnType, a.predicate] = this.flowParseTypeAndPredicateInitialiser()),
              (D.typeAnnotation = this.finishNode(d, 'FunctionTypeAnnotation')),
              (h.typeAnnotation = this.finishNode(D, 'TypeAnnotation')),
              this.resetEndLocation(h),
              this.semicolon(),
              this.scope.declareName(a.id.name, 2048, a.id.loc.start),
              this.finishNode(a, 'DeclareFunction')
            );
          }
          flowParseDeclare(a, h) {
            if (this.match(80)) return this.flowParseDeclareClass(a);
            if (this.match(68)) return this.flowParseDeclareFunction(a);
            if (this.match(74)) return this.flowParseDeclareVariable(a);
            if (this.eatContextual(125))
              return this.match(16)
                ? this.flowParseDeclareModuleExports(a)
                : (h && this.raise(Ye.NestedDeclareModule, { at: this.state.lastTokStartLoc }),
                  this.flowParseDeclareModule(a));
            if (this.isContextual(128)) return this.flowParseDeclareTypeAlias(a);
            if (this.isContextual(129)) return this.flowParseDeclareOpaqueType(a);
            if (this.isContextual(127)) return this.flowParseDeclareInterface(a);
            if (this.match(82)) return this.flowParseDeclareExportDeclaration(a, h);
            this.unexpected();
          }
          flowParseDeclareVariable(a) {
            return (
              this.next(),
              (a.id = this.flowParseTypeAnnotatableIdentifier(!0)),
              this.scope.declareName(a.id.name, 5, a.id.loc.start),
              this.semicolon(),
              this.finishNode(a, 'DeclareVariable')
            );
          }
          flowParseDeclareModule(a) {
            this.scope.enter(0), this.match(131) ? (a.id = super.parseExprAtom()) : (a.id = this.parseIdentifier());
            let h = (a.body = this.startNode()),
              d = (h.body = []);
            for (this.expect(5); !this.match(8); ) {
              let P = this.startNode();
              this.match(83)
                ? (this.next(),
                  !this.isContextual(128) &&
                    !this.match(87) &&
                    this.raise(Ye.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }),
                  super.parseImport(P))
                : (this.expectContextual(123, Ye.UnsupportedStatementInDeclareModule),
                  (P = this.flowParseDeclare(P, !0))),
                d.push(P);
            }
            this.scope.exit(), this.expect(8), this.finishNode(h, 'BlockStatement');
            let D = null,
              A = !1;
            return (
              d.forEach((P) => {
                Wl(P)
                  ? (D === 'CommonJS' && this.raise(Ye.AmbiguousDeclareModuleKind, { at: P }), (D = 'ES'))
                  : P.type === 'DeclareModuleExports' &&
                    (A && this.raise(Ye.DuplicateDeclareModuleExports, { at: P }),
                    D === 'ES' && this.raise(Ye.AmbiguousDeclareModuleKind, { at: P }),
                    (D = 'CommonJS'),
                    (A = !0));
              }),
              (a.kind = D || 'CommonJS'),
              this.finishNode(a, 'DeclareModule')
            );
          }
          flowParseDeclareExportDeclaration(a, h) {
            if ((this.expect(82), this.eat(65)))
              return (
                this.match(68) || this.match(80)
                  ? (a.declaration = this.flowParseDeclare(this.startNode()))
                  : ((a.declaration = this.flowParseType()), this.semicolon()),
                (a.default = !0),
                this.finishNode(a, 'DeclareExportDeclaration')
              );
            if (this.match(75) || this.isLet() || ((this.isContextual(128) || this.isContextual(127)) && !h)) {
              let d = this.state.value;
              throw this.raise(Ye.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: d,
                suggestion: nd[d],
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129))
              return (
                (a.declaration = this.flowParseDeclare(this.startNode())),
                (a.default = !1),
                this.finishNode(a, 'DeclareExportDeclaration')
              );
            if (
              this.match(55) ||
              this.match(5) ||
              this.isContextual(127) ||
              this.isContextual(128) ||
              this.isContextual(129)
            )
              return (
                (a = this.parseExport(a, null)),
                a.type === 'ExportNamedDeclaration' &&
                  ((a.type = 'ExportDeclaration'), (a.default = !1), delete a.exportKind),
                (a.type = 'Declare' + a.type),
                a
              );
            this.unexpected();
          }
          flowParseDeclareModuleExports(a) {
            return (
              this.next(),
              this.expectContextual(109),
              (a.typeAnnotation = this.flowParseTypeAnnotation()),
              this.semicolon(),
              this.finishNode(a, 'DeclareModuleExports')
            );
          }
          flowParseDeclareTypeAlias(a) {
            this.next();
            let h = this.flowParseTypeAlias(a);
            return (h.type = 'DeclareTypeAlias'), h;
          }
          flowParseDeclareOpaqueType(a) {
            this.next();
            let h = this.flowParseOpaqueType(a, !0);
            return (h.type = 'DeclareOpaqueType'), h;
          }
          flowParseDeclareInterface(a) {
            return this.next(), this.flowParseInterfaceish(a, !1), this.finishNode(a, 'DeclareInterface');
          }
          flowParseInterfaceish(a, h) {
            if (
              ((a.id = this.flowParseRestrictedIdentifier(!h, !0)),
              this.scope.declareName(a.id.name, h ? 17 : 8201, a.id.loc.start),
              this.match(47)
                ? (a.typeParameters = this.flowParseTypeParameterDeclaration())
                : (a.typeParameters = null),
              (a.extends = []),
              this.eat(81))
            )
              do a.extends.push(this.flowParseInterfaceExtends());
              while (!h && this.eat(12));
            if (h) {
              if (((a.implements = []), (a.mixins = []), this.eatContextual(115)))
                do a.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              if (this.eatContextual(111))
                do a.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
            }
            a.body = this.flowParseObjectType({
              allowStatic: h,
              allowExact: !1,
              allowSpread: !1,
              allowProto: h,
              allowInexact: !1,
            });
          }
          flowParseInterfaceExtends() {
            let a = this.startNode();
            return (
              (a.id = this.flowParseQualifiedTypeIdentifier()),
              this.match(47)
                ? (a.typeParameters = this.flowParseTypeParameterInstantiation())
                : (a.typeParameters = null),
              this.finishNode(a, 'InterfaceExtends')
            );
          }
          flowParseInterface(a) {
            return this.flowParseInterfaceish(a, !1), this.finishNode(a, 'InterfaceDeclaration');
          }
          checkNotUnderscore(a) {
            a === '_' && this.raise(Ye.UnexpectedReservedUnderscore, { at: this.state.startLoc });
          }
          checkReservedType(a, h, d) {
            _c.has(a) && this.raise(d ? Ye.AssignReservedType : Ye.UnexpectedReservedType, { at: h, reservedType: a });
          }
          flowParseRestrictedIdentifier(a, h) {
            return this.checkReservedType(this.state.value, this.state.startLoc, h), this.parseIdentifier(a);
          }
          flowParseTypeAlias(a) {
            return (
              (a.id = this.flowParseRestrictedIdentifier(!1, !0)),
              this.scope.declareName(a.id.name, 8201, a.id.loc.start),
              this.match(47)
                ? (a.typeParameters = this.flowParseTypeParameterDeclaration())
                : (a.typeParameters = null),
              (a.right = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(a, 'TypeAlias')
            );
          }
          flowParseOpaqueType(a, h) {
            return (
              this.expectContextual(128),
              (a.id = this.flowParseRestrictedIdentifier(!0, !0)),
              this.scope.declareName(a.id.name, 8201, a.id.loc.start),
              this.match(47)
                ? (a.typeParameters = this.flowParseTypeParameterDeclaration())
                : (a.typeParameters = null),
              (a.supertype = null),
              this.match(14) && (a.supertype = this.flowParseTypeInitialiser(14)),
              (a.impltype = null),
              h || (a.impltype = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(a, 'OpaqueType')
            );
          }
          flowParseTypeParameter(a = !1) {
            let h = this.state.startLoc,
              d = this.startNode(),
              D = this.flowParseVariance(),
              A = this.flowParseTypeAnnotatableIdentifier();
            return (
              (d.name = A.name),
              (d.variance = D),
              (d.bound = A.typeAnnotation),
              this.match(29)
                ? (this.eat(29), (d.default = this.flowParseType()))
                : a && this.raise(Ye.MissingTypeParamDefault, { at: h }),
              this.finishNode(d, 'TypeParameter')
            );
          }
          flowParseTypeParameterDeclaration() {
            let a = this.state.inType,
              h = this.startNode();
            (h.params = []),
              (this.state.inType = !0),
              this.match(47) || this.match(140) ? this.next() : this.unexpected();
            let d = !1;
            do {
              let D = this.flowParseTypeParameter(d);
              h.params.push(D), D.default && (d = !0), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), (this.state.inType = a), this.finishNode(h, 'TypeParameterDeclaration');
          }
          flowParseTypeParameterInstantiation() {
            let a = this.startNode(),
              h = this.state.inType;
            (a.params = []), (this.state.inType = !0), this.expect(47);
            let d = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = !1; !this.match(48); )
              a.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return (
              (this.state.noAnonFunctionType = d),
              this.expect(48),
              (this.state.inType = h),
              this.finishNode(a, 'TypeParameterInstantiation')
            );
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let a = this.startNode(),
              h = this.state.inType;
            for (a.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
              a.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), (this.state.inType = h), this.finishNode(a, 'TypeParameterInstantiation');
          }
          flowParseInterfaceType() {
            let a = this.startNode();
            if ((this.expectContextual(127), (a.extends = []), this.eat(81)))
              do a.extends.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            return (
              (a.body = this.flowParseObjectType({
                allowStatic: !1,
                allowExact: !1,
                allowSpread: !1,
                allowProto: !1,
                allowInexact: !1,
              })),
              this.finishNode(a, 'InterfaceTypeAnnotation')
            );
          }
          flowParseObjectPropertyKey() {
            return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(a, h, d) {
            return (
              (a.static = h),
              this.lookahead().type === 14
                ? ((a.id = this.flowParseObjectPropertyKey()), (a.key = this.flowParseTypeInitialiser()))
                : ((a.id = null), (a.key = this.flowParseType())),
              this.expect(3),
              (a.value = this.flowParseTypeInitialiser()),
              (a.variance = d),
              this.finishNode(a, 'ObjectTypeIndexer')
            );
          }
          flowParseObjectTypeInternalSlot(a, h) {
            return (
              (a.static = h),
              (a.id = this.flowParseObjectPropertyKey()),
              this.expect(3),
              this.expect(3),
              this.match(47) || this.match(10)
                ? ((a.method = !0),
                  (a.optional = !1),
                  (a.value = this.flowParseObjectTypeMethodish(this.startNodeAt(a.loc.start))))
                : ((a.method = !1), this.eat(17) && (a.optional = !0), (a.value = this.flowParseTypeInitialiser())),
              this.finishNode(a, 'ObjectTypeInternalSlot')
            );
          }
          flowParseObjectTypeMethodish(a) {
            for (
              a.params = [],
                a.rest = null,
                a.typeParameters = null,
                a.this = null,
                this.match(47) && (a.typeParameters = this.flowParseTypeParameterDeclaration()),
                this.expect(10),
                this.match(78) &&
                  ((a.this = this.flowParseFunctionTypeParam(!0)),
                  (a.this.name = null),
                  this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              a.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return (
              this.eat(21) && (a.rest = this.flowParseFunctionTypeParam(!1)),
              this.expect(11),
              (a.returnType = this.flowParseTypeInitialiser()),
              this.finishNode(a, 'FunctionTypeAnnotation')
            );
          }
          flowParseObjectTypeCallProperty(a, h) {
            let d = this.startNode();
            return (
              (a.static = h),
              (a.value = this.flowParseObjectTypeMethodish(d)),
              this.finishNode(a, 'ObjectTypeCallProperty')
            );
          }
          flowParseObjectType({ allowStatic: a, allowExact: h, allowSpread: d, allowProto: D, allowInexact: A }) {
            let P = this.state.inType;
            this.state.inType = !0;
            let N = this.startNode();
            (N.callProperties = []), (N.properties = []), (N.indexers = []), (N.internalSlots = []);
            let R,
              _,
              ue = !1;
            for (
              h && this.match(6) ? (this.expect(6), (R = 9), (_ = !0)) : (this.expect(5), (R = 8), (_ = !1)),
                N.exact = _;
              !this.match(R);

            ) {
              let Ie = !1,
                _e = null,
                Bt = null,
                wt = this.startNode();
              if (D && this.isContextual(116)) {
                let Qt = this.lookahead();
                Qt.type !== 14 && Qt.type !== 17 && (this.next(), (_e = this.state.startLoc), (a = !1));
              }
              if (a && this.isContextual(104)) {
                let Qt = this.lookahead();
                Qt.type !== 14 && Qt.type !== 17 && (this.next(), (Ie = !0));
              }
              let ur = this.flowParseVariance();
              if (this.eat(0))
                _e != null && this.unexpected(_e),
                  this.eat(0)
                    ? (ur && this.unexpected(ur.loc.start),
                      N.internalSlots.push(this.flowParseObjectTypeInternalSlot(wt, Ie)))
                    : N.indexers.push(this.flowParseObjectTypeIndexer(wt, Ie, ur));
              else if (this.match(10) || this.match(47))
                _e != null && this.unexpected(_e),
                  ur && this.unexpected(ur.loc.start),
                  N.callProperties.push(this.flowParseObjectTypeCallProperty(wt, Ie));
              else {
                let Qt = 'init';
                if (this.isContextual(98) || this.isContextual(103)) {
                  let On = this.lookahead();
                  V(On.type) && ((Qt = this.state.value), this.next());
                }
                let Zr = this.flowParseObjectTypeProperty(wt, Ie, _e, ur, Qt, d, A ?? !_);
                Zr === null ? ((ue = !0), (Bt = this.state.lastTokStartLoc)) : N.properties.push(Zr);
              }
              this.flowObjectTypeSemicolon(),
                Bt && !this.match(8) && !this.match(9) && this.raise(Ye.UnexpectedExplicitInexactInObject, { at: Bt });
            }
            this.expect(R), d && (N.inexact = ue);
            let ve = this.finishNode(N, 'ObjectTypeAnnotation');
            return (this.state.inType = P), ve;
          }
          flowParseObjectTypeProperty(a, h, d, D, A, P, N) {
            if (this.eat(21))
              return this.match(12) || this.match(13) || this.match(8) || this.match(9)
                ? (P
                    ? N || this.raise(Ye.InexactInsideExact, { at: this.state.lastTokStartLoc })
                    : this.raise(Ye.InexactInsideNonObject, { at: this.state.lastTokStartLoc }),
                  D && this.raise(Ye.InexactVariance, { at: D }),
                  null)
                : (P || this.raise(Ye.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }),
                  d != null && this.unexpected(d),
                  D && this.raise(Ye.SpreadVariance, { at: D }),
                  (a.argument = this.flowParseType()),
                  this.finishNode(a, 'ObjectTypeSpreadProperty'));
            {
              (a.key = this.flowParseObjectPropertyKey()), (a.static = h), (a.proto = d != null), (a.kind = A);
              let R = !1;
              return (
                this.match(47) || this.match(10)
                  ? ((a.method = !0),
                    d != null && this.unexpected(d),
                    D && this.unexpected(D.loc.start),
                    (a.value = this.flowParseObjectTypeMethodish(this.startNodeAt(a.loc.start))),
                    (A === 'get' || A === 'set') && this.flowCheckGetterSetterParams(a),
                    !P &&
                      a.key.name === 'constructor' &&
                      a.value.this &&
                      this.raise(Ye.ThisParamBannedInConstructor, { at: a.value.this }))
                  : (A !== 'init' && this.unexpected(),
                    (a.method = !1),
                    this.eat(17) && (R = !0),
                    (a.value = this.flowParseTypeInitialiser()),
                    (a.variance = D)),
                (a.optional = R),
                this.finishNode(a, 'ObjectTypeProperty')
              );
            }
          }
          flowCheckGetterSetterParams(a) {
            let h = a.kind === 'get' ? 0 : 1,
              d = a.value.params.length + (a.value.rest ? 1 : 0);
            a.value.this &&
              this.raise(a.kind === 'get' ? Ye.GetterMayNotHaveThisParam : Ye.SetterMayNotHaveThisParam, {
                at: a.value.this,
              }),
              d !== h && this.raise(a.kind === 'get' ? T.BadGetterArity : T.BadSetterArity, { at: a }),
              a.kind === 'set' && a.value.rest && this.raise(T.BadSetterRestParameter, { at: a });
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(a, h) {
            a != null || (a = this.state.startLoc);
            let d = h || this.flowParseRestrictedIdentifier(!0);
            for (; this.eat(16); ) {
              let D = this.startNodeAt(a);
              (D.qualification = d),
                (D.id = this.flowParseRestrictedIdentifier(!0)),
                (d = this.finishNode(D, 'QualifiedTypeIdentifier'));
            }
            return d;
          }
          flowParseGenericType(a, h) {
            let d = this.startNodeAt(a);
            return (
              (d.typeParameters = null),
              (d.id = this.flowParseQualifiedTypeIdentifier(a, h)),
              this.match(47) && (d.typeParameters = this.flowParseTypeParameterInstantiation()),
              this.finishNode(d, 'GenericTypeAnnotation')
            );
          }
          flowParseTypeofType() {
            let a = this.startNode();
            return (
              this.expect(87), (a.argument = this.flowParsePrimaryType()), this.finishNode(a, 'TypeofTypeAnnotation')
            );
          }
          flowParseTupleType() {
            let a = this.startNode();
            for (
              a.types = [], this.expect(0);
              this.state.pos < this.length && !this.match(3) && (a.types.push(this.flowParseType()), !this.match(3));

            )
              this.expect(12);
            return this.expect(3), this.finishNode(a, 'TupleTypeAnnotation');
          }
          flowParseFunctionTypeParam(a) {
            let h = null,
              d = !1,
              D = null,
              A = this.startNode(),
              P = this.lookahead(),
              N = this.state.type === 78;
            return (
              P.type === 14 || P.type === 17
                ? (N && !a && this.raise(Ye.ThisParamMustBeFirst, { at: A }),
                  (h = this.parseIdentifier(N)),
                  this.eat(17) && ((d = !0), N && this.raise(Ye.ThisParamMayNotBeOptional, { at: A })),
                  (D = this.flowParseTypeInitialiser()))
                : (D = this.flowParseType()),
              (A.name = h),
              (A.optional = d),
              (A.typeAnnotation = D),
              this.finishNode(A, 'FunctionTypeParam')
            );
          }
          reinterpretTypeAsFunctionTypeParam(a) {
            let h = this.startNodeAt(a.loc.start);
            return (h.name = null), (h.optional = !1), (h.typeAnnotation = a), this.finishNode(h, 'FunctionTypeParam');
          }
          flowParseFunctionTypeParams(a = []) {
            let h = null,
              d = null;
            for (
              this.match(78) &&
              ((d = this.flowParseFunctionTypeParam(!0)), (d.name = null), this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              a.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (h = this.flowParseFunctionTypeParam(!1)), { params: a, rest: h, _this: d };
          }
          flowIdentToTypeAnnotation(a, h, d) {
            switch (d.name) {
              case 'any':
                return this.finishNode(h, 'AnyTypeAnnotation');
              case 'bool':
              case 'boolean':
                return this.finishNode(h, 'BooleanTypeAnnotation');
              case 'mixed':
                return this.finishNode(h, 'MixedTypeAnnotation');
              case 'empty':
                return this.finishNode(h, 'EmptyTypeAnnotation');
              case 'number':
                return this.finishNode(h, 'NumberTypeAnnotation');
              case 'string':
                return this.finishNode(h, 'StringTypeAnnotation');
              case 'symbol':
                return this.finishNode(h, 'SymbolTypeAnnotation');
              default:
                return this.checkNotUnderscore(d.name), this.flowParseGenericType(a, d);
            }
          }
          flowParsePrimaryType() {
            let a = this.state.startLoc,
              h = this.startNode(),
              d,
              D,
              A = !1,
              P = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !1,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !0,
                });
              case 6:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !0,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !1,
                });
              case 0:
                return (
                  (this.state.noAnonFunctionType = !1),
                  (D = this.flowParseTupleType()),
                  (this.state.noAnonFunctionType = P),
                  D
                );
              case 47:
                return (
                  (h.typeParameters = this.flowParseTypeParameterDeclaration()),
                  this.expect(10),
                  (d = this.flowParseFunctionTypeParams()),
                  (h.params = d.params),
                  (h.rest = d.rest),
                  (h.this = d._this),
                  this.expect(11),
                  this.expect(19),
                  (h.returnType = this.flowParseType()),
                  this.finishNode(h, 'FunctionTypeAnnotation')
                );
              case 10:
                if ((this.next(), !this.match(11) && !this.match(21)))
                  if (fe(this.state.type) || this.match(78)) {
                    let N = this.lookahead().type;
                    A = N !== 17 && N !== 14;
                  } else A = !0;
                if (A) {
                  if (
                    ((this.state.noAnonFunctionType = !1),
                    (D = this.flowParseType()),
                    (this.state.noAnonFunctionType = P),
                    this.state.noAnonFunctionType ||
                      !(this.match(12) || (this.match(11) && this.lookahead().type === 19)))
                  )
                    return this.expect(11), D;
                  this.eat(12);
                }
                return (
                  D
                    ? (d = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(D)]))
                    : (d = this.flowParseFunctionTypeParams()),
                  (h.params = d.params),
                  (h.rest = d.rest),
                  (h.this = d._this),
                  this.expect(11),
                  this.expect(19),
                  (h.returnType = this.flowParseType()),
                  (h.typeParameters = null),
                  this.finishNode(h, 'FunctionTypeAnnotation')
                );
              case 131:
                return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation');
              case 85:
              case 86:
                return (h.value = this.match(85)), this.next(), this.finishNode(h, 'BooleanLiteralTypeAnnotation');
              case 53:
                if (this.state.value === '-') {
                  if ((this.next(), this.match(132)))
                    return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', h);
                  if (this.match(133))
                    return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', h);
                  throw this.raise(Ye.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                }
                this.unexpected();
                return;
              case 132:
                return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation');
              case 133:
                return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation');
              case 88:
                return this.next(), this.finishNode(h, 'VoidTypeAnnotation');
              case 84:
                return this.next(), this.finishNode(h, 'NullLiteralTypeAnnotation');
              case 78:
                return this.next(), this.finishNode(h, 'ThisTypeAnnotation');
              case 55:
                return this.next(), this.finishNode(h, 'ExistsTypeAnnotation');
              case 87:
                return this.flowParseTypeofType();
              default:
                if (Fe(this.state.type)) {
                  let N = et(this.state.type);
                  return this.next(), super.createIdentifier(h, N);
                } else if (fe(this.state.type))
                  return this.isContextual(127)
                    ? this.flowParseInterfaceType()
                    : this.flowIdentToTypeAnnotation(a, h, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            let a = this.state.startLoc,
              h = this.flowParsePrimaryType(),
              d = !1;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              let D = this.startNodeAt(a),
                A = this.eat(18);
              (d = d || A),
                this.expect(0),
                !A && this.match(3)
                  ? ((D.elementType = h), this.next(), (h = this.finishNode(D, 'ArrayTypeAnnotation')))
                  : ((D.objectType = h),
                    (D.indexType = this.flowParseType()),
                    this.expect(3),
                    d
                      ? ((D.optional = A), (h = this.finishNode(D, 'OptionalIndexedAccessType')))
                      : (h = this.finishNode(D, 'IndexedAccessType')));
            }
            return h;
          }
          flowParsePrefixType() {
            let a = this.startNode();
            return this.eat(17)
              ? ((a.typeAnnotation = this.flowParsePrefixType()), this.finishNode(a, 'NullableTypeAnnotation'))
              : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            let a = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let h = this.startNodeAt(a.loc.start);
              return (
                (h.params = [this.reinterpretTypeAsFunctionTypeParam(a)]),
                (h.rest = null),
                (h.this = null),
                (h.returnType = this.flowParseType()),
                (h.typeParameters = null),
                this.finishNode(h, 'FunctionTypeAnnotation')
              );
            }
            return a;
          }
          flowParseIntersectionType() {
            let a = this.startNode();
            this.eat(45);
            let h = this.flowParseAnonFunctionWithoutParens();
            for (a.types = [h]; this.eat(45); ) a.types.push(this.flowParseAnonFunctionWithoutParens());
            return a.types.length === 1 ? h : this.finishNode(a, 'IntersectionTypeAnnotation');
          }
          flowParseUnionType() {
            let a = this.startNode();
            this.eat(43);
            let h = this.flowParseIntersectionType();
            for (a.types = [h]; this.eat(43); ) a.types.push(this.flowParseIntersectionType());
            return a.types.length === 1 ? h : this.finishNode(a, 'UnionTypeAnnotation');
          }
          flowParseType() {
            let a = this.state.inType;
            this.state.inType = !0;
            let h = this.flowParseUnionType();
            return (this.state.inType = a), h;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 130 && this.state.value === '_') {
              let a = this.state.startLoc,
                h = this.parseIdentifier();
              return this.flowParseGenericType(a, h);
            } else return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            let a = this.startNode();
            return (a.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(a, 'TypeAnnotation');
          }
          flowParseTypeAnnotatableIdentifier(a) {
            let h = a ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && ((h.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(h)), h;
          }
          typeCastToParameter(a) {
            return (
              (a.expression.typeAnnotation = a.typeAnnotation),
              this.resetEndLocation(a.expression, a.typeAnnotation.loc.end),
              a.expression
            );
          }
          flowParseVariance() {
            let a = null;
            return this.match(53)
              ? ((a = this.startNode()),
                this.state.value === '+' ? (a.kind = 'plus') : (a.kind = 'minus'),
                this.next(),
                this.finishNode(a, 'Variance'))
              : a;
          }
          parseFunctionBody(a, h, d = !1) {
            if (h) {
              this.forwardNoArrowParamsConversionAt(a, () => super.parseFunctionBody(a, !0, d));
              return;
            }
            super.parseFunctionBody(a, !1, d);
          }
          parseFunctionBodyAndFinish(a, h, d = !1) {
            if (this.match(14)) {
              let D = this.startNode();
              ([D.typeAnnotation, a.predicate] = this.flowParseTypeAndPredicateInitialiser()),
                (a.returnType = D.typeAnnotation ? this.finishNode(D, 'TypeAnnotation') : null);
            }
            return super.parseFunctionBodyAndFinish(a, h, d);
          }
          parseStatementLike(a) {
            if (this.state.strict && this.isContextual(127)) {
              let d = this.lookahead();
              if (M(d.type)) {
                let D = this.startNode();
                return this.next(), this.flowParseInterface(D);
              }
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
              let d = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(d);
            }
            let h = super.parseStatementLike(a);
            return this.flowPragma === void 0 && !this.isValidDirective(h) && (this.flowPragma = null), h;
          }
          parseExpressionStatement(a, h, d) {
            if (h.type === 'Identifier') {
              if (h.name === 'declare') {
                if (this.match(80) || fe(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                  return this.flowParseDeclare(a);
              } else if (fe(this.state.type)) {
                if (h.name === 'interface') return this.flowParseInterface(a);
                if (h.name === 'type') return this.flowParseTypeAlias(a);
                if (h.name === 'opaque') return this.flowParseOpaqueType(a, !1);
              }
            }
            return super.parseExpressionStatement(a, h, d);
          }
          shouldParseExportDeclaration() {
            let { type: a } = this.state;
            return ye(a) || (this.shouldParseEnums() && a === 124)
              ? !this.state.containsEsc
              : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            let { type: a } = this.state;
            return ye(a) || (this.shouldParseEnums() && a === 124)
              ? this.state.containsEsc
              : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(124)) {
              let a = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(a);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(a, h, d) {
            if (!this.match(17)) return a;
            if (this.state.maybeInArrowParameters) {
              let ve = this.lookaheadCharCode();
              if (ve === 44 || ve === 61 || ve === 58 || ve === 41) return this.setOptionalParametersError(d), a;
            }
            this.expect(17);
            let D = this.state.clone(),
              A = this.state.noArrowAt,
              P = this.startNodeAt(h),
              { consequent: N, failed: R } = this.tryParseConditionalConsequent(),
              [_, ue] = this.getArrowLikeExpressions(N);
            if (R || ue.length > 0) {
              let ve = [...A];
              if (ue.length > 0) {
                (this.state = D), (this.state.noArrowAt = ve);
                for (let Ie = 0; Ie < ue.length; Ie++) ve.push(ue[Ie].start);
                ({ consequent: N, failed: R } = this.tryParseConditionalConsequent()),
                  ([_, ue] = this.getArrowLikeExpressions(N));
              }
              R && _.length > 1 && this.raise(Ye.AmbiguousConditionalArrow, { at: D.startLoc }),
                R &&
                  _.length === 1 &&
                  ((this.state = D),
                  ve.push(_[0].start),
                  (this.state.noArrowAt = ve),
                  ({ consequent: N, failed: R } = this.tryParseConditionalConsequent()));
            }
            return (
              this.getArrowLikeExpressions(N, !0),
              (this.state.noArrowAt = A),
              this.expect(14),
              (P.test = a),
              (P.consequent = N),
              (P.alternate = this.forwardNoArrowParamsConversionAt(P, () => this.parseMaybeAssign(void 0, void 0))),
              this.finishNode(P, 'ConditionalExpression')
            );
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let a = this.parseMaybeAssignAllowIn(),
              h = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: a, failed: h };
          }
          getArrowLikeExpressions(a, h) {
            let d = [a],
              D = [];
            for (; d.length !== 0; ) {
              let A = d.pop();
              A.type === 'ArrowFunctionExpression'
                ? (A.typeParameters || !A.returnType ? this.finishArrowValidation(A) : D.push(A), d.push(A.body))
                : A.type === 'ConditionalExpression' && (d.push(A.consequent), d.push(A.alternate));
            }
            return h
              ? (D.forEach((A) => this.finishArrowValidation(A)), [D, []])
              : Rc(D, (A) => A.params.every((P) => this.isAssignable(P, !0)));
          }
          finishArrowValidation(a) {
            var h;
            this.toAssignableList(a.params, (h = a.extra) == null ? void 0 : h.trailingCommaLoc, !1),
              this.scope.enter(6),
              super.checkParams(a, !1, !0),
              this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(a, h) {
            let d;
            return (
              this.state.noArrowParamsConversionAt.indexOf(a.start) !== -1
                ? (this.state.noArrowParamsConversionAt.push(this.state.start),
                  (d = h()),
                  this.state.noArrowParamsConversionAt.pop())
                : (d = h()),
              d
            );
          }
          parseParenItem(a, h) {
            if (
              ((a = super.parseParenItem(a, h)),
              this.eat(17) && ((a.optional = !0), this.resetEndLocation(a)),
              this.match(14))
            ) {
              let d = this.startNodeAt(h);
              return (
                (d.expression = a),
                (d.typeAnnotation = this.flowParseTypeAnnotation()),
                this.finishNode(d, 'TypeCastExpression')
              );
            }
            return a;
          }
          assertModuleNodeAllowed(a) {
            (a.type === 'ImportDeclaration' && (a.importKind === 'type' || a.importKind === 'typeof')) ||
              (a.type === 'ExportNamedDeclaration' && a.exportKind === 'type') ||
              (a.type === 'ExportAllDeclaration' && a.exportKind === 'type') ||
              super.assertModuleNodeAllowed(a);
          }
          parseExportDeclaration(a) {
            if (this.isContextual(128)) {
              a.exportKind = 'type';
              let h = this.startNode();
              return (
                this.next(),
                this.match(5)
                  ? ((a.specifiers = this.parseExportSpecifiers(!0)), super.parseExportFrom(a), null)
                  : this.flowParseTypeAlias(h)
              );
            } else if (this.isContextual(129)) {
              a.exportKind = 'type';
              let h = this.startNode();
              return this.next(), this.flowParseOpaqueType(h, !1);
            } else if (this.isContextual(127)) {
              a.exportKind = 'type';
              let h = this.startNode();
              return this.next(), this.flowParseInterface(h);
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
              a.exportKind = 'value';
              let h = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(h);
            } else return super.parseExportDeclaration(a);
          }
          eatExportStar(a) {
            return super.eatExportStar(a)
              ? !0
              : this.isContextual(128) && this.lookahead().type === 55
              ? ((a.exportKind = 'type'), this.next(), this.next(), !0)
              : !1;
          }
          maybeParseExportNamespaceSpecifier(a) {
            let { startLoc: h } = this.state,
              d = super.maybeParseExportNamespaceSpecifier(a);
            return d && a.exportKind === 'type' && this.unexpected(h), d;
          }
          parseClassId(a, h, d) {
            super.parseClassId(a, h, d),
              this.match(47) && (a.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(a, h, d) {
            let { startLoc: D } = this.state;
            if (this.isContextual(123)) {
              if (super.parseClassMemberFromModifier(a, h)) return;
              h.declare = !0;
            }
            super.parseClassMember(a, h, d),
              h.declare &&
                (h.type !== 'ClassProperty' && h.type !== 'ClassPrivateProperty' && h.type !== 'PropertyDefinition'
                  ? this.raise(Ye.DeclareClassElement, { at: D })
                  : h.value && this.raise(Ye.DeclareClassFieldInitializer, { at: h.value }));
          }
          isIterator(a) {
            return a === 'iterator' || a === 'asyncIterator';
          }
          readIterator() {
            let a = super.readWord1(),
              h = '@@' + a;
            (!this.isIterator(a) || !this.state.inType) &&
              this.raise(T.InvalidIdentifier, { at: this.state.curPosition(), identifierName: h }),
              this.finishToken(130, h);
          }
          getTokenFromCode(a) {
            let h = this.input.charCodeAt(this.state.pos + 1);
            a === 123 && h === 124
              ? this.finishOp(6, 2)
              : this.state.inType && (a === 62 || a === 60)
              ? this.finishOp(a === 62 ? 48 : 47, 1)
              : this.state.inType && a === 63
              ? h === 46
                ? this.finishOp(18, 2)
                : this.finishOp(17, 1)
              : Fc(a, h, this.input.charCodeAt(this.state.pos + 2))
              ? ((this.state.pos += 2), this.readIterator())
              : super.getTokenFromCode(a);
          }
          isAssignable(a, h) {
            return a.type === 'TypeCastExpression' ? this.isAssignable(a.expression, h) : super.isAssignable(a, h);
          }
          toAssignable(a, h = !1) {
            !h &&
              a.type === 'AssignmentExpression' &&
              a.left.type === 'TypeCastExpression' &&
              (a.left = this.typeCastToParameter(a.left)),
              super.toAssignable(a, h);
          }
          toAssignableList(a, h, d) {
            for (let D = 0; D < a.length; D++) {
              let A = a[D];
              (A == null ? void 0 : A.type) === 'TypeCastExpression' && (a[D] = this.typeCastToParameter(A));
            }
            super.toAssignableList(a, h, d);
          }
          toReferencedList(a, h) {
            for (let D = 0; D < a.length; D++) {
              var d;
              let A = a[D];
              A &&
                A.type === 'TypeCastExpression' &&
                !((d = A.extra) != null && d.parenthesized) &&
                (a.length > 1 || !h) &&
                this.raise(Ye.TypeCastInPattern, { at: A.typeAnnotation });
            }
            return a;
          }
          parseArrayLike(a, h, d, D) {
            let A = super.parseArrayLike(a, h, d, D);
            return h && !this.state.maybeInArrowParameters && this.toReferencedList(A.elements), A;
          }
          isValidLVal(a, h, d) {
            return a === 'TypeCastExpression' || super.isValidLVal(a, h, d);
          }
          parseClassProperty(a) {
            return this.match(14) && (a.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(a);
          }
          parseClassPrivateProperty(a) {
            return (
              this.match(14) && (a.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(a)
            );
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(a) {
            return !this.match(14) && super.isNonstaticConstructor(a);
          }
          pushClassMethod(a, h, d, D, A, P) {
            if (
              (h.variance && this.unexpected(h.variance.loc.start),
              delete h.variance,
              this.match(47) && (h.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassMethod(a, h, d, D, A, P),
              h.params && A)
            ) {
              let N = h.params;
              N.length > 0 && this.isThisParam(N[0]) && this.raise(Ye.ThisParamBannedInConstructor, { at: h });
            } else if (h.type === 'MethodDefinition' && A && h.value.params) {
              let N = h.value.params;
              N.length > 0 && this.isThisParam(N[0]) && this.raise(Ye.ThisParamBannedInConstructor, { at: h });
            }
          }
          pushClassPrivateMethod(a, h, d, D) {
            h.variance && this.unexpected(h.variance.loc.start),
              delete h.variance,
              this.match(47) && (h.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassPrivateMethod(a, h, d, D);
          }
          parseClassSuper(a) {
            if (
              (super.parseClassSuper(a),
              a.superClass && this.match(47) && (a.superTypeParameters = this.flowParseTypeParameterInstantiation()),
              this.isContextual(111))
            ) {
              this.next();
              let h = (a.implements = []);
              do {
                let d = this.startNode();
                (d.id = this.flowParseRestrictedIdentifier(!0)),
                  this.match(47)
                    ? (d.typeParameters = this.flowParseTypeParameterInstantiation())
                    : (d.typeParameters = null),
                  h.push(this.finishNode(d, 'ClassImplements'));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(a) {
            super.checkGetterSetterParams(a);
            let h = this.getObjectOrClassMethodParams(a);
            if (h.length > 0) {
              let d = h[0];
              this.isThisParam(d) && a.kind === 'get'
                ? this.raise(Ye.GetterMayNotHaveThisParam, { at: d })
                : this.isThisParam(d) && this.raise(Ye.SetterMayNotHaveThisParam, { at: d });
            }
          }
          parsePropertyNamePrefixOperator(a) {
            a.variance = this.flowParseVariance();
          }
          parseObjPropValue(a, h, d, D, A, P, N) {
            a.variance && this.unexpected(a.variance.loc.start), delete a.variance;
            let R;
            this.match(47) &&
              !P &&
              ((R = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected());
            let _ = super.parseObjPropValue(a, h, d, D, A, P, N);
            return R && ((_.value || _).typeParameters = R), _;
          }
          parseAssignableListItemTypes(a) {
            return (
              this.eat(17) &&
                (a.type !== 'Identifier' && this.raise(Ye.PatternIsOptional, { at: a }),
                this.isThisParam(a) && this.raise(Ye.ThisParamMayNotBeOptional, { at: a }),
                (a.optional = !0)),
              this.match(14)
                ? (a.typeAnnotation = this.flowParseTypeAnnotation())
                : this.isThisParam(a) && this.raise(Ye.ThisParamAnnotationRequired, { at: a }),
              this.match(29) && this.isThisParam(a) && this.raise(Ye.ThisParamNoDefault, { at: a }),
              this.resetEndLocation(a),
              a
            );
          }
          parseMaybeDefault(a, h) {
            let d = super.parseMaybeDefault(a, h);
            return (
              d.type === 'AssignmentPattern' &&
                d.typeAnnotation &&
                d.right.start < d.typeAnnotation.start &&
                this.raise(Ye.TypeBeforeInitializer, { at: d.typeAnnotation }),
              d
            );
          }
          checkImportReflection(a) {
            super.checkImportReflection(a),
              a.module &&
                a.importKind !== 'value' &&
                this.raise(Ye.ImportReflectionHasImportType, { at: a.specifiers[0].loc.start });
          }
          parseImportSpecifierLocal(a, h, d) {
            (h.local = Ul(a) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()),
              a.specifiers.push(this.finishImportSpecifier(h, d));
          }
          isPotentialImportPhase(a) {
            if (super.isPotentialImportPhase(a)) return !0;
            if (this.isContextual(128)) {
              if (!a) return !0;
              let h = this.lookaheadCharCode();
              return h === 123 || h === 42;
            }
            return !a && this.isContextual(87);
          }
          applyImportPhase(a, h, d, D) {
            if ((super.applyImportPhase(a, h, d, D), h)) {
              if (!d && this.match(65)) return;
              a.exportKind = d === 'type' ? d : 'value';
            } else
              d === 'type' && this.match(55) && this.unexpected(),
                (a.importKind = d === 'type' || d === 'typeof' ? d : 'value');
          }
          parseImportSpecifier(a, h, d, D, A) {
            let P = a.imported,
              N = null;
            P.type === 'Identifier' && (P.name === 'type' ? (N = 'type') : P.name === 'typeof' && (N = 'typeof'));
            let R = !1;
            if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
              let ue = this.parseIdentifier(!0);
              N !== null && !M(this.state.type)
                ? ((a.imported = ue), (a.importKind = N), (a.local = Qn(ue)))
                : ((a.imported = P), (a.importKind = null), (a.local = this.parseIdentifier()));
            } else {
              if (N !== null && M(this.state.type)) (a.imported = this.parseIdentifier(!0)), (a.importKind = N);
              else {
                if (h) throw this.raise(T.ImportBindingIsString, { at: a, importName: P.value });
                (a.imported = P), (a.importKind = null);
              }
              this.eatContextual(93) ? (a.local = this.parseIdentifier()) : ((R = !0), (a.local = Qn(a.imported)));
            }
            let _ = Ul(a);
            return (
              d && _ && this.raise(Ye.ImportTypeShorthandOnlyInPureImport, { at: a }),
              (d || _) && this.checkReservedType(a.local.name, a.local.loc.start, !0),
              R && !d && !_ && this.checkReservedWord(a.local.name, a.loc.start, !0, !0),
              this.finishImportSpecifier(a, 'ImportSpecifier')
            );
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(!0);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(a, h) {
            let d = a.kind;
            d !== 'get' &&
              d !== 'set' &&
              this.match(47) &&
              (a.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.parseFunctionParams(a, h);
          }
          parseVarId(a, h) {
            super.parseVarId(a, h),
              this.match(14) && ((a.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(a.id));
          }
          parseAsyncArrowFromCallExpression(a, h) {
            if (this.match(14)) {
              let d = this.state.noAnonFunctionType;
              (this.state.noAnonFunctionType = !0),
                (a.returnType = this.flowParseTypeAnnotation()),
                (this.state.noAnonFunctionType = d);
            }
            return super.parseAsyncArrowFromCallExpression(a, h);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(a, h) {
            var d;
            let D = null,
              A;
            if (this.hasPlugin('jsx') && (this.match(140) || this.match(47))) {
              if (((D = this.state.clone()), (A = this.tryParse(() => super.parseMaybeAssign(a, h), D)), !A.error))
                return A.node;
              let { context: R } = this.state,
                _ = R[R.length - 1];
              (_ === W.j_oTag || _ === W.j_expr) && R.pop();
            }
            if (((d = A) != null && d.error) || this.match(47)) {
              var P, N;
              D = D || this.state.clone();
              let R,
                _ = this.tryParse((ve) => {
                  var Ie;
                  R = this.flowParseTypeParameterDeclaration();
                  let _e = this.forwardNoArrowParamsConversionAt(R, () => {
                    let wt = super.parseMaybeAssign(a, h);
                    return this.resetStartLocationFromNode(wt, R), wt;
                  });
                  (Ie = _e.extra) != null && Ie.parenthesized && ve();
                  let Bt = this.maybeUnwrapTypeCastExpression(_e);
                  return (
                    Bt.type !== 'ArrowFunctionExpression' && ve(),
                    (Bt.typeParameters = R),
                    this.resetStartLocationFromNode(Bt, R),
                    _e
                  );
                }, D),
                ue = null;
              if (_.node && this.maybeUnwrapTypeCastExpression(_.node).type === 'ArrowFunctionExpression') {
                if (!_.error && !_.aborted)
                  return (
                    _.node.async && this.raise(Ye.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: R }), _.node
                  );
                ue = _.node;
              }
              if ((P = A) != null && P.node) return (this.state = A.failState), A.node;
              if (ue) return (this.state = _.failState), ue;
              throw (N = A) != null && N.thrown
                ? A.error
                : _.thrown
                ? _.error
                : this.raise(Ye.UnexpectedTokenAfterTypeParameter, { at: R });
            }
            return super.parseMaybeAssign(a, h);
          }
          parseArrow(a) {
            if (this.match(14)) {
              let h = this.tryParse(() => {
                let d = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = !0;
                let D = this.startNode();
                return (
                  ([D.typeAnnotation, a.predicate] = this.flowParseTypeAndPredicateInitialiser()),
                  (this.state.noAnonFunctionType = d),
                  this.canInsertSemicolon() && this.unexpected(),
                  this.match(19) || this.unexpected(),
                  D
                );
              });
              if (h.thrown) return null;
              h.error && (this.state = h.failState),
                (a.returnType = h.node.typeAnnotation ? this.finishNode(h.node, 'TypeAnnotation') : null);
            }
            return super.parseArrow(a);
          }
          shouldParseArrow(a) {
            return this.match(14) || super.shouldParseArrow(a);
          }
          setArrowFunctionParameters(a, h) {
            this.state.noArrowParamsConversionAt.indexOf(a.start) !== -1
              ? (a.params = h)
              : super.setArrowFunctionParameters(a, h);
          }
          checkParams(a, h, d, D = !0) {
            if (!(d && this.state.noArrowParamsConversionAt.indexOf(a.start) !== -1)) {
              for (let A = 0; A < a.params.length; A++)
                this.isThisParam(a.params[A]) && A > 0 && this.raise(Ye.ThisParamMustBeFirst, { at: a.params[A] });
              super.checkParams(a, h, d, D);
            }
          }
          parseParenAndDistinguishExpression(a) {
            return super.parseParenAndDistinguishExpression(a && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(a, h, d) {
            if (a.type === 'Identifier' && a.name === 'async' && this.state.noArrowAt.indexOf(h.index) !== -1) {
              this.next();
              let D = this.startNodeAt(h);
              (D.callee = a),
                (D.arguments = super.parseCallExpressionArguments(11, !1)),
                (a = this.finishNode(D, 'CallExpression'));
            } else if (a.type === 'Identifier' && a.name === 'async' && this.match(47)) {
              let D = this.state.clone(),
                A = this.tryParse((N) => this.parseAsyncArrowWithTypeParameters(h) || N(), D);
              if (!A.error && !A.aborted) return A.node;
              let P = this.tryParse(() => super.parseSubscripts(a, h, d), D);
              if (P.node && !P.error) return P.node;
              if (A.node) return (this.state = A.failState), A.node;
              if (P.node) return (this.state = P.failState), P.node;
              throw A.error || P.error;
            }
            return super.parseSubscripts(a, h, d);
          }
          parseSubscript(a, h, d, D) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (((D.optionalChainMember = !0), d)) return (D.stop = !0), a;
              this.next();
              let A = this.startNodeAt(h);
              return (
                (A.callee = a),
                (A.typeArguments = this.flowParseTypeParameterInstantiation()),
                this.expect(10),
                (A.arguments = this.parseCallExpressionArguments(11, !1)),
                (A.optional = !0),
                this.finishCallExpression(A, !0)
              );
            } else if (!d && this.shouldParseTypes() && this.match(47)) {
              let A = this.startNodeAt(h);
              A.callee = a;
              let P = this.tryParse(
                () => (
                  (A.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()),
                  this.expect(10),
                  (A.arguments = super.parseCallExpressionArguments(11, !1)),
                  D.optionalChainMember && (A.optional = !1),
                  this.finishCallExpression(A, D.optionalChainMember)
                ),
              );
              if (P.node) return P.error && (this.state = P.failState), P.node;
            }
            return super.parseSubscript(a, h, d, D);
          }
          parseNewCallee(a) {
            super.parseNewCallee(a);
            let h = null;
            this.shouldParseTypes() &&
              this.match(47) &&
              (h = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node),
              (a.typeArguments = h);
          }
          parseAsyncArrowWithTypeParameters(a) {
            let h = this.startNodeAt(a);
            if ((this.parseFunctionParams(h, !1), !!this.parseArrow(h)))
              return super.parseArrowExpression(h, void 0, !0);
          }
          readToken_mult_modulo(a) {
            let h = this.input.charCodeAt(this.state.pos + 1);
            if (a === 42 && h === 47 && this.state.hasFlowComment) {
              (this.state.hasFlowComment = !1), (this.state.pos += 2), this.nextToken();
              return;
            }
            super.readToken_mult_modulo(a);
          }
          readToken_pipe_amp(a) {
            let h = this.input.charCodeAt(this.state.pos + 1);
            if (a === 124 && h === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(a);
          }
          parseTopLevel(a, h) {
            let d = super.parseTopLevel(a, h);
            return (
              this.state.hasFlowComment && this.raise(Ye.UnterminatedFlowComment, { at: this.state.curPosition() }), d
            );
          }
          skipBlockComment() {
            if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
              if (this.state.hasFlowComment) throw this.raise(Ye.NestedFlowComment, { at: this.state.startLoc });
              this.hasFlowCommentCompletion();
              let a = this.skipFlowComment();
              a && ((this.state.pos += a), (this.state.hasFlowComment = !0));
              return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? '*-/' : '*/');
          }
          skipFlowComment() {
            let { pos: a } = this.state,
              h = 2;
            for (; [32, 9].includes(this.input.charCodeAt(a + h)); ) h++;
            let d = this.input.charCodeAt(h + a),
              D = this.input.charCodeAt(h + a + 1);
            return d === 58 && D === 58
              ? h + 2
              : this.input.slice(h + a, h + a + 12) === 'flow-include'
              ? h + 12
              : d === 58 && D !== 58
              ? h
              : !1;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf('*/', this.state.pos) === -1)
              throw this.raise(T.UnterminatedComment, { at: this.state.curPosition() });
          }
          flowEnumErrorBooleanMemberNotInitialized(a, { enumName: h, memberName: d }) {
            this.raise(Ye.EnumBooleanMemberNotInitialized, { at: a, memberName: d, enumName: h });
          }
          flowEnumErrorInvalidMemberInitializer(a, h) {
            return this.raise(
              h.explicitType
                ? h.explicitType === 'symbol'
                  ? Ye.EnumInvalidMemberInitializerSymbolType
                  : Ye.EnumInvalidMemberInitializerPrimaryType
                : Ye.EnumInvalidMemberInitializerUnknownType,
              Object.assign({ at: a }, h),
            );
          }
          flowEnumErrorNumberMemberNotInitialized(a, { enumName: h, memberName: d }) {
            this.raise(Ye.EnumNumberMemberNotInitialized, { at: a, enumName: h, memberName: d });
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(a, { enumName: h }) {
            this.raise(Ye.EnumStringMemberInconsistentlyInitailized, { at: a, enumName: h });
          }
          flowEnumMemberInit() {
            let a = this.state.startLoc,
              h = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 132: {
                let d = this.parseNumericLiteral(this.state.value);
                return h() ? { type: 'number', loc: d.loc.start, value: d } : { type: 'invalid', loc: a };
              }
              case 131: {
                let d = this.parseStringLiteral(this.state.value);
                return h() ? { type: 'string', loc: d.loc.start, value: d } : { type: 'invalid', loc: a };
              }
              case 85:
              case 86: {
                let d = this.parseBooleanLiteral(this.match(85));
                return h() ? { type: 'boolean', loc: d.loc.start, value: d } : { type: 'invalid', loc: a };
              }
              default:
                return { type: 'invalid', loc: a };
            }
          }
          flowEnumMemberRaw() {
            let a = this.state.startLoc,
              h = this.parseIdentifier(!0),
              d = this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: a };
            return { id: h, init: d };
          }
          flowEnumCheckExplicitTypeMismatch(a, h, d) {
            let { explicitType: D } = h;
            D !== null && D !== d && this.flowEnumErrorInvalidMemberInitializer(a, h);
          }
          flowEnumMembers({ enumName: a, explicitType: h }) {
            let d = new Set(),
              D = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] },
              A = !1;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                A = !0;
                break;
              }
              let P = this.startNode(),
                { id: N, init: R } = this.flowEnumMemberRaw(),
                _ = N.name;
              if (_ === '') continue;
              /^[a-z]/.test(_) &&
                this.raise(Ye.EnumInvalidMemberName, {
                  at: N,
                  memberName: _,
                  suggestion: _[0].toUpperCase() + _.slice(1),
                  enumName: a,
                }),
                d.has(_) && this.raise(Ye.EnumDuplicateMemberName, { at: N, memberName: _, enumName: a }),
                d.add(_);
              let ue = { enumName: a, explicitType: h, memberName: _ };
              switch (((P.id = N), R.type)) {
                case 'boolean': {
                  this.flowEnumCheckExplicitTypeMismatch(R.loc, ue, 'boolean'),
                    (P.init = R.value),
                    D.booleanMembers.push(this.finishNode(P, 'EnumBooleanMember'));
                  break;
                }
                case 'number': {
                  this.flowEnumCheckExplicitTypeMismatch(R.loc, ue, 'number'),
                    (P.init = R.value),
                    D.numberMembers.push(this.finishNode(P, 'EnumNumberMember'));
                  break;
                }
                case 'string': {
                  this.flowEnumCheckExplicitTypeMismatch(R.loc, ue, 'string'),
                    (P.init = R.value),
                    D.stringMembers.push(this.finishNode(P, 'EnumStringMember'));
                  break;
                }
                case 'invalid':
                  throw this.flowEnumErrorInvalidMemberInitializer(R.loc, ue);
                case 'none':
                  switch (h) {
                    case 'boolean':
                      this.flowEnumErrorBooleanMemberNotInitialized(R.loc, ue);
                      break;
                    case 'number':
                      this.flowEnumErrorNumberMemberNotInitialized(R.loc, ue);
                      break;
                    default:
                      D.defaultedMembers.push(this.finishNode(P, 'EnumDefaultedMember'));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: D, hasUnknownMembers: A };
          }
          flowEnumStringMembers(a, h, { enumName: d }) {
            if (a.length === 0) return h;
            if (h.length === 0) return a;
            if (h.length > a.length) {
              for (let D of a) this.flowEnumErrorStringMemberInconsistentlyInitailized(D, { enumName: d });
              return h;
            } else {
              for (let D of h) this.flowEnumErrorStringMemberInconsistentlyInitailized(D, { enumName: d });
              return a;
            }
          }
          flowEnumParseExplicitType({ enumName: a }) {
            if (!this.eatContextual(101)) return null;
            if (!fe(this.state.type))
              throw this.raise(Ye.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: a });
            let { value: h } = this.state;
            return (
              this.next(),
              h !== 'boolean' &&
                h !== 'number' &&
                h !== 'string' &&
                h !== 'symbol' &&
                this.raise(Ye.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: a, invalidEnumType: h }),
              h
            );
          }
          flowEnumBody(a, h) {
            let d = h.name,
              D = h.loc.start,
              A = this.flowEnumParseExplicitType({ enumName: d });
            this.expect(5);
            let { members: P, hasUnknownMembers: N } = this.flowEnumMembers({ enumName: d, explicitType: A });
            switch (((a.hasUnknownMembers = N), A)) {
              case 'boolean':
                return (
                  (a.explicitType = !0),
                  (a.members = P.booleanMembers),
                  this.expect(8),
                  this.finishNode(a, 'EnumBooleanBody')
                );
              case 'number':
                return (
                  (a.explicitType = !0),
                  (a.members = P.numberMembers),
                  this.expect(8),
                  this.finishNode(a, 'EnumNumberBody')
                );
              case 'string':
                return (
                  (a.explicitType = !0),
                  (a.members = this.flowEnumStringMembers(P.stringMembers, P.defaultedMembers, { enumName: d })),
                  this.expect(8),
                  this.finishNode(a, 'EnumStringBody')
                );
              case 'symbol':
                return (a.members = P.defaultedMembers), this.expect(8), this.finishNode(a, 'EnumSymbolBody');
              default: {
                let R = () => ((a.members = []), this.expect(8), this.finishNode(a, 'EnumStringBody'));
                a.explicitType = !1;
                let _ = P.booleanMembers.length,
                  ue = P.numberMembers.length,
                  ve = P.stringMembers.length,
                  Ie = P.defaultedMembers.length;
                if (!_ && !ue && !ve && !Ie) return R();
                if (!_ && !ue)
                  return (
                    (a.members = this.flowEnumStringMembers(P.stringMembers, P.defaultedMembers, { enumName: d })),
                    this.expect(8),
                    this.finishNode(a, 'EnumStringBody')
                  );
                if (!ue && !ve && _ >= Ie) {
                  for (let _e of P.defaultedMembers)
                    this.flowEnumErrorBooleanMemberNotInitialized(_e.loc.start, {
                      enumName: d,
                      memberName: _e.id.name,
                    });
                  return (a.members = P.booleanMembers), this.expect(8), this.finishNode(a, 'EnumBooleanBody');
                } else if (!_ && !ve && ue >= Ie) {
                  for (let _e of P.defaultedMembers)
                    this.flowEnumErrorNumberMemberNotInitialized(_e.loc.start, { enumName: d, memberName: _e.id.name });
                  return (a.members = P.numberMembers), this.expect(8), this.finishNode(a, 'EnumNumberBody');
                } else return this.raise(Ye.EnumInconsistentMemberValues, { at: D, enumName: d }), R();
              }
            }
          }
          flowParseEnumDeclaration(a) {
            let h = this.parseIdentifier();
            return (a.id = h), (a.body = this.flowEnumBody(this.startNode(), h)), this.finishNode(a, 'EnumDeclaration');
          }
          isLookaheadToken_lt() {
            let a = this.nextTokenStart();
            if (this.input.charCodeAt(a) === 60) {
              let h = this.input.charCodeAt(a + 1);
              return h !== 60 && h !== 61;
            }
            return !1;
          }
          maybeUnwrapTypeCastExpression(a) {
            return a.type === 'TypeCastExpression' ? a.expression : a;
          }
        },
      Wr = I`jsx`({
        AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.',
        MissingClosingTagElement: ({ openingTagName: u }) => `Expected corresponding JSX closing tag for <${u}>.`,
        MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.',
        UnexpectedSequenceExpression:
          'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
        UnexpectedToken: ({ unexpected: u, HTMLEntity: a }) =>
          `Unexpected token \`${u}\`. Did you mean \`${a}\` or \`{'${u}'}\`?`,
        UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.',
        UnterminatedJsxContent: 'Unterminated JSX contents.',
        UnwrappedAdjacentJSXElements:
          'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
      });
    function xi(u) {
      return u ? u.type === 'JSXOpeningFragment' || u.type === 'JSXClosingFragment' : !1;
    }
    function vs(u) {
      if (u.type === 'JSXIdentifier') return u.name;
      if (u.type === 'JSXNamespacedName') return u.namespace.name + ':' + u.name.name;
      if (u.type === 'JSXMemberExpression') return vs(u.object) + '.' + vs(u.property);
      throw new Error('Node had unexpected type: ' + u.type);
    }
    var od = (u) =>
        class extends u {
          jsxReadToken() {
            let a = '',
              h = this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length)
                throw this.raise(Wr.UnterminatedJsxContent, { at: this.state.startLoc });
              let d = this.input.charCodeAt(this.state.pos);
              switch (d) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    d === 60 && this.state.canStartJSXElement
                      ? (++this.state.pos, this.finishToken(140))
                      : super.getTokenFromCode(d);
                    return;
                  }
                  (a += this.input.slice(h, this.state.pos)), this.finishToken(139, a);
                  return;
                case 38:
                  (a += this.input.slice(h, this.state.pos)), (a += this.jsxReadEntity()), (h = this.state.pos);
                  break;
                case 62:
                case 125:
                default:
                  Ao(d)
                    ? ((a += this.input.slice(h, this.state.pos)), (a += this.jsxReadNewLine(!0)), (h = this.state.pos))
                    : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(a) {
            let h = this.input.charCodeAt(this.state.pos),
              d;
            return (
              ++this.state.pos,
              h === 13 && this.input.charCodeAt(this.state.pos) === 10
                ? (++this.state.pos,
                  (d = a
                    ? `
`
                    : `\r
`))
                : (d = String.fromCharCode(h)),
              ++this.state.curLine,
              (this.state.lineStart = this.state.pos),
              d
            );
          }
          jsxReadString(a) {
            let h = '',
              d = ++this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length) throw this.raise(T.UnterminatedString, { at: this.state.startLoc });
              let D = this.input.charCodeAt(this.state.pos);
              if (D === a) break;
              D === 38
                ? ((h += this.input.slice(d, this.state.pos)), (h += this.jsxReadEntity()), (d = this.state.pos))
                : Ao(D)
                ? ((h += this.input.slice(d, this.state.pos)), (h += this.jsxReadNewLine(!1)), (d = this.state.pos))
                : ++this.state.pos;
            }
            (h += this.input.slice(d, this.state.pos++)), this.finishToken(131, h);
          }
          jsxReadEntity() {
            let a = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let h = 10;
              this.codePointAtPos(this.state.pos) === 120 && ((h = 16), ++this.state.pos);
              let d = this.readInt(h, void 0, !1, 'bail');
              if (d !== null && this.codePointAtPos(this.state.pos) === 59)
                return ++this.state.pos, String.fromCodePoint(d);
            } else {
              let h = 0,
                d = !1;
              for (; h++ < 10 && this.state.pos < this.length && !(d = this.codePointAtPos(this.state.pos) == 59); )
                ++this.state.pos;
              if (d) {
                this.input.slice(a, this.state.pos);
                let D;
                ++this.state.pos;
              }
            }
            return (this.state.pos = a), '&';
          }
          jsxReadWord() {
            let a,
              h = this.state.pos;
            do a = this.input.charCodeAt(++this.state.pos);
            while (pn(a) || a === 45);
            this.finishToken(138, this.input.slice(h, this.state.pos));
          }
          jsxParseIdentifier() {
            let a = this.startNode();
            return (
              this.match(138)
                ? (a.name = this.state.value)
                : Fe(this.state.type)
                ? (a.name = et(this.state.type))
                : this.unexpected(),
              this.next(),
              this.finishNode(a, 'JSXIdentifier')
            );
          }
          jsxParseNamespacedName() {
            let a = this.state.startLoc,
              h = this.jsxParseIdentifier();
            if (!this.eat(14)) return h;
            let d = this.startNodeAt(a);
            return (d.namespace = h), (d.name = this.jsxParseIdentifier()), this.finishNode(d, 'JSXNamespacedName');
          }
          jsxParseElementName() {
            let a = this.state.startLoc,
              h = this.jsxParseNamespacedName();
            if (h.type === 'JSXNamespacedName') return h;
            for (; this.eat(16); ) {
              let d = this.startNodeAt(a);
              (d.object = h), (d.property = this.jsxParseIdentifier()), (h = this.finishNode(d, 'JSXMemberExpression'));
            }
            return h;
          }
          jsxParseAttributeValue() {
            let a;
            switch (this.state.type) {
              case 5:
                return (
                  (a = this.startNode()),
                  this.setContext(W.brace),
                  this.next(),
                  (a = this.jsxParseExpressionContainer(a, W.j_oTag)),
                  a.expression.type === 'JSXEmptyExpression' && this.raise(Wr.AttributeIsEmpty, { at: a }),
                  a
                );
              case 140:
              case 131:
                return this.parseExprAtom();
              default:
                throw this.raise(Wr.UnsupportedJsxValue, { at: this.state.startLoc });
            }
          }
          jsxParseEmptyExpression() {
            let a = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(a, 'JSXEmptyExpression', this.state.startLoc);
          }
          jsxParseSpreadChild(a) {
            return (
              this.next(),
              (a.expression = this.parseExpression()),
              this.setContext(W.j_expr),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(a, 'JSXSpreadChild')
            );
          }
          jsxParseExpressionContainer(a, h) {
            if (this.match(8)) a.expression = this.jsxParseEmptyExpression();
            else {
              let d = this.parseExpression();
              a.expression = d;
            }
            return (
              this.setContext(h),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(a, 'JSXExpressionContainer')
            );
          }
          jsxParseAttribute() {
            let a = this.startNode();
            return this.match(5)
              ? (this.setContext(W.brace),
                this.next(),
                this.expect(21),
                (a.argument = this.parseMaybeAssignAllowIn()),
                this.setContext(W.j_oTag),
                (this.state.canStartJSXElement = !0),
                this.expect(8),
                this.finishNode(a, 'JSXSpreadAttribute'))
              : ((a.name = this.jsxParseNamespacedName()),
                (a.value = this.eat(29) ? this.jsxParseAttributeValue() : null),
                this.finishNode(a, 'JSXAttribute'));
          }
          jsxParseOpeningElementAt(a) {
            let h = this.startNodeAt(a);
            return this.eat(141)
              ? this.finishNode(h, 'JSXOpeningFragment')
              : ((h.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(h));
          }
          jsxParseOpeningElementAfterName(a) {
            let h = [];
            for (; !this.match(56) && !this.match(141); ) h.push(this.jsxParseAttribute());
            return (
              (a.attributes = h),
              (a.selfClosing = this.eat(56)),
              this.expect(141),
              this.finishNode(a, 'JSXOpeningElement')
            );
          }
          jsxParseClosingElementAt(a) {
            let h = this.startNodeAt(a);
            return this.eat(141)
              ? this.finishNode(h, 'JSXClosingFragment')
              : ((h.name = this.jsxParseElementName()), this.expect(141), this.finishNode(h, 'JSXClosingElement'));
          }
          jsxParseElementAt(a) {
            let h = this.startNodeAt(a),
              d = [],
              D = this.jsxParseOpeningElementAt(a),
              A = null;
            if (!D.selfClosing) {
              e: for (;;)
                switch (this.state.type) {
                  case 140:
                    if (((a = this.state.startLoc), this.next(), this.eat(56))) {
                      A = this.jsxParseClosingElementAt(a);
                      break e;
                    }
                    d.push(this.jsxParseElementAt(a));
                    break;
                  case 139:
                    d.push(this.parseExprAtom());
                    break;
                  case 5: {
                    let P = this.startNode();
                    this.setContext(W.brace),
                      this.next(),
                      this.match(21)
                        ? d.push(this.jsxParseSpreadChild(P))
                        : d.push(this.jsxParseExpressionContainer(P, W.j_expr));
                    break;
                  }
                  default:
                    this.unexpected();
                }
              xi(D) && !xi(A) && A !== null
                ? this.raise(Wr.MissingClosingTagFragment, { at: A })
                : !xi(D) && xi(A)
                ? this.raise(Wr.MissingClosingTagElement, { at: A, openingTagName: vs(D.name) })
                : !xi(D) &&
                  !xi(A) &&
                  vs(A.name) !== vs(D.name) &&
                  this.raise(Wr.MissingClosingTagElement, { at: A, openingTagName: vs(D.name) });
            }
            if (
              (xi(D)
                ? ((h.openingFragment = D), (h.closingFragment = A))
                : ((h.openingElement = D), (h.closingElement = A)),
              (h.children = d),
              this.match(47))
            )
              throw this.raise(Wr.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
            return xi(D) ? this.finishNode(h, 'JSXFragment') : this.finishNode(h, 'JSXElement');
          }
          jsxParseElement() {
            let a = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(a);
          }
          setContext(a) {
            let { context: h } = this.state;
            h[h.length - 1] = a;
          }
          parseExprAtom(a) {
            return this.match(139)
              ? this.parseLiteral(this.state.value, 'JSXText')
              : this.match(140)
              ? this.jsxParseElement()
              : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33
              ? (this.replaceToken(140), this.jsxParseElement())
              : super.parseExprAtom(a);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(a) {
            let h = this.curContext();
            if (h === W.j_expr) {
              this.jsxReadToken();
              return;
            }
            if (h === W.j_oTag || h === W.j_cTag) {
              if (hn(a)) {
                this.jsxReadWord();
                return;
              }
              if (a === 62) {
                ++this.state.pos, this.finishToken(141);
                return;
              }
              if ((a === 34 || a === 39) && h === W.j_oTag) {
                this.jsxReadString(a);
                return;
              }
            }
            if (a === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
              ++this.state.pos, this.finishToken(140);
              return;
            }
            super.getTokenFromCode(a);
          }
          updateContext(a) {
            let { context: h, type: d } = this.state;
            if (d === 56 && a === 140) h.splice(-2, 2, W.j_cTag), (this.state.canStartJSXElement = !1);
            else if (d === 140) h.push(W.j_oTag);
            else if (d === 141) {
              let D = h[h.length - 1];
              (D === W.j_oTag && a === 56) || D === W.j_cTag
                ? (h.pop(), (this.state.canStartJSXElement = h[h.length - 1] === W.j_expr))
                : (this.setContext(W.j_expr), (this.state.canStartJSXElement = !0));
            } else this.state.canStartJSXElement = J(d);
          }
        },
      ad = class extends Ml {
        constructor(...u) {
          super(...u),
            (this.types = new Set()),
            (this.enums = new Set()),
            (this.constEnums = new Set()),
            (this.classes = new Set()),
            (this.exportOnlyBindings = new Set());
        }
      },
      jc = class extends Ol {
        constructor(...u) {
          super(...u), (this.importsStack = []);
        }
        createScope(u) {
          return this.importsStack.push(new Set()), new ad(u);
        }
        enter(u) {
          u == 256 && this.importsStack.push(new Set()), super.enter(u);
        }
        exit() {
          let u = super.exit();
          return u == 256 && this.importsStack.pop(), u;
        }
        hasImport(u, a) {
          let h = this.importsStack.length;
          if (this.importsStack[h - 1].has(u)) return !0;
          if (!a && h > 1) {
            for (let d = 0; d < h - 1; d++) if (this.importsStack[d].has(u)) return !0;
          }
          return !1;
        }
        declareName(u, a, h) {
          if (a & 4096) {
            this.hasImport(u, !0) && this.parser.raise(T.VarRedeclaration, { at: h, identifierName: u }),
              this.importsStack[this.importsStack.length - 1].add(u);
            return;
          }
          let d = this.currentScope();
          if (a & 1024) {
            this.maybeExportDefined(d, u), d.exportOnlyBindings.add(u);
            return;
          }
          super.declareName(u, a, h),
            a & 2 &&
              (a & 1 || (this.checkRedeclarationInScope(d, u, a, h), this.maybeExportDefined(d, u)), d.types.add(u)),
            a & 256 && d.enums.add(u),
            a & 512 && d.constEnums.add(u),
            a & 128 && d.classes.add(u);
        }
        isRedeclaredInScope(u, a, h) {
          if (u.enums.has(a)) {
            if (h & 256) {
              let d = !!(h & 512),
                D = u.constEnums.has(a);
              return d !== D;
            }
            return !0;
          }
          return h & 128 && u.classes.has(a)
            ? u.lexical.has(a)
              ? !!(h & 1)
              : !1
            : h & 2 && u.types.has(a)
            ? !0
            : super.isRedeclaredInScope(u, a, h);
        }
        checkLocalExport(u) {
          let { name: a } = u;
          if (this.hasImport(a)) return;
          let h = this.scopeStack.length;
          for (let d = h - 1; d >= 0; d--) {
            let D = this.scopeStack[d];
            if (D.types.has(a) || D.exportOnlyBindings.has(a)) return;
          }
          super.checkLocalExport(u);
        }
      },
      ld = (u, a) => Object.hasOwnProperty.call(u, a) && u[a],
      $c = (u) => (u.type === 'ParenthesizedExpression' ? $c(u.expression) : u),
      ud = class extends Lc {
        toAssignable(u, a = !1) {
          var h, d;
          let D;
          switch (
            ((u.type === 'ParenthesizedExpression' || ((h = u.extra) != null && h.parenthesized)) &&
              ((D = $c(u)),
              a
                ? D.type === 'Identifier'
                  ? this.expressionScope.recordArrowParameterBindingError(T.InvalidParenthesizedAssignment, { at: u })
                  : D.type !== 'MemberExpression' && this.raise(T.InvalidParenthesizedAssignment, { at: u })
                : this.raise(T.InvalidParenthesizedAssignment, { at: u })),
            u.type)
          ) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              break;
            case 'ObjectExpression':
              u.type = 'ObjectPattern';
              for (let P = 0, N = u.properties.length, R = N - 1; P < N; P++) {
                var A;
                let _ = u.properties[P],
                  ue = P === R;
                this.toAssignableObjectExpressionProp(_, ue, a),
                  ue &&
                    _.type === 'RestElement' &&
                    (A = u.extra) != null &&
                    A.trailingCommaLoc &&
                    this.raise(T.RestTrailingComma, { at: u.extra.trailingCommaLoc });
              }
              break;
            case 'ObjectProperty': {
              let { key: P, value: N } = u;
              this.isPrivateName(P) && this.classScope.usePrivateName(this.getPrivateNameSV(P), P.loc.start),
                this.toAssignable(N, a);
              break;
            }
            case 'SpreadElement':
              throw new Error(
                "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.",
              );
            case 'ArrayExpression':
              (u.type = 'ArrayPattern'),
                this.toAssignableList(u.elements, (d = u.extra) == null ? void 0 : d.trailingCommaLoc, a);
              break;
            case 'AssignmentExpression':
              u.operator !== '=' && this.raise(T.MissingEqInAssignment, { at: u.left.loc.end }),
                (u.type = 'AssignmentPattern'),
                delete u.operator,
                this.toAssignable(u.left, a);
              break;
            case 'ParenthesizedExpression':
              this.toAssignable(D, a);
              break;
          }
        }
        toAssignableObjectExpressionProp(u, a, h) {
          if (u.type === 'ObjectMethod')
            this.raise(u.kind === 'get' || u.kind === 'set' ? T.PatternHasAccessor : T.PatternHasMethod, { at: u.key });
          else if (u.type === 'SpreadElement') {
            u.type = 'RestElement';
            let d = u.argument;
            this.checkToRestConversion(d, !1), this.toAssignable(d, h), a || this.raise(T.RestTrailingComma, { at: u });
          } else this.toAssignable(u, h);
        }
        toAssignableList(u, a, h) {
          let d = u.length - 1;
          for (let D = 0; D <= d; D++) {
            let A = u[D];
            if (A) {
              if (A.type === 'SpreadElement') {
                A.type = 'RestElement';
                let P = A.argument;
                this.checkToRestConversion(P, !0), this.toAssignable(P, h);
              } else this.toAssignable(A, h);
              A.type === 'RestElement' &&
                (D < d ? this.raise(T.RestTrailingComma, { at: A }) : a && this.raise(T.RestTrailingComma, { at: a }));
            }
          }
        }
        isAssignable(u, a) {
          switch (u.type) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              return !0;
            case 'ObjectExpression': {
              let h = u.properties.length - 1;
              return u.properties.every(
                (d, D) => d.type !== 'ObjectMethod' && (D === h || d.type !== 'SpreadElement') && this.isAssignable(d),
              );
            }
            case 'ObjectProperty':
              return this.isAssignable(u.value);
            case 'SpreadElement':
              return this.isAssignable(u.argument);
            case 'ArrayExpression':
              return u.elements.every((h) => h === null || this.isAssignable(h));
            case 'AssignmentExpression':
              return u.operator === '=';
            case 'ParenthesizedExpression':
              return this.isAssignable(u.expression);
            case 'MemberExpression':
            case 'OptionalMemberExpression':
              return !a;
            default:
              return !1;
          }
        }
        toReferencedList(u, a) {
          return u;
        }
        toReferencedListDeep(u, a) {
          this.toReferencedList(u, a);
          for (let h of u) (h == null ? void 0 : h.type) === 'ArrayExpression' && this.toReferencedListDeep(h.elements);
        }
        parseSpread(u) {
          let a = this.startNode();
          return (
            this.next(), (a.argument = this.parseMaybeAssignAllowIn(u, void 0)), this.finishNode(a, 'SpreadElement')
          );
        }
        parseRestBinding() {
          let u = this.startNode();
          return this.next(), (u.argument = this.parseBindingAtom()), this.finishNode(u, 'RestElement');
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              let u = this.startNode();
              return this.next(), (u.elements = this.parseBindingList(3, 93, 1)), this.finishNode(u, 'ArrayPattern');
            }
            case 5:
              return this.parseObjectLike(8, !0);
          }
          return this.parseIdentifier();
        }
        parseBindingList(u, a, h) {
          let d = h & 1,
            D = [],
            A = !0;
          for (; !this.eat(u); )
            if ((A ? (A = !1) : this.expect(12), d && this.match(12))) D.push(null);
            else {
              if (this.eat(u)) break;
              if (this.match(21)) {
                if (
                  (D.push(this.parseAssignableListItemTypes(this.parseRestBinding(), h)), !this.checkCommaAfterRest(a))
                ) {
                  this.expect(u);
                  break;
                }
              } else {
                let P = [];
                for (
                  this.match(26) &&
                  this.hasPlugin('decorators') &&
                  this.raise(T.UnsupportedParameterDecorator, { at: this.state.startLoc });
                  this.match(26);

                )
                  P.push(this.parseDecorator());
                D.push(this.parseAssignableListItem(h, P));
              }
            }
          return D;
        }
        parseBindingRestProperty(u) {
          return (
            this.next(),
            (u.argument = this.parseIdentifier()),
            this.checkCommaAfterRest(125),
            this.finishNode(u, 'RestElement')
          );
        }
        parseBindingProperty() {
          let u = this.startNode(),
            { type: a, startLoc: h } = this.state;
          return a === 21
            ? this.parseBindingRestProperty(u)
            : (a === 136
                ? (this.expectPlugin('destructuringPrivate', h),
                  this.classScope.usePrivateName(this.state.value, h),
                  (u.key = this.parsePrivateName()))
                : this.parsePropertyName(u),
              (u.method = !1),
              this.parseObjPropValue(u, h, !1, !1, !0, !1));
        }
        parseAssignableListItem(u, a) {
          let h = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(h, u);
          let d = this.parseMaybeDefault(h.loc.start, h);
          return a.length && (h.decorators = a), d;
        }
        parseAssignableListItemTypes(u, a) {
          return u;
        }
        parseMaybeDefault(u, a) {
          var h;
          if (
            (u != null || (u = this.state.startLoc), (a = (h = a) != null ? h : this.parseBindingAtom()), !this.eat(29))
          )
            return a;
          let d = this.startNodeAt(u);
          return (d.left = a), (d.right = this.parseMaybeAssignAllowIn()), this.finishNode(d, 'AssignmentPattern');
        }
        isValidLVal(u, a, h) {
          return ld(
            {
              AssignmentPattern: 'left',
              RestElement: 'argument',
              ObjectProperty: 'value',
              ParenthesizedExpression: 'expression',
              ArrayPattern: 'elements',
              ObjectPattern: 'properties',
            },
            u,
          );
        }
        checkLVal(
          u,
          { in: a, binding: h = 64, checkClashes: d = !1, strictModeChanged: D = !1, hasParenthesizedAncestor: A = !1 },
        ) {
          var P;
          let N = u.type;
          if (this.isObjectMethod(u)) return;
          if (N === 'MemberExpression') {
            h !== 64 && this.raise(T.InvalidPropertyBindingPattern, { at: u });
            return;
          }
          if (N === 'Identifier') {
            this.checkIdentifier(u, h, D);
            let { name: Ie } = u;
            d && (d.has(Ie) ? this.raise(T.ParamDupe, { at: u }) : d.add(Ie));
            return;
          }
          let R = this.isValidLVal(
            N,
            !(A || ((P = u.extra) != null && P.parenthesized)) && a.type === 'AssignmentExpression',
            h,
          );
          if (R === !0) return;
          if (R === !1) {
            let Ie = h === 64 ? T.InvalidLhs : T.InvalidLhsBinding;
            this.raise(Ie, { at: u, ancestor: a });
            return;
          }
          let [_, ue] = Array.isArray(R) ? R : [R, N === 'ParenthesizedExpression'],
            ve = N === 'ArrayPattern' || N === 'ObjectPattern' || N === 'ParenthesizedExpression' ? { type: N } : a;
          for (let Ie of [].concat(u[_]))
            Ie &&
              this.checkLVal(Ie, {
                in: ve,
                binding: h,
                checkClashes: d,
                strictModeChanged: D,
                hasParenthesizedAncestor: ue,
              });
        }
        checkIdentifier(u, a, h = !1) {
          this.state.strict &&
            (h ? vc(u.name, this.inModule) : lr(u.name)) &&
            (a === 64
              ? this.raise(T.StrictEvalArguments, { at: u, referenceName: u.name })
              : this.raise(T.StrictEvalArgumentsBinding, { at: u, bindingName: u.name })),
            a & 8192 && u.name === 'let' && this.raise(T.LetInLexicalBinding, { at: u }),
            a & 64 || this.declareNameFromIdentifier(u, a);
        }
        declareNameFromIdentifier(u, a) {
          this.scope.declareName(u.name, a, u.loc.start);
        }
        checkToRestConversion(u, a) {
          switch (u.type) {
            case 'ParenthesizedExpression':
              this.checkToRestConversion(u.expression, a);
              break;
            case 'Identifier':
            case 'MemberExpression':
              break;
            case 'ArrayExpression':
            case 'ObjectExpression':
              if (a) break;
            default:
              this.raise(T.InvalidRestAssignmentPattern, { at: u });
          }
        }
        checkCommaAfterRest(u) {
          return this.match(12)
            ? (this.raise(this.lookaheadCharCode() === u ? T.RestTrailingComma : T.ElementAfterRest, {
                at: this.state.startLoc,
              }),
              !0)
            : !1;
        }
      },
      cd = (u, a) => Object.hasOwnProperty.call(u, a) && u[a];
    function hd(u) {
      if (u == null) throw new Error(`Unexpected ${u} value.`);
      return u;
    }
    function Vc(u) {
      if (!u) throw new Error('Assert fail');
    }
    var Ve = I`typescript`({
      AbstractMethodHasImplementation: ({ methodName: u }) =>
        `Method '${u}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({ propertyName: u }) =>
        `Property '${u}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: 'An accessor cannot have type parameters.',
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:
        "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.',
      DeclareAccessor: ({ kind: u }) => `'declare' is not allowed in ${u}ters.`,
      DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.',
      DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.',
      DuplicateAccessibilityModifier: ({ modifier: u }) => 'Accessibility modifier already seen.',
      DuplicateModifier: ({ modifier: u }) => `Duplicate modifier: '${u}'.`,
      EmptyHeritageClauseType: ({ token: u }) => `'${u}' list cannot be empty.`,
      EmptyTypeArguments: 'Type argument list cannot be empty.',
      EmptyTypeParameters: 'Type parameter list cannot be empty.',
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: 'An `import module` declaration can not use `type` modifier',
      IncompatibleModifiers: ({ modifiers: u }) => `'${u[0]}' modifier cannot be used with '${u[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({ modifier: u }) =>
        `Index signatures cannot have an accessibility modifier ('${u}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.',
      InvalidModifierOnTypeMember: ({ modifier: u }) => `'${u}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({ modifier: u }) => `'${u}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({ modifier: u }) =>
        `'${u}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({ orderedModifiers: u }) => `'${u[0]}' modifier must precede '${u[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression:
        'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.',
      InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.',
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      MixedLabeledAndUnlabeledElements: 'Tuple members must all have names or all not have names.',
      NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.',
      NonClassMethodPropertyHasAbstractModifer:
        "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.',
      OverrideNotInSubClass:
        "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.',
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({ modifier: u }) =>
        `Private elements cannot have an accessibility modifier ('${u}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam:
        'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.',
      ReservedTypeAssertion:
        'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.',
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: u }) =>
        `Single type parameter ${u} should have a trailing comma. Example usage: <${u},>.`,
      StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.',
      TupleOptionalAfterType:
        'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).',
      TypeAnnotationAfterAssign:
        'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
      TypeImportCannotSpecifyDefaultAndNamed:
        'A type-only import can specify a default import or named bindings, but not both.',
      TypeModifierIsUsedInTypeExports:
        "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports:
        "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.',
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
      UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.',
      UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.',
      UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.',
      UnsupportedSignatureParameterKind: ({ type: u }) =>
        `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${u}.`,
    });
    function pd(u) {
      switch (u) {
        case 'any':
          return 'TSAnyKeyword';
        case 'boolean':
          return 'TSBooleanKeyword';
        case 'bigint':
          return 'TSBigIntKeyword';
        case 'never':
          return 'TSNeverKeyword';
        case 'number':
          return 'TSNumberKeyword';
        case 'object':
          return 'TSObjectKeyword';
        case 'string':
          return 'TSStringKeyword';
        case 'symbol':
          return 'TSSymbolKeyword';
        case 'undefined':
          return 'TSUndefinedKeyword';
        case 'unknown':
          return 'TSUnknownKeyword';
        default:
          return;
      }
    }
    function ql(u) {
      return u === 'private' || u === 'public' || u === 'protected';
    }
    function zc(u) {
      return u === 'in' || u === 'out';
    }
    var Hc = (u) =>
      class extends u {
        constructor(...a) {
          super(...a),
            (this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['in', 'out'],
              disallowedModifiers: [
                'const',
                'public',
                'private',
                'protected',
                'readonly',
                'declare',
                'abstract',
                'override',
              ],
              errorTemplate: Ve.InvalidModifierOnTypeParameter,
            })),
            (this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['const'],
              disallowedModifiers: ['in', 'out'],
              errorTemplate: Ve.InvalidModifierOnTypeParameterPositions,
            })),
            (this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['in', 'out', 'const'],
              disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'],
              errorTemplate: Ve.InvalidModifierOnTypeParameter,
            }));
        }
        getScopeHandler() {
          return jc;
        }
        tsIsIdentifier() {
          return fe(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (
            (this.match(0) ||
              this.match(5) ||
              this.match(55) ||
              this.match(21) ||
              this.match(136) ||
              this.isLiteralPropertyName()) &&
            !this.hasPrecedingLineBreak()
          );
        }
        tsNextTokenCanFollowModifier() {
          return this.next(), this.tsTokenCanFollowModifier();
        }
        tsParseModifier(a, h) {
          if (!fe(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
          let d = this.state.value;
          if (a.indexOf(d) !== -1) {
            if (h && this.tsIsStartOfStaticBlocks()) return;
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return d;
          }
        }
        tsParseModifiers(
          {
            allowedModifiers: a,
            disallowedModifiers: h,
            stopOnStartOfClassStaticBlock: d,
            errorTemplate: D = Ve.InvalidModifierOnTypeMember,
          },
          A,
        ) {
          let P = (R, _, ue, ve) => {
              _ === ue && A[ve] && this.raise(Ve.InvalidModifiersOrder, { at: R, orderedModifiers: [ue, ve] });
            },
            N = (R, _, ue, ve) => {
              ((A[ue] && _ === ve) || (A[ve] && _ === ue)) &&
                this.raise(Ve.IncompatibleModifiers, { at: R, modifiers: [ue, ve] });
            };
          for (;;) {
            let { startLoc: R } = this.state,
              _ = this.tsParseModifier(a.concat(h ?? []), d);
            if (!_) break;
            ql(_)
              ? A.accessibility
                ? this.raise(Ve.DuplicateAccessibilityModifier, { at: R, modifier: _ })
                : (P(R, _, _, 'override'), P(R, _, _, 'static'), P(R, _, _, 'readonly'), (A.accessibility = _))
              : zc(_)
              ? (A[_] && this.raise(Ve.DuplicateModifier, { at: R, modifier: _ }), (A[_] = !0), P(R, _, 'in', 'out'))
              : (Object.hasOwnProperty.call(A, _)
                  ? this.raise(Ve.DuplicateModifier, { at: R, modifier: _ })
                  : (P(R, _, 'static', 'readonly'),
                    P(R, _, 'static', 'override'),
                    P(R, _, 'override', 'readonly'),
                    P(R, _, 'abstract', 'override'),
                    N(R, _, 'declare', 'override'),
                    N(R, _, 'static', 'abstract')),
                (A[_] = !0)),
              h != null && h.includes(_) && this.raise(D, { at: R, modifier: _ });
          }
        }
        tsIsListTerminator(a) {
          switch (a) {
            case 'EnumMembers':
            case 'TypeMembers':
              return this.match(8);
            case 'HeritageClauseElement':
              return this.match(5);
            case 'TupleElementTypes':
              return this.match(3);
            case 'TypeParametersOrArguments':
              return this.match(48);
          }
        }
        tsParseList(a, h) {
          let d = [];
          for (; !this.tsIsListTerminator(a); ) d.push(h());
          return d;
        }
        tsParseDelimitedList(a, h, d) {
          return hd(this.tsParseDelimitedListWorker(a, h, !0, d));
        }
        tsParseDelimitedListWorker(a, h, d, D) {
          let A = [],
            P = -1;
          for (; !this.tsIsListTerminator(a); ) {
            P = -1;
            let N = h();
            if (N == null) return;
            if ((A.push(N), this.eat(12))) {
              P = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(a)) break;
            d && this.expect(12);
            return;
          }
          return D && (D.value = P), A;
        }
        tsParseBracketedList(a, h, d, D, A) {
          D || (d ? this.expect(0) : this.expect(47));
          let P = this.tsParseDelimitedList(a, h, A);
          return d ? this.expect(3) : this.expect(48), P;
        }
        tsParseImportType() {
          let a = this.startNode();
          return (
            this.expect(83),
            this.expect(10),
            this.match(131) || this.raise(Ve.UnsupportedImportTypeArgument, { at: this.state.startLoc }),
            (a.argument = super.parseExprAtom()),
            this.expect(11),
            this.eat(16) && (a.qualifier = this.tsParseEntityName()),
            this.match(47) && (a.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(a, 'TSImportType')
          );
        }
        tsParseEntityName(a = !0) {
          let h = this.parseIdentifier(a);
          for (; this.eat(16); ) {
            let d = this.startNodeAtNode(h);
            (d.left = h), (d.right = this.parseIdentifier(a)), (h = this.finishNode(d, 'TSQualifiedName'));
          }
          return h;
        }
        tsParseTypeReference() {
          let a = this.startNode();
          return (
            (a.typeName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() && this.match(47) && (a.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(a, 'TSTypeReference')
          );
        }
        tsParseThisTypePredicate(a) {
          this.next();
          let h = this.startNodeAtNode(a);
          return (
            (h.parameterName = a),
            (h.typeAnnotation = this.tsParseTypeAnnotation(!1)),
            (h.asserts = !1),
            this.finishNode(h, 'TSTypePredicate')
          );
        }
        tsParseThisTypeNode() {
          let a = this.startNode();
          return this.next(), this.finishNode(a, 'TSThisType');
        }
        tsParseTypeQuery() {
          let a = this.startNode();
          return (
            this.expect(87),
            this.match(83) ? (a.exprName = this.tsParseImportType()) : (a.exprName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() && this.match(47) && (a.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(a, 'TSTypeQuery')
          );
        }
        tsParseTypeParameter(a) {
          let h = this.startNode();
          return (
            a(h),
            (h.name = this.tsParseTypeParameterName()),
            (h.constraint = this.tsEatThenParseType(81)),
            (h.default = this.tsEatThenParseType(29)),
            this.finishNode(h, 'TSTypeParameter')
          );
        }
        tsTryParseTypeParameters(a) {
          if (this.match(47)) return this.tsParseTypeParameters(a);
        }
        tsParseTypeParameters(a) {
          let h = this.startNode();
          this.match(47) || this.match(140) ? this.next() : this.unexpected();
          let d = { value: -1 };
          return (
            (h.params = this.tsParseBracketedList(
              'TypeParametersOrArguments',
              this.tsParseTypeParameter.bind(this, a),
              !1,
              !0,
              d,
            )),
            h.params.length === 0 && this.raise(Ve.EmptyTypeParameters, { at: h }),
            d.value !== -1 && this.addExtra(h, 'trailingComma', d.value),
            this.finishNode(h, 'TSTypeParameterDeclaration')
          );
        }
        tsFillSignature(a, h) {
          let d = a === 19,
            D = 'parameters',
            A = 'typeAnnotation';
          (h.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier)),
            this.expect(10),
            (h[D] = this.tsParseBindingListForSignature()),
            d
              ? (h[A] = this.tsParseTypeOrTypePredicateAnnotation(a))
              : this.match(a) && (h[A] = this.tsParseTypeOrTypePredicateAnnotation(a));
        }
        tsParseBindingListForSignature() {
          let a = super.parseBindingList(11, 41, 2);
          for (let h of a) {
            let { type: d } = h;
            (d === 'AssignmentPattern' || d === 'TSParameterProperty') &&
              this.raise(Ve.UnsupportedSignatureParameterKind, { at: h, type: d });
          }
          return a;
        }
        tsParseTypeMemberSemicolon() {
          !this.eat(12) && !this.isLineTerminator() && this.expect(13);
        }
        tsParseSignatureMember(a, h) {
          return this.tsFillSignature(14, h), this.tsParseTypeMemberSemicolon(), this.finishNode(h, a);
        }
        tsIsUnambiguouslyIndexSignature() {
          return this.next(), fe(this.state.type) ? (this.next(), this.match(14)) : !1;
        }
        tsTryParseIndexSignature(a) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
          this.expect(0);
          let h = this.parseIdentifier();
          (h.typeAnnotation = this.tsParseTypeAnnotation()),
            this.resetEndLocation(h),
            this.expect(3),
            (a.parameters = [h]);
          let d = this.tsTryParseTypeAnnotation();
          return d && (a.typeAnnotation = d), this.tsParseTypeMemberSemicolon(), this.finishNode(a, 'TSIndexSignature');
        }
        tsParsePropertyOrMethodSignature(a, h) {
          this.eat(17) && (a.optional = !0);
          let d = a;
          if (this.match(10) || this.match(47)) {
            h && this.raise(Ve.ReadonlyForMethodSignature, { at: a });
            let D = d;
            D.kind &&
              this.match(47) &&
              this.raise(Ve.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }),
              this.tsFillSignature(14, D),
              this.tsParseTypeMemberSemicolon();
            let A = 'parameters',
              P = 'typeAnnotation';
            if (D.kind === 'get')
              D[A].length > 0 &&
                (this.raise(T.BadGetterArity, { at: this.state.curPosition() }),
                this.isThisParam(D[A][0]) &&
                  this.raise(Ve.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
            else if (D.kind === 'set') {
              if (D[A].length !== 1) this.raise(T.BadSetterArity, { at: this.state.curPosition() });
              else {
                let N = D[A][0];
                this.isThisParam(N) &&
                  this.raise(Ve.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }),
                  N.type === 'Identifier' &&
                    N.optional &&
                    this.raise(Ve.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }),
                  N.type === 'RestElement' &&
                    this.raise(Ve.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
              }
              D[P] && this.raise(Ve.SetAccesorCannotHaveReturnType, { at: D[P] });
            } else D.kind = 'method';
            return this.finishNode(D, 'TSMethodSignature');
          } else {
            let D = d;
            h && (D.readonly = !0);
            let A = this.tsTryParseTypeAnnotation();
            return (
              A && (D.typeAnnotation = A), this.tsParseTypeMemberSemicolon(), this.finishNode(D, 'TSPropertySignature')
            );
          }
        }
        tsParseTypeMember() {
          let a = this.startNode();
          if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', a);
          if (this.match(77)) {
            let d = this.startNode();
            return (
              this.next(),
              this.match(10) || this.match(47)
                ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', a)
                : ((a.key = this.createIdentifier(d, 'new')), this.tsParsePropertyOrMethodSignature(a, !1))
            );
          }
          return (
            this.tsParseModifiers(
              {
                allowedModifiers: ['readonly'],
                disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'],
              },
              a,
            ),
            this.tsTryParseIndexSignature(a) ||
              (super.parsePropertyName(a),
              !a.computed &&
                a.key.type === 'Identifier' &&
                (a.key.name === 'get' || a.key.name === 'set') &&
                this.tsTokenCanFollowModifier() &&
                ((a.kind = a.key.name), super.parsePropertyName(a)),
              this.tsParsePropertyOrMethodSignature(a, !!a.readonly))
          );
        }
        tsParseTypeLiteral() {
          let a = this.startNode();
          return (a.members = this.tsParseObjectTypeMembers()), this.finishNode(a, 'TSTypeLiteral');
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          let a = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
          return this.expect(8), a;
        }
        tsIsStartOfMappedType() {
          return (
            this.next(),
            this.eat(53)
              ? this.isContextual(120)
              : (this.isContextual(120) && this.next(),
                !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)))
          );
        }
        tsParseMappedTypeParameter() {
          let a = this.startNode();
          return (
            (a.name = this.tsParseTypeParameterName()),
            (a.constraint = this.tsExpectThenParseType(58)),
            this.finishNode(a, 'TSTypeParameter')
          );
        }
        tsParseMappedType() {
          let a = this.startNode();
          return (
            this.expect(5),
            this.match(53)
              ? ((a.readonly = this.state.value), this.next(), this.expectContextual(120))
              : this.eatContextual(120) && (a.readonly = !0),
            this.expect(0),
            (a.typeParameter = this.tsParseMappedTypeParameter()),
            (a.nameType = this.eatContextual(93) ? this.tsParseType() : null),
            this.expect(3),
            this.match(53)
              ? ((a.optional = this.state.value), this.next(), this.expect(17))
              : this.eat(17) && (a.optional = !0),
            (a.typeAnnotation = this.tsTryParseType()),
            this.semicolon(),
            this.expect(8),
            this.finishNode(a, 'TSMappedType')
          );
        }
        tsParseTupleType() {
          let a = this.startNode();
          a.elementTypes = this.tsParseBracketedList(
            'TupleElementTypes',
            this.tsParseTupleElementType.bind(this),
            !0,
            !1,
          );
          let h = !1,
            d = null;
          return (
            a.elementTypes.forEach((D) => {
              let { type: A } = D;
              h &&
                A !== 'TSRestType' &&
                A !== 'TSOptionalType' &&
                !(A === 'TSNamedTupleMember' && D.optional) &&
                this.raise(Ve.OptionalTypeBeforeRequired, { at: D }),
                h || (h = (A === 'TSNamedTupleMember' && D.optional) || A === 'TSOptionalType');
              let P = A;
              A === 'TSRestType' && ((D = D.typeAnnotation), (P = D.type));
              let N = P === 'TSNamedTupleMember';
              d != null || (d = N), d !== N && this.raise(Ve.MixedLabeledAndUnlabeledElements, { at: D });
            }),
            this.finishNode(a, 'TSTupleType')
          );
        }
        tsParseTupleElementType() {
          let { startLoc: a } = this.state,
            h = this.eat(21),
            d,
            D,
            A,
            P,
            N = M(this.state.type) ? this.lookaheadCharCode() : null;
          if (N === 58) (d = !0), (A = !1), (D = this.parseIdentifier(!0)), this.expect(14), (P = this.tsParseType());
          else if (N === 63) {
            A = !0;
            let R = this.state.startLoc,
              _ = this.state.value,
              ue = this.tsParseNonArrayType();
            this.lookaheadCharCode() === 58
              ? ((d = !0),
                (D = this.createIdentifier(this.startNodeAt(R), _)),
                this.expect(17),
                this.expect(14),
                (P = this.tsParseType()))
              : ((d = !1), (P = ue), this.expect(17));
          } else (P = this.tsParseType()), (A = this.eat(17)), (d = this.eat(14));
          if (d) {
            let R;
            D
              ? ((R = this.startNodeAtNode(D)),
                (R.optional = A),
                (R.label = D),
                (R.elementType = P),
                this.eat(17) &&
                  ((R.optional = !0), this.raise(Ve.TupleOptionalAfterType, { at: this.state.lastTokStartLoc })))
              : ((R = this.startNodeAtNode(P)),
                (R.optional = A),
                this.raise(Ve.InvalidTupleMemberLabel, { at: P }),
                (R.label = P),
                (R.elementType = this.tsParseType())),
              (P = this.finishNode(R, 'TSNamedTupleMember'));
          } else if (A) {
            let R = this.startNodeAtNode(P);
            (R.typeAnnotation = P), (P = this.finishNode(R, 'TSOptionalType'));
          }
          if (h) {
            let R = this.startNodeAt(a);
            (R.typeAnnotation = P), (P = this.finishNode(R, 'TSRestType'));
          }
          return P;
        }
        tsParseParenthesizedType() {
          let a = this.startNode();
          return (
            this.expect(10),
            (a.typeAnnotation = this.tsParseType()),
            this.expect(11),
            this.finishNode(a, 'TSParenthesizedType')
          );
        }
        tsParseFunctionOrConstructorType(a, h) {
          let d = this.startNode();
          return (
            a === 'TSConstructorType' && ((d.abstract = !!h), h && this.next(), this.next()),
            this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, d)),
            this.finishNode(d, a)
          );
        }
        tsParseLiteralTypeNode() {
          let a = this.startNode();
          switch (this.state.type) {
            case 132:
            case 133:
            case 131:
            case 85:
            case 86:
              a.literal = super.parseExprAtom();
              break;
            default:
              this.unexpected();
          }
          return this.finishNode(a, 'TSLiteralType');
        }
        tsParseTemplateLiteralType() {
          let a = this.startNode();
          return (a.literal = super.parseTemplate(!1)), this.finishNode(a, 'TSLiteralType');
        }
        parseTemplateSubstitution() {
          return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          let a = this.tsParseThisTypeNode();
          return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(a) : a;
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 131:
            case 132:
            case 133:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === '-') {
                let a = this.startNode(),
                  h = this.lookahead();
                return (
                  h.type !== 132 && h.type !== 133 && this.unexpected(),
                  (a.literal = this.parseMaybeUnary()),
                  this.finishNode(a, 'TSLiteralType')
                );
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
                ? this.tsParseMappedType()
                : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              let { type: a } = this.state;
              if (fe(a) || a === 88 || a === 84) {
                let h = a === 88 ? 'TSVoidKeyword' : a === 84 ? 'TSNullKeyword' : pd(this.state.value);
                if (h !== void 0 && this.lookaheadCharCode() !== 46) {
                  let d = this.startNode();
                  return this.next(), this.finishNode(d, h);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let a = this.tsParseNonArrayType();
          for (; !this.hasPrecedingLineBreak() && this.eat(0); )
            if (this.match(3)) {
              let h = this.startNodeAtNode(a);
              (h.elementType = a), this.expect(3), (a = this.finishNode(h, 'TSArrayType'));
            } else {
              let h = this.startNodeAtNode(a);
              (h.objectType = a),
                (h.indexType = this.tsParseType()),
                this.expect(3),
                (a = this.finishNode(h, 'TSIndexedAccessType'));
            }
          return a;
        }
        tsParseTypeOperator() {
          let a = this.startNode(),
            h = this.state.value;
          return (
            this.next(),
            (a.operator = h),
            (a.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
            h === 'readonly' && this.tsCheckTypeAnnotationForReadOnly(a),
            this.finishNode(a, 'TSTypeOperator')
          );
        }
        tsCheckTypeAnnotationForReadOnly(a) {
          switch (a.typeAnnotation.type) {
            case 'TSTupleType':
            case 'TSArrayType':
              return;
            default:
              this.raise(Ve.UnexpectedReadonly, { at: a });
          }
        }
        tsParseInferType() {
          let a = this.startNode();
          this.expectContextual(113);
          let h = this.startNode();
          return (
            (h.name = this.tsParseTypeParameterName()),
            (h.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())),
            (a.typeParameter = this.finishNode(h, 'TSTypeParameter')),
            this.finishNode(a, 'TSInferType')
          );
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            let a = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return a;
          }
        }
        tsParseTypeOperatorOrHigher() {
          return He(this.state.type) && !this.state.containsEsc
            ? this.tsParseTypeOperator()
            : this.isContextual(113)
            ? this.tsParseInferType()
            : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(a, h, d) {
          let D = this.startNode(),
            A = this.eat(d),
            P = [];
          do P.push(h());
          while (this.eat(d));
          return P.length === 1 && !A ? P[0] : ((D.types = P), this.finishNode(D, a));
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            'TSIntersectionType',
            this.tsParseTypeOperatorOrHigher.bind(this),
            45,
          );
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            'TSUnionType',
            this.tsParseIntersectionTypeOrHigher.bind(this),
            43,
          );
        }
        tsIsStartOfFunctionType() {
          return this.match(47)
            ? !0
            : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (fe(this.state.type) || this.match(78)) return this.next(), !0;
          if (this.match(5)) {
            let { errors: a } = this.state,
              h = a.length;
            try {
              return this.parseObjectLike(8, !0), a.length === h;
            } catch {
              return !1;
            }
          }
          if (this.match(0)) {
            this.next();
            let { errors: a } = this.state,
              h = a.length;
            try {
              return super.parseBindingList(3, 93, 1), a.length === h;
            } catch {
              return !1;
            }
          }
          return !1;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          return (
            this.next(),
            !!(
              this.match(11) ||
              this.match(21) ||
              (this.tsSkipParameterStart() &&
                (this.match(14) ||
                  this.match(12) ||
                  this.match(17) ||
                  this.match(29) ||
                  (this.match(11) && (this.next(), this.match(19)))))
            )
          );
        }
        tsParseTypeOrTypePredicateAnnotation(a) {
          return this.tsInType(() => {
            let h = this.startNode();
            this.expect(a);
            let d = this.startNode(),
              D = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (D && this.match(78)) {
              let N = this.tsParseThisTypeOrThisTypePredicate();
              return (
                N.type === 'TSThisType'
                  ? ((d.parameterName = N),
                    (d.asserts = !0),
                    (d.typeAnnotation = null),
                    (N = this.finishNode(d, 'TSTypePredicate')))
                  : (this.resetStartLocationFromNode(N, d), (N.asserts = !0)),
                (h.typeAnnotation = N),
                this.finishNode(h, 'TSTypeAnnotation')
              );
            }
            let A = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!A)
              return D
                ? ((d.parameterName = this.parseIdentifier()),
                  (d.asserts = D),
                  (d.typeAnnotation = null),
                  (h.typeAnnotation = this.finishNode(d, 'TSTypePredicate')),
                  this.finishNode(h, 'TSTypeAnnotation'))
                : this.tsParseTypeAnnotation(!1, h);
            let P = this.tsParseTypeAnnotation(!1);
            return (
              (d.parameterName = A),
              (d.typeAnnotation = P),
              (d.asserts = D),
              (h.typeAnnotation = this.finishNode(d, 'TSTypePredicate')),
              this.finishNode(h, 'TSTypeAnnotation')
            );
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        tsTryParseTypeAnnotation() {
          if (this.match(14)) return this.tsParseTypeAnnotation();
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          let a = this.parseIdentifier();
          if (this.isContextual(114) && !this.hasPrecedingLineBreak()) return this.next(), a;
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 107) return !1;
          let a = this.state.containsEsc;
          return (
            this.next(),
            !fe(this.state.type) && !this.match(78)
              ? !1
              : (a &&
                  this.raise(T.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: 'asserts' }),
                !0)
          );
        }
        tsParseTypeAnnotation(a = !0, h = this.startNode()) {
          return (
            this.tsInType(() => {
              a && this.expect(14), (h.typeAnnotation = this.tsParseType());
            }),
            this.finishNode(h, 'TSTypeAnnotation')
          );
        }
        tsParseType() {
          Vc(this.state.inType);
          let a = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return a;
          let h = this.startNodeAtNode(a);
          return (
            (h.checkType = a),
            (h.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())),
            this.expect(17),
            (h.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
            this.expect(14),
            (h.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
            this.finishNode(h, 'TSConditionalType')
          );
        }
        isAbstractConstructorSignature() {
          return this.isContextual(122) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          return this.tsIsStartOfFunctionType()
            ? this.tsParseFunctionOrConstructorType('TSFunctionType')
            : this.match(77)
            ? this.tsParseFunctionOrConstructorType('TSConstructorType')
            : this.isAbstractConstructorSignature()
            ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0)
            : this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
            this.raise(Ve.ReservedTypeAssertion, { at: this.state.startLoc });
          let a = this.startNode();
          return (
            (a.typeAnnotation = this.tsInType(
              () => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType()),
            )),
            this.expect(48),
            (a.expression = this.parseMaybeUnary()),
            this.finishNode(a, 'TSTypeAssertion')
          );
        }
        tsParseHeritageClause(a) {
          let h = this.state.startLoc,
            d = this.tsParseDelimitedList('HeritageClauseElement', () => {
              let D = this.startNode();
              return (
                (D.expression = this.tsParseEntityName()),
                this.match(47) && (D.typeParameters = this.tsParseTypeArguments()),
                this.finishNode(D, 'TSExpressionWithTypeArguments')
              );
            });
          return d.length || this.raise(Ve.EmptyHeritageClauseType, { at: h, token: a }), d;
        }
        tsParseInterfaceDeclaration(a, h = {}) {
          if (this.hasFollowingLineBreak()) return null;
          this.expectContextual(127),
            h.declare && (a.declare = !0),
            fe(this.state.type)
              ? ((a.id = this.parseIdentifier()), this.checkIdentifier(a.id, 130))
              : ((a.id = null), this.raise(Ve.MissingInterfaceName, { at: this.state.startLoc })),
            (a.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)),
            this.eat(81) && (a.extends = this.tsParseHeritageClause('extends'));
          let d = this.startNode();
          return (
            (d.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))),
            (a.body = this.finishNode(d, 'TSInterfaceBody')),
            this.finishNode(a, 'TSInterfaceDeclaration')
          );
        }
        tsParseTypeAliasDeclaration(a) {
          return (
            (a.id = this.parseIdentifier()),
            this.checkIdentifier(a.id, 2),
            (a.typeAnnotation = this.tsInType(() => {
              if (
                ((a.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers)),
                this.expect(29),
                this.isContextual(112) && this.lookahead().type !== 16)
              ) {
                let h = this.startNode();
                return this.next(), this.finishNode(h, 'TSIntrinsicKeyword');
              }
              return this.tsParseType();
            })),
            this.semicolon(),
            this.finishNode(a, 'TSTypeAliasDeclaration')
          );
        }
        tsInNoContext(a) {
          let h = this.state.context;
          this.state.context = [h[0]];
          try {
            return a();
          } finally {
            this.state.context = h;
          }
        }
        tsInType(a) {
          let h = this.state.inType;
          this.state.inType = !0;
          try {
            return a();
          } finally {
            this.state.inType = h;
          }
        }
        tsInDisallowConditionalTypesContext(a) {
          let h = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !0;
          try {
            return a();
          } finally {
            this.state.inDisallowConditionalTypesContext = h;
          }
        }
        tsInAllowConditionalTypesContext(a) {
          let h = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !1;
          try {
            return a();
          } finally {
            this.state.inDisallowConditionalTypesContext = h;
          }
        }
        tsEatThenParseType(a) {
          if (this.match(a)) return this.tsNextThenParseType();
        }
        tsExpectThenParseType(a) {
          return this.tsInType(() => (this.expect(a), this.tsParseType()));
        }
        tsNextThenParseType() {
          return this.tsInType(() => (this.next(), this.tsParseType()));
        }
        tsParseEnumMember() {
          let a = this.startNode();
          return (
            (a.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0)),
            this.eat(29) && (a.initializer = super.parseMaybeAssignAllowIn()),
            this.finishNode(a, 'TSEnumMember')
          );
        }
        tsParseEnumDeclaration(a, h = {}) {
          return (
            h.const && (a.const = !0),
            h.declare && (a.declare = !0),
            this.expectContextual(124),
            (a.id = this.parseIdentifier()),
            this.checkIdentifier(a.id, a.const ? 8971 : 8459),
            this.expect(5),
            (a.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))),
            this.expect(8),
            this.finishNode(a, 'TSEnumDeclaration')
          );
        }
        tsParseModuleBlock() {
          let a = this.startNode();
          return (
            this.scope.enter(0),
            this.expect(5),
            super.parseBlockOrModuleBlockBody((a.body = []), void 0, !0, 8),
            this.scope.exit(),
            this.finishNode(a, 'TSModuleBlock')
          );
        }
        tsParseModuleOrNamespaceDeclaration(a, h = !1) {
          if (((a.id = this.parseIdentifier()), h || this.checkIdentifier(a.id, 1024), this.eat(16))) {
            let d = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(d, !0), (a.body = d);
          } else
            this.scope.enter(256),
              this.prodParam.enter(Cs),
              (a.body = this.tsParseModuleBlock()),
              this.prodParam.exit(),
              this.scope.exit();
          return this.finishNode(a, 'TSModuleDeclaration');
        }
        tsParseAmbientExternalModuleDeclaration(a) {
          return (
            this.isContextual(110)
              ? ((a.global = !0), (a.id = this.parseIdentifier()))
              : this.match(131)
              ? (a.id = super.parseStringLiteral(this.state.value))
              : this.unexpected(),
            this.match(5)
              ? (this.scope.enter(256),
                this.prodParam.enter(Cs),
                (a.body = this.tsParseModuleBlock()),
                this.prodParam.exit(),
                this.scope.exit())
              : this.semicolon(),
            this.finishNode(a, 'TSModuleDeclaration')
          );
        }
        tsParseImportEqualsDeclaration(a, h, d) {
          (a.isExport = d || !1),
            (a.id = h || this.parseIdentifier()),
            this.checkIdentifier(a.id, 4096),
            this.expect(29);
          let D = this.tsParseModuleReference();
          return (
            a.importKind === 'type' &&
              D.type !== 'TSExternalModuleReference' &&
              this.raise(Ve.ImportAliasHasImportType, { at: D }),
            (a.moduleReference = D),
            this.semicolon(),
            this.finishNode(a, 'TSImportEqualsDeclaration')
          );
        }
        tsIsExternalModuleReference() {
          return this.isContextual(117) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference()
            ? this.tsParseExternalModuleReference()
            : this.tsParseEntityName(!1);
        }
        tsParseExternalModuleReference() {
          let a = this.startNode();
          return (
            this.expectContextual(117),
            this.expect(10),
            this.match(131) || this.unexpected(),
            (a.expression = super.parseExprAtom()),
            this.expect(11),
            (this.sawUnambiguousESM = !0),
            this.finishNode(a, 'TSExternalModuleReference')
          );
        }
        tsLookAhead(a) {
          let h = this.state.clone(),
            d = a();
          return (this.state = h), d;
        }
        tsTryParseAndCatch(a) {
          let h = this.tryParse((d) => a() || d());
          if (!(h.aborted || !h.node)) return h.error && (this.state = h.failState), h.node;
        }
        tsTryParse(a) {
          let h = this.state.clone(),
            d = a();
          if (d !== void 0 && d !== !1) return d;
          this.state = h;
        }
        tsTryParseDeclare(a) {
          if (this.isLineTerminator()) return;
          let h = this.state.type,
            d;
          return (
            this.isContextual(99) && ((h = 74), (d = 'let')),
            this.tsInAmbientContext(() => {
              switch (h) {
                case 68:
                  return (a.declare = !0), super.parseFunctionStatement(a, !1, !1);
                case 80:
                  return (a.declare = !0), this.parseClass(a, !0, !1);
                case 124:
                  return this.tsParseEnumDeclaration(a, { declare: !0 });
                case 110:
                  return this.tsParseAmbientExternalModuleDeclaration(a);
                case 75:
                case 74:
                  return !this.match(75) || !this.isLookaheadContextual('enum')
                    ? ((a.declare = !0), this.parseVarStatement(a, d || this.state.value, !0))
                    : (this.expect(75), this.tsParseEnumDeclaration(a, { const: !0, declare: !0 }));
                case 127: {
                  let D = this.tsParseInterfaceDeclaration(a, { declare: !0 });
                  if (D) return D;
                }
                default:
                  if (fe(h)) return this.tsParseDeclaration(a, this.state.value, !0, null);
              }
            })
          );
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
        }
        tsParseExpressionStatement(a, h, d) {
          switch (h.name) {
            case 'declare': {
              let D = this.tsTryParseDeclare(a);
              return D && (D.declare = !0), D;
            }
            case 'global':
              if (this.match(5)) {
                this.scope.enter(256), this.prodParam.enter(Cs);
                let D = a;
                return (
                  (D.global = !0),
                  (D.id = h),
                  (D.body = this.tsParseModuleBlock()),
                  this.scope.exit(),
                  this.prodParam.exit(),
                  this.finishNode(D, 'TSModuleDeclaration')
                );
              }
              break;
            default:
              return this.tsParseDeclaration(a, h.name, !1, d);
          }
        }
        tsParseDeclaration(a, h, d, D) {
          switch (h) {
            case 'abstract':
              if (this.tsCheckLineTerminator(d) && (this.match(80) || fe(this.state.type)))
                return this.tsParseAbstractDeclaration(a, D);
              break;
            case 'module':
              if (this.tsCheckLineTerminator(d)) {
                if (this.match(131)) return this.tsParseAmbientExternalModuleDeclaration(a);
                if (fe(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(a);
              }
              break;
            case 'namespace':
              if (this.tsCheckLineTerminator(d) && fe(this.state.type))
                return this.tsParseModuleOrNamespaceDeclaration(a);
              break;
            case 'type':
              if (this.tsCheckLineTerminator(d) && fe(this.state.type)) return this.tsParseTypeAliasDeclaration(a);
              break;
          }
        }
        tsCheckLineTerminator(a) {
          return a ? (this.hasFollowingLineBreak() ? !1 : (this.next(), !0)) : !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(a) {
          if (!this.match(47)) return;
          let h = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = !0;
          let d = this.tsTryParseAndCatch(() => {
            let D = this.startNodeAt(a);
            return (
              (D.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier)),
              super.parseFunctionParams(D),
              (D.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()),
              this.expect(19),
              D
            );
          });
          if (((this.state.maybeInArrowParameters = h), !!d)) return super.parseArrowExpression(d, null, !0);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          let a = this.startNode();
          return (
            (a.params = this.tsInType(() =>
              this.tsInNoContext(
                () => (
                  this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this))
                ),
              ),
            )),
            a.params.length === 0
              ? this.raise(Ve.EmptyTypeArguments, { at: a })
              : !this.state.inType && this.curContext() === W.brace && this.reScan_lt_gt(),
            this.expect(48),
            this.finishNode(a, 'TSTypeParameterInstantiation')
          );
        }
        tsIsDeclarationStart() {
          return Ze(this.state.type);
        }
        isExportDefaultSpecifier() {
          return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(a, h) {
          let d = this.state.startLoc,
            D = {};
          this.tsParseModifiers({ allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'] }, D);
          let A = D.accessibility,
            P = D.override,
            N = D.readonly;
          !(a & 4) && (A || N || P) && this.raise(Ve.UnexpectedParameterModifier, { at: d });
          let R = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(R, a);
          let _ = this.parseMaybeDefault(R.loc.start, R);
          if (A || N || P) {
            let ue = this.startNodeAt(d);
            return (
              h.length && (ue.decorators = h),
              A && (ue.accessibility = A),
              N && (ue.readonly = N),
              P && (ue.override = P),
              _.type !== 'Identifier' &&
                _.type !== 'AssignmentPattern' &&
                this.raise(Ve.UnsupportedParameterPropertyKind, { at: ue }),
              (ue.parameter = _),
              this.finishNode(ue, 'TSParameterProperty')
            );
          }
          return h.length && (R.decorators = h), _;
        }
        isSimpleParameter(a) {
          return (
            (a.type === 'TSParameterProperty' && super.isSimpleParameter(a.parameter)) || super.isSimpleParameter(a)
          );
        }
        tsDisallowOptionalPattern(a) {
          for (let h of a.params)
            h.type !== 'Identifier' &&
              h.optional &&
              !this.state.isAmbientContext &&
              this.raise(Ve.PatternIsOptional, { at: h });
        }
        setArrowFunctionParameters(a, h, d) {
          super.setArrowFunctionParameters(a, h, d), this.tsDisallowOptionalPattern(a);
        }
        parseFunctionBodyAndFinish(a, h, d = !1) {
          this.match(14) && (a.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
          let D =
            h === 'FunctionDeclaration'
              ? 'TSDeclareFunction'
              : h === 'ClassMethod' || h === 'ClassPrivateMethod'
              ? 'TSDeclareMethod'
              : void 0;
          return D && !this.match(5) && this.isLineTerminator()
            ? this.finishNode(a, D)
            : D === 'TSDeclareFunction' &&
              this.state.isAmbientContext &&
              (this.raise(Ve.DeclareFunctionHasImplementation, { at: a }), a.declare)
            ? super.parseFunctionBodyAndFinish(a, D, d)
            : (this.tsDisallowOptionalPattern(a), super.parseFunctionBodyAndFinish(a, h, d));
        }
        registerFunctionStatementId(a) {
          !a.body && a.id ? this.checkIdentifier(a.id, 1024) : super.registerFunctionStatementId(a);
        }
        tsCheckForInvalidTypeCasts(a) {
          a.forEach((h) => {
            (h == null ? void 0 : h.type) === 'TSTypeCastExpression' &&
              this.raise(Ve.UnexpectedTypeAnnotation, { at: h.typeAnnotation });
          });
        }
        toReferencedList(a, h) {
          return this.tsCheckForInvalidTypeCasts(a), a;
        }
        parseArrayLike(a, h, d, D) {
          let A = super.parseArrayLike(a, h, d, D);
          return A.type === 'ArrayExpression' && this.tsCheckForInvalidTypeCasts(A.elements), A;
        }
        parseSubscript(a, h, d, D) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            (this.state.canStartJSXElement = !1), this.next();
            let P = this.startNodeAt(h);
            return (P.expression = a), this.finishNode(P, 'TSNonNullExpression');
          }
          let A = !1;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (d) return (D.stop = !0), a;
            (D.optionalChainMember = A = !0), this.next();
          }
          if (this.match(47) || this.match(51)) {
            let P,
              N = this.tsTryParseAndCatch(() => {
                if (!d && this.atPossibleAsyncArrow(a)) {
                  let ve = this.tsTryParseGenericAsyncArrowFunction(h);
                  if (ve) return ve;
                }
                let R = this.tsParseTypeArgumentsInExpression();
                if (!R) return;
                if (A && !this.match(10)) {
                  P = this.state.curPosition();
                  return;
                }
                if (Et(this.state.type)) {
                  let ve = super.parseTaggedTemplateExpression(a, h, D);
                  return (ve.typeParameters = R), ve;
                }
                if (!d && this.eat(10)) {
                  let ve = this.startNodeAt(h);
                  return (
                    (ve.callee = a),
                    (ve.arguments = this.parseCallExpressionArguments(11, !1)),
                    this.tsCheckForInvalidTypeCasts(ve.arguments),
                    (ve.typeParameters = R),
                    D.optionalChainMember && (ve.optional = A),
                    this.finishCallExpression(ve, D.optionalChainMember)
                  );
                }
                let _ = this.state.type;
                if (_ === 48 || _ === 52 || (_ !== 10 && ae(_) && !this.hasPrecedingLineBreak())) return;
                let ue = this.startNodeAt(h);
                return (ue.expression = a), (ue.typeParameters = R), this.finishNode(ue, 'TSInstantiationExpression');
              });
            if ((P && this.unexpected(P, 10), N))
              return (
                N.type === 'TSInstantiationExpression' &&
                  (this.match(16) || (this.match(18) && this.lookaheadCharCode() !== 40)) &&
                  this.raise(Ve.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }),
                N
              );
          }
          return super.parseSubscript(a, h, d, D);
        }
        parseNewCallee(a) {
          var h;
          super.parseNewCallee(a);
          let { callee: d } = a;
          d.type === 'TSInstantiationExpression' &&
            !((h = d.extra) != null && h.parenthesized) &&
            ((a.typeParameters = d.typeParameters), (a.callee = d.expression));
        }
        parseExprOp(a, h, d) {
          let D;
          if (lt(58) > d && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (D = this.isContextual(118)))) {
            let A = this.startNodeAt(h);
            return (
              (A.expression = a),
              (A.typeAnnotation = this.tsInType(
                () => (
                  this.next(),
                  this.match(75)
                    ? (D && this.raise(T.UnexpectedKeyword, { at: this.state.startLoc, keyword: 'const' }),
                      this.tsParseTypeReference())
                    : this.tsParseType()
                ),
              )),
              this.finishNode(A, D ? 'TSSatisfiesExpression' : 'TSAsExpression'),
              this.reScan_lt_gt(),
              this.parseExprOp(A, h, d)
            );
          }
          return super.parseExprOp(a, h, d);
        }
        checkReservedWord(a, h, d, D) {
          this.state.isAmbientContext || super.checkReservedWord(a, h, d, D);
        }
        checkImportReflection(a) {
          super.checkImportReflection(a),
            a.module &&
              a.importKind !== 'value' &&
              this.raise(Ve.ImportReflectionHasImportType, { at: a.specifiers[0].loc.start });
        }
        checkDuplicateExports() {}
        isPotentialImportPhase(a) {
          if (super.isPotentialImportPhase(a)) return !0;
          if (this.isContextual(128)) {
            let h = this.lookaheadCharCode();
            return a ? h === 123 || h === 42 : h !== 61;
          }
          return !a && this.isContextual(87);
        }
        applyImportPhase(a, h, d, D) {
          super.applyImportPhase(a, h, d, D),
            h
              ? (a.exportKind = d === 'type' ? 'type' : 'value')
              : (a.importKind = d === 'type' || d === 'typeof' ? d : 'value');
        }
        parseImport(a) {
          if (this.match(131)) return (a.importKind = 'value'), super.parseImport(a);
          let h;
          if (fe(this.state.type) && this.lookaheadCharCode() === 61)
            return (a.importKind = 'value'), this.tsParseImportEqualsDeclaration(a);
          if (this.isContextual(128)) {
            let d = this.parseMaybeImportPhase(a, !1);
            if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(a, d);
            h = super.parseImportSpecifiersAndAfter(a, d);
          } else h = super.parseImport(a);
          return (
            h.importKind === 'type' &&
              h.specifiers.length > 1 &&
              h.specifiers[0].type === 'ImportDefaultSpecifier' &&
              this.raise(Ve.TypeImportCannotSpecifyDefaultAndNamed, { at: h }),
            h
          );
        }
        parseExport(a, h) {
          if (this.match(83)) {
            this.next();
            let d = null;
            return (
              this.isContextual(128) && this.isPotentialImportPhase(!1)
                ? (d = this.parseMaybeImportPhase(a, !1))
                : (a.importKind = 'value'),
              this.tsParseImportEqualsDeclaration(a, d, !0)
            );
          } else if (this.eat(29)) {
            let d = a;
            return (
              (d.expression = super.parseExpression()),
              this.semicolon(),
              (this.sawUnambiguousESM = !0),
              this.finishNode(d, 'TSExportAssignment')
            );
          } else if (this.eatContextual(93)) {
            let d = a;
            return (
              this.expectContextual(126),
              (d.id = this.parseIdentifier()),
              this.semicolon(),
              this.finishNode(d, 'TSNamespaceExportDeclaration')
            );
          } else return super.parseExport(a, h);
        }
        isAbstractClass() {
          return this.isContextual(122) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            let a = this.startNode();
            return this.next(), (a.abstract = !0), this.parseClass(a, !0, !0);
          }
          if (this.match(127)) {
            let a = this.tsParseInterfaceDeclaration(this.startNode());
            if (a) return a;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(a, h, d = !1) {
          let { isAmbientContext: D } = this.state,
            A = super.parseVarStatement(a, h, d || D);
          if (!D) return A;
          for (let { id: P, init: N } of A.declarations)
            N &&
              (h !== 'const' || P.typeAnnotation
                ? this.raise(Ve.InitializerNotAllowedInAmbientContext, { at: N })
                : Uc(N, this.hasPlugin('estree')) ||
                  this.raise(Ve.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: N }));
          return A;
        }
        parseStatementContent(a, h) {
          if (this.match(75) && this.isLookaheadContextual('enum')) {
            let d = this.startNode();
            return this.expect(75), this.tsParseEnumDeclaration(d, { const: !0 });
          }
          if (this.isContextual(124)) return this.tsParseEnumDeclaration(this.startNode());
          if (this.isContextual(127)) {
            let d = this.tsParseInterfaceDeclaration(this.startNode());
            if (d) return d;
          }
          return super.parseStatementContent(a, h);
        }
        parseAccessModifier() {
          return this.tsParseModifier(['public', 'protected', 'private']);
        }
        tsHasSomeModifiers(a, h) {
          return h.some((d) => (ql(d) ? a.accessibility === d : !!a[d]));
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(a, h, d) {
          let D = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static'];
          this.tsParseModifiers(
            {
              allowedModifiers: D,
              disallowedModifiers: ['in', 'out'],
              stopOnStartOfClassStaticBlock: !0,
              errorTemplate: Ve.InvalidModifierOnTypeParameterPositions,
            },
            h,
          );
          let A = () => {
            this.tsIsStartOfStaticBlocks()
              ? (this.next(),
                this.next(),
                this.tsHasSomeModifiers(h, D) &&
                  this.raise(Ve.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }),
                super.parseClassStaticBlock(a, h))
              : this.parseClassMemberWithIsStatic(a, h, d, !!h.static);
          };
          h.declare ? this.tsInAmbientContext(A) : A();
        }
        parseClassMemberWithIsStatic(a, h, d, D) {
          let A = this.tsTryParseIndexSignature(h);
          if (A) {
            a.body.push(A),
              h.abstract && this.raise(Ve.IndexSignatureHasAbstract, { at: h }),
              h.accessibility && this.raise(Ve.IndexSignatureHasAccessibility, { at: h, modifier: h.accessibility }),
              h.declare && this.raise(Ve.IndexSignatureHasDeclare, { at: h }),
              h.override && this.raise(Ve.IndexSignatureHasOverride, { at: h });
            return;
          }
          !this.state.inAbstractClass && h.abstract && this.raise(Ve.NonAbstractClassHasAbstractMethod, { at: h }),
            h.override && (d.hadSuperClass || this.raise(Ve.OverrideNotInSubClass, { at: h })),
            super.parseClassMemberWithIsStatic(a, h, d, D);
        }
        parsePostMemberNameModifiers(a) {
          this.eat(17) && (a.optional = !0),
            a.readonly && this.match(10) && this.raise(Ve.ClassMethodHasReadonly, { at: a }),
            a.declare && this.match(10) && this.raise(Ve.ClassMethodHasDeclare, { at: a });
        }
        parseExpressionStatement(a, h, d) {
          return (
            (h.type === 'Identifier' ? this.tsParseExpressionStatement(a, h, d) : void 0) ||
            super.parseExpressionStatement(a, h, d)
          );
        }
        shouldParseExportDeclaration() {
          return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
        }
        parseConditional(a, h, d) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(a, h, d);
          let D = this.tryParse(() => super.parseConditional(a, h));
          return D.node
            ? (D.error && (this.state = D.failState), D.node)
            : (D.error && super.setOptionalParametersError(d, D.error), a);
        }
        parseParenItem(a, h) {
          if (
            ((a = super.parseParenItem(a, h)),
            this.eat(17) && ((a.optional = !0), this.resetEndLocation(a)),
            this.match(14))
          ) {
            let d = this.startNodeAt(h);
            return (
              (d.expression = a),
              (d.typeAnnotation = this.tsParseTypeAnnotation()),
              this.finishNode(d, 'TSTypeCastExpression')
            );
          }
          return a;
        }
        parseExportDeclaration(a) {
          if (!this.state.isAmbientContext && this.isContextual(123))
            return this.tsInAmbientContext(() => this.parseExportDeclaration(a));
          let h = this.state.startLoc,
            d = this.eatContextual(123);
          if (d && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
            throw this.raise(Ve.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
          let D = (fe(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(a);
          return D
            ? ((D.type === 'TSInterfaceDeclaration' || D.type === 'TSTypeAliasDeclaration' || d) &&
                (a.exportKind = 'type'),
              d && (this.resetStartLocation(D, h), (D.declare = !0)),
              D)
            : null;
        }
        parseClassId(a, h, d, D) {
          if ((!h || d) && this.isContextual(111)) return;
          super.parseClassId(a, h, d, a.declare ? 1024 : 8331);
          let A = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
          A && (a.typeParameters = A);
        }
        parseClassPropertyAnnotation(a) {
          a.optional || (this.eat(35) ? (a.definite = !0) : this.eat(17) && (a.optional = !0));
          let h = this.tsTryParseTypeAnnotation();
          h && (a.typeAnnotation = h);
        }
        parseClassProperty(a) {
          if (
            (this.parseClassPropertyAnnotation(a),
            this.state.isAmbientContext &&
              !(a.readonly && !a.typeAnnotation) &&
              this.match(29) &&
              this.raise(Ve.DeclareClassFieldHasInitializer, { at: this.state.startLoc }),
            a.abstract && this.match(29))
          ) {
            let { key: h } = a;
            this.raise(Ve.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: h.type === 'Identifier' && !a.computed ? h.name : `[${this.input.slice(h.start, h.end)}]`,
            });
          }
          return super.parseClassProperty(a);
        }
        parseClassPrivateProperty(a) {
          return (
            a.abstract && this.raise(Ve.PrivateElementHasAbstract, { at: a }),
            a.accessibility && this.raise(Ve.PrivateElementHasAccessibility, { at: a, modifier: a.accessibility }),
            this.parseClassPropertyAnnotation(a),
            super.parseClassPrivateProperty(a)
          );
        }
        parseClassAccessorProperty(a) {
          return (
            this.parseClassPropertyAnnotation(a),
            a.optional && this.raise(Ve.AccessorCannotBeOptional, { at: a }),
            super.parseClassAccessorProperty(a)
          );
        }
        pushClassMethod(a, h, d, D, A, P) {
          let N = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          N && A && this.raise(Ve.ConstructorHasTypeParameters, { at: N });
          let { declare: R = !1, kind: _ } = h;
          R && (_ === 'get' || _ === 'set') && this.raise(Ve.DeclareAccessor, { at: h, kind: _ }),
            N && (h.typeParameters = N),
            super.pushClassMethod(a, h, d, D, A, P);
        }
        pushClassPrivateMethod(a, h, d, D) {
          let A = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          A && (h.typeParameters = A), super.pushClassPrivateMethod(a, h, d, D);
        }
        declareClassPrivateMethodInScope(a, h) {
          a.type !== 'TSDeclareMethod' &&
            ((a.type === 'MethodDefinition' && !a.value.body) || super.declareClassPrivateMethodInScope(a, h));
        }
        parseClassSuper(a) {
          super.parseClassSuper(a),
            a.superClass &&
              (this.match(47) || this.match(51)) &&
              (a.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
            this.eatContextual(111) && (a.implements = this.tsParseHeritageClause('implements'));
        }
        parseObjPropValue(a, h, d, D, A, P, N) {
          let R = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          return R && (a.typeParameters = R), super.parseObjPropValue(a, h, d, D, A, P, N);
        }
        parseFunctionParams(a, h) {
          let d = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          d && (a.typeParameters = d), super.parseFunctionParams(a, h);
        }
        parseVarId(a, h) {
          super.parseVarId(a, h),
            a.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(35) && (a.definite = !0);
          let d = this.tsTryParseTypeAnnotation();
          d && ((a.id.typeAnnotation = d), this.resetEndLocation(a.id));
        }
        parseAsyncArrowFromCallExpression(a, h) {
          return (
            this.match(14) && (a.returnType = this.tsParseTypeAnnotation()),
            super.parseAsyncArrowFromCallExpression(a, h)
          );
        }
        parseMaybeAssign(a, h) {
          var d, D, A, P, N;
          let R, _, ue;
          if (this.hasPlugin('jsx') && (this.match(140) || this.match(47))) {
            if (((R = this.state.clone()), (_ = this.tryParse(() => super.parseMaybeAssign(a, h), R)), !_.error))
              return _.node;
            let { context: _e } = this.state,
              Bt = _e[_e.length - 1];
            (Bt === W.j_oTag || Bt === W.j_expr) && _e.pop();
          }
          if (!((d = _) != null && d.error) && !this.match(47)) return super.parseMaybeAssign(a, h);
          (!R || R === this.state) && (R = this.state.clone());
          let ve,
            Ie = this.tryParse((_e) => {
              var Bt, wt;
              ve = this.tsParseTypeParameters(this.tsParseConstModifier);
              let ur = super.parseMaybeAssign(a, h);
              return (
                (ur.type !== 'ArrowFunctionExpression' || ((Bt = ur.extra) != null && Bt.parenthesized)) && _e(),
                ((wt = ve) == null ? void 0 : wt.params.length) !== 0 && this.resetStartLocationFromNode(ur, ve),
                (ur.typeParameters = ve),
                ur
              );
            }, R);
          if (!Ie.error && !Ie.aborted) return ve && this.reportReservedArrowTypeParam(ve), Ie.node;
          if (
            !_ &&
            (Vc(!this.hasPlugin('jsx')), (ue = this.tryParse(() => super.parseMaybeAssign(a, h), R)), !ue.error)
          )
            return ue.node;
          if ((D = _) != null && D.node) return (this.state = _.failState), _.node;
          if (Ie.node) return (this.state = Ie.failState), ve && this.reportReservedArrowTypeParam(ve), Ie.node;
          if ((A = ue) != null && A.node) return (this.state = ue.failState), ue.node;
          throw ((P = _) == null ? void 0 : P.error) || Ie.error || ((N = ue) == null ? void 0 : N.error);
        }
        reportReservedArrowTypeParam(a) {
          var h;
          a.params.length === 1 &&
            !a.params[0].constraint &&
            !((h = a.extra) != null && h.trailingComma) &&
            this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
            this.raise(Ve.ReservedArrowTypeParam, { at: a });
        }
        parseMaybeUnary(a, h) {
          return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(a, h);
        }
        parseArrow(a) {
          if (this.match(14)) {
            let h = this.tryParse((d) => {
              let D = this.tsParseTypeOrTypePredicateAnnotation(14);
              return (this.canInsertSemicolon() || !this.match(19)) && d(), D;
            });
            if (h.aborted) return;
            h.thrown || (h.error && (this.state = h.failState), (a.returnType = h.node));
          }
          return super.parseArrow(a);
        }
        parseAssignableListItemTypes(a, h) {
          if (!(h & 2)) return a;
          this.eat(17) && (a.optional = !0);
          let d = this.tsTryParseTypeAnnotation();
          return d && (a.typeAnnotation = d), this.resetEndLocation(a), a;
        }
        isAssignable(a, h) {
          switch (a.type) {
            case 'TSTypeCastExpression':
              return this.isAssignable(a.expression, h);
            case 'TSParameterProperty':
              return !0;
            default:
              return super.isAssignable(a, h);
          }
        }
        toAssignable(a, h = !1) {
          switch (a.type) {
            case 'ParenthesizedExpression':
              this.toAssignableParenthesizedExpression(a, h);
              break;
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
              h
                ? this.expressionScope.recordArrowParameterBindingError(Ve.UnexpectedTypeCastInParameter, { at: a })
                : this.raise(Ve.UnexpectedTypeCastInParameter, { at: a }),
                this.toAssignable(a.expression, h);
              break;
            case 'AssignmentExpression':
              !h && a.left.type === 'TSTypeCastExpression' && (a.left = this.typeCastToParameter(a.left));
            default:
              super.toAssignable(a, h);
          }
        }
        toAssignableParenthesizedExpression(a, h) {
          switch (a.expression.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
            case 'ParenthesizedExpression':
              this.toAssignable(a.expression, h);
              break;
            default:
              super.toAssignable(a, h);
          }
        }
        checkToRestConversion(a, h) {
          switch (a.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSTypeAssertion':
            case 'TSNonNullExpression':
              this.checkToRestConversion(a.expression, !1);
              break;
            default:
              super.checkToRestConversion(a, h);
          }
        }
        isValidLVal(a, h, d) {
          return (
            cd(
              {
                TSTypeCastExpression: !0,
                TSParameterProperty: 'parameter',
                TSNonNullExpression: 'expression',
                TSAsExpression: (d !== 64 || !h) && ['expression', !0],
                TSSatisfiesExpression: (d !== 64 || !h) && ['expression', !0],
                TSTypeAssertion: (d !== 64 || !h) && ['expression', !0],
              },
              a,
            ) || super.isValidLVal(a, h, d)
          );
        }
        parseBindingAtom() {
          return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
        }
        parseMaybeDecoratorArguments(a) {
          if (this.match(47) || this.match(51)) {
            let h = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              let d = super.parseMaybeDecoratorArguments(a);
              return (d.typeParameters = h), d;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(a);
        }
        checkCommaAfterRest(a) {
          return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === a
            ? (this.next(), !1)
            : super.checkCommaAfterRest(a);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(a, h) {
          let d = super.parseMaybeDefault(a, h);
          return (
            d.type === 'AssignmentPattern' &&
              d.typeAnnotation &&
              d.right.start < d.typeAnnotation.start &&
              this.raise(Ve.TypeAnnotationAfterAssign, { at: d.typeAnnotation }),
            d
          );
        }
        getTokenFromCode(a) {
          if (this.state.inType) {
            if (a === 62) {
              this.finishOp(48, 1);
              return;
            }
            if (a === 60) {
              this.finishOp(47, 1);
              return;
            }
          }
          super.getTokenFromCode(a);
        }
        reScan_lt_gt() {
          let { type: a } = this.state;
          a === 47
            ? ((this.state.pos -= 1), this.readToken_lt())
            : a === 48 && ((this.state.pos -= 1), this.readToken_gt());
        }
        reScan_lt() {
          let { type: a } = this.state;
          return a === 51 ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : a;
        }
        toAssignableList(a, h, d) {
          for (let D = 0; D < a.length; D++) {
            let A = a[D];
            (A == null ? void 0 : A.type) === 'TSTypeCastExpression' && (a[D] = this.typeCastToParameter(A));
          }
          super.toAssignableList(a, h, d);
        }
        typeCastToParameter(a) {
          return (
            (a.expression.typeAnnotation = a.typeAnnotation),
            this.resetEndLocation(a.expression, a.typeAnnotation.loc.end),
            a.expression
          );
        }
        shouldParseArrow(a) {
          return this.match(14) ? a.every((h) => this.isAssignable(h, !0)) : super.shouldParseArrow(a);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(a) {
          if (this.match(47) || this.match(51)) {
            let h = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            h && (a.typeParameters = h);
          }
          return super.jsxParseOpeningElementAfterName(a);
        }
        getGetterSetterExpectedParamCount(a) {
          let h = super.getGetterSetterExpectedParamCount(a),
            d = this.getObjectOrClassMethodParams(a)[0];
          return d && this.isThisParam(d) ? h + 1 : h;
        }
        parseCatchClauseParam() {
          let a = super.parseCatchClauseParam(),
            h = this.tsTryParseTypeAnnotation();
          return h && ((a.typeAnnotation = h), this.resetEndLocation(a)), a;
        }
        tsInAmbientContext(a) {
          let h = this.state.isAmbientContext;
          this.state.isAmbientContext = !0;
          try {
            return a();
          } finally {
            this.state.isAmbientContext = h;
          }
        }
        parseClass(a, h, d) {
          let D = this.state.inAbstractClass;
          this.state.inAbstractClass = !!a.abstract;
          try {
            return super.parseClass(a, h, d);
          } finally {
            this.state.inAbstractClass = D;
          }
        }
        tsParseAbstractDeclaration(a, h) {
          if (this.match(80)) return (a.abstract = !0), this.maybeTakeDecorators(h, this.parseClass(a, !0, !1));
          if (this.isContextual(127)) {
            if (!this.hasFollowingLineBreak())
              return (
                (a.abstract = !0),
                this.raise(Ve.NonClassMethodPropertyHasAbstractModifer, { at: a }),
                this.tsParseInterfaceDeclaration(a)
              );
          } else this.unexpected(null, 80);
        }
        parseMethod(a, h, d, D, A, P, N) {
          let R = super.parseMethod(a, h, d, D, A, P, N);
          if (R.abstract && (this.hasPlugin('estree') ? R.value.body : R.body)) {
            let { key: _ } = R;
            this.raise(Ve.AbstractMethodHasImplementation, {
              at: R,
              methodName: _.type === 'Identifier' && !R.computed ? _.name : `[${this.input.slice(_.start, _.end)}]`,
            });
          }
          return R;
        }
        tsParseTypeParameterName() {
          return this.parseIdentifier().name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption('typescript', 'dts');
        }
        parse() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
        }
        getExpression() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
        }
        parseExportSpecifier(a, h, d, D) {
          return !h && D
            ? (this.parseTypeOnlyImportExportSpecifier(a, !1, d), this.finishNode(a, 'ExportSpecifier'))
            : ((a.exportKind = 'value'), super.parseExportSpecifier(a, h, d, D));
        }
        parseImportSpecifier(a, h, d, D, A) {
          return !h && D
            ? (this.parseTypeOnlyImportExportSpecifier(a, !0, d), this.finishNode(a, 'ImportSpecifier'))
            : ((a.importKind = 'value'), super.parseImportSpecifier(a, h, d, D, d ? 4098 : 4096));
        }
        parseTypeOnlyImportExportSpecifier(a, h, d) {
          let D = h ? 'imported' : 'local',
            A = h ? 'local' : 'exported',
            P = a[D],
            N,
            R = !1,
            _ = !0,
            ue = P.loc.start;
          if (this.isContextual(93)) {
            let Ie = this.parseIdentifier();
            if (this.isContextual(93)) {
              let _e = this.parseIdentifier();
              M(this.state.type)
                ? ((R = !0), (P = Ie), (N = h ? this.parseIdentifier() : this.parseModuleExportName()), (_ = !1))
                : ((N = _e), (_ = !1));
            } else
              M(this.state.type)
                ? ((_ = !1), (N = h ? this.parseIdentifier() : this.parseModuleExportName()))
                : ((R = !0), (P = Ie));
          } else
            M(this.state.type) &&
              ((R = !0),
              h
                ? ((P = this.parseIdentifier(!0)),
                  this.isContextual(93) || this.checkReservedWord(P.name, P.loc.start, !0, !0))
                : (P = this.parseModuleExportName()));
          R && d && this.raise(h ? Ve.TypeModifierIsUsedInTypeImports : Ve.TypeModifierIsUsedInTypeExports, { at: ue }),
            (a[D] = P),
            (a[A] = N);
          let ve = h ? 'importKind' : 'exportKind';
          (a[ve] = R ? 'type' : 'value'),
            _ && this.eatContextual(93) && (a[A] = h ? this.parseIdentifier() : this.parseModuleExportName()),
            a[A] || (a[A] = Qn(a[D])),
            h && this.checkIdentifier(a[A], R ? 4098 : 4096);
        }
      };
    function Wc(u) {
      if (u.type !== 'MemberExpression') return !1;
      let { computed: a, property: h } = u;
      return a && h.type !== 'StringLiteral' && (h.type !== 'TemplateLiteral' || h.expressions.length > 0)
        ? !1
        : Kc(u.object);
    }
    function Uc(u, a) {
      var h;
      let { type: d } = u;
      if ((h = u.extra) != null && h.parenthesized) return !1;
      if (a) {
        if (d === 'Literal') {
          let { value: D } = u;
          if (typeof D == 'string' || typeof D == 'boolean') return !0;
        }
      } else if (d === 'StringLiteral' || d === 'BooleanLiteral') return !0;
      return !!(Aa(u, a) || qc(u, a) || (d === 'TemplateLiteral' && u.expressions.length === 0) || Wc(u));
    }
    function Aa(u, a) {
      return a
        ? u.type === 'Literal' && (typeof u.value == 'number' || 'bigint' in u)
        : u.type === 'NumericLiteral' || u.type === 'BigIntLiteral';
    }
    function qc(u, a) {
      if (u.type === 'UnaryExpression') {
        let { operator: h, argument: d } = u;
        if (h === '-' && Aa(d, a)) return !0;
      }
      return !1;
    }
    function Kc(u) {
      return u.type === 'Identifier' ? !0 : u.type !== 'MemberExpression' || u.computed ? !1 : Kc(u.object);
    }
    var Jc = I`placeholders`({
        ClassNameIsRequired: 'A class name is required.',
        UnexpectedSpace: 'Unexpected space in placeholder.',
      }),
      fd = (u) =>
        class extends u {
          parsePlaceholder(a) {
            if (this.match(142)) {
              let h = this.startNode();
              return (
                this.next(),
                this.assertNoSpace(),
                (h.name = super.parseIdentifier(!0)),
                this.assertNoSpace(),
                this.expect(142),
                this.finishPlaceholder(h, a)
              );
            }
          }
          finishPlaceholder(a, h) {
            let d = !!(a.expectedNode && a.type === 'Placeholder');
            return (a.expectedNode = h), d ? a : this.finishNode(a, 'Placeholder');
          }
          getTokenFromCode(a) {
            a === 37 && this.input.charCodeAt(this.state.pos + 1) === 37
              ? this.finishOp(142, 2)
              : super.getTokenFromCode(a);
          }
          parseExprAtom(a) {
            return this.parsePlaceholder('Expression') || super.parseExprAtom(a);
          }
          parseIdentifier(a) {
            return this.parsePlaceholder('Identifier') || super.parseIdentifier(a);
          }
          checkReservedWord(a, h, d, D) {
            a !== void 0 && super.checkReservedWord(a, h, d, D);
          }
          parseBindingAtom() {
            return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
          }
          isValidLVal(a, h, d) {
            return a === 'Placeholder' || super.isValidLVal(a, h, d);
          }
          toAssignable(a, h) {
            a && a.type === 'Placeholder' && a.expectedNode === 'Expression'
              ? (a.expectedNode = 'Pattern')
              : super.toAssignable(a, h);
          }
          chStartsBindingIdentifier(a, h) {
            return !!(super.chStartsBindingIdentifier(a, h) || this.lookahead().type === 142);
          }
          verifyBreakContinue(a, h) {
            (a.label && a.label.type === 'Placeholder') || super.verifyBreakContinue(a, h);
          }
          parseExpressionStatement(a, h) {
            var d;
            if (h.type !== 'Placeholder' || ((d = h.extra) != null && d.parenthesized))
              return super.parseExpressionStatement(a, h);
            if (this.match(14)) {
              let D = a;
              return (
                (D.label = this.finishPlaceholder(h, 'Identifier')),
                this.next(),
                (D.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration()),
                this.finishNode(D, 'LabeledStatement')
              );
            }
            return this.semicolon(), (a.name = h.name), this.finishPlaceholder(a, 'Statement');
          }
          parseBlock(a, h, d) {
            return this.parsePlaceholder('BlockStatement') || super.parseBlock(a, h, d);
          }
          parseFunctionId(a) {
            return this.parsePlaceholder('Identifier') || super.parseFunctionId(a);
          }
          parseClass(a, h, d) {
            let D = h ? 'ClassDeclaration' : 'ClassExpression';
            this.next();
            let A = this.state.strict,
              P = this.parsePlaceholder('Identifier');
            if (P)
              if (this.match(81) || this.match(142) || this.match(5)) a.id = P;
              else {
                if (d || !h)
                  return (a.id = null), (a.body = this.finishPlaceholder(P, 'ClassBody')), this.finishNode(a, D);
                throw this.raise(Jc.ClassNameIsRequired, { at: this.state.startLoc });
              }
            else this.parseClassId(a, h, d);
            return (
              super.parseClassSuper(a),
              (a.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!a.superClass, A)),
              this.finishNode(a, D)
            );
          }
          parseExport(a, h) {
            let d = this.parsePlaceholder('Identifier');
            if (!d) return super.parseExport(a, h);
            if (!this.isContextual(97) && !this.match(12))
              return (
                (a.specifiers = []),
                (a.source = null),
                (a.declaration = this.finishPlaceholder(d, 'Declaration')),
                this.finishNode(a, 'ExportNamedDeclaration')
              );
            this.expectPlugin('exportDefaultFrom');
            let D = this.startNode();
            return (
              (D.exported = d), (a.specifiers = [this.finishNode(D, 'ExportDefaultSpecifier')]), super.parseExport(a, h)
            );
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let a = this.nextTokenStart();
              if (
                this.isUnparsedContextual(a, 'from') &&
                this.input.startsWith(et(142), this.nextTokenStartSince(a + 4))
              )
                return !0;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(a, h) {
            var d;
            return (d = a.specifiers) != null && d.length ? !0 : super.maybeParseExportDefaultSpecifier(a, h);
          }
          checkExport(a) {
            let { specifiers: h } = a;
            h != null && h.length && (a.specifiers = h.filter((d) => d.exported.type === 'Placeholder')),
              super.checkExport(a),
              (a.specifiers = h);
          }
          parseImport(a) {
            let h = this.parsePlaceholder('Identifier');
            if (!h) return super.parseImport(a);
            if (((a.specifiers = []), !this.isContextual(97) && !this.match(12)))
              return (
                (a.source = this.finishPlaceholder(h, 'StringLiteral')),
                this.semicolon(),
                this.finishNode(a, 'ImportDeclaration')
              );
            let d = this.startNodeAtNode(h);
            return (
              (d.local = h),
              a.specifiers.push(this.finishNode(d, 'ImportDefaultSpecifier')),
              this.eat(12) && (this.maybeParseStarImportSpecifier(a) || this.parseNamedImportSpecifiers(a)),
              this.expectContextual(97),
              (a.source = this.parseImportSource()),
              this.semicolon(),
              this.finishNode(a, 'ImportDeclaration')
            );
          }
          parseImportSource() {
            return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index &&
              this.raise(Jc.UnexpectedSpace, { at: this.state.lastTokEndLoc });
          }
        },
      dd = (u) =>
        class extends u {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let a = this.state.startLoc,
                h = this.startNode();
              if ((this.next(), fe(this.state.type))) {
                let d = this.parseIdentifierName(),
                  D = this.createIdentifier(h, d);
                if (((D.type = 'V8IntrinsicIdentifier'), this.match(10))) return D;
              }
              this.unexpected(a);
            }
          }
          parseExprAtom(a) {
            return this.parseV8Intrinsic() || super.parseExprAtom(a);
          }
        };
    function sr(u, a) {
      let [h, d] = typeof a == 'string' ? [a, {}] : a,
        D = Object.keys(d),
        A = D.length === 0;
      return u.some((P) => {
        if (typeof P == 'string') return A && P === h;
        {
          let [N, R] = P;
          if (N !== h) return !1;
          for (let _ of D) if (R[_] !== d[_]) return !1;
          return !0;
        }
      });
    }
    function Yi(u, a, h) {
      let d = u.find((D) => (Array.isArray(D) ? D[0] === a : D === a));
      return d && Array.isArray(d) && d.length > 1 ? d[1][h] : null;
    }
    var Xc = ['minimal', 'fsharp', 'hack', 'smart'],
      Gc = ['^^', '@@', '^', '%', '#'],
      Yc = ['hash', 'bar'];
    function md(u) {
      if (sr(u, 'decorators')) {
        if (sr(u, 'decorators-legacy'))
          throw new Error('Cannot use the decorators and decorators-legacy plugin together');
        let a = Yi(u, 'decorators', 'decoratorsBeforeExport');
        if (a != null && typeof a != 'boolean')
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        let h = Yi(u, 'decorators', 'allowCallParenthesized');
        if (h != null && typeof h != 'boolean') throw new Error("'allowCallParenthesized' must be a boolean.");
      }
      if (sr(u, 'flow') && sr(u, 'typescript')) throw new Error('Cannot combine flow and typescript plugins.');
      if (sr(u, 'placeholders') && sr(u, 'v8intrinsic'))
        throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
      if (sr(u, 'pipelineOperator')) {
        let a = Yi(u, 'pipelineOperator', 'proposal');
        if (!Xc.includes(a)) {
          let d = Xc.map((D) => `"${D}"`).join(', ');
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${d}.`);
        }
        let h = sr(u, ['recordAndTuple', { syntaxType: 'hash' }]);
        if (a === 'hack') {
          if (sr(u, 'placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
          if (sr(u, 'v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
          let d = Yi(u, 'pipelineOperator', 'topicToken');
          if (!Gc.includes(d)) {
            let D = Gc.map((A) => `"${A}"`).join(', ');
            throw new Error(
              `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${D}.`,
            );
          }
          if (d === '#' && h)
            throw new Error(
              'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.',
            );
        } else if (a === 'smart' && h)
          throw new Error(
            'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.',
          );
      }
      if (sr(u, 'moduleAttributes')) {
        if (sr(u, 'importAssertions') || sr(u, 'importAttributes'))
          throw new Error('Cannot combine importAssertions, importAttributes and moduleAttributes plugins.');
        if (Yi(u, 'moduleAttributes', 'version') !== 'may-2020')
          throw new Error(
            "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.",
          );
      }
      if (sr(u, 'importAssertions') && sr(u, 'importAttributes'))
        throw new Error('Cannot combine importAssertions and importAttributes plugins.');
      if (
        sr(u, 'recordAndTuple') &&
        Yi(u, 'recordAndTuple', 'syntaxType') != null &&
        !Yc.includes(Yi(u, 'recordAndTuple', 'syntaxType'))
      )
        throw new Error(
          "The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " +
            Yc.map((a) => `'${a}'`).join(', '),
        );
      if (sr(u, 'asyncDoExpressions') && !sr(u, 'doExpressions')) {
        let a = new Error(
          "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.",
        );
        throw ((a.missingPlugins = 'doExpressions'), a);
      }
    }
    var Ea = { estree: se, jsx: od, flow: sd, typescript: Hc, v8intrinsic: dd, placeholders: fd },
      gd = Object.keys(Ea),
      Kl = {
        sourceType: 'script',
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowNewTargetOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        plugins: [],
        strictMode: null,
        ranges: !1,
        tokens: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1,
        attachComment: !0,
        annexB: !0,
      };
    function yd(u) {
      if (u == null) return Object.assign({}, Kl);
      if (u.annexB != null && u.annexB !== !1) throw new Error('The `annexB` option can only be set to `false`.');
      let a = {};
      for (let d of Object.keys(Kl)) {
        var h;
        a[d] = (h = u[d]) != null ? h : Kl[d];
      }
      return a;
    }
    var Dd = class extends ud {
        checkProto(u, a, h, d) {
          if (u.type === 'SpreadElement' || this.isObjectMethod(u) || u.computed || u.shorthand) return;
          let D = u.key;
          if ((D.type === 'Identifier' ? D.name : D.value) === '__proto__') {
            if (a) {
              this.raise(T.RecordNoProto, { at: D });
              return;
            }
            h.used &&
              (d
                ? d.doubleProtoLoc === null && (d.doubleProtoLoc = D.loc.start)
                : this.raise(T.DuplicateProto, { at: D })),
              (h.used = !0);
          }
        }
        shouldExitDescending(u, a) {
          return u.type === 'ArrowFunctionExpression' && u.start === a;
        }
        getExpression() {
          this.enterInitialScopes(), this.nextToken();
          let u = this.parseExpression();
          return (
            this.match(137) || this.unexpected(),
            this.finalizeRemainingComments(),
            (u.comments = this.state.comments),
            (u.errors = this.state.errors),
            this.options.tokens && (u.tokens = this.tokens),
            u
          );
        }
        parseExpression(u, a) {
          return u
            ? this.disallowInAnd(() => this.parseExpressionBase(a))
            : this.allowInAnd(() => this.parseExpressionBase(a));
        }
        parseExpressionBase(u) {
          let a = this.state.startLoc,
            h = this.parseMaybeAssign(u);
          if (this.match(12)) {
            let d = this.startNodeAt(a);
            for (d.expressions = [h]; this.eat(12); ) d.expressions.push(this.parseMaybeAssign(u));
            return this.toReferencedList(d.expressions), this.finishNode(d, 'SequenceExpression');
          }
          return h;
        }
        parseMaybeAssignDisallowIn(u, a) {
          return this.disallowInAnd(() => this.parseMaybeAssign(u, a));
        }
        parseMaybeAssignAllowIn(u, a) {
          return this.allowInAnd(() => this.parseMaybeAssign(u, a));
        }
        setOptionalParametersError(u, a) {
          var h;
          u.optionalParametersLoc = (h = a == null ? void 0 : a.loc) != null ? h : this.state.startLoc;
        }
        parseMaybeAssign(u, a) {
          let h = this.state.startLoc;
          if (this.isContextual(106) && this.prodParam.hasYield) {
            let P = this.parseYield();
            return a && (P = a.call(this, P, h)), P;
          }
          let d;
          u ? (d = !1) : ((u = new Yn()), (d = !0));
          let { type: D } = this.state;
          (D === 10 || fe(D)) && (this.state.potentialArrowAt = this.state.start);
          let A = this.parseMaybeConditional(u);
          if ((a && (A = a.call(this, A, h)), de(this.state.type))) {
            let P = this.startNodeAt(h),
              N = this.state.value;
            if (((P.operator = N), this.match(29))) {
              this.toAssignable(A, !0), (P.left = A);
              let R = h.index;
              u.doubleProtoLoc != null && u.doubleProtoLoc.index >= R && (u.doubleProtoLoc = null),
                u.shorthandAssignLoc != null && u.shorthandAssignLoc.index >= R && (u.shorthandAssignLoc = null),
                u.privateKeyLoc != null &&
                  u.privateKeyLoc.index >= R &&
                  (this.checkDestructuringPrivate(u), (u.privateKeyLoc = null));
            } else P.left = A;
            return (
              this.next(),
              (P.right = this.parseMaybeAssign()),
              this.checkLVal(A, { in: this.finishNode(P, 'AssignmentExpression') }),
              P
            );
          } else d && this.checkExpressionErrors(u, !0);
          return A;
        }
        parseMaybeConditional(u) {
          let a = this.state.startLoc,
            h = this.state.potentialArrowAt,
            d = this.parseExprOps(u);
          return this.shouldExitDescending(d, h) ? d : this.parseConditional(d, a, u);
        }
        parseConditional(u, a, h) {
          if (this.eat(17)) {
            let d = this.startNodeAt(a);
            return (
              (d.test = u),
              (d.consequent = this.parseMaybeAssignAllowIn()),
              this.expect(14),
              (d.alternate = this.parseMaybeAssign()),
              this.finishNode(d, 'ConditionalExpression')
            );
          }
          return u;
        }
        parseMaybeUnaryOrPrivate(u) {
          return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(u);
        }
        parseExprOps(u) {
          let a = this.state.startLoc,
            h = this.state.potentialArrowAt,
            d = this.parseMaybeUnaryOrPrivate(u);
          return this.shouldExitDescending(d, h) ? d : this.parseExprOp(d, a, -1);
        }
        parseExprOp(u, a, h) {
          if (this.isPrivateName(u)) {
            let D = this.getPrivateNameSV(u);
            (h >= lt(58) || !this.prodParam.hasIn || !this.match(58)) &&
              this.raise(T.PrivateInExpectedIn, { at: u, identifierName: D }),
              this.classScope.usePrivateName(D, u.loc.start);
          }
          let d = this.state.type;
          if (ke(d) && (this.prodParam.hasIn || !this.match(58))) {
            let D = lt(d);
            if (D > h) {
              if (d === 39) {
                if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return u;
                this.checkPipelineAtInfixOperator(u, a);
              }
              let A = this.startNodeAt(a);
              (A.left = u), (A.operator = this.state.value);
              let P = d === 41 || d === 42,
                N = d === 40;
              if (
                (N && (D = lt(42)),
                this.next(),
                d === 39 &&
                  this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }]) &&
                  this.state.type === 96 &&
                  this.prodParam.hasAwait)
              )
                throw this.raise(T.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
              A.right = this.parseExprOpRightExpr(d, D);
              let R = this.finishNode(A, P || N ? 'LogicalExpression' : 'BinaryExpression'),
                _ = this.state.type;
              if ((N && (_ === 41 || _ === 42)) || (P && _ === 40))
                throw this.raise(T.MixingCoalesceWithLogical, { at: this.state.startLoc });
              return this.parseExprOp(R, a, h);
            }
          }
          return u;
        }
        parseExprOpRightExpr(u, a) {
          let h = this.state.startLoc;
          switch (u) {
            case 39:
              switch (this.getPluginOption('pipelineOperator', 'proposal')) {
                case 'hack':
                  return this.withTopicBindingContext(() => this.parseHackPipeBody());
                case 'smart':
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(106))
                      throw this.raise(T.PipeBodyIsTighter, { at: this.state.startLoc });
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(u, a), h);
                  });
                case 'fsharp':
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(a));
              }
            default:
              return this.parseExprOpBaseRightExpr(u, a);
          }
        }
        parseExprOpBaseRightExpr(u, a) {
          let h = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), h, Mt(u) ? a - 1 : a);
        }
        parseHackPipeBody() {
          var u;
          let { startLoc: a } = this.state,
            h = this.parseMaybeAssign();
          return (
            x.has(h.type) &&
              !((u = h.extra) != null && u.parenthesized) &&
              this.raise(T.PipeUnparenthesizedBody, { at: a, type: h.type }),
            this.topicReferenceWasUsedInCurrentContext() || this.raise(T.PipeTopicUnused, { at: a }),
            h
          );
        }
        checkExponentialAfterUnary(u) {
          this.match(57) && this.raise(T.UnexpectedTokenUnaryExponentiation, { at: u.argument });
        }
        parseMaybeUnary(u, a) {
          let h = this.state.startLoc,
            d = this.isContextual(96);
          if (d && this.isAwaitAllowed()) {
            this.next();
            let N = this.parseAwait(h);
            return a || this.checkExponentialAfterUnary(N), N;
          }
          let D = this.match(34),
            A = this.startNode();
          if (Ge(this.state.type)) {
            (A.operator = this.state.value), (A.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions');
            let N = this.match(89);
            if (
              (this.next(),
              (A.argument = this.parseMaybeUnary(null, !0)),
              this.checkExpressionErrors(u, !0),
              this.state.strict && N)
            ) {
              let R = A.argument;
              R.type === 'Identifier'
                ? this.raise(T.StrictDelete, { at: A })
                : this.hasPropertyAsPrivateName(R) && this.raise(T.DeletePrivateField, { at: A });
            }
            if (!D) return a || this.checkExponentialAfterUnary(A), this.finishNode(A, 'UnaryExpression');
          }
          let P = this.parseUpdate(A, D, u);
          if (d) {
            let { type: N } = this.state;
            if ((this.hasPlugin('v8intrinsic') ? ae(N) : ae(N) && !this.match(54)) && !this.isAmbiguousAwait())
              return this.raiseOverwrite(T.AwaitNotInAsyncContext, { at: h }), this.parseAwait(h);
          }
          return P;
        }
        parseUpdate(u, a, h) {
          if (a) {
            let A = u;
            return this.checkLVal(A.argument, { in: this.finishNode(A, 'UpdateExpression') }), u;
          }
          let d = this.state.startLoc,
            D = this.parseExprSubscripts(h);
          if (this.checkExpressionErrors(h, !1)) return D;
          for (; De(this.state.type) && !this.canInsertSemicolon(); ) {
            let A = this.startNodeAt(d);
            (A.operator = this.state.value),
              (A.prefix = !1),
              (A.argument = D),
              this.next(),
              this.checkLVal(D, { in: (D = this.finishNode(A, 'UpdateExpression')) });
          }
          return D;
        }
        parseExprSubscripts(u) {
          let a = this.state.startLoc,
            h = this.state.potentialArrowAt,
            d = this.parseExprAtom(u);
          return this.shouldExitDescending(d, h) ? d : this.parseSubscripts(d, a);
        }
        parseSubscripts(u, a, h) {
          let d = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(u), stop: !1 };
          do (u = this.parseSubscript(u, a, h, d)), (d.maybeAsyncArrow = !1);
          while (!d.stop);
          return u;
        }
        parseSubscript(u, a, h, d) {
          let { type: D } = this.state;
          if (!h && D === 15) return this.parseBind(u, a, h, d);
          if (Et(D)) return this.parseTaggedTemplateExpression(u, a, d);
          let A = !1;
          if (D === 18) {
            if (
              h &&
              (this.raise(T.OptionalChainingNoNew, { at: this.state.startLoc }), this.lookaheadCharCode() === 40)
            )
              return (d.stop = !0), u;
            (d.optionalChainMember = A = !0), this.next();
          }
          if (!h && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(u, a, d, A);
          {
            let P = this.eat(0);
            return P || A || this.eat(16) ? this.parseMember(u, a, d, P, A) : ((d.stop = !0), u);
          }
        }
        parseMember(u, a, h, d, D) {
          let A = this.startNodeAt(a);
          return (
            (A.object = u),
            (A.computed = d),
            d
              ? ((A.property = this.parseExpression()), this.expect(3))
              : this.match(136)
              ? (u.type === 'Super' && this.raise(T.SuperPrivateField, { at: a }),
                this.classScope.usePrivateName(this.state.value, this.state.startLoc),
                (A.property = this.parsePrivateName()))
              : (A.property = this.parseIdentifier(!0)),
            h.optionalChainMember
              ? ((A.optional = D), this.finishNode(A, 'OptionalMemberExpression'))
              : this.finishNode(A, 'MemberExpression')
          );
        }
        parseBind(u, a, h, d) {
          let D = this.startNodeAt(a);
          return (
            (D.object = u),
            this.next(),
            (D.callee = this.parseNoCallExpr()),
            (d.stop = !0),
            this.parseSubscripts(this.finishNode(D, 'BindExpression'), a, h)
          );
        }
        parseCoverCallAndAsyncArrowHead(u, a, h, d) {
          let D = this.state.maybeInArrowParameters,
            A = null;
          (this.state.maybeInArrowParameters = !0), this.next();
          let P = this.startNodeAt(a);
          P.callee = u;
          let { maybeAsyncArrow: N, optionalChainMember: R } = h;
          N && (this.expressionScope.enter(td()), (A = new Yn())),
            R && (P.optional = d),
            d
              ? (P.arguments = this.parseCallExpressionArguments(11))
              : (P.arguments = this.parseCallExpressionArguments(11, u.type === 'Import', u.type !== 'Super', P, A));
          let _ = this.finishCallExpression(P, R);
          return (
            N && this.shouldParseAsyncArrow() && !d
              ? ((h.stop = !0),
                this.checkDestructuringPrivate(A),
                this.expressionScope.validateAsPattern(),
                this.expressionScope.exit(),
                (_ = this.parseAsyncArrowFromCallExpression(this.startNodeAt(a), _)))
              : (N && (this.checkExpressionErrors(A, !0), this.expressionScope.exit()), this.toReferencedArguments(_)),
            (this.state.maybeInArrowParameters = D),
            _
          );
        }
        toReferencedArguments(u, a) {
          this.toReferencedListDeep(u.arguments, a);
        }
        parseTaggedTemplateExpression(u, a, h) {
          let d = this.startNodeAt(a);
          return (
            (d.tag = u),
            (d.quasi = this.parseTemplate(!0)),
            h.optionalChainMember && this.raise(T.OptionalChainingNoTemplate, { at: a }),
            this.finishNode(d, 'TaggedTemplateExpression')
          );
        }
        atPossibleAsyncArrow(u) {
          return (
            u.type === 'Identifier' &&
            u.name === 'async' &&
            this.state.lastTokEndLoc.index === u.end &&
            !this.canInsertSemicolon() &&
            u.end - u.start === 5 &&
            u.start === this.state.potentialArrowAt
          );
        }
        expectImportAttributesPlugin() {
          this.hasPlugin('importAssertions') || this.expectPlugin('importAttributes');
        }
        finishCallExpression(u, a) {
          if (u.callee.type === 'Import')
            if (
              (u.arguments.length === 2 && (this.hasPlugin('moduleAttributes') || this.expectImportAttributesPlugin()),
              u.arguments.length === 0 || u.arguments.length > 2)
            )
              this.raise(T.ImportCallArity, {
                at: u,
                maxArgumentCount:
                  this.hasPlugin('importAttributes') ||
                  this.hasPlugin('importAssertions') ||
                  this.hasPlugin('moduleAttributes')
                    ? 2
                    : 1,
              });
            else
              for (let h of u.arguments)
                h.type === 'SpreadElement' && this.raise(T.ImportCallSpreadArgument, { at: h });
          return this.finishNode(u, a ? 'OptionalCallExpression' : 'CallExpression');
        }
        parseCallExpressionArguments(u, a, h, d, D) {
          let A = [],
            P = !0,
            N = this.state.inFSharpPipelineDirectBody;
          for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(u); ) {
            if (P) P = !1;
            else if ((this.expect(12), this.match(u))) {
              a &&
                !this.hasPlugin('importAttributes') &&
                !this.hasPlugin('importAssertions') &&
                !this.hasPlugin('moduleAttributes') &&
                this.raise(T.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }),
                d && this.addTrailingCommaExtraToNode(d),
                this.next();
              break;
            }
            A.push(this.parseExprListItem(!1, D, h));
          }
          return (this.state.inFSharpPipelineDirectBody = N), A;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(u, a) {
          var h;
          return (
            this.resetPreviousNodeTrailingComments(a),
            this.expect(19),
            this.parseArrowExpression(u, a.arguments, !0, (h = a.extra) == null ? void 0 : h.trailingCommaLoc),
            a.innerComments && Co(u, a.innerComments),
            a.callee.trailingComments && Co(u, a.callee.trailingComments),
            u
          );
        }
        parseNoCallExpr() {
          let u = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), u, !0);
        }
        parseExprAtom(u) {
          let a,
            h = null,
            { type: d } = this.state;
          switch (d) {
            case 79:
              return this.parseSuper();
            case 83:
              return (
                (a = this.startNode()),
                this.next(),
                this.match(16)
                  ? this.parseImportMetaProperty(a)
                  : (this.match(10) || this.raise(T.UnsupportedImport, { at: this.state.lastTokStartLoc }),
                    this.finishNode(a, 'Import'))
              );
            case 78:
              return (a = this.startNode()), this.next(), this.finishNode(a, 'ThisExpression');
            case 90:
              return this.parseDo(this.startNode(), !1);
            case 56:
            case 31:
              return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
            case 132:
              return this.parseNumericLiteral(this.state.value);
            case 133:
              return this.parseBigIntLiteral(this.state.value);
            case 134:
              return this.parseDecimalLiteral(this.state.value);
            case 131:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(!0);
            case 86:
              return this.parseBooleanLiteral(!1);
            case 10: {
              let D = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(D);
            }
            case 2:
            case 1:
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
            case 0:
              return this.parseArrayLike(3, !0, !1, u);
            case 6:
            case 7:
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
            case 5:
              return this.parseObjectLike(8, !1, !1, u);
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              h = this.parseDecorators();
            case 80:
              return this.parseClass(this.maybeTakeDecorators(h, this.startNode()), !1);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(!1);
            case 15: {
              (a = this.startNode()), this.next(), (a.object = null);
              let D = (a.callee = this.parseNoCallExpr());
              if (D.type === 'MemberExpression') return this.finishNode(a, 'BindExpression');
              throw this.raise(T.UnsupportedBind, { at: D });
            }
            case 136:
              return (
                this.raise(T.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }),
                this.parsePrivateName()
              );
            case 33:
              return this.parseTopicReferenceThenEqualsSign(54, '%');
            case 32:
              return this.parseTopicReferenceThenEqualsSign(44, '^');
            case 37:
            case 38:
              return this.parseTopicReference('hack');
            case 44:
            case 54:
            case 27: {
              let D = this.getPluginOption('pipelineOperator', 'proposal');
              if (D) return this.parseTopicReference(D);
              this.unexpected();
              break;
            }
            case 47: {
              let D = this.input.codePointAt(this.nextTokenStart());
              hn(D) || D === 62 ? this.expectOnePlugin(['jsx', 'flow', 'typescript']) : this.unexpected();
              break;
            }
            default:
              if (fe(d)) {
                if (this.isContextual(125) && this.lookaheadInLineCharCode() === 123)
                  return this.parseModuleExpression();
                let D = this.state.potentialArrowAt === this.state.start,
                  A = this.state.containsEsc,
                  P = this.parseIdentifier();
                if (!A && P.name === 'async' && !this.canInsertSemicolon()) {
                  let { type: N } = this.state;
                  if (N === 68)
                    return (
                      this.resetPreviousNodeTrailingComments(P),
                      this.next(),
                      this.parseAsyncFunctionExpression(this.startNodeAtNode(P))
                    );
                  if (fe(N))
                    return this.lookaheadCharCode() === 61
                      ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(P))
                      : P;
                  if (N === 90)
                    return this.resetPreviousNodeTrailingComments(P), this.parseDo(this.startNodeAtNode(P), !0);
                }
                return D && this.match(19) && !this.canInsertSemicolon()
                  ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(P), [P], !1))
                  : P;
              } else this.unexpected();
          }
        }
        parseTopicReferenceThenEqualsSign(u, a) {
          let h = this.getPluginOption('pipelineOperator', 'proposal');
          if (h)
            return (
              (this.state.type = u),
              (this.state.value = a),
              this.state.pos--,
              this.state.end--,
              (this.state.endLoc = i(this.state.endLoc, -1)),
              this.parseTopicReference(h)
            );
          this.unexpected();
        }
        parseTopicReference(u) {
          let a = this.startNode(),
            h = this.state.startLoc,
            d = this.state.type;
          return this.next(), this.finishTopicReference(a, h, u, d);
        }
        finishTopicReference(u, a, h, d) {
          if (this.testTopicReferenceConfiguration(h, a, d)) {
            let D = h === 'smart' ? 'PipelinePrimaryTopicReference' : 'TopicReference';
            return (
              this.topicReferenceIsAllowedInCurrentContext() ||
                this.raise(h === 'smart' ? T.PrimaryTopicNotAllowed : T.PipeTopicUnbound, { at: a }),
              this.registerTopicReference(),
              this.finishNode(u, D)
            );
          } else throw this.raise(T.PipeTopicUnconfiguredToken, { at: a, token: et(d) });
        }
        testTopicReferenceConfiguration(u, a, h) {
          switch (u) {
            case 'hack':
              return this.hasPlugin(['pipelineOperator', { topicToken: et(h) }]);
            case 'smart':
              return h === 27;
            default:
              throw this.raise(T.PipeTopicRequiresHackPipes, { at: a });
          }
        }
        parseAsyncArrowUnaryFunction(u) {
          this.prodParam.enter(Eo(!0, this.prodParam.hasYield));
          let a = [this.parseIdentifier()];
          return (
            this.prodParam.exit(),
            this.hasPrecedingLineBreak() && this.raise(T.LineTerminatorBeforeArrow, { at: this.state.curPosition() }),
            this.expect(19),
            this.parseArrowExpression(u, a, !0)
          );
        }
        parseDo(u, a) {
          this.expectPlugin('doExpressions'), a && this.expectPlugin('asyncDoExpressions'), (u.async = a), this.next();
          let h = this.state.labels;
          return (
            (this.state.labels = []),
            a
              ? (this.prodParam.enter(ba), (u.body = this.parseBlock()), this.prodParam.exit())
              : (u.body = this.parseBlock()),
            (this.state.labels = h),
            this.finishNode(u, 'DoExpression')
          );
        }
        parseSuper() {
          let u = this.startNode();
          return (
            this.next(),
            this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod
              ? this.raise(T.SuperNotAllowed, { at: u })
              : !this.scope.allowSuper &&
                !this.options.allowSuperOutsideMethod &&
                this.raise(T.UnexpectedSuper, { at: u }),
            !this.match(10) && !this.match(0) && !this.match(16) && this.raise(T.UnsupportedSuper, { at: u }),
            this.finishNode(u, 'Super')
          );
        }
        parsePrivateName() {
          let u = this.startNode(),
            a = this.startNodeAt(i(this.state.startLoc, 1)),
            h = this.state.value;
          return this.next(), (u.id = this.createIdentifier(a, h)), this.finishNode(u, 'PrivateName');
        }
        parseFunctionOrFunctionSent() {
          let u = this.startNode();
          if ((this.next(), this.prodParam.hasYield && this.match(16))) {
            let a = this.createIdentifier(this.startNodeAtNode(u), 'function');
            return (
              this.next(),
              this.match(102) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(),
              this.parseMetaProperty(u, a, 'sent')
            );
          }
          return this.parseFunction(u);
        }
        parseMetaProperty(u, a, h) {
          u.meta = a;
          let d = this.state.containsEsc;
          return (
            (u.property = this.parseIdentifier(!0)),
            (u.property.name !== h || d) &&
              this.raise(T.UnsupportedMetaProperty, { at: u.property, target: a.name, onlyValidPropertyName: h }),
            this.finishNode(u, 'MetaProperty')
          );
        }
        parseImportMetaProperty(u) {
          let a = this.createIdentifier(this.startNodeAtNode(u), 'import');
          return (
            this.next(),
            this.isContextual(100) &&
              (this.inModule || this.raise(T.ImportMetaOutsideModule, { at: a }), (this.sawUnambiguousESM = !0)),
            this.parseMetaProperty(u, a, 'meta')
          );
        }
        parseLiteralAtNode(u, a, h) {
          return (
            this.addExtra(h, 'rawValue', u),
            this.addExtra(h, 'raw', this.input.slice(h.start, this.state.end)),
            (h.value = u),
            this.next(),
            this.finishNode(h, a)
          );
        }
        parseLiteral(u, a) {
          let h = this.startNode();
          return this.parseLiteralAtNode(u, a, h);
        }
        parseStringLiteral(u) {
          return this.parseLiteral(u, 'StringLiteral');
        }
        parseNumericLiteral(u) {
          return this.parseLiteral(u, 'NumericLiteral');
        }
        parseBigIntLiteral(u) {
          return this.parseLiteral(u, 'BigIntLiteral');
        }
        parseDecimalLiteral(u) {
          return this.parseLiteral(u, 'DecimalLiteral');
        }
        parseRegExpLiteral(u) {
          let a = this.parseLiteral(u.value, 'RegExpLiteral');
          return (a.pattern = u.pattern), (a.flags = u.flags), a;
        }
        parseBooleanLiteral(u) {
          let a = this.startNode();
          return (a.value = u), this.next(), this.finishNode(a, 'BooleanLiteral');
        }
        parseNullLiteral() {
          let u = this.startNode();
          return this.next(), this.finishNode(u, 'NullLiteral');
        }
        parseParenAndDistinguishExpression(u) {
          let a = this.state.startLoc,
            h;
          this.next(), this.expressionScope.enter(Bc());
          let d = this.state.maybeInArrowParameters,
            D = this.state.inFSharpPipelineDirectBody;
          (this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1);
          let A = this.state.startLoc,
            P = [],
            N = new Yn(),
            R = !0,
            _,
            ue;
          for (; !this.match(11); ) {
            if (R) R = !1;
            else if (
              (this.expect(12, N.optionalParametersLoc === null ? null : N.optionalParametersLoc), this.match(11))
            ) {
              ue = this.state.startLoc;
              break;
            }
            if (this.match(21)) {
              let _e = this.state.startLoc;
              if (
                ((_ = this.state.startLoc),
                P.push(this.parseParenItem(this.parseRestBinding(), _e)),
                !this.checkCommaAfterRest(41))
              )
                break;
            } else P.push(this.parseMaybeAssignAllowIn(N, this.parseParenItem));
          }
          let ve = this.state.lastTokEndLoc;
          this.expect(11), (this.state.maybeInArrowParameters = d), (this.state.inFSharpPipelineDirectBody = D);
          let Ie = this.startNodeAt(a);
          return u && this.shouldParseArrow(P) && (Ie = this.parseArrow(Ie))
            ? (this.checkDestructuringPrivate(N),
              this.expressionScope.validateAsPattern(),
              this.expressionScope.exit(),
              this.parseArrowExpression(Ie, P, !1),
              Ie)
            : (this.expressionScope.exit(),
              P.length || this.unexpected(this.state.lastTokStartLoc),
              ue && this.unexpected(ue),
              _ && this.unexpected(_),
              this.checkExpressionErrors(N, !0),
              this.toReferencedListDeep(P, !0),
              P.length > 1
                ? ((h = this.startNodeAt(A)),
                  (h.expressions = P),
                  this.finishNode(h, 'SequenceExpression'),
                  this.resetEndLocation(h, ve))
                : (h = P[0]),
              this.wrapParenthesis(a, h));
        }
        wrapParenthesis(u, a) {
          if (!this.options.createParenthesizedExpressions)
            return (
              this.addExtra(a, 'parenthesized', !0),
              this.addExtra(a, 'parenStart', u.index),
              this.takeSurroundingComments(a, u.index, this.state.lastTokEndLoc.index),
              a
            );
          let h = this.startNodeAt(u);
          return (h.expression = a), this.finishNode(h, 'ParenthesizedExpression');
        }
        shouldParseArrow(u) {
          return !this.canInsertSemicolon();
        }
        parseArrow(u) {
          if (this.eat(19)) return u;
        }
        parseParenItem(u, a) {
          return u;
        }
        parseNewOrNewTarget() {
          let u = this.startNode();
          if ((this.next(), this.match(16))) {
            let a = this.createIdentifier(this.startNodeAtNode(u), 'new');
            this.next();
            let h = this.parseMetaProperty(u, a, 'target');
            return (
              !this.scope.inNonArrowFunction &&
                !this.scope.inClass &&
                !this.options.allowNewTargetOutsideFunction &&
                this.raise(T.UnexpectedNewTarget, { at: h }),
              h
            );
          }
          return this.parseNew(u);
        }
        parseNew(u) {
          if ((this.parseNewCallee(u), this.eat(10))) {
            let a = this.parseExprList(11);
            this.toReferencedList(a), (u.arguments = a);
          } else u.arguments = [];
          return this.finishNode(u, 'NewExpression');
        }
        parseNewCallee(u) {
          (u.callee = this.parseNoCallExpr()),
            u.callee.type === 'Import' && this.raise(T.ImportCallNotNewExpression, { at: u.callee });
        }
        parseTemplateElement(u) {
          let { start: a, startLoc: h, end: d, value: D } = this.state,
            A = a + 1,
            P = this.startNodeAt(i(h, 1));
          D === null &&
            (u || this.raise(T.InvalidEscapeSequenceTemplate, { at: i(this.state.firstInvalidTemplateEscapePos, 1) }));
          let N = this.match(24),
            R = N ? -1 : -2,
            _ = d + R;
          (P.value = {
            raw: this.input.slice(A, _).replace(
              /\r\n?/g,
              `
`,
            ),
            cooked: D === null ? null : D.slice(1, R),
          }),
            (P.tail = N),
            this.next();
          let ue = this.finishNode(P, 'TemplateElement');
          return this.resetEndLocation(ue, i(this.state.lastTokEndLoc, R)), ue;
        }
        parseTemplate(u) {
          let a = this.startNode();
          a.expressions = [];
          let h = this.parseTemplateElement(u);
          for (a.quasis = [h]; !h.tail; )
            a.expressions.push(this.parseTemplateSubstitution()),
              this.readTemplateContinuation(),
              a.quasis.push((h = this.parseTemplateElement(u)));
          return this.finishNode(a, 'TemplateLiteral');
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(u, a, h, d) {
          h && this.expectPlugin('recordAndTuple');
          let D = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          let A = Object.create(null),
            P = !0,
            N = this.startNode();
          for (N.properties = [], this.next(); !this.match(u); ) {
            if (P) P = !1;
            else if ((this.expect(12), this.match(u))) {
              this.addTrailingCommaExtraToNode(N);
              break;
            }
            let _;
            a
              ? (_ = this.parseBindingProperty())
              : ((_ = this.parsePropertyDefinition(d)), this.checkProto(_, h, A, d)),
              h &&
                !this.isObjectProperty(_) &&
                _.type !== 'SpreadElement' &&
                this.raise(T.InvalidRecordProperty, { at: _ }),
              _.shorthand && this.addExtra(_, 'shorthand', !0),
              N.properties.push(_);
          }
          this.next(), (this.state.inFSharpPipelineDirectBody = D);
          let R = 'ObjectExpression';
          return a ? (R = 'ObjectPattern') : h && (R = 'RecordExpression'), this.finishNode(N, R);
        }
        addTrailingCommaExtraToNode(u) {
          this.addExtra(u, 'trailingComma', this.state.lastTokStart),
            this.addExtra(u, 'trailingCommaLoc', this.state.lastTokStartLoc, !1);
        }
        maybeAsyncOrAccessorProp(u) {
          return (
            !u.computed &&
            u.key.type === 'Identifier' &&
            (this.isLiteralPropertyName() || this.match(0) || this.match(55))
          );
        }
        parsePropertyDefinition(u) {
          let a = [];
          if (this.match(26))
            for (
              this.hasPlugin('decorators') && this.raise(T.UnsupportedPropertyDecorator, { at: this.state.startLoc });
              this.match(26);

            )
              a.push(this.parseDecorator());
          let h = this.startNode(),
            d = !1,
            D = !1,
            A;
          if (this.match(21)) return a.length && this.unexpected(), this.parseSpread();
          a.length && ((h.decorators = a), (a = [])), (h.method = !1), u && (A = this.state.startLoc);
          let P = this.eat(55);
          this.parsePropertyNamePrefixOperator(h);
          let N = this.state.containsEsc,
            R = this.parsePropertyName(h, u);
          if (!P && !N && this.maybeAsyncOrAccessorProp(h)) {
            let _ = R.name;
            _ === 'async' &&
              !this.hasPrecedingLineBreak() &&
              ((d = !0), this.resetPreviousNodeTrailingComments(R), (P = this.eat(55)), this.parsePropertyName(h)),
              (_ === 'get' || _ === 'set') &&
                ((D = !0),
                this.resetPreviousNodeTrailingComments(R),
                (h.kind = _),
                this.match(55) &&
                  ((P = !0), this.raise(T.AccessorIsGenerator, { at: this.state.curPosition(), kind: _ }), this.next()),
                this.parsePropertyName(h));
          }
          return this.parseObjPropValue(h, A, P, d, !1, D, u);
        }
        getGetterSetterExpectedParamCount(u) {
          return u.kind === 'get' ? 0 : 1;
        }
        getObjectOrClassMethodParams(u) {
          return u.params;
        }
        checkGetterSetterParams(u) {
          var a;
          let h = this.getGetterSetterExpectedParamCount(u),
            d = this.getObjectOrClassMethodParams(u);
          d.length !== h && this.raise(u.kind === 'get' ? T.BadGetterArity : T.BadSetterArity, { at: u }),
            u.kind === 'set' &&
              ((a = d[d.length - 1]) == null ? void 0 : a.type) === 'RestElement' &&
              this.raise(T.BadSetterRestParameter, { at: u });
        }
        parseObjectMethod(u, a, h, d, D) {
          if (D) {
            let A = this.parseMethod(u, a, !1, !1, !1, 'ObjectMethod');
            return this.checkGetterSetterParams(A), A;
          }
          if (h || a || this.match(10))
            return (
              d && this.unexpected(),
              (u.kind = 'method'),
              (u.method = !0),
              this.parseMethod(u, a, h, !1, !1, 'ObjectMethod')
            );
        }
        parseObjectProperty(u, a, h, d) {
          if (((u.shorthand = !1), this.eat(14)))
            return (
              (u.value = h ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(d)),
              this.finishNode(u, 'ObjectProperty')
            );
          if (!u.computed && u.key.type === 'Identifier') {
            if ((this.checkReservedWord(u.key.name, u.key.loc.start, !0, !1), h))
              u.value = this.parseMaybeDefault(a, Qn(u.key));
            else if (this.match(29)) {
              let D = this.state.startLoc;
              d != null
                ? d.shorthandAssignLoc === null && (d.shorthandAssignLoc = D)
                : this.raise(T.InvalidCoverInitializedName, { at: D }),
                (u.value = this.parseMaybeDefault(a, Qn(u.key)));
            } else u.value = Qn(u.key);
            return (u.shorthand = !0), this.finishNode(u, 'ObjectProperty');
          }
        }
        parseObjPropValue(u, a, h, d, D, A, P) {
          let N = this.parseObjectMethod(u, h, d, D, A) || this.parseObjectProperty(u, a, D, P);
          return N || this.unexpected(), N;
        }
        parsePropertyName(u, a) {
          if (this.eat(0)) (u.computed = !0), (u.key = this.parseMaybeAssignAllowIn()), this.expect(3);
          else {
            let { type: h, value: d } = this.state,
              D;
            if (M(h)) D = this.parseIdentifier(!0);
            else
              switch (h) {
                case 132:
                  D = this.parseNumericLiteral(d);
                  break;
                case 131:
                  D = this.parseStringLiteral(d);
                  break;
                case 133:
                  D = this.parseBigIntLiteral(d);
                  break;
                case 134:
                  D = this.parseDecimalLiteral(d);
                  break;
                case 136: {
                  let A = this.state.startLoc;
                  a != null
                    ? a.privateKeyLoc === null && (a.privateKeyLoc = A)
                    : this.raise(T.UnexpectedPrivateField, { at: A }),
                    (D = this.parsePrivateName());
                  break;
                }
                default:
                  this.unexpected();
              }
            (u.key = D), h !== 136 && (u.computed = !1);
          }
          return u.key;
        }
        initFunction(u, a) {
          (u.id = null), (u.generator = !1), (u.async = a);
        }
        parseMethod(u, a, h, d, D, A, P = !1) {
          this.initFunction(u, h),
            (u.generator = a),
            this.scope.enter(18 | (P ? 64 : 0) | (D ? 32 : 0)),
            this.prodParam.enter(Eo(h, u.generator)),
            this.parseFunctionParams(u, d);
          let N = this.parseFunctionBodyAndFinish(u, A, !0);
          return this.prodParam.exit(), this.scope.exit(), N;
        }
        parseArrayLike(u, a, h, d) {
          h && this.expectPlugin('recordAndTuple');
          let D = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          let A = this.startNode();
          return (
            this.next(),
            (A.elements = this.parseExprList(u, !h, d, A)),
            (this.state.inFSharpPipelineDirectBody = D),
            this.finishNode(A, h ? 'TupleExpression' : 'ArrayExpression')
          );
        }
        parseArrowExpression(u, a, h, d) {
          this.scope.enter(6);
          let D = Eo(h, !1);
          !this.match(5) && this.prodParam.hasIn && (D |= bs), this.prodParam.enter(D), this.initFunction(u, h);
          let A = this.state.maybeInArrowParameters;
          return (
            a && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(u, a, d)),
            (this.state.maybeInArrowParameters = !1),
            this.parseFunctionBody(u, !0),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.maybeInArrowParameters = A),
            this.finishNode(u, 'ArrowFunctionExpression')
          );
        }
        setArrowFunctionParameters(u, a, h) {
          this.toAssignableList(a, h, !1), (u.params = a);
        }
        parseFunctionBodyAndFinish(u, a, h = !1) {
          return this.parseFunctionBody(u, !1, h), this.finishNode(u, a);
        }
        parseFunctionBody(u, a, h = !1) {
          let d = a && !this.match(5);
          if ((this.expressionScope.enter(Ic()), d)) (u.body = this.parseMaybeAssign()), this.checkParams(u, !1, a, !1);
          else {
            let D = this.state.strict,
              A = this.state.labels;
            (this.state.labels = []),
              this.prodParam.enter(this.prodParam.currentFlags() | Nc),
              (u.body = this.parseBlock(!0, !1, (P) => {
                let N = !this.isSimpleParamList(u.params);
                P &&
                  N &&
                  this.raise(T.IllegalLanguageModeDirective, {
                    at: (u.kind === 'method' || u.kind === 'constructor') && u.key ? u.key.loc.end : u,
                  });
                let R = !D && this.state.strict;
                this.checkParams(u, !this.state.strict && !a && !h && !N, a, R),
                  this.state.strict && u.id && this.checkIdentifier(u.id, 65, R);
              })),
              this.prodParam.exit(),
              (this.state.labels = A);
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(u) {
          return u.type === 'Identifier';
        }
        isSimpleParamList(u) {
          for (let a = 0, h = u.length; a < h; a++) if (!this.isSimpleParameter(u[a])) return !1;
          return !0;
        }
        checkParams(u, a, h, d = !0) {
          let D = !a && new Set(),
            A = { type: 'FormalParameters' };
          for (let P of u.params) this.checkLVal(P, { in: A, binding: 5, checkClashes: D, strictModeChanged: d });
        }
        parseExprList(u, a, h, d) {
          let D = [],
            A = !0;
          for (; !this.eat(u); ) {
            if (A) A = !1;
            else if ((this.expect(12), this.match(u))) {
              d && this.addTrailingCommaExtraToNode(d), this.next();
              break;
            }
            D.push(this.parseExprListItem(a, h));
          }
          return D;
        }
        parseExprListItem(u, a, h) {
          let d;
          if (this.match(12))
            u || this.raise(T.UnexpectedToken, { at: this.state.curPosition(), unexpected: ',' }), (d = null);
          else if (this.match(21)) {
            let D = this.state.startLoc;
            d = this.parseParenItem(this.parseSpread(a), D);
          } else if (this.match(17)) {
            this.expectPlugin('partialApplication'),
              h || this.raise(T.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
            let D = this.startNode();
            this.next(), (d = this.finishNode(D, 'ArgumentPlaceholder'));
          } else d = this.parseMaybeAssignAllowIn(a, this.parseParenItem);
          return d;
        }
        parseIdentifier(u) {
          let a = this.startNode(),
            h = this.parseIdentifierName(u);
          return this.createIdentifier(a, h);
        }
        createIdentifier(u, a) {
          return (u.name = a), (u.loc.identifierName = a), this.finishNode(u, 'Identifier');
        }
        parseIdentifierName(u) {
          let a,
            { startLoc: h, type: d } = this.state;
          M(d) ? (a = this.state.value) : this.unexpected();
          let D = at(d);
          return u ? D && this.replaceToken(130) : this.checkReservedWord(a, h, D, !1), this.next(), a;
        }
        checkReservedWord(u, a, h, d) {
          if (!(u.length > 10 || !Uf(u))) {
            if (h && Nl(u)) {
              this.raise(T.UnexpectedKeyword, { at: a, keyword: u });
              return;
            }
            if ((this.state.strict ? (d ? vc : Ec) : Ac)(u, this.inModule)) {
              this.raise(T.UnexpectedReservedWord, { at: a, reservedWord: u });
              return;
            } else if (u === 'yield') {
              if (this.prodParam.hasYield) {
                this.raise(T.YieldBindingIdentifier, { at: a });
                return;
              }
            } else if (u === 'await') {
              if (this.prodParam.hasAwait) {
                this.raise(T.AwaitBindingIdentifier, { at: a });
                return;
              }
              if (this.scope.inStaticBlock) {
                this.raise(T.AwaitBindingIdentifierInStaticBlock, { at: a });
                return;
              }
              this.expressionScope.recordAsyncArrowParametersError({ at: a });
            } else if (u === 'arguments' && this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(T.ArgumentsInClass, { at: a });
              return;
            }
          }
        }
        isAwaitAllowed() {
          return !!(this.prodParam.hasAwait || (this.options.allowAwaitOutsideFunction && !this.scope.inFunction));
        }
        parseAwait(u) {
          let a = this.startNodeAt(u);
          return (
            this.expressionScope.recordParameterInitializerError(T.AwaitExpressionFormalParameter, { at: a }),
            this.eat(55) && this.raise(T.ObsoleteAwaitStar, { at: a }),
            !this.scope.inFunction &&
              !this.options.allowAwaitOutsideFunction &&
              (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)),
            this.state.soloAwait || (a.argument = this.parseMaybeUnary(null, !0)),
            this.finishNode(a, 'AwaitExpression')
          );
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak()) return !0;
          let { type: u } = this.state;
          return (
            u === 53 ||
            u === 10 ||
            u === 0 ||
            Et(u) ||
            (u === 101 && !this.state.containsEsc) ||
            u === 135 ||
            u === 56 ||
            (this.hasPlugin('v8intrinsic') && u === 54)
          );
        }
        parseYield() {
          let u = this.startNode();
          this.expressionScope.recordParameterInitializerError(T.YieldInParameter, { at: u }), this.next();
          let a = !1,
            h = null;
          if (!this.hasPrecedingLineBreak())
            switch (((a = this.eat(55)), this.state.type)) {
              case 13:
              case 137:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!a) break;
              default:
                h = this.parseMaybeAssign();
            }
          return (u.delegate = a), (u.argument = h), this.finishNode(u, 'YieldExpression');
        }
        checkPipelineAtInfixOperator(u, a) {
          this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) &&
            u.type === 'SequenceExpression' &&
            this.raise(T.PipelineHeadSequenceExpression, { at: a });
        }
        parseSmartPipelineBodyInStyle(u, a) {
          if (this.isSimpleReference(u)) {
            let h = this.startNodeAt(a);
            return (h.callee = u), this.finishNode(h, 'PipelineBareFunction');
          } else {
            let h = this.startNodeAt(a);
            return (
              this.checkSmartPipeTopicBodyEarlyErrors(a),
              (h.expression = u),
              this.finishNode(h, 'PipelineTopicExpression')
            );
          }
        }
        isSimpleReference(u) {
          switch (u.type) {
            case 'MemberExpression':
              return !u.computed && this.isSimpleReference(u.object);
            case 'Identifier':
              return !0;
            default:
              return !1;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(u) {
          if (this.match(19)) throw this.raise(T.PipelineBodyNoArrow, { at: this.state.startLoc });
          this.topicReferenceWasUsedInCurrentContext() || this.raise(T.PipelineTopicUnused, { at: u });
        }
        withTopicBindingContext(u) {
          let a = this.state.topicContext;
          this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
          try {
            return u();
          } finally {
            this.state.topicContext = a;
          }
        }
        withSmartMixTopicForbiddingContext(u) {
          if (this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) {
            let a = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
            try {
              return u();
            } finally {
              this.state.topicContext = a;
            }
          } else return u();
        }
        withSoloAwaitPermittingContext(u) {
          let a = this.state.soloAwait;
          this.state.soloAwait = !0;
          try {
            return u();
          } finally {
            this.state.soloAwait = a;
          }
        }
        allowInAnd(u) {
          let a = this.prodParam.currentFlags();
          if (bs & ~a) {
            this.prodParam.enter(a | bs);
            try {
              return u();
            } finally {
              this.prodParam.exit();
            }
          }
          return u();
        }
        disallowInAnd(u) {
          let a = this.prodParam.currentFlags();
          if (bs & a) {
            this.prodParam.enter(a & ~bs);
            try {
              return u();
            } finally {
              this.prodParam.exit();
            }
          }
          return u();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(u) {
          let a = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          let h = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !0;
          let d = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), a, u);
          return (this.state.inFSharpPipelineDirectBody = h), d;
        }
        parseModuleExpression() {
          this.expectPlugin('moduleBlocks');
          let u = this.startNode();
          this.next(), this.match(5) || this.unexpected(null, 5);
          let a = this.startNodeAt(this.state.endLoc);
          this.next();
          let h = this.initializeScopes(!0);
          this.enterInitialScopes();
          try {
            u.body = this.parseProgram(a, 8, 'module');
          } finally {
            h();
          }
          return this.finishNode(u, 'ModuleExpression');
        }
        parsePropertyNamePrefixOperator(u) {}
      },
      va = { kind: 'loop' },
      xd = { kind: 'switch' },
      Qc = /[\uD800-\uDFFF]/u,
      Fa = /in(?:stanceof)?/y;
    function Cd(u, a) {
      for (let h = 0; h < u.length; h++) {
        let d = u[h],
          { type: D } = d;
        if (typeof D == 'number') {
          {
            if (D === 136) {
              let { loc: A, start: P, value: N, end: R } = d,
                _ = P + 1,
                ue = i(A.start, 1);
              u.splice(
                h,
                1,
                new Cn({ type: Pt(27), value: '#', start: P, end: _, startLoc: A.start, endLoc: ue }),
                new Cn({ type: Pt(130), value: N, start: _, end: R, startLoc: ue, endLoc: A.end }),
              ),
                h++;
              continue;
            }
            if (Et(D)) {
              let { loc: A, start: P, value: N, end: R } = d,
                _ = P + 1,
                ue = i(A.start, 1),
                ve;
              a.charCodeAt(P) === 96
                ? (ve = new Cn({ type: Pt(22), value: '`', start: P, end: _, startLoc: A.start, endLoc: ue }))
                : (ve = new Cn({ type: Pt(8), value: '}', start: P, end: _, startLoc: A.start, endLoc: ue }));
              let Ie, _e, Bt, wt;
              D === 24
                ? ((_e = R - 1),
                  (Bt = i(A.end, -1)),
                  (Ie = N === null ? null : N.slice(1, -1)),
                  (wt = new Cn({ type: Pt(22), value: '`', start: _e, end: R, startLoc: Bt, endLoc: A.end })))
                : ((_e = R - 2),
                  (Bt = i(A.end, -2)),
                  (Ie = N === null ? null : N.slice(1, -2)),
                  (wt = new Cn({ type: Pt(23), value: '${', start: _e, end: R, startLoc: Bt, endLoc: A.end }))),
                u.splice(
                  h,
                  1,
                  ve,
                  new Cn({ type: Pt(20), value: Ie, start: _, end: _e, startLoc: ue, endLoc: Bt }),
                  wt,
                ),
                (h += 2);
              continue;
            }
          }
          d.type = Pt(D);
        }
      }
      return u;
    }
    var Zc = class extends Dd {
        parseTopLevel(u, a) {
          return (
            (u.program = this.parseProgram(a)),
            (u.comments = this.state.comments),
            this.options.tokens && (u.tokens = Cd(this.tokens, this.input)),
            this.finishNode(u, 'File')
          );
        }
        parseProgram(u, a = 137, h = this.options.sourceType) {
          if (
            ((u.sourceType = h),
            (u.interpreter = this.parseInterpreterDirective()),
            this.parseBlockBody(u, !0, !0, a),
            this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
          )
            for (let [D, A] of Array.from(this.scope.undefinedExports))
              this.raise(T.ModuleExportUndefined, { at: A, localName: D });
          let d;
          return (
            a === 137
              ? (d = this.finishNode(u, 'Program'))
              : (d = this.finishNodeAt(u, 'Program', i(this.state.startLoc, -1))),
            d
          );
        }
        stmtToDirective(u) {
          let a = u;
          (a.type = 'Directive'), (a.value = a.expression), delete a.expression;
          let h = a.value,
            d = h.value,
            D = this.input.slice(h.start, h.end),
            A = (h.value = D.slice(1, -1));
          return (
            this.addExtra(h, 'raw', D),
            this.addExtra(h, 'rawValue', A),
            this.addExtra(h, 'expressionValue', d),
            (h.type = 'DirectiveLiteral'),
            a
          );
        }
        parseInterpreterDirective() {
          if (!this.match(28)) return null;
          let u = this.startNode();
          return (u.value = this.state.value), this.next(), this.finishNode(u, 'InterpreterDirective');
        }
        isLet() {
          return this.isContextual(99) ? this.hasFollowingBindingAtom() : !1;
        }
        chStartsBindingIdentifier(u, a) {
          if (hn(u)) {
            if (((Fa.lastIndex = a), Fa.test(this.input))) {
              let h = this.codePointAtPos(Fa.lastIndex);
              if (!pn(h) && h !== 92) return !1;
            }
            return !0;
          } else return u === 92;
        }
        chStartsBindingPattern(u) {
          return u === 91 || u === 123;
        }
        hasFollowingBindingAtom() {
          let u = this.nextTokenStart(),
            a = this.codePointAtPos(u);
          return this.chStartsBindingPattern(a) || this.chStartsBindingIdentifier(a, u);
        }
        hasInLineFollowingBindingIdentifier() {
          let u = this.nextTokenInLineStart(),
            a = this.codePointAtPos(u);
          return this.chStartsBindingIdentifier(a, u);
        }
        startsUsingForOf() {
          let { type: u, containsEsc: a } = this.lookahead();
          if (u === 101 && !a) return !1;
          if (fe(u) && !this.hasFollowingLineBreak()) return this.expectPlugin('explicitResourceManagement'), !0;
        }
        startsAwaitUsing() {
          let u = this.nextTokenInLineStart();
          if (this.isUnparsedContextual(u, 'using')) {
            u = this.nextTokenInLineStartSince(u + 5);
            let a = this.codePointAtPos(u);
            if (this.chStartsBindingIdentifier(a, u)) return this.expectPlugin('explicitResourceManagement'), !0;
          }
          return !1;
        }
        parseModuleItem() {
          return this.parseStatementLike(15);
        }
        parseStatementListItem() {
          return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
        }
        parseStatementOrSloppyAnnexBFunctionDeclaration(u = !1) {
          let a = 0;
          return this.options.annexB && !this.state.strict && ((a |= 4), u && (a |= 8)), this.parseStatementLike(a);
        }
        parseStatement() {
          return this.parseStatementLike(0);
        }
        parseStatementLike(u) {
          let a = null;
          return this.match(26) && (a = this.parseDecorators(!0)), this.parseStatementContent(u, a);
        }
        parseStatementContent(u, a) {
          let h = this.state.type,
            d = this.startNode(),
            D = !!(u & 2),
            A = !!(u & 4),
            P = u & 1;
          switch (h) {
            case 60:
              return this.parseBreakContinueStatement(d, !0);
            case 63:
              return this.parseBreakContinueStatement(d, !1);
            case 64:
              return this.parseDebuggerStatement(d);
            case 90:
              return this.parseDoWhileStatement(d);
            case 91:
              return this.parseForStatement(d);
            case 68:
              if (this.lookaheadCharCode() === 46) break;
              return (
                A ||
                  this.raise(
                    this.state.strict
                      ? T.StrictFunction
                      : this.options.annexB
                      ? T.SloppyFunctionAnnexB
                      : T.SloppyFunction,
                    { at: this.state.startLoc },
                  ),
                this.parseFunctionStatement(d, !1, !D && A)
              );
            case 80:
              return D || this.unexpected(), this.parseClass(this.maybeTakeDecorators(a, d), !0);
            case 69:
              return this.parseIfStatement(d);
            case 70:
              return this.parseReturnStatement(d);
            case 71:
              return this.parseSwitchStatement(d);
            case 72:
              return this.parseThrowStatement(d);
            case 73:
              return this.parseTryStatement(d);
            case 96:
              if (!this.state.containsEsc && this.startsAwaitUsing())
                return (
                  this.isAwaitAllowed()
                    ? D || this.raise(T.UnexpectedLexicalDeclaration, { at: d })
                    : this.raise(T.AwaitUsingNotInAsyncContext, { at: d }),
                  this.next(),
                  this.parseVarStatement(d, 'await using')
                );
              break;
            case 105:
              if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
              return (
                this.expectPlugin('explicitResourceManagement'),
                !this.scope.inModule && this.scope.inTopLevel
                  ? this.raise(T.UnexpectedUsingDeclaration, { at: this.state.startLoc })
                  : D || this.raise(T.UnexpectedLexicalDeclaration, { at: this.state.startLoc }),
                this.parseVarStatement(d, 'using')
              );
            case 99: {
              if (this.state.containsEsc) break;
              let _ = this.nextTokenStart(),
                ue = this.codePointAtPos(_);
              if (
                ue !== 91 &&
                ((!D && this.hasFollowingLineBreak()) || (!this.chStartsBindingIdentifier(ue, _) && ue !== 123))
              )
                break;
            }
            case 75:
              D || this.raise(T.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
            case 74: {
              let _ = this.state.value;
              return this.parseVarStatement(d, _);
            }
            case 92:
              return this.parseWhileStatement(d);
            case 76:
              return this.parseWithStatement(d);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(d);
            case 83: {
              let _ = this.lookaheadCharCode();
              if (_ === 40 || _ === 46) break;
            }
            case 82: {
              !this.options.allowImportExportEverywhere &&
                !P &&
                this.raise(T.UnexpectedImportExport, { at: this.state.startLoc }),
                this.next();
              let _;
              return (
                h === 83
                  ? ((_ = this.parseImport(d)),
                    _.type === 'ImportDeclaration' &&
                      (!_.importKind || _.importKind === 'value') &&
                      (this.sawUnambiguousESM = !0))
                  : ((_ = this.parseExport(d, a)),
                    ((_.type === 'ExportNamedDeclaration' && (!_.exportKind || _.exportKind === 'value')) ||
                      (_.type === 'ExportAllDeclaration' && (!_.exportKind || _.exportKind === 'value')) ||
                      _.type === 'ExportDefaultDeclaration') &&
                      (this.sawUnambiguousESM = !0)),
                this.assertModuleNodeAllowed(_),
                _
              );
            }
            default:
              if (this.isAsyncFunction())
                return (
                  D || this.raise(T.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }),
                  this.next(),
                  this.parseFunctionStatement(d, !0, !D && A)
                );
          }
          let N = this.state.value,
            R = this.parseExpression();
          return fe(h) && R.type === 'Identifier' && this.eat(14)
            ? this.parseLabeledStatement(d, N, R, u)
            : this.parseExpressionStatement(d, R, a);
        }
        assertModuleNodeAllowed(u) {
          !this.options.allowImportExportEverywhere && !this.inModule && this.raise(T.ImportOutsideModule, { at: u });
        }
        decoratorsEnabledBeforeExport() {
          return this.hasPlugin('decorators-legacy')
            ? !0
            : this.hasPlugin('decorators') && this.getPluginOption('decorators', 'decoratorsBeforeExport') !== !1;
        }
        maybeTakeDecorators(u, a, h) {
          return (
            u &&
              (a.decorators && a.decorators.length > 0
                ? (typeof this.getPluginOption('decorators', 'decoratorsBeforeExport') != 'boolean' &&
                    this.raise(T.DecoratorsBeforeAfterExport, { at: a.decorators[0] }),
                  a.decorators.unshift(...u))
                : (a.decorators = u),
              this.resetStartLocationFromNode(a, u[0]),
              h && this.resetStartLocationFromNode(h, a)),
            a
          );
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(u) {
          let a = [];
          do a.push(this.parseDecorator());
          while (this.match(26));
          if (this.match(82))
            u || this.unexpected(),
              this.decoratorsEnabledBeforeExport() || this.raise(T.DecoratorExportClass, { at: this.state.startLoc });
          else if (!this.canHaveLeadingDecorator())
            throw this.raise(T.UnexpectedLeadingDecorator, { at: this.state.startLoc });
          return a;
        }
        parseDecorator() {
          this.expectOnePlugin(['decorators', 'decorators-legacy']);
          let u = this.startNode();
          if ((this.next(), this.hasPlugin('decorators'))) {
            let a = this.state.startLoc,
              h;
            if (this.match(10)) {
              let d = this.state.startLoc;
              this.next(), (h = this.parseExpression()), this.expect(11), (h = this.wrapParenthesis(d, h));
              let D = this.state.startLoc;
              (u.expression = this.parseMaybeDecoratorArguments(h)),
                this.getPluginOption('decorators', 'allowCallParenthesized') === !1 &&
                  u.expression !== h &&
                  this.raise(T.DecoratorArgumentsOutsideParentheses, { at: D });
            } else {
              for (h = this.parseIdentifier(!1); this.eat(16); ) {
                let d = this.startNodeAt(a);
                (d.object = h),
                  this.match(136)
                    ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc),
                      (d.property = this.parsePrivateName()))
                    : (d.property = this.parseIdentifier(!0)),
                  (d.computed = !1),
                  (h = this.finishNode(d, 'MemberExpression'));
              }
              u.expression = this.parseMaybeDecoratorArguments(h);
            }
          } else u.expression = this.parseExprSubscripts();
          return this.finishNode(u, 'Decorator');
        }
        parseMaybeDecoratorArguments(u) {
          if (this.eat(10)) {
            let a = this.startNodeAtNode(u);
            return (
              (a.callee = u),
              (a.arguments = this.parseCallExpressionArguments(11, !1)),
              this.toReferencedList(a.arguments),
              this.finishNode(a, 'CallExpression')
            );
          }
          return u;
        }
        parseBreakContinueStatement(u, a) {
          return (
            this.next(),
            this.isLineTerminator() ? (u.label = null) : ((u.label = this.parseIdentifier()), this.semicolon()),
            this.verifyBreakContinue(u, a),
            this.finishNode(u, a ? 'BreakStatement' : 'ContinueStatement')
          );
        }
        verifyBreakContinue(u, a) {
          let h;
          for (h = 0; h < this.state.labels.length; ++h) {
            let d = this.state.labels[h];
            if (
              (u.label == null || d.name === u.label.name) &&
              ((d.kind != null && (a || d.kind === 'loop')) || (u.label && a))
            )
              break;
          }
          if (h === this.state.labels.length) {
            let d = a ? 'BreakStatement' : 'ContinueStatement';
            this.raise(T.IllegalBreakContinue, { at: u, type: d });
          }
        }
        parseDebuggerStatement(u) {
          return this.next(), this.semicolon(), this.finishNode(u, 'DebuggerStatement');
        }
        parseHeaderExpression() {
          this.expect(10);
          let u = this.parseExpression();
          return this.expect(11), u;
        }
        parseDoWhileStatement(u) {
          return (
            this.next(),
            this.state.labels.push(va),
            (u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.state.labels.pop(),
            this.expect(92),
            (u.test = this.parseHeaderExpression()),
            this.eat(13),
            this.finishNode(u, 'DoWhileStatement')
          );
        }
        parseForStatement(u) {
          this.next(), this.state.labels.push(va);
          let a = null;
          if (
            (this.isAwaitAllowed() && this.eatContextual(96) && (a = this.state.lastTokStartLoc),
            this.scope.enter(0),
            this.expect(10),
            this.match(13))
          )
            return a !== null && this.unexpected(a), this.parseFor(u, null);
          let h = this.isContextual(99);
          {
            let N = this.isContextual(96) && this.startsAwaitUsing(),
              R = N || (this.isContextual(105) && this.startsUsingForOf()),
              _ = (h && this.hasFollowingBindingAtom()) || R;
            if (this.match(74) || this.match(75) || _) {
              let ue = this.startNode(),
                ve;
              N
                ? ((ve = 'await using'),
                  this.isAwaitAllowed() || this.raise(T.AwaitUsingNotInAsyncContext, { at: this.state.startLoc }),
                  this.next())
                : (ve = this.state.value),
                this.next(),
                this.parseVar(ue, !0, ve);
              let Ie = this.finishNode(ue, 'VariableDeclaration'),
                _e = this.match(58);
              return (
                _e && R && this.raise(T.ForInUsing, { at: Ie }),
                (_e || this.isContextual(101)) && Ie.declarations.length === 1
                  ? this.parseForIn(u, Ie, a)
                  : (a !== null && this.unexpected(a), this.parseFor(u, Ie))
              );
            }
          }
          let d = this.isContextual(95),
            D = new Yn(),
            A = this.parseExpression(!0, D),
            P = this.isContextual(101);
          if (
            (P &&
              (h && this.raise(T.ForOfLet, { at: A }),
              a === null && d && A.type === 'Identifier' && this.raise(T.ForOfAsync, { at: A })),
            P || this.match(58))
          ) {
            this.checkDestructuringPrivate(D), this.toAssignable(A, !0);
            let N = P ? 'ForOfStatement' : 'ForInStatement';
            return this.checkLVal(A, { in: { type: N } }), this.parseForIn(u, A, a);
          } else this.checkExpressionErrors(D, !0);
          return a !== null && this.unexpected(a), this.parseFor(u, A);
        }
        parseFunctionStatement(u, a, h) {
          return this.next(), this.parseFunction(u, 1 | (h ? 2 : 0) | (a ? 8 : 0));
        }
        parseIfStatement(u) {
          return (
            this.next(),
            (u.test = this.parseHeaderExpression()),
            (u.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration()),
            (u.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null),
            this.finishNode(u, 'IfStatement')
          );
        }
        parseReturnStatement(u) {
          return (
            !this.prodParam.hasReturn &&
              !this.options.allowReturnOutsideFunction &&
              this.raise(T.IllegalReturn, { at: this.state.startLoc }),
            this.next(),
            this.isLineTerminator() ? (u.argument = null) : ((u.argument = this.parseExpression()), this.semicolon()),
            this.finishNode(u, 'ReturnStatement')
          );
        }
        parseSwitchStatement(u) {
          this.next(), (u.discriminant = this.parseHeaderExpression());
          let a = (u.cases = []);
          this.expect(5), this.state.labels.push(xd), this.scope.enter(0);
          let h;
          for (let d; !this.match(8); )
            if (this.match(61) || this.match(65)) {
              let D = this.match(61);
              h && this.finishNode(h, 'SwitchCase'),
                a.push((h = this.startNode())),
                (h.consequent = []),
                this.next(),
                D
                  ? (h.test = this.parseExpression())
                  : (d && this.raise(T.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }),
                    (d = !0),
                    (h.test = null)),
                this.expect(14);
            } else h ? h.consequent.push(this.parseStatementListItem()) : this.unexpected();
          return (
            this.scope.exit(),
            h && this.finishNode(h, 'SwitchCase'),
            this.next(),
            this.state.labels.pop(),
            this.finishNode(u, 'SwitchStatement')
          );
        }
        parseThrowStatement(u) {
          return (
            this.next(),
            this.hasPrecedingLineBreak() && this.raise(T.NewlineAfterThrow, { at: this.state.lastTokEndLoc }),
            (u.argument = this.parseExpression()),
            this.semicolon(),
            this.finishNode(u, 'ThrowStatement')
          );
        }
        parseCatchClauseParam() {
          let u = this.parseBindingAtom();
          return (
            this.scope.enter(this.options.annexB && u.type === 'Identifier' ? 8 : 0),
            this.checkLVal(u, { in: { type: 'CatchClause' }, binding: 9 }),
            u
          );
        }
        parseTryStatement(u) {
          if ((this.next(), (u.block = this.parseBlock()), (u.handler = null), this.match(62))) {
            let a = this.startNode();
            this.next(),
              this.match(10)
                ? (this.expect(10), (a.param = this.parseCatchClauseParam()), this.expect(11))
                : ((a.param = null), this.scope.enter(0)),
              (a.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))),
              this.scope.exit(),
              (u.handler = this.finishNode(a, 'CatchClause'));
          }
          return (
            (u.finalizer = this.eat(67) ? this.parseBlock() : null),
            !u.handler && !u.finalizer && this.raise(T.NoCatchOrFinally, { at: u }),
            this.finishNode(u, 'TryStatement')
          );
        }
        parseVarStatement(u, a, h = !1) {
          return this.next(), this.parseVar(u, !1, a, h), this.semicolon(), this.finishNode(u, 'VariableDeclaration');
        }
        parseWhileStatement(u) {
          return (
            this.next(),
            (u.test = this.parseHeaderExpression()),
            this.state.labels.push(va),
            (u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.state.labels.pop(),
            this.finishNode(u, 'WhileStatement')
          );
        }
        parseWithStatement(u) {
          return (
            this.state.strict && this.raise(T.StrictWith, { at: this.state.startLoc }),
            this.next(),
            (u.object = this.parseHeaderExpression()),
            (u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.finishNode(u, 'WithStatement')
          );
        }
        parseEmptyStatement(u) {
          return this.next(), this.finishNode(u, 'EmptyStatement');
        }
        parseLabeledStatement(u, a, h, d) {
          for (let A of this.state.labels) A.name === a && this.raise(T.LabelRedeclaration, { at: h, labelName: a });
          let D = Le(this.state.type) ? 'loop' : this.match(71) ? 'switch' : null;
          for (let A = this.state.labels.length - 1; A >= 0; A--) {
            let P = this.state.labels[A];
            if (P.statementStart === u.start) (P.statementStart = this.state.start), (P.kind = D);
            else break;
          }
          return (
            this.state.labels.push({ name: a, kind: D, statementStart: this.state.start }),
            (u.body = d & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement()),
            this.state.labels.pop(),
            (u.label = h),
            this.finishNode(u, 'LabeledStatement')
          );
        }
        parseExpressionStatement(u, a, h) {
          return (u.expression = a), this.semicolon(), this.finishNode(u, 'ExpressionStatement');
        }
        parseBlock(u = !1, a = !0, h) {
          let d = this.startNode();
          return (
            u && this.state.strictErrors.clear(),
            this.expect(5),
            a && this.scope.enter(0),
            this.parseBlockBody(d, u, !1, 8, h),
            a && this.scope.exit(),
            this.finishNode(d, 'BlockStatement')
          );
        }
        isValidDirective(u) {
          return (
            u.type === 'ExpressionStatement' &&
            u.expression.type === 'StringLiteral' &&
            !u.expression.extra.parenthesized
          );
        }
        parseBlockBody(u, a, h, d, D) {
          let A = (u.body = []),
            P = (u.directives = []);
          this.parseBlockOrModuleBlockBody(A, a ? P : void 0, h, d, D);
        }
        parseBlockOrModuleBlockBody(u, a, h, d, D) {
          let A = this.state.strict,
            P = !1,
            N = !1;
          for (; !this.match(d); ) {
            let R = h ? this.parseModuleItem() : this.parseStatementListItem();
            if (a && !N) {
              if (this.isValidDirective(R)) {
                let _ = this.stmtToDirective(R);
                a.push(_), !P && _.value.value === 'use strict' && ((P = !0), this.setStrict(!0));
                continue;
              }
              (N = !0), this.state.strictErrors.clear();
            }
            u.push(R);
          }
          D == null || D.call(this, P), A || this.setStrict(!1), this.next();
        }
        parseFor(u, a) {
          return (
            (u.init = a),
            this.semicolon(!1),
            (u.test = this.match(13) ? null : this.parseExpression()),
            this.semicolon(!1),
            (u.update = this.match(11) ? null : this.parseExpression()),
            this.expect(11),
            (u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(u, 'ForStatement')
          );
        }
        parseForIn(u, a, h) {
          let d = this.match(58);
          return (
            this.next(),
            d ? h !== null && this.unexpected(h) : (u.await = h !== null),
            a.type === 'VariableDeclaration' &&
              a.declarations[0].init != null &&
              (!d ||
                !this.options.annexB ||
                this.state.strict ||
                a.kind !== 'var' ||
                a.declarations[0].id.type !== 'Identifier') &&
              this.raise(T.ForInOfLoopInitializer, { at: a, type: d ? 'ForInStatement' : 'ForOfStatement' }),
            a.type === 'AssignmentPattern' && this.raise(T.InvalidLhs, { at: a, ancestor: { type: 'ForStatement' } }),
            (u.left = a),
            (u.right = d ? this.parseExpression() : this.parseMaybeAssignAllowIn()),
            this.expect(11),
            (u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(u, d ? 'ForInStatement' : 'ForOfStatement')
          );
        }
        parseVar(u, a, h, d = !1) {
          let D = (u.declarations = []);
          for (u.kind = h; ; ) {
            let A = this.startNode();
            if (
              (this.parseVarId(A, h),
              (A.init = this.eat(29) ? (a ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null),
              A.init === null &&
                !d &&
                (A.id.type !== 'Identifier' && !(a && (this.match(58) || this.isContextual(101)))
                  ? this.raise(T.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: 'destructuring' })
                  : h === 'const' &&
                    !(this.match(58) || this.isContextual(101)) &&
                    this.raise(T.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: 'const' })),
              D.push(this.finishNode(A, 'VariableDeclarator')),
              !this.eat(12))
            )
              break;
          }
          return u;
        }
        parseVarId(u, a) {
          let h = this.parseBindingAtom();
          this.checkLVal(h, { in: { type: 'VariableDeclarator' }, binding: a === 'var' ? 5 : 8201 }), (u.id = h);
        }
        parseAsyncFunctionExpression(u) {
          return this.parseFunction(u, 8);
        }
        parseFunction(u, a = 0) {
          let h = a & 2,
            d = !!(a & 1),
            D = d && !(a & 4),
            A = !!(a & 8);
          this.initFunction(u, A),
            this.match(55) &&
              (h && this.raise(T.GeneratorInSingleStatementContext, { at: this.state.startLoc }),
              this.next(),
              (u.generator = !0)),
            d && (u.id = this.parseFunctionId(D));
          let P = this.state.maybeInArrowParameters;
          return (
            (this.state.maybeInArrowParameters = !1),
            this.scope.enter(2),
            this.prodParam.enter(Eo(A, u.generator)),
            d || (u.id = this.parseFunctionId()),
            this.parseFunctionParams(u, !1),
            this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(u, d ? 'FunctionDeclaration' : 'FunctionExpression');
            }),
            this.prodParam.exit(),
            this.scope.exit(),
            d && !h && this.registerFunctionStatementId(u),
            (this.state.maybeInArrowParameters = P),
            u
          );
        }
        parseFunctionId(u) {
          return u || fe(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(u, a) {
          this.expect(10),
            this.expressionScope.enter(ed()),
            (u.params = this.parseBindingList(11, 41, 2 | (a ? 4 : 0))),
            this.expressionScope.exit();
        }
        registerFunctionStatementId(u) {
          u.id &&
            this.scope.declareName(
              u.id.name,
              !this.options.annexB || this.state.strict || u.generator || u.async
                ? this.scope.treatFunctionsAsVar
                  ? 5
                  : 8201
                : 17,
              u.id.loc.start,
            );
        }
        parseClass(u, a, h) {
          this.next();
          let d = this.state.strict;
          return (
            (this.state.strict = !0),
            this.parseClassId(u, a, h),
            this.parseClassSuper(u),
            (u.body = this.parseClassBody(!!u.superClass, d)),
            this.finishNode(u, a ? 'ClassDeclaration' : 'ClassExpression')
          );
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(u) {
          return !u.computed && !u.static && (u.key.name === 'constructor' || u.key.value === 'constructor');
        }
        parseClassBody(u, a) {
          this.classScope.enter();
          let h = { hadConstructor: !1, hadSuperClass: u },
            d = [],
            D = this.startNode();
          if (
            ((D.body = []),
            this.expect(5),
            this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (d.length > 0) throw this.raise(T.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                  continue;
                }
                if (this.match(26)) {
                  d.push(this.parseDecorator());
                  continue;
                }
                let A = this.startNode();
                d.length && ((A.decorators = d), this.resetStartLocationFromNode(A, d[0]), (d = [])),
                  this.parseClassMember(D, A, h),
                  A.kind === 'constructor' &&
                    A.decorators &&
                    A.decorators.length > 0 &&
                    this.raise(T.DecoratorConstructor, { at: A });
              }
            }),
            (this.state.strict = a),
            this.next(),
            d.length)
          )
            throw this.raise(T.TrailingDecorator, { at: this.state.startLoc });
          return this.classScope.exit(), this.finishNode(D, 'ClassBody');
        }
        parseClassMemberFromModifier(u, a) {
          let h = this.parseIdentifier(!0);
          if (this.isClassMethod()) {
            let d = a;
            return (
              (d.kind = 'method'),
              (d.computed = !1),
              (d.key = h),
              (d.static = !1),
              this.pushClassMethod(u, d, !1, !1, !1, !1),
              !0
            );
          } else if (this.isClassProperty()) {
            let d = a;
            return (d.computed = !1), (d.key = h), (d.static = !1), u.body.push(this.parseClassProperty(d)), !0;
          }
          return this.resetPreviousNodeTrailingComments(h), !1;
        }
        parseClassMember(u, a, h) {
          let d = this.isContextual(104);
          if (d) {
            if (this.parseClassMemberFromModifier(u, a)) return;
            if (this.eat(5)) {
              this.parseClassStaticBlock(u, a);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(u, a, h, d);
        }
        parseClassMemberWithIsStatic(u, a, h, d) {
          let D = a,
            A = a,
            P = a,
            N = a,
            R = a,
            _ = D,
            ue = D;
          if (((a.static = d), this.parsePropertyNamePrefixOperator(a), this.eat(55))) {
            _.kind = 'method';
            let wt = this.match(136);
            if ((this.parseClassElementName(_), wt)) {
              this.pushClassPrivateMethod(u, A, !0, !1);
              return;
            }
            this.isNonstaticConstructor(D) && this.raise(T.ConstructorIsGenerator, { at: D.key }),
              this.pushClassMethod(u, D, !0, !1, !1, !1);
            return;
          }
          let ve = fe(this.state.type) && !this.state.containsEsc,
            Ie = this.match(136),
            _e = this.parseClassElementName(a),
            Bt = this.state.startLoc;
          if ((this.parsePostMemberNameModifiers(ue), this.isClassMethod())) {
            if (((_.kind = 'method'), Ie)) {
              this.pushClassPrivateMethod(u, A, !1, !1);
              return;
            }
            let wt = this.isNonstaticConstructor(D),
              ur = !1;
            wt &&
              ((D.kind = 'constructor'),
              h.hadConstructor && !this.hasPlugin('typescript') && this.raise(T.DuplicateConstructor, { at: _e }),
              wt && this.hasPlugin('typescript') && a.override && this.raise(T.OverrideOnConstructor, { at: _e }),
              (h.hadConstructor = !0),
              (ur = h.hadSuperClass)),
              this.pushClassMethod(u, D, !1, !1, wt, ur);
          } else if (this.isClassProperty()) Ie ? this.pushClassPrivateProperty(u, N) : this.pushClassProperty(u, P);
          else if (ve && _e.name === 'async' && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(_e);
            let wt = this.eat(55);
            ue.optional && this.unexpected(Bt), (_.kind = 'method');
            let ur = this.match(136);
            this.parseClassElementName(_),
              this.parsePostMemberNameModifiers(ue),
              ur
                ? this.pushClassPrivateMethod(u, A, wt, !0)
                : (this.isNonstaticConstructor(D) && this.raise(T.ConstructorIsAsync, { at: D.key }),
                  this.pushClassMethod(u, D, wt, !0, !1, !1));
          } else if (ve && (_e.name === 'get' || _e.name === 'set') && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(_e), (_.kind = _e.name);
            let wt = this.match(136);
            this.parseClassElementName(D),
              wt
                ? this.pushClassPrivateMethod(u, A, !1, !1)
                : (this.isNonstaticConstructor(D) && this.raise(T.ConstructorIsAccessor, { at: D.key }),
                  this.pushClassMethod(u, D, !1, !1, !1, !1)),
              this.checkGetterSetterParams(D);
          } else if (ve && _e.name === 'accessor' && !this.isLineTerminator()) {
            this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(_e);
            let wt = this.match(136);
            this.parseClassElementName(P), this.pushClassAccessorProperty(u, R, wt);
          } else
            this.isLineTerminator()
              ? Ie
                ? this.pushClassPrivateProperty(u, N)
                : this.pushClassProperty(u, P)
              : this.unexpected();
        }
        parseClassElementName(u) {
          let { type: a, value: h } = this.state;
          if (
            ((a === 130 || a === 131) &&
              u.static &&
              h === 'prototype' &&
              this.raise(T.StaticPrototype, { at: this.state.startLoc }),
            a === 136)
          ) {
            h === 'constructor' && this.raise(T.ConstructorClassPrivateField, { at: this.state.startLoc });
            let d = this.parsePrivateName();
            return (u.key = d), d;
          }
          return this.parsePropertyName(u);
        }
        parseClassStaticBlock(u, a) {
          var h;
          this.scope.enter(208);
          let d = this.state.labels;
          (this.state.labels = []), this.prodParam.enter(Cs);
          let D = (a.body = []);
          this.parseBlockOrModuleBlockBody(D, void 0, !1, 8),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.labels = d),
            u.body.push(this.finishNode(a, 'StaticBlock')),
            (h = a.decorators) != null && h.length && this.raise(T.DecoratorStaticBlock, { at: a });
        }
        pushClassProperty(u, a) {
          !a.computed &&
            (a.key.name === 'constructor' || a.key.value === 'constructor') &&
            this.raise(T.ConstructorClassField, { at: a.key }),
            u.body.push(this.parseClassProperty(a));
        }
        pushClassPrivateProperty(u, a) {
          let h = this.parseClassPrivateProperty(a);
          u.body.push(h), this.classScope.declarePrivateName(this.getPrivateNameSV(h.key), 0, h.key.loc.start);
        }
        pushClassAccessorProperty(u, a, h) {
          if (!h && !a.computed) {
            let D = a.key;
            (D.name === 'constructor' || D.value === 'constructor') && this.raise(T.ConstructorClassField, { at: D });
          }
          let d = this.parseClassAccessorProperty(a);
          u.body.push(d), h && this.classScope.declarePrivateName(this.getPrivateNameSV(d.key), 0, d.key.loc.start);
        }
        pushClassMethod(u, a, h, d, D, A) {
          u.body.push(this.parseMethod(a, h, d, D, A, 'ClassMethod', !0));
        }
        pushClassPrivateMethod(u, a, h, d) {
          let D = this.parseMethod(a, h, d, !1, !1, 'ClassPrivateMethod', !0);
          u.body.push(D);
          let A = D.kind === 'get' ? (D.static ? 6 : 2) : D.kind === 'set' ? (D.static ? 5 : 1) : 0;
          this.declareClassPrivateMethodInScope(D, A);
        }
        declareClassPrivateMethodInScope(u, a) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(u.key), a, u.key.loc.start);
        }
        parsePostMemberNameModifiers(u) {}
        parseClassPrivateProperty(u) {
          return this.parseInitializer(u), this.semicolon(), this.finishNode(u, 'ClassPrivateProperty');
        }
        parseClassProperty(u) {
          return this.parseInitializer(u), this.semicolon(), this.finishNode(u, 'ClassProperty');
        }
        parseClassAccessorProperty(u) {
          return this.parseInitializer(u), this.semicolon(), this.finishNode(u, 'ClassAccessorProperty');
        }
        parseInitializer(u) {
          this.scope.enter(80),
            this.expressionScope.enter(Ic()),
            this.prodParam.enter(Cs),
            (u.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null),
            this.expressionScope.exit(),
            this.prodParam.exit(),
            this.scope.exit();
        }
        parseClassId(u, a, h, d = 8331) {
          if (fe(this.state.type)) (u.id = this.parseIdentifier()), a && this.declareNameFromIdentifier(u.id, d);
          else if (h || !a) u.id = null;
          else throw this.raise(T.MissingClassName, { at: this.state.startLoc });
        }
        parseClassSuper(u) {
          u.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(u, a) {
          let h = this.parseMaybeImportPhase(u, !0),
            d = this.maybeParseExportDefaultSpecifier(u, h),
            D = !d || this.eat(12),
            A = D && this.eatExportStar(u),
            P = A && this.maybeParseExportNamespaceSpecifier(u),
            N = D && (!P || this.eat(12)),
            R = d || A;
          if (A && !P) {
            if ((d && this.unexpected(), a)) throw this.raise(T.UnsupportedDecoratorExport, { at: u });
            return this.parseExportFrom(u, !0), this.finishNode(u, 'ExportAllDeclaration');
          }
          let _ = this.maybeParseExportNamedSpecifiers(u);
          d && D && !A && !_ && this.unexpected(null, 5), P && N && this.unexpected(null, 97);
          let ue;
          if (R || _) {
            if (((ue = !1), a)) throw this.raise(T.UnsupportedDecoratorExport, { at: u });
            this.parseExportFrom(u, R);
          } else ue = this.maybeParseExportDeclaration(u);
          if (R || _ || ue) {
            var ve;
            let Ie = u;
            if (
              (this.checkExport(Ie, !0, !1, !!Ie.source),
              ((ve = Ie.declaration) == null ? void 0 : ve.type) === 'ClassDeclaration')
            )
              this.maybeTakeDecorators(a, Ie.declaration, Ie);
            else if (a) throw this.raise(T.UnsupportedDecoratorExport, { at: u });
            return this.finishNode(Ie, 'ExportNamedDeclaration');
          }
          if (this.eat(65)) {
            let Ie = u,
              _e = this.parseExportDefaultExpression();
            if (((Ie.declaration = _e), _e.type === 'ClassDeclaration')) this.maybeTakeDecorators(a, _e, Ie);
            else if (a) throw this.raise(T.UnsupportedDecoratorExport, { at: u });
            return this.checkExport(Ie, !0, !0), this.finishNode(Ie, 'ExportDefaultDeclaration');
          }
          this.unexpected(null, 5);
        }
        eatExportStar(u) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(u, a) {
          if (a || this.isExportDefaultSpecifier()) {
            this.expectPlugin('exportDefaultFrom', a == null ? void 0 : a.loc.start);
            let h = a || this.parseIdentifier(!0),
              d = this.startNodeAtNode(h);
            return (d.exported = h), (u.specifiers = [this.finishNode(d, 'ExportDefaultSpecifier')]), !0;
          }
          return !1;
        }
        maybeParseExportNamespaceSpecifier(u) {
          if (this.isContextual(93)) {
            u.specifiers || (u.specifiers = []);
            let a = this.startNodeAt(this.state.lastTokStartLoc);
            return (
              this.next(),
              (a.exported = this.parseModuleExportName()),
              u.specifiers.push(this.finishNode(a, 'ExportNamespaceSpecifier')),
              !0
            );
          }
          return !1;
        }
        maybeParseExportNamedSpecifiers(u) {
          if (this.match(5)) {
            u.specifiers || (u.specifiers = []);
            let a = u.exportKind === 'type';
            return (
              u.specifiers.push(...this.parseExportSpecifiers(a)),
              (u.source = null),
              (u.declaration = null),
              this.hasPlugin('importAssertions') && (u.assertions = []),
              !0
            );
          }
          return !1;
        }
        maybeParseExportDeclaration(u) {
          return this.shouldParseExportDeclaration()
            ? ((u.specifiers = []),
              (u.source = null),
              this.hasPlugin('importAssertions') && (u.assertions = []),
              (u.declaration = this.parseExportDeclaration(u)),
              !0)
            : !1;
        }
        isAsyncFunction() {
          if (!this.isContextual(95)) return !1;
          let u = this.nextTokenInLineStart();
          return this.isUnparsedContextual(u, 'function');
        }
        parseExportDefaultExpression() {
          let u = this.startNode();
          if (this.match(68)) return this.next(), this.parseFunction(u, 5);
          if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(u, 13);
          if (this.match(80)) return this.parseClass(u, !0, !0);
          if (this.match(26))
            return (
              this.hasPlugin('decorators') &&
                this.getPluginOption('decorators', 'decoratorsBeforeExport') === !0 &&
                this.raise(T.DecoratorBeforeExport, { at: this.state.startLoc }),
              this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0)
            );
          if (this.match(75) || this.match(74) || this.isLet())
            throw this.raise(T.UnsupportedDefaultExport, { at: this.state.startLoc });
          let a = this.parseMaybeAssignAllowIn();
          return this.semicolon(), a;
        }
        parseExportDeclaration(u) {
          return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
        }
        isExportDefaultSpecifier() {
          let { type: u } = this.state;
          if (fe(u)) {
            if ((u === 95 && !this.state.containsEsc) || u === 99) return !1;
            if ((u === 128 || u === 127) && !this.state.containsEsc) {
              let { type: d } = this.lookahead();
              if ((fe(d) && d !== 97) || d === 5) return this.expectOnePlugin(['flow', 'typescript']), !1;
            }
          } else if (!this.match(65)) return !1;
          let a = this.nextTokenStart(),
            h = this.isUnparsedContextual(a, 'from');
          if (this.input.charCodeAt(a) === 44 || (fe(this.state.type) && h)) return !0;
          if (this.match(65) && h) {
            let d = this.input.charCodeAt(this.nextTokenStartSince(a + 4));
            return d === 34 || d === 39;
          }
          return !1;
        }
        parseExportFrom(u, a) {
          this.eatContextual(97)
            ? ((u.source = this.parseImportSource()),
              this.checkExport(u),
              this.maybeParseImportAttributes(u),
              this.checkJSONModuleImport(u))
            : a && this.unexpected(),
            this.semicolon();
        }
        shouldParseExportDeclaration() {
          let { type: u } = this.state;
          return u === 26 && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators'))
            ? (this.getPluginOption('decorators', 'decoratorsBeforeExport') === !0 &&
                this.raise(T.DecoratorBeforeExport, { at: this.state.startLoc }),
              !0)
            : u === 74 || u === 75 || u === 68 || u === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(u, a, h, d) {
          if (a) {
            var D;
            if (h) {
              if ((this.checkDuplicateExports(u, 'default'), this.hasPlugin('exportDefaultFrom'))) {
                var A;
                let P = u.declaration;
                P.type === 'Identifier' &&
                  P.name === 'from' &&
                  P.end - P.start === 4 &&
                  !((A = P.extra) != null && A.parenthesized) &&
                  this.raise(T.ExportDefaultFromAsIdentifier, { at: P });
              }
            } else if ((D = u.specifiers) != null && D.length)
              for (let P of u.specifiers) {
                let { exported: N } = P,
                  R = N.type === 'Identifier' ? N.name : N.value;
                if ((this.checkDuplicateExports(P, R), !d && P.local)) {
                  let { local: _ } = P;
                  _.type !== 'Identifier'
                    ? this.raise(T.ExportBindingIsString, { at: P, localName: _.value, exportName: R })
                    : (this.checkReservedWord(_.name, _.loc.start, !0, !1), this.scope.checkLocalExport(_));
                }
              }
            else if (u.declaration) {
              if (u.declaration.type === 'FunctionDeclaration' || u.declaration.type === 'ClassDeclaration') {
                let P = u.declaration.id;
                if (!P) throw new Error('Assertion failure');
                this.checkDuplicateExports(u, P.name);
              } else if (u.declaration.type === 'VariableDeclaration')
                for (let P of u.declaration.declarations) this.checkDeclaration(P.id);
            }
          }
        }
        checkDeclaration(u) {
          if (u.type === 'Identifier') this.checkDuplicateExports(u, u.name);
          else if (u.type === 'ObjectPattern') for (let a of u.properties) this.checkDeclaration(a);
          else if (u.type === 'ArrayPattern') for (let a of u.elements) a && this.checkDeclaration(a);
          else
            u.type === 'ObjectProperty'
              ? this.checkDeclaration(u.value)
              : u.type === 'RestElement'
              ? this.checkDeclaration(u.argument)
              : u.type === 'AssignmentPattern' && this.checkDeclaration(u.left);
        }
        checkDuplicateExports(u, a) {
          this.exportedIdentifiers.has(a) &&
            (a === 'default'
              ? this.raise(T.DuplicateDefaultExport, { at: u })
              : this.raise(T.DuplicateExport, { at: u, exportName: a })),
            this.exportedIdentifiers.add(a);
        }
        parseExportSpecifiers(u) {
          let a = [],
            h = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (h) h = !1;
            else if ((this.expect(12), this.eat(8))) break;
            let d = this.isContextual(128),
              D = this.match(131),
              A = this.startNode();
            (A.local = this.parseModuleExportName()), a.push(this.parseExportSpecifier(A, D, u, d));
          }
          return a;
        }
        parseExportSpecifier(u, a, h, d) {
          return (
            this.eatContextual(93)
              ? (u.exported = this.parseModuleExportName())
              : a
              ? (u.exported = Oc(u.local))
              : u.exported || (u.exported = Qn(u.local)),
            this.finishNode(u, 'ExportSpecifier')
          );
        }
        parseModuleExportName() {
          if (this.match(131)) {
            let u = this.parseStringLiteral(this.state.value),
              a = u.value.match(Qc);
            return (
              a && this.raise(T.ModuleExportNameHasLoneSurrogate, { at: u, surrogateCharCode: a[0].charCodeAt(0) }), u
            );
          }
          return this.parseIdentifier(!0);
        }
        isJSONModuleImport(u) {
          return u.assertions != null
            ? u.assertions.some(
                ({ key: a, value: h }) =>
                  h.value === 'json' && (a.type === 'Identifier' ? a.name === 'type' : a.value === 'type'),
              )
            : !1;
        }
        checkImportReflection(u) {
          if (u.module) {
            var a;
            (u.specifiers.length !== 1 || u.specifiers[0].type !== 'ImportDefaultSpecifier') &&
              this.raise(T.ImportReflectionNotBinding, { at: u.specifiers[0].loc.start }),
              ((a = u.assertions) == null ? void 0 : a.length) > 0 &&
                this.raise(T.ImportReflectionHasAssertion, { at: u.specifiers[0].loc.start });
          }
        }
        checkJSONModuleImport(u) {
          if (this.isJSONModuleImport(u) && u.type !== 'ExportAllDeclaration') {
            let { specifiers: a } = u;
            if (a != null) {
              let h = a.find((d) => {
                let D;
                if (
                  (d.type === 'ExportSpecifier' ? (D = d.local) : d.type === 'ImportSpecifier' && (D = d.imported),
                  D !== void 0)
                )
                  return D.type === 'Identifier' ? D.name !== 'default' : D.value !== 'default';
              });
              h !== void 0 && this.raise(T.ImportJSONBindingNotDefault, { at: h.loc.start });
            }
          }
        }
        isPotentialImportPhase(u) {
          return !u && this.isContextual(125);
        }
        applyImportPhase(u, a, h, d) {
          a ||
            (h === 'module'
              ? (this.expectPlugin('importReflection', d), (u.module = !0))
              : this.hasPlugin('importReflection') && (u.module = !1));
        }
        parseMaybeImportPhase(u, a) {
          if (!this.isPotentialImportPhase(a)) return this.applyImportPhase(u, a, null), null;
          let h = this.parseIdentifier(!0),
            { type: d } = this.state;
          return (M(d) ? d !== 97 || this.lookaheadCharCode() === 102 : d !== 12)
            ? (this.resetPreviousIdentifierLeadingComments(h), this.applyImportPhase(u, a, h.name, h.loc.start), null)
            : (this.applyImportPhase(u, a, null), h);
        }
        isPrecedingIdImportPhase(u) {
          let { type: a } = this.state;
          return fe(a) ? a !== 97 || this.lookaheadCharCode() === 102 : a !== 12;
        }
        parseImport(u) {
          return this.match(131)
            ? this.parseImportSourceAndAttributes(u)
            : this.parseImportSpecifiersAndAfter(u, this.parseMaybeImportPhase(u, !1));
        }
        parseImportSpecifiersAndAfter(u, a) {
          u.specifiers = [];
          let h = !this.maybeParseDefaultImportSpecifier(u, a) || this.eat(12),
            d = h && this.maybeParseStarImportSpecifier(u);
          return (
            h && !d && this.parseNamedImportSpecifiers(u),
            this.expectContextual(97),
            this.parseImportSourceAndAttributes(u)
          );
        }
        parseImportSourceAndAttributes(u) {
          return (
            u.specifiers != null || (u.specifiers = []),
            (u.source = this.parseImportSource()),
            this.maybeParseImportAttributes(u),
            this.checkImportReflection(u),
            this.checkJSONModuleImport(u),
            this.semicolon(),
            this.finishNode(u, 'ImportDeclaration')
          );
        }
        parseImportSource() {
          return this.match(131) || this.unexpected(), this.parseExprAtom();
        }
        parseImportSpecifierLocal(u, a, h) {
          (a.local = this.parseIdentifier()), u.specifiers.push(this.finishImportSpecifier(a, h));
        }
        finishImportSpecifier(u, a, h = 8201) {
          return this.checkLVal(u.local, { in: { type: a }, binding: h }), this.finishNode(u, a);
        }
        parseImportAttributes() {
          this.expect(5);
          let u = [],
            a = new Set();
          do {
            if (this.match(8)) break;
            let h = this.startNode(),
              d = this.state.value;
            if (
              (a.has(d) && this.raise(T.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: d }),
              a.add(d),
              this.match(131) ? (h.key = this.parseStringLiteral(d)) : (h.key = this.parseIdentifier(!0)),
              this.expect(14),
              !this.match(131))
            )
              throw this.raise(T.ModuleAttributeInvalidValue, { at: this.state.startLoc });
            (h.value = this.parseStringLiteral(this.state.value)), u.push(this.finishNode(h, 'ImportAttribute'));
          } while (this.eat(12));
          return this.expect(8), u;
        }
        parseModuleAttributes() {
          let u = [],
            a = new Set();
          do {
            let h = this.startNode();
            if (
              ((h.key = this.parseIdentifier(!0)),
              h.key.name !== 'type' && this.raise(T.ModuleAttributeDifferentFromType, { at: h.key }),
              a.has(h.key.name) && this.raise(T.ModuleAttributesWithDuplicateKeys, { at: h.key, key: h.key.name }),
              a.add(h.key.name),
              this.expect(14),
              !this.match(131))
            )
              throw this.raise(T.ModuleAttributeInvalidValue, { at: this.state.startLoc });
            (h.value = this.parseStringLiteral(this.state.value)), u.push(this.finishNode(h, 'ImportAttribute'));
          } while (this.eat(12));
          return u;
        }
        maybeParseImportAttributes(u) {
          let a,
            h = !1;
          if (this.match(76)) {
            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
            this.next(),
              this.hasPlugin('moduleAttributes')
                ? (a = this.parseModuleAttributes())
                : (this.expectImportAttributesPlugin(), (a = this.parseImportAttributes())),
              (h = !0);
          } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
            this.hasPlugin('importAttributes')
              ? (this.getPluginOption('importAttributes', 'deprecatedAssertSyntax') !== !0 &&
                  this.raise(T.ImportAttributesUseAssert, { at: this.state.startLoc }),
                this.addExtra(u, 'deprecatedAssertSyntax', !0))
              : this.expectOnePlugin(['importAttributes', 'importAssertions']),
              this.next(),
              (a = this.parseImportAttributes());
          else if (this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions')) a = [];
          else if (this.hasPlugin('moduleAttributes')) a = [];
          else return;
          !h && this.hasPlugin('importAssertions') ? (u.assertions = a) : (u.attributes = a);
        }
        maybeParseDefaultImportSpecifier(u, a) {
          if (a) {
            let h = this.startNodeAtNode(a);
            return (h.local = a), u.specifiers.push(this.finishImportSpecifier(h, 'ImportDefaultSpecifier')), !0;
          } else if (M(this.state.type))
            return this.parseImportSpecifierLocal(u, this.startNode(), 'ImportDefaultSpecifier'), !0;
          return !1;
        }
        maybeParseStarImportSpecifier(u) {
          if (this.match(55)) {
            let a = this.startNode();
            return (
              this.next(),
              this.expectContextual(93),
              this.parseImportSpecifierLocal(u, a, 'ImportNamespaceSpecifier'),
              !0
            );
          }
          return !1;
        }
        parseNamedImportSpecifiers(u) {
          let a = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (a) a = !1;
            else {
              if (this.eat(14)) throw this.raise(T.DestructureNamedImport, { at: this.state.startLoc });
              if ((this.expect(12), this.eat(8))) break;
            }
            let h = this.startNode(),
              d = this.match(131),
              D = this.isContextual(128);
            h.imported = this.parseModuleExportName();
            let A = this.parseImportSpecifier(h, d, u.importKind === 'type' || u.importKind === 'typeof', D, void 0);
            u.specifiers.push(A);
          }
        }
        parseImportSpecifier(u, a, h, d, D) {
          if (this.eatContextual(93)) u.local = this.parseIdentifier();
          else {
            let { imported: A } = u;
            if (a) throw this.raise(T.ImportBindingIsString, { at: u, importName: A.value });
            this.checkReservedWord(A.name, u.loc.start, !0, !0), u.local || (u.local = Qn(A));
          }
          return this.finishImportSpecifier(u, 'ImportSpecifier', D);
        }
        isThisParam(u) {
          return u.type === 'Identifier' && u.name === 'this';
        }
      },
      eh = class extends Zc {
        constructor(u, a) {
          (u = yd(u)),
            super(u, a),
            (this.options = u),
            this.initializeScopes(),
            (this.plugins = Fs(this.options.plugins)),
            (this.filename = u.sourceFilename);
        }
        getScopeHandler() {
          return Ol;
        }
        parse() {
          this.enterInitialScopes();
          let u = this.startNode(),
            a = this.startNode();
          return this.nextToken(), (u.errors = null), this.parseTopLevel(u, a), (u.errors = this.state.errors), u;
        }
      };
    function Fs(u) {
      let a = new Map();
      for (let h of u) {
        let [d, D] = Array.isArray(h) ? h : [h, {}];
        a.has(d) || a.set(d, D || {});
      }
      return a;
    }
    function th(u, a) {
      var h;
      if (((h = a) == null ? void 0 : h.sourceType) === 'unambiguous') {
        a = Object.assign({}, a);
        try {
          a.sourceType = 'module';
          let d = Fo(a, u),
            D = d.parse();
          if (d.sawUnambiguousESM) return D;
          if (d.ambiguousScriptDifferentAst)
            try {
              return (a.sourceType = 'script'), Fo(a, u).parse();
            } catch {}
          else D.program.sourceType = 'script';
          return D;
        } catch (d) {
          try {
            return (a.sourceType = 'script'), Fo(a, u).parse();
          } catch {}
          throw d;
        }
      } else return Fo(a, u).parse();
    }
    function bd(u, a) {
      let h = Fo(a, u);
      return h.options.strictMode && (h.state.strict = !0), h.getExpression();
    }
    function Ad(u) {
      let a = {};
      for (let h of Object.keys(u)) a[h] = Pt(u[h]);
      return a;
    }
    var Sa = Ad(Te);
    function Fo(u, a) {
      let h = eh;
      return u != null && u.plugins && (md(u.plugins), (h = Ed(u.plugins))), new h(u, a);
    }
    var rh = {};
    function Ed(u) {
      let a = gd.filter((D) => sr(u, D)),
        h = a.join('/'),
        d = rh[h];
      if (!d) {
        d = eh;
        for (let D of a) d = Ea[D](d);
        rh[h] = d;
      }
      return d;
    }
    (t.parse = th), (t.parseExpression = bd), (t.tokTypes = Sa);
  }),
  b7 = Nv((t) => {
    Object.defineProperty(t, '__esModule', { value: !0 }),
      (t.extract = f),
      (t.parse = g),
      (t.parseWithComments = x),
      (t.print = b),
      (t.strip = m);
    var e = /\*\/$/,
      r = /^\/\*\*?/,
      n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      i = /(^|\s+)\/\/([^\r\n]*)/g,
      s = /^(\r?\n)+/,
      o = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      c = /(\r?\n|^) *\* ?/g,
      p = [];
    function f(E) {
      let w = E.match(n);
      return w ? w[0].trimLeft() : '';
    }
    function m(E) {
      let w = E.match(n);
      return w && w[0] ? E.substring(w[0].length) : E;
    }
    function g(E) {
      return x(E).pragmas;
    }
    function x(E) {
      let w = `
`;
      E = E.replace(r, '').replace(e, '').replace(c, '$1');
      let I = '';
      for (; I !== E; ) (I = E), (E = E.replace(o, `${w}$1 $2${w}`));
      E = E.replace(s, '').trimRight();
      let T = Object.create(null),
        j = E.replace(l, '').replace(s, '').trimRight(),
        $;
      for (; ($ = l.exec(E)); ) {
        let L = $[2].replace(i, '');
        typeof T[$[1]] == 'string' || Array.isArray(T[$[1]]) ? (T[$[1]] = p.concat(T[$[1]], L)) : (T[$[1]] = L);
      }
      return { comments: j, pragmas: T };
    }
    function b({ comments: E = '', pragmas: w = {} }) {
      let I = `
`,
        T = '/**',
        j = ' *',
        $ = ' */',
        L = Object.keys(w),
        se = L.map((W) => F(W, w[W]))
          .reduce((W, X) => W.concat(X), [])
          .map((W) => `${j} ${W}${I}`)
          .join('');
      if (!E) {
        if (L.length === 0) return '';
        if (L.length === 1 && !Array.isArray(w[L[0]])) {
          let W = w[L[0]];
          return `${T} ${F(L[0], W)[0]}${$}`;
        }
      }
      let Y =
        E.split(I)
          .map((W) => `${j} ${W}`)
          .join(I) + I;
      return T + I + (E ? Y : '') + (E && L.length ? j + I : '') + se + $;
    }
    function F(E, w) {
      return p.concat(w).map((I) => `@${E} ${I}`.trim());
    }
  }),
  Lv = {};
x7(Lv, { parsers: () => D5 });
var gC = Cy(Mv(), 1);
function A7(t) {
  let e = [];
  for (let r of t)
    try {
      return r();
    } catch (n) {
      e.push(n);
    }
  throw Object.assign(new Error('All combinations failed'), { errors: e });
}
var E7 = A7;
function v7(t) {
  if (!t.startsWith('#!')) return '';
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var _v = v7;
function F7(t, e) {
  if (e === !1) return !1;
  if (t.charAt(e) === '/' && t.charAt(e + 1) === '*') {
    for (let r = e + 2; r < t.length; ++r) if (t.charAt(r) === '*' && t.charAt(r + 1) === '/') return r + 2;
  }
  return e;
}
var S7 = F7;
function w7(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1) return !1;
  let i = t.charAt(e);
  if (n) {
    if (
      t.charAt(e - 1) === '\r' &&
      i ===
        `
`
    )
      return e - 2;
    if (
      i ===
        `
` ||
      i === '\r' ||
      i === '\u2028' ||
      i === '\u2029'
    )
      return e - 1;
  } else {
    if (
      i === '\r' &&
      t.charAt(e + 1) ===
        `
`
    )
      return e + 2;
    if (
      i ===
        `
` ||
      i === '\r' ||
      i === '\u2028' ||
      i === '\u2029'
    )
      return e + 1;
  }
  return e;
}
var T7 = w7;
function Rv(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1) return !1;
    let { length: s } = e,
      o = r;
    for (; o >= 0 && o < s; ) {
      let l = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(l)) return o;
      } else if (!t.includes(l)) return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var k7 = Rv(' 	'),
  P7 = Rv(/[^\n\r]/);
function B7(t, e) {
  return e === !1 ? !1 : t.charAt(e) === '/' && t.charAt(e + 1) === '/' ? P7(t, e) : e;
}
var I7 = B7;
function N7(t, e) {
  let r = null,
    n = e;
  for (; n !== r; ) (r = n), (n = k7(t, n)), (n = S7(t, n)), (n = I7(t, n)), (n = T7(t, n));
  return n;
}
var M7 = N7,
  yC = Cy(b7(), 1);
function O7(t) {
  let e = _v(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, yC.extract)(t),
    { pragmas: n, comments: i } = (0, yC.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function L7(t) {
  let { pragmas: e } = O7(t);
  return Object.prototype.hasOwnProperty.call(e, 'prettier') || Object.prototype.hasOwnProperty.call(e, 'format');
}
function _7(t) {
  return Array.isArray(t) && t.length > 0;
}
var Mf = _7;
function ti(t) {
  var e;
  let r = t.range ? t.range[0] : t.start,
    n = ((e = t.declaration) == null ? void 0 : e.decorators) ?? t.decorators;
  return Mf(n) ? Math.min(ti(n[0]), r) : r;
}
function js(t) {
  return t.range ? t.range[1] : t.end;
}
function R7(t) {
  return (
    (t = typeof t == 'function' ? { parse: t } : t),
    { astFormat: 'estree', hasPragma: L7, locStart: ti, locEnd: js, ...t }
  );
}
var rp = R7;
function j7(t, e) {
  let r = new SyntaxError(t + ' (' + e.loc.start.line + ':' + e.loc.start.column + ')');
  return Object.assign(r, e);
}
var jv = j7;
function $7(t) {
  let { message: e, loc: r } = t;
  return jv(e.replace(/ \(.*\)$/, ''), {
    loc: { start: { line: r ? r.line : 0, column: r ? r.column + 1 : 0 } },
    cause: t,
  });
}
var G0 = $7,
  V7 = (t, e, r) => {
    if (!(t && e == null)) return Array.isArray(e) || typeof e == 'string' ? e[r < 0 ? e.length + r : r] : e.at(r);
  },
  DC = V7;
function z7(t) {
  return (t = new Set(t)), (e) => t.has(e == null ? void 0 : e.type);
}
var H7 = z7,
  W7 = H7(['Block', 'CommentBlock', 'MultiLine']),
  Y0 = W7;
function U7(t) {
  return Y0(t) && t.value[0] === '*' && /@(?:type|satisfies)\b/.test(t.value);
}
var q7 = U7;
function K7(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === '*');
}
var xC = K7,
  iu = null;
function Su(t) {
  if (iu !== null && typeof iu.property) {
    let e = iu;
    return (iu = Su.prototype = null), e;
  }
  return (iu = Su.prototype = t ?? Object.create(null)), new Su();
}
var J7 = 10;
for (let t = 0; t <= J7; t++) Su();
function X7(t) {
  return Su(t);
}
function G7(t, e = 'type') {
  X7(t);
  function r(n) {
    let i = n[e],
      s = t[i];
    if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var Y7 = G7,
  Q7 = {
    ArrayExpression: ['elements'],
    AssignmentExpression: ['left', 'right'],
    BinaryExpression: ['left', 'right'],
    InterpreterDirective: [],
    Directive: ['value'],
    DirectiveLiteral: [],
    BlockStatement: ['directives', 'body'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    CatchClause: ['param', 'body'],
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DoWhileStatement: ['test', 'body'],
    EmptyStatement: [],
    ExpressionStatement: ['expression'],
    File: ['program'],
    ForInStatement: ['left', 'right', 'body'],
    ForStatement: ['init', 'test', 'update', 'body'],
    FunctionDeclaration: ['id', 'params', 'body', 'returnType', 'typeParameters', 'predicate'],
    FunctionExpression: ['id', 'params', 'body', 'returnType', 'typeParameters'],
    Identifier: ['typeAnnotation', 'decorators'],
    IfStatement: ['test', 'consequent', 'alternate'],
    LabeledStatement: ['label', 'body'],
    StringLiteral: [],
    NumericLiteral: [],
    NullLiteral: [],
    BooleanLiteral: [],
    RegExpLiteral: [],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    Program: ['directives', 'body'],
    ObjectExpression: ['properties'],
    ObjectMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectProperty: ['key', 'value', 'decorators'],
    RestElement: ['argument', 'typeAnnotation', 'decorators'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    ParenthesizedExpression: ['expression'],
    SwitchCase: ['test', 'consequent'],
    SwitchStatement: ['discriminant', 'cases'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'],
    ArrayPattern: ['elements', 'typeAnnotation', 'decorators'],
    ArrowFunctionExpression: ['params', 'body', 'returnType', 'typeParameters', 'predicate'],
    ClassBody: ['body'],
    ClassExpression: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ClassDeclaration: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ExportAllDeclaration: ['source', 'attributes', 'assertions', 'exported'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes', 'assertions'],
    ExportSpecifier: ['local', 'exported'],
    ForOfStatement: ['left', 'right', 'body'],
    ImportDeclaration: ['specifiers', 'source', 'attributes', 'assertions'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['local', 'imported'],
    MetaProperty: ['meta', 'property'],
    ClassMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectPattern: ['properties', 'typeAnnotation', 'decorators'],
    SpreadElement: ['argument'],
    Super: [],
    TaggedTemplateExpression: ['tag', 'quasi', 'typeParameters', 'typeArguments'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    YieldExpression: ['argument'],
    AwaitExpression: ['argument'],
    Import: [],
    BigIntLiteral: [],
    ExportNamespaceSpecifier: ['exported'],
    OptionalMemberExpression: ['object', 'property'],
    OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    ClassProperty: ['key', 'value', 'typeAnnotation', 'decorators', 'variance'],
    ClassAccessorProperty: ['key', 'value', 'typeAnnotation', 'decorators'],
    ClassPrivateProperty: ['key', 'value', 'decorators', 'typeAnnotation', 'variance'],
    ClassPrivateMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    PrivateName: ['id'],
    StaticBlock: ['body'],
    AnyTypeAnnotation: [],
    ArrayTypeAnnotation: ['elementType'],
    BooleanTypeAnnotation: [],
    BooleanLiteralTypeAnnotation: [],
    NullLiteralTypeAnnotation: [],
    ClassImplements: ['id', 'typeParameters'],
    DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'],
    DeclareFunction: ['id', 'predicate'],
    DeclareInterface: ['id', 'typeParameters', 'extends', 'body'],
    DeclareModule: ['id', 'body'],
    DeclareModuleExports: ['typeAnnotation'],
    DeclareTypeAlias: ['id', 'typeParameters', 'right'],
    DeclareOpaqueType: ['id', 'typeParameters', 'supertype'],
    DeclareVariable: ['id'],
    DeclareExportDeclaration: ['declaration', 'specifiers', 'source'],
    DeclareExportAllDeclaration: ['source'],
    DeclaredPredicate: ['value'],
    ExistsTypeAnnotation: [],
    FunctionTypeAnnotation: ['typeParameters', 'params', 'rest', 'returnType', 'this'],
    FunctionTypeParam: ['name', 'typeAnnotation'],
    GenericTypeAnnotation: ['id', 'typeParameters'],
    InferredPredicate: [],
    InterfaceExtends: ['id', 'typeParameters'],
    InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    InterfaceTypeAnnotation: ['extends', 'body'],
    IntersectionTypeAnnotation: ['types'],
    MixedTypeAnnotation: [],
    EmptyTypeAnnotation: [],
    NullableTypeAnnotation: ['typeAnnotation'],
    NumberLiteralTypeAnnotation: [],
    NumberTypeAnnotation: [],
    ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'],
    ObjectTypeInternalSlot: ['id', 'value', 'optional', 'static', 'method'],
    ObjectTypeCallProperty: ['value'],
    ObjectTypeIndexer: ['id', 'key', 'value', 'variance'],
    ObjectTypeProperty: ['key', 'value', 'variance'],
    ObjectTypeSpreadProperty: ['argument'],
    OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'],
    QualifiedTypeIdentifier: ['id', 'qualification'],
    StringLiteralTypeAnnotation: [],
    StringTypeAnnotation: [],
    SymbolTypeAnnotation: [],
    ThisTypeAnnotation: [],
    TupleTypeAnnotation: ['types', 'elementTypes'],
    TypeofTypeAnnotation: ['argument'],
    TypeAlias: ['id', 'typeParameters', 'right'],
    TypeAnnotation: ['typeAnnotation'],
    TypeCastExpression: ['expression', 'typeAnnotation'],
    TypeParameter: ['bound', 'default', 'variance'],
    TypeParameterDeclaration: ['params'],
    TypeParameterInstantiation: ['params'],
    UnionTypeAnnotation: ['types'],
    Variance: [],
    VoidTypeAnnotation: [],
    EnumDeclaration: ['id', 'body'],
    EnumBooleanBody: ['members'],
    EnumNumberBody: ['members'],
    EnumStringBody: ['members'],
    EnumSymbolBody: ['members'],
    EnumBooleanMember: ['id', 'init'],
    EnumNumberMember: ['id', 'init'],
    EnumStringMember: ['id', 'init'],
    EnumDefaultedMember: ['id'],
    IndexedAccessType: ['objectType', 'indexType'],
    OptionalIndexedAccessType: ['objectType', 'indexType'],
    JSXAttribute: ['name', 'value'],
    JSXClosingElement: ['name'],
    JSXElement: ['openingElement', 'children', 'closingElement'],
    JSXEmptyExpression: [],
    JSXExpressionContainer: ['expression'],
    JSXSpreadChild: ['expression'],
    JSXIdentifier: [],
    JSXMemberExpression: ['object', 'property'],
    JSXNamespacedName: ['namespace', 'name'],
    JSXOpeningElement: ['name', 'attributes', 'typeArguments', 'typeParameters'],
    JSXSpreadAttribute: ['argument'],
    JSXText: [],
    JSXFragment: ['openingFragment', 'children', 'closingFragment'],
    JSXOpeningFragment: [],
    JSXClosingFragment: [],
    Noop: [],
    Placeholder: [],
    V8IntrinsicIdentifier: [],
    ArgumentPlaceholder: [],
    BindExpression: ['object', 'callee'],
    ImportAttribute: ['key', 'value'],
    Decorator: ['expression'],
    DoExpression: ['body'],
    ExportDefaultSpecifier: ['exported'],
    RecordExpression: ['properties'],
    TupleExpression: ['elements'],
    DecimalLiteral: [],
    ModuleExpression: ['body'],
    TopicReference: [],
    PipelineTopicExpression: ['expression'],
    PipelineBareFunction: ['callee'],
    PipelinePrimaryTopicReference: [],
    TSParameterProperty: ['parameter', 'decorators'],
    TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'],
    TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'],
    TSQualifiedName: ['left', 'right'],
    TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSPropertySignature: ['key', 'typeAnnotation'],
    TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSIndexSignature: ['parameters', 'typeAnnotation'],
    TSAnyKeyword: [],
    TSBooleanKeyword: [],
    TSBigIntKeyword: [],
    TSIntrinsicKeyword: [],
    TSNeverKeyword: [],
    TSNullKeyword: [],
    TSNumberKeyword: [],
    TSObjectKeyword: [],
    TSStringKeyword: [],
    TSSymbolKeyword: [],
    TSUndefinedKeyword: [],
    TSUnknownKeyword: [],
    TSVoidKeyword: [],
    TSThisType: [],
    TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'],
    TSTypePredicate: ['parameterName', 'typeAnnotation'],
    TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'],
    TSTypeLiteral: ['members'],
    TSArrayType: ['elementType'],
    TSTupleType: ['elementTypes'],
    TSOptionalType: ['typeAnnotation'],
    TSRestType: ['typeAnnotation'],
    TSNamedTupleMember: ['label', 'elementType'],
    TSUnionType: ['types'],
    TSIntersectionType: ['types'],
    TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'],
    TSInferType: ['typeParameter'],
    TSParenthesizedType: ['typeAnnotation'],
    TSTypeOperator: ['typeAnnotation'],
    TSIndexedAccessType: ['objectType', 'indexType'],
    TSMappedType: ['typeParameter', 'typeAnnotation', 'nameType'],
    TSLiteralType: ['literal'],
    TSExpressionWithTypeArguments: ['expression', 'typeParameters'],
    TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    TSInterfaceBody: ['body'],
    TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'],
    TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'],
    TSAsExpression: ['expression', 'typeAnnotation'],
    TSSatisfiesExpression: ['expression', 'typeAnnotation'],
    TSTypeAssertion: ['typeAnnotation', 'expression'],
    TSEnumDeclaration: ['id', 'members'],
    TSEnumMember: ['id', 'initializer'],
    TSModuleDeclaration: ['id', 'body'],
    TSModuleBlock: ['body'],
    TSImportType: ['argument', 'qualifier', 'typeParameters', 'typeArguments'],
    TSImportEqualsDeclaration: ['id', 'moduleReference'],
    TSExternalModuleReference: ['expression'],
    TSNonNullExpression: ['expression'],
    TSExportAssignment: ['expression'],
    TSNamespaceExportDeclaration: ['id'],
    TSTypeAnnotation: ['typeAnnotation'],
    TSTypeParameterInstantiation: ['params'],
    TSTypeParameterDeclaration: ['params'],
    TSTypeParameter: ['constraint', 'default', 'name'],
    ChainExpression: ['expression'],
    ExperimentalRestProperty: ['argument'],
    ExperimentalSpreadProperty: ['argument'],
    ImportExpression: ['source', 'attributes'],
    Literal: [],
    MethodDefinition: ['decorators', 'key', 'value'],
    PrivateIdentifier: [],
    Property: ['key', 'value'],
    PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'],
    AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'],
    TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'],
    TSAbstractKeyword: [],
    TSAbstractMethodDefinition: ['key', 'value'],
    TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'],
    TSAsyncKeyword: [],
    TSClassImplements: ['expression', 'typeArguments', 'typeParameters'],
    TSDeclareKeyword: [],
    TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'],
    TSExportKeyword: [],
    TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'],
    TSPrivateKeyword: [],
    TSProtectedKeyword: [],
    TSPublicKeyword: [],
    TSReadonlyKeyword: [],
    TSStaticKeyword: [],
    TSTemplateLiteralType: ['quasis', 'types'],
    BigIntLiteralTypeAnnotation: [],
    BigIntTypeAnnotation: [],
    ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'],
    DeclareEnum: ['id', 'body'],
    InferTypeAnnotation: ['typeParameter'],
    KeyofTypeAnnotation: ['argument'],
    ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'],
    QualifiedTypeofIdentifier: ['qualification', 'id'],
    TupleTypeLabeledElement: ['label', 'elementType', 'variance'],
    TupleTypeSpreadElement: ['label', 'typeAnnotation'],
    TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'],
    NGRoot: ['node'],
    NGPipeExpression: ['left', 'right', 'arguments'],
    NGChainedExpression: ['expressions'],
    NGEmptyExpression: [],
    NGMicrosyntax: ['body'],
    NGMicrosyntaxKey: [],
    NGMicrosyntaxExpression: ['expression', 'alias'],
    NGMicrosyntaxKeyedExpression: ['key', 'expression'],
    NGMicrosyntaxLet: ['key', 'value'],
    NGMicrosyntaxAs: ['key', 'alias'],
    JsExpressionRoot: ['node'],
    JsonRoot: ['node'],
    TSJSDocAllType: [],
    TSJSDocUnknownType: [],
    TSJSDocNullableType: ['typeAnnotation'],
    TSJSDocNonNullableType: ['typeAnnotation'],
    NeverTypeAnnotation: [],
    UndefinedTypeAnnotation: [],
    UnknownTypeAnnotation: [],
  },
  Z7 = Y7(Q7),
  e5 = Z7;
function Q0(t, e) {
  if (!(t !== null && typeof t == 'object')) return t;
  if (Array.isArray(t)) {
    for (let n = 0; n < t.length; n++) t[n] = Q0(t[n], e);
    return t;
  }
  let r = e5(t);
  for (let n = 0; n < r.length; n++) t[r[n]] = Q0(t[r[n]], e);
  return e(t) || t;
}
var Em = Q0;
function t5(t, e) {
  let { parser: r, text: n } = e;
  if (t.type === 'File' && t.program.interpreter) {
    let {
      program: { interpreter: s },
      comments: o,
    } = t;
    delete t.program.interpreter, o.unshift(s);
  }
  if (r === 'babel') {
    let s = new Set();
    (t = Em(t, (o) => {
      var l;
      (l = o.leadingComments) != null && l.some(q7) && s.add(ti(o));
    })),
      (t = Em(t, (o) => {
        if (o.type === 'ParenthesizedExpression') {
          let { expression: l } = o;
          if (l.type === 'TypeCastExpression') return (l.range = o.range), l;
          let c = ti(o);
          if (!s.has(c)) return (l.extra = { ...l.extra, parenthesized: !0 }), l;
        }
      }));
  }
  if (
    ((t = Em(t, (s) => {
      switch (s.type) {
        case 'LogicalExpression':
          if ($v(s)) return Z0(s);
          break;
        case 'VariableDeclaration': {
          let o = DC(!1, s.declarations, -1);
          o != null && o.init && i(s, o);
          break;
        }
        case 'TSParenthesizedType':
          return s.typeAnnotation;
        case 'TSTypeParameter':
          if (typeof s.name == 'string') {
            let o = ti(s);
            s.name = { type: 'Identifier', name: s.name, range: [o, o + s.name.length] };
          }
          break;
        case 'TopicReference':
          t.extra = { ...t.extra, __isUsingHackPipeline: !0 };
          break;
        case 'ExportAllDeclaration': {
          let { exported: o } = s;
          if (r === 'meriyah' && (o == null ? void 0 : o.type) === 'Identifier') {
            let l = n.slice(ti(o), js(o));
            (l.startsWith('"') || l.startsWith("'")) &&
              (s.exported = { ...s.exported, type: 'Literal', value: s.exported.name, raw: l });
          }
          break;
        }
        case 'TSUnionType':
        case 'TSIntersectionType':
          if (s.types.length === 1) return s.types[0];
          break;
      }
    })),
    Mf(t.comments))
  ) {
    let s = DC(!1, t.comments, -1);
    for (let o = t.comments.length - 2; o >= 0; o--) {
      let l = t.comments[o];
      js(l) === ti(s) &&
        Y0(l) &&
        Y0(s) &&
        xC(l) &&
        xC(s) &&
        (t.comments.splice(o + 1, 1), (l.value += '*//*' + s.value), (l.range = [ti(l), js(s)])),
        (s = l);
    }
  }
  return t.type === 'Program' && (t.range = [0, n.length]), t;
  function i(s, o) {
    n[js(o)] !== ';' && (s.range = [ti(s), js(o)]);
  }
}
function $v(t) {
  return t.type === 'LogicalExpression' && t.right.type === 'LogicalExpression' && t.operator === t.right.operator;
}
function Z0(t) {
  return $v(t)
    ? Z0({
        type: 'LogicalExpression',
        operator: t.operator,
        left: Z0({
          type: 'LogicalExpression',
          operator: t.operator,
          left: t.left,
          right: t.right.left,
          range: [ti(t.left), js(t.right.left)],
        }),
        right: t.right.right,
        range: [ti(t), js(t)],
      })
    : t;
}
var r5 = t5;
function n5(t) {
  let { filepath: e } = t;
  if (e) {
    if (((e = e.toLowerCase()), e.endsWith('.cjs'))) return 'script';
    if (e.endsWith('.mjs')) return 'module';
  }
}
var i5 = n5;
function s5(t, e) {
  let { type: r = 'JsExpressionRoot', rootMarker: n, text: i } = e,
    { tokens: s, comments: o } = t;
  return (
    delete t.tokens,
    delete t.comments,
    { tokens: s, comments: o, type: r, node: t, range: [0, i.length], rootMarker: n }
  );
}
var Vv = s5,
  El = (t) => rp(h5(t)),
  o5 = {
    sourceType: 'module',
    allowImportExportEverywhere: !0,
    allowReturnOutsideFunction: !0,
    allowNewTargetOutsideFunction: !0,
    allowSuperOutsideMethod: !0,
    allowUndeclaredExports: !0,
    errorRecovery: !0,
    createParenthesizedExpressions: !0,
    plugins: [
      'doExpressions',
      'exportDefaultFrom',
      'functionBind',
      'functionSent',
      'throwExpressions',
      'partialApplication',
      'decorators',
      'decimal',
      'moduleBlocks',
      'asyncDoExpressions',
      'regexpUnicodeSets',
      'destructuringPrivate',
      'decoratorAutoAccessors',
      'importReflection',
      'explicitResourceManagement',
      ['importAttributes', { deprecatedAssertSyntax: !0 }],
    ],
    tokens: !0,
    ranges: !0,
  },
  a5 = ['recordAndTuple', { syntaxType: 'hash' }],
  CC = 'v8intrinsic',
  bC = [
    ['pipelineOperator', { proposal: 'hack', topicToken: '%' }],
    ['pipelineOperator', { proposal: 'minimal' }],
    ['pipelineOperator', { proposal: 'fsharp' }],
  ],
  Ri = (t, e = o5) => ({ ...e, plugins: [...e.plugins, ...t] }),
  l5 = /@(?:no)?flow\b/;
function u5(t, e) {
  var r;
  if ((r = e.filepath) != null && r.endsWith('.js.flow')) return !0;
  let n = _v(t);
  n && (t = t.slice(n.length));
  let i = M7(t, 0);
  return i !== !1 && (t = t.slice(0, i)), l5.test(t);
}
function c5(t, e, r) {
  let n = t(e, r),
    i = n.errors.find((s) => !p5.has(s.reasonCode));
  if (i) throw i;
  return n;
}
function h5({ isExpression: t = !1, optionsCombinations: e }) {
  return (r, n = {}) => {
    if ((n.parser === 'babel' || n.parser === '__babel_estree') && u5(r, n))
      return (n.parser = 'babel-flow'), Hv.parse(r, n);
    let i = e;
    (n.__babelSourceType ?? i5(n)) === 'script' && (i = i.map((c) => ({ ...c, sourceType: 'script' }))),
      /#[[{]/.test(r) && (i = i.map((c) => Ri([a5], c)));
    let s = /%[A-Z]/.test(r);
    r.includes('|>')
      ? (i = (s ? [...bC, CC] : bC).flatMap((c) => i.map((p) => Ri([c], p))))
      : s && (i = i.map((c) => Ri([CC], c)));
    let o = t ? gC.parseExpression : gC.parse,
      l;
    try {
      l = E7(i.map((c) => () => c5(o, r, c)));
    } catch ({ errors: [c] }) {
      throw G0(c);
    }
    return t && (l = Vv(l, { text: r, rootMarker: n.rootMarker })), r5(l, { parser: 'babel', text: r });
  };
}
var p5 = new Set([
    'StrictNumericEscape',
    'StrictWith',
    'StrictOctalLiteral',
    'StrictDelete',
    'StrictEvalArguments',
    'StrictEvalArgumentsBinding',
    'StrictFunction',
    'EmptyTypeArguments',
    'EmptyTypeParameters',
    'ConstructorHasTypeParameters',
    'UnsupportedParameterPropertyKind',
    'MixedLabeledAndUnlabeledElements',
    'DuplicateAccessibilityModifier',
    'DecoratorExportClass',
    'ParamDupe',
    'InvalidDecimal',
    'RestTrailingComma',
    'UnsupportedParameterDecorator',
    'UnterminatedJsxContent',
    'UnexpectedReservedWord',
    'ModuleAttributesWithDuplicateKeys',
    'LineTerminatorBeforeArrow',
    'InvalidEscapeSequenceTemplate',
    'NonAbstractClassHasAbstractMethod',
    'OptionalTypeBeforeRequired',
    'PatternIsOptional',
    'OptionalBindingPattern',
    'DeclareClassFieldHasInitializer',
    'TypeImportCannotSpecifyDefaultAndNamed',
    'DeclareFunctionHasImplementation',
    'ConstructorClassField',
    'VarRedeclaration',
    'InvalidPrivateFieldResolution',
    'DuplicateExport',
  ]),
  zv = [Ri(['jsx'])],
  AC = El({ optionsCombinations: zv }),
  EC = El({ optionsCombinations: [Ri(['jsx', 'typescript']), Ri(['typescript'])] }),
  vC = El({ isExpression: !0, optionsCombinations: [Ri(['jsx'])] }),
  FC = El({ isExpression: !0, optionsCombinations: [Ri(['typescript'])] }),
  Hv = El({ optionsCombinations: [Ri(['jsx', ['flow', { all: !0, enums: !0 }], 'flowComments'])] }),
  f5 = El({ optionsCombinations: zv.map((t) => Ri(['estree'], t)) }),
  d5 = {
    'babel': AC,
    'babel-flow': Hv,
    'babel-ts': EC,
    '__js_expression': vC,
    '__ts_expression': FC,
    '__vue_expression': vC,
    '__vue_ts_expression': FC,
    '__vue_event_binding': AC,
    '__vue_ts_event_binding': EC,
    '__babel_estree': f5,
  },
  m5 = Cy(Mv(), 1);
function Wv(t = {}) {
  let { allowComments: e = !0 } = t;
  return function (r) {
    let n;
    try {
      n = (0, m5.parseExpression)(r, { tokens: !0, ranges: !0 });
    } catch (i) {
      throw (i == null ? void 0 : i.reasonCode) === 'MissingPlugin' ||
        (i == null ? void 0 : i.reasonCode) === 'MissingOneOfPlugins'
        ? G0({ message: 'Unexpected token', loc: i.loc })
        : G0(i);
    }
    if (!e && Mf(n.comments)) throw Ns(n.comments[0], 'Comment');
    return Ra(n), Vv(n, { type: 'JsonRoot', text: r });
  };
}
function Ns(t, e) {
  let [r, n] = [t.loc.start, t.loc.end].map(({ line: i, column: s }) => ({ line: i, column: s + 1 }));
  return jv(`${e} is not allowed in JSON.`, { loc: { start: r, end: n } });
}
function Ra(t) {
  switch (t.type) {
    case 'ArrayExpression':
      for (let e of t.elements) e !== null && Ra(e);
      return;
    case 'ObjectExpression':
      for (let e of t.properties) Ra(e);
      return;
    case 'ObjectProperty':
      if (t.computed) throw Ns(t.key, 'Computed key');
      if (t.shorthand) throw Ns(t.key, 'Shorthand property');
      t.key.type !== 'Identifier' && Ra(t.key), Ra(t.value);
      return;
    case 'UnaryExpression': {
      let { operator: e, argument: r } = t;
      if (e !== '+' && e !== '-') throw Ns(t, `Operator '${t.operator}'`);
      if (r.type === 'NumericLiteral' || (r.type === 'Identifier' && (r.name === 'Infinity' || r.name === 'NaN')))
        return;
      throw Ns(r, `Operator '${e}' before '${r.type}'`);
    }
    case 'Identifier':
      if (t.name !== 'Infinity' && t.name !== 'NaN' && t.name !== 'undefined') throw Ns(t, `Identifier '${t.name}'`);
      return;
    case 'TemplateLiteral':
      if (Mf(t.expressions)) throw Ns(t.expressions[0], "'TemplateLiteral' with expression");
      for (let e of t.quasis) Ra(e);
      return;
    case 'NullLiteral':
    case 'BooleanLiteral':
    case 'NumericLiteral':
    case 'StringLiteral':
    case 'TemplateElement':
      return;
    default:
      throw Ns(t, `'${t.type}'`);
  }
}
var SC = Wv(),
  g5 = {
    'json': rp({
      parse: SC,
      hasPragma() {
        return !0;
      },
    }),
    'json5': rp(SC),
    'json-stringify': rp({ parse: Wv({ allowComments: !1 }), astFormat: 'estree-json' }),
  },
  y5 = g5,
  D5 = { ...d5, ...y5 },
  x5 = Lv,
  C5 = Object.create,
  by = Object.defineProperty,
  b5 = Object.getOwnPropertyDescriptor,
  A5 = Object.getOwnPropertyNames,
  E5 = Object.getPrototypeOf,
  v5 = Object.prototype.hasOwnProperty,
  F5 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports),
  Of = (t, e) => {
    for (var r in e) by(t, r, { get: e[r], enumerable: !0 });
  },
  S5 = (t, e, r, n) => {
    if ((e && typeof e == 'object') || typeof e == 'function')
      for (let i of A5(e))
        !v5.call(t, i) && i !== r && by(t, i, { get: () => e[i], enumerable: !(n = b5(e, i)) || n.enumerable });
    return t;
  },
  w5 = (t, e, r) => (
    (r = t != null ? C5(E5(t)) : {}),
    S5(e || !t || !t.__esModule ? by(r, 'default', { value: t, enumerable: !0 }) : r, t)
  ),
  Uv = (t, e, r) => {
    if (!e.has(t)) throw TypeError('Cannot ' + r);
  },
  Ps = (t, e, r) => (Uv(t, e, 'read from private field'), r ? r.call(t) : e.get(t)),
  T5 = (t, e, r) => {
    if (e.has(t)) throw TypeError('Cannot add the same private member more than once');
    e instanceof WeakSet ? e.add(t) : e.set(t, r);
  },
  k5 = (t, e, r, n) => (Uv(t, e, 'write to private field'), n ? n.call(t, r) : e.set(t, r), r),
  P5 = F5((t) => {
    Object.defineProperty(t, '__esModule', { value: !0 }),
      (t.extract = f),
      (t.parse = g),
      (t.parseWithComments = x),
      (t.print = b),
      (t.strip = m);
    var e = /\*\/$/,
      r = /^\/\*\*?/,
      n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      i = /(^|\s+)\/\/([^\r\n]*)/g,
      s = /^(\r?\n)+/,
      o = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      c = /(\r?\n|^) *\* ?/g,
      p = [];
    function f(E) {
      let w = E.match(n);
      return w ? w[0].trimLeft() : '';
    }
    function m(E) {
      let w = E.match(n);
      return w && w[0] ? E.substring(w[0].length) : E;
    }
    function g(E) {
      return x(E).pragmas;
    }
    function x(E) {
      let w = `
`;
      E = E.replace(r, '').replace(e, '').replace(c, '$1');
      let I = '';
      for (; I !== E; ) (I = E), (E = E.replace(o, `${w}$1 $2${w}`));
      E = E.replace(s, '').trimRight();
      let T = Object.create(null),
        j = E.replace(l, '').replace(s, '').trimRight(),
        $;
      for (; ($ = l.exec(E)); ) {
        let L = $[2].replace(i, '');
        typeof T[$[1]] == 'string' || Array.isArray(T[$[1]]) ? (T[$[1]] = p.concat(T[$[1]], L)) : (T[$[1]] = L);
      }
      return { comments: j, pragmas: T };
    }
    function b({ comments: E = '', pragmas: w = {} }) {
      let I = `
`,
        T = '/**',
        j = ' *',
        $ = ' */',
        L = Object.keys(w),
        se = L.map((W) => F(W, w[W]))
          .reduce((W, X) => W.concat(X), [])
          .map((W) => `${j} ${W}${I}`)
          .join('');
      if (!E) {
        if (L.length === 0) return '';
        if (L.length === 1 && !Array.isArray(w[L[0]])) {
          let W = w[L[0]];
          return `${T} ${F(L[0], W)[0]}${$}`;
        }
      }
      let Y =
        E.split(I)
          .map((W) => `${j} ${W}`)
          .join(I) + I;
      return T + I + (E ? Y : '') + (E && L.length ? j + I : '') + se + $;
    }
    function F(E, w) {
      return p.concat(w).map((I) => `@${E} ${I}`.trim());
    }
  }),
  qv = {};
Of(qv, { languages: () => Z$, options: () => Y$, printers: () => Q$ });
var Kv = {};
Of(Kv, {
  canAttachComment: () => W_,
  embed: () => M$,
  experimentalFeatures: () => V$,
  getCommentChildNodes: () => U_,
  getVisitorKeys: () => tF,
  handleComments: () => xF,
  insertPragma: () => $$,
  isBlockComment: () => ys,
  isGap: () => q_,
  massageAstNode: () => L$,
  print: () => a$,
  printComment: () => V_,
  willPrintOwnComments: () => TF,
});
function B5(t, e) {
  let { originalText: r, [Symbol.for('comments')]: n, locStart: i, locEnd: s, [Symbol.for('printedComments')]: o } = e,
    { node: l } = t,
    c = i(l),
    p = s(l);
  for (let f of n) i(f) >= c && s(f) <= p && o.add(f);
  return r.slice(c, p);
}
var I5 = B5,
  vl = 'string',
  na = 'array',
  Fl = 'cursor',
  ua = 'indent',
  ca = 'align',
  Sl = 'trim',
  Un = 'group',
  Hi = 'fill',
  ji = 'if-break',
  ha = 'indent-if-break',
  pa = 'line-suffix',
  fa = 'line-suffix-boundary',
  Nn = 'line',
  fo = 'label',
  mo = 'break-parent',
  Jv = new Set([Fl, ua, ca, Sl, Un, Hi, ji, ha, pa, fa, Nn, fo, mo]);
function N5(t) {
  if (typeof t == 'string') return vl;
  if (Array.isArray(t)) return na;
  if (!t) return;
  let { type: e } = t;
  if (Jv.has(e)) return e;
}
var wl = N5,
  M5 = (t) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(t);
function O5(t) {
  let e = t === null ? 'null' : typeof t;
  if (e !== 'string' && e !== 'object')
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (wl(t)) throw new Error('doc is valid.');
  let r = Object.prototype.toString.call(t);
  if (r !== '[object Object]') return `Unexpected doc '${r}'.`;
  let n = M5([...Jv].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var L5 = class extends Error {
    constructor(e) {
      super(O5(e));
      ko(this, 'name', 'InvalidDocError');
      this.doc = e;
    }
  },
  ec = L5,
  wC = {};
function _5(t, e, r, n) {
  let i = [t];
  for (; i.length > 0; ) {
    let s = i.pop();
    if (s === wC) {
      r(i.pop());
      continue;
    }
    r && i.push(s, wC);
    let o = wl(s);
    if (!o) throw new ec(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (o) {
        case na:
        case Hi: {
          let l = o === na ? s : s.parts;
          for (let c = l.length, p = c - 1; p >= 0; --p) i.push(l[p]);
          break;
        }
        case ji:
          i.push(s.flatContents, s.breakContents);
          break;
        case Un:
          if (n && s.expandedStates)
            for (let l = s.expandedStates.length, c = l - 1; c >= 0; --c) i.push(s.expandedStates[c]);
          else i.push(s.contents);
          break;
        case ca:
        case ua:
        case ha:
        case fo:
        case pa:
          i.push(s.contents);
          break;
        case vl:
        case Fl:
        case Sl:
        case fa:
        case Nn:
        case mo:
          break;
        default:
          throw new ec(s);
      }
  }
}
var Xv = _5,
  R5 = () => {},
  j5 = R5;
function Se(t) {
  return { type: ua, contents: t };
}
function ci(t, e) {
  return { type: ca, contents: e, n: t };
}
function oe(t, e = {}) {
  return (
    j5(e.expandedStates), { type: Un, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates }
  );
}
function $5(t) {
  return ci(Number.NEGATIVE_INFINITY, t);
}
function V5(t) {
  return ci(-1, t);
}
function Jo(t, e) {
  return oe(t[0], { ...e, expandedStates: t });
}
function Ay(t) {
  return { type: Hi, parts: t };
}
function Nt(t, e = '', r = {}) {
  return { type: ji, breakContents: t, flatContents: e, groupId: r.groupId };
}
function Lf(t, e) {
  return { type: ha, contents: t, groupId: e.groupId, negate: e.negate };
}
function TC(t) {
  return { type: pa, contents: t };
}
var cs = { type: fa },
  uo = { type: mo },
  Gv = { type: Nn, hard: !0 },
  z5 = { type: Nn, hard: !0, literal: !0 },
  We = { type: Nn },
  Ae = { type: Nn, soft: !0 },
  Ee = [Gv, uo],
  Yv = [z5, uo],
  kC = { type: Fl };
function vt(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++) n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
function H5(t, e, r) {
  let n = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i) n = Se(n);
    (n = ci(e % r, n)), (n = ci(Number.NEGATIVE_INFINITY, n));
  }
  return n;
}
function dc(t, e) {
  return t ? { type: fo, label: t, contents: e } : e;
}
var W5 = (t, e, r) => {
    if (!(t && e == null)) return Array.isArray(e) || typeof e == 'string' ? e[r < 0 ? e.length + r : r] : e.at(r);
  },
  Lt = W5,
  Qv = (t) => {
    if (Array.isArray(t)) return t;
    if (t.type !== Hi) throw new Error(`Expect doc to be 'array' or '${Hi}'.`);
    return t.parts;
  };
function Tl(t, e) {
  if (typeof t == 'string') return e(t);
  let r = new Map();
  return n(t);
  function n(s) {
    if (r.has(s)) return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch (wl(s)) {
      case na:
        return e(s.map(n));
      case Hi:
        return e({ ...s, parts: s.parts.map(n) });
      case ji:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case Un: {
        let { expandedStates: o, contents: l } = s;
        return o ? ((o = o.map(n)), (l = o[0])) : (l = n(l)), e({ ...s, contents: l, expandedStates: o });
      }
      case ca:
      case ua:
      case ha:
      case fo:
      case pa:
        return e({ ...s, contents: n(s.contents) });
      case vl:
      case Fl:
      case Sl:
      case fa:
      case Nn:
      case mo:
        return e(s);
      default:
        throw new ec(s);
    }
  }
}
function Zv(t, e, r) {
  let n = r,
    i = !1;
  function s(o) {
    if (i) return !1;
    let l = e(o);
    l !== void 0 && ((i = !0), (n = l));
  }
  return Xv(t, s), n;
}
function U5(t) {
  if ((t.type === Un && t.break) || (t.type === Nn && t.hard) || t.type === mo) return !0;
}
function an(t) {
  return Zv(t, U5, !1);
}
function PC(t) {
  if (t.length > 0) {
    let e = Lt(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = 'propagated');
  }
  return null;
}
function q5(t) {
  let e = new Set(),
    r = [];
  function n(s) {
    if ((s.type === mo && PC(r), s.type === Un)) {
      if ((r.push(s), e.has(s))) return !1;
      e.add(s);
    }
  }
  function i(s) {
    s.type === Un && r.pop().break && PC(r);
  }
  Xv(t, n, i, !0);
}
function K5(t) {
  return t.type === Nn && !t.hard ? (t.soft ? '' : ' ') : t.type === ji ? t.flatContents : t;
}
function eg(t) {
  return Tl(t, K5);
}
function J5(t) {
  switch (wl(t)) {
    case Hi:
      if (t.parts.every((e) => e === '')) return '';
      break;
    case Un:
      if (!t.contents && !t.id && !t.break && !t.expandedStates) return '';
      if (
        t.contents.type === Un &&
        t.contents.id === t.id &&
        t.contents.break === t.break &&
        t.contents.expandedStates === t.expandedStates
      )
        return t.contents;
      break;
    case ca:
    case ua:
    case ha:
    case pa:
      if (!t.contents) return '';
      break;
    case ji:
      if (!t.flatContents && !t.breakContents) return '';
      break;
    case na: {
      let e = [];
      for (let r of t) {
        if (!r) continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == 'string' && typeof Lt(!1, e, -1) == 'string' ? (e[e.length - 1] += n) : e.push(n), e.push(...i);
      }
      return e.length === 0 ? '' : e.length === 1 ? e[0] : e;
    }
    case vl:
    case Fl:
    case Sl:
    case fa:
    case Nn:
    case fo:
    case mo:
      break;
    default:
      throw new ec(t);
  }
  return t;
}
function Ey(t) {
  return Tl(t, (e) => J5(e));
}
function ia(t, e = Yv) {
  return Tl(t, (r) =>
    typeof r == 'string'
      ? vt(
          e,
          r.split(`
`),
        )
      : r,
  );
}
function X5(t) {
  if (t.type === Nn) return !0;
}
function G5(t) {
  return Zv(t, X5, !1);
}
function tg(t, e) {
  return t.type === fo ? { ...t, contents: e(t.contents) } : e(t);
}
function Y5(t) {
  return Array.isArray(t) && t.length > 0;
}
var kt = Y5,
  Q5 =
    /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/,
  Z5 = (t) => Q5.test(t),
  eL = Z5;
function tL(t) {
  return t !== null && typeof t == 'object';
}
var rL = tL;
function* nL(t, e) {
  let { getVisitorKeys: r, filter: n = () => !0 } = e,
    i = (s) => rL(s) && n(s);
  for (let s of r(t)) {
    let o = t[s];
    if (Array.isArray(o)) for (let l of o) i(l) && (yield l);
    else i(o) && (yield o);
  }
}
function* iL(t, e) {
  let r = [t];
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    for (let s of nL(i, e)) yield s, r.push(s);
  }
}
function sL(t, { getVisitorKeys: e, predicate: r }) {
  for (let n of iL(t, { getVisitorKeys: e })) if (r(n)) return !0;
  return !1;
}
function vy(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1) return !1;
    let { length: s } = e,
      o = r;
    for (; o >= 0 && o < s; ) {
      let l = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(l)) return o;
      } else if (!t.includes(l)) return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var hl = vy(' 	'),
  oL = vy(',; 	'),
  aL = vy(/[^\n\r]/);
function lL(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1) return !1;
  let i = t.charAt(e);
  if (n) {
    if (
      t.charAt(e - 1) === '\r' &&
      i ===
        `
`
    )
      return e - 2;
    if (
      i ===
        `
` ||
      i === '\r' ||
      i === '\u2028' ||
      i === '\u2029'
    )
      return e - 1;
  } else {
    if (
      i === '\r' &&
      t.charAt(e + 1) ===
        `
`
    )
      return e + 2;
    if (
      i ===
        `
` ||
      i === '\r' ||
      i === '\u2028' ||
      i === '\u2029'
    )
      return e + 1;
  }
  return e;
}
var pl = lL;
function uL(t, e, r = {}) {
  let n = hl(t, r.backwards ? e - 1 : e, r),
    i = pl(t, n, r);
  return n !== i;
}
var Pn = uL;
function cL(t, e) {
  if (e === !1) return !1;
  if (t.charAt(e) === '/' && t.charAt(e + 1) === '*') {
    for (let r = e + 2; r < t.length; ++r) if (t.charAt(r) === '*' && t.charAt(r + 1) === '/') return r + 2;
  }
  return e;
}
var Fy = cL;
function hL(t, e) {
  return e === !1 ? !1 : t.charAt(e) === '/' && t.charAt(e + 1) === '/' ? aL(t, e) : e;
}
var Sy = hL;
function pL(t, e) {
  let r = null,
    n = e;
  for (; n !== r; ) (r = n), (n = oL(t, n)), (n = Fy(t, n)), (n = hl(t, n));
  return (n = Sy(t, n)), (n = pl(t, n)), n !== !1 && Pn(t, n);
}
var wy = pL,
  fL = () =>
    /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g,
  dL = {
    eastAsianWidth(t) {
      var e = t.charCodeAt(0),
        r = t.length == 2 ? t.charCodeAt(1) : 0,
        n = e;
      return (
        55296 <= e &&
          e <= 56319 &&
          56320 <= r &&
          r <= 57343 &&
          ((e &= 1023), (r &= 1023), (n = (e << 10) | r), (n += 65536)),
        n == 12288 || (65281 <= n && n <= 65376) || (65504 <= n && n <= 65510)
          ? 'F'
          : (4352 <= n && n <= 4447) ||
            (4515 <= n && n <= 4519) ||
            (4602 <= n && n <= 4607) ||
            (9001 <= n && n <= 9002) ||
            (11904 <= n && n <= 11929) ||
            (11931 <= n && n <= 12019) ||
            (12032 <= n && n <= 12245) ||
            (12272 <= n && n <= 12283) ||
            (12289 <= n && n <= 12350) ||
            (12353 <= n && n <= 12438) ||
            (12441 <= n && n <= 12543) ||
            (12549 <= n && n <= 12589) ||
            (12593 <= n && n <= 12686) ||
            (12688 <= n && n <= 12730) ||
            (12736 <= n && n <= 12771) ||
            (12784 <= n && n <= 12830) ||
            (12832 <= n && n <= 12871) ||
            (12880 <= n && n <= 13054) ||
            (13056 <= n && n <= 19903) ||
            (19968 <= n && n <= 42124) ||
            (42128 <= n && n <= 42182) ||
            (43360 <= n && n <= 43388) ||
            (44032 <= n && n <= 55203) ||
            (55216 <= n && n <= 55238) ||
            (55243 <= n && n <= 55291) ||
            (63744 <= n && n <= 64255) ||
            (65040 <= n && n <= 65049) ||
            (65072 <= n && n <= 65106) ||
            (65108 <= n && n <= 65126) ||
            (65128 <= n && n <= 65131) ||
            (110592 <= n && n <= 110593) ||
            (127488 <= n && n <= 127490) ||
            (127504 <= n && n <= 127546) ||
            (127552 <= n && n <= 127560) ||
            (127568 <= n && n <= 127569) ||
            (131072 <= n && n <= 194367) ||
            (177984 <= n && n <= 196605) ||
            (196608 <= n && n <= 262141)
          ? 'W'
          : 'N'
      );
    },
  },
  mL = /[^\x20-\x7F]/;
function gL(t) {
  if (!t) return 0;
  if (!mL.test(t)) return t.length;
  t = t.replace(fL(), '  ');
  let e = 0;
  for (let r of t) {
    let n = r.codePointAt(0);
    if (n <= 31 || (n >= 127 && n <= 159) || (n >= 768 && n <= 879)) continue;
    let i = dL.eastAsianWidth(r);
    e += i === 'F' || i === 'W' ? 2 : 1;
  }
  return e;
}
var fl = gL;
function Er(t) {
  var e;
  let r = t.range ? t.range[0] : t.start,
    n = ((e = t.declaration) == null ? void 0 : e.decorators) ?? t.decorators;
  return kt(n) ? Math.min(Er(n[0]), r) : r;
}
function zt(t) {
  return t.range ? t.range[1] : t.end;
}
function mc(t, e) {
  let r = Er(t);
  return Number.isInteger(r) && r === Er(e);
}
function yL(t, e) {
  let r = zt(t);
  return Number.isInteger(r) && r === zt(e);
}
function DL(t, e) {
  return mc(t, e) && yL(t, e);
}
var su = null;
function wu(t) {
  if (su !== null && typeof su.property) {
    let e = su;
    return (su = wu.prototype = null), e;
  }
  return (su = wu.prototype = t ?? Object.create(null)), new wu();
}
var xL = 10;
for (let t = 0; t <= xL; t++) wu();
function CL(t) {
  return wu(t);
}
function bL(t, e = 'type') {
  CL(t);
  function r(n) {
    let i = n[e],
      s = t[i];
    if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var eF = bL,
  AL = {
    ArrayExpression: ['elements'],
    AssignmentExpression: ['left', 'right'],
    BinaryExpression: ['left', 'right'],
    InterpreterDirective: [],
    Directive: ['value'],
    DirectiveLiteral: [],
    BlockStatement: ['directives', 'body'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    CatchClause: ['param', 'body'],
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DoWhileStatement: ['test', 'body'],
    EmptyStatement: [],
    ExpressionStatement: ['expression'],
    File: ['program'],
    ForInStatement: ['left', 'right', 'body'],
    ForStatement: ['init', 'test', 'update', 'body'],
    FunctionDeclaration: ['id', 'params', 'body', 'returnType', 'typeParameters', 'predicate'],
    FunctionExpression: ['id', 'params', 'body', 'returnType', 'typeParameters'],
    Identifier: ['typeAnnotation', 'decorators'],
    IfStatement: ['test', 'consequent', 'alternate'],
    LabeledStatement: ['label', 'body'],
    StringLiteral: [],
    NumericLiteral: [],
    NullLiteral: [],
    BooleanLiteral: [],
    RegExpLiteral: [],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    Program: ['directives', 'body'],
    ObjectExpression: ['properties'],
    ObjectMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectProperty: ['key', 'value', 'decorators'],
    RestElement: ['argument', 'typeAnnotation', 'decorators'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    ParenthesizedExpression: ['expression'],
    SwitchCase: ['test', 'consequent'],
    SwitchStatement: ['discriminant', 'cases'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'],
    ArrayPattern: ['elements', 'typeAnnotation', 'decorators'],
    ArrowFunctionExpression: ['params', 'body', 'returnType', 'typeParameters', 'predicate'],
    ClassBody: ['body'],
    ClassExpression: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ClassDeclaration: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ExportAllDeclaration: ['source', 'attributes', 'assertions', 'exported'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes', 'assertions'],
    ExportSpecifier: ['local', 'exported'],
    ForOfStatement: ['left', 'right', 'body'],
    ImportDeclaration: ['specifiers', 'source', 'attributes', 'assertions'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['local', 'imported'],
    MetaProperty: ['meta', 'property'],
    ClassMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectPattern: ['properties', 'typeAnnotation', 'decorators'],
    SpreadElement: ['argument'],
    Super: [],
    TaggedTemplateExpression: ['tag', 'quasi', 'typeParameters', 'typeArguments'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    YieldExpression: ['argument'],
    AwaitExpression: ['argument'],
    Import: [],
    BigIntLiteral: [],
    ExportNamespaceSpecifier: ['exported'],
    OptionalMemberExpression: ['object', 'property'],
    OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    ClassProperty: ['key', 'value', 'typeAnnotation', 'decorators', 'variance'],
    ClassAccessorProperty: ['key', 'value', 'typeAnnotation', 'decorators'],
    ClassPrivateProperty: ['key', 'value', 'decorators', 'typeAnnotation', 'variance'],
    ClassPrivateMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    PrivateName: ['id'],
    StaticBlock: ['body'],
    AnyTypeAnnotation: [],
    ArrayTypeAnnotation: ['elementType'],
    BooleanTypeAnnotation: [],
    BooleanLiteralTypeAnnotation: [],
    NullLiteralTypeAnnotation: [],
    ClassImplements: ['id', 'typeParameters'],
    DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'],
    DeclareFunction: ['id', 'predicate'],
    DeclareInterface: ['id', 'typeParameters', 'extends', 'body'],
    DeclareModule: ['id', 'body'],
    DeclareModuleExports: ['typeAnnotation'],
    DeclareTypeAlias: ['id', 'typeParameters', 'right'],
    DeclareOpaqueType: ['id', 'typeParameters', 'supertype'],
    DeclareVariable: ['id'],
    DeclareExportDeclaration: ['declaration', 'specifiers', 'source'],
    DeclareExportAllDeclaration: ['source'],
    DeclaredPredicate: ['value'],
    ExistsTypeAnnotation: [],
    FunctionTypeAnnotation: ['typeParameters', 'params', 'rest', 'returnType', 'this'],
    FunctionTypeParam: ['name', 'typeAnnotation'],
    GenericTypeAnnotation: ['id', 'typeParameters'],
    InferredPredicate: [],
    InterfaceExtends: ['id', 'typeParameters'],
    InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    InterfaceTypeAnnotation: ['extends', 'body'],
    IntersectionTypeAnnotation: ['types'],
    MixedTypeAnnotation: [],
    EmptyTypeAnnotation: [],
    NullableTypeAnnotation: ['typeAnnotation'],
    NumberLiteralTypeAnnotation: [],
    NumberTypeAnnotation: [],
    ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'],
    ObjectTypeInternalSlot: ['id', 'value', 'optional', 'static', 'method'],
    ObjectTypeCallProperty: ['value'],
    ObjectTypeIndexer: ['id', 'key', 'value', 'variance'],
    ObjectTypeProperty: ['key', 'value', 'variance'],
    ObjectTypeSpreadProperty: ['argument'],
    OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'],
    QualifiedTypeIdentifier: ['id', 'qualification'],
    StringLiteralTypeAnnotation: [],
    StringTypeAnnotation: [],
    SymbolTypeAnnotation: [],
    ThisTypeAnnotation: [],
    TupleTypeAnnotation: ['types', 'elementTypes'],
    TypeofTypeAnnotation: ['argument'],
    TypeAlias: ['id', 'typeParameters', 'right'],
    TypeAnnotation: ['typeAnnotation'],
    TypeCastExpression: ['expression', 'typeAnnotation'],
    TypeParameter: ['bound', 'default', 'variance'],
    TypeParameterDeclaration: ['params'],
    TypeParameterInstantiation: ['params'],
    UnionTypeAnnotation: ['types'],
    Variance: [],
    VoidTypeAnnotation: [],
    EnumDeclaration: ['id', 'body'],
    EnumBooleanBody: ['members'],
    EnumNumberBody: ['members'],
    EnumStringBody: ['members'],
    EnumSymbolBody: ['members'],
    EnumBooleanMember: ['id', 'init'],
    EnumNumberMember: ['id', 'init'],
    EnumStringMember: ['id', 'init'],
    EnumDefaultedMember: ['id'],
    IndexedAccessType: ['objectType', 'indexType'],
    OptionalIndexedAccessType: ['objectType', 'indexType'],
    JSXAttribute: ['name', 'value'],
    JSXClosingElement: ['name'],
    JSXElement: ['openingElement', 'children', 'closingElement'],
    JSXEmptyExpression: [],
    JSXExpressionContainer: ['expression'],
    JSXSpreadChild: ['expression'],
    JSXIdentifier: [],
    JSXMemberExpression: ['object', 'property'],
    JSXNamespacedName: ['namespace', 'name'],
    JSXOpeningElement: ['name', 'attributes', 'typeArguments', 'typeParameters'],
    JSXSpreadAttribute: ['argument'],
    JSXText: [],
    JSXFragment: ['openingFragment', 'children', 'closingFragment'],
    JSXOpeningFragment: [],
    JSXClosingFragment: [],
    Noop: [],
    Placeholder: [],
    V8IntrinsicIdentifier: [],
    ArgumentPlaceholder: [],
    BindExpression: ['object', 'callee'],
    ImportAttribute: ['key', 'value'],
    Decorator: ['expression'],
    DoExpression: ['body'],
    ExportDefaultSpecifier: ['exported'],
    RecordExpression: ['properties'],
    TupleExpression: ['elements'],
    DecimalLiteral: [],
    ModuleExpression: ['body'],
    TopicReference: [],
    PipelineTopicExpression: ['expression'],
    PipelineBareFunction: ['callee'],
    PipelinePrimaryTopicReference: [],
    TSParameterProperty: ['parameter', 'decorators'],
    TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'],
    TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'],
    TSQualifiedName: ['left', 'right'],
    TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSPropertySignature: ['key', 'typeAnnotation'],
    TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSIndexSignature: ['parameters', 'typeAnnotation'],
    TSAnyKeyword: [],
    TSBooleanKeyword: [],
    TSBigIntKeyword: [],
    TSIntrinsicKeyword: [],
    TSNeverKeyword: [],
    TSNullKeyword: [],
    TSNumberKeyword: [],
    TSObjectKeyword: [],
    TSStringKeyword: [],
    TSSymbolKeyword: [],
    TSUndefinedKeyword: [],
    TSUnknownKeyword: [],
    TSVoidKeyword: [],
    TSThisType: [],
    TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'],
    TSTypePredicate: ['parameterName', 'typeAnnotation'],
    TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'],
    TSTypeLiteral: ['members'],
    TSArrayType: ['elementType'],
    TSTupleType: ['elementTypes'],
    TSOptionalType: ['typeAnnotation'],
    TSRestType: ['typeAnnotation'],
    TSNamedTupleMember: ['label', 'elementType'],
    TSUnionType: ['types'],
    TSIntersectionType: ['types'],
    TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'],
    TSInferType: ['typeParameter'],
    TSParenthesizedType: ['typeAnnotation'],
    TSTypeOperator: ['typeAnnotation'],
    TSIndexedAccessType: ['objectType', 'indexType'],
    TSMappedType: ['typeParameter', 'typeAnnotation', 'nameType'],
    TSLiteralType: ['literal'],
    TSExpressionWithTypeArguments: ['expression', 'typeParameters'],
    TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    TSInterfaceBody: ['body'],
    TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'],
    TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'],
    TSAsExpression: ['expression', 'typeAnnotation'],
    TSSatisfiesExpression: ['expression', 'typeAnnotation'],
    TSTypeAssertion: ['typeAnnotation', 'expression'],
    TSEnumDeclaration: ['id', 'members'],
    TSEnumMember: ['id', 'initializer'],
    TSModuleDeclaration: ['id', 'body'],
    TSModuleBlock: ['body'],
    TSImportType: ['argument', 'qualifier', 'typeParameters', 'typeArguments'],
    TSImportEqualsDeclaration: ['id', 'moduleReference'],
    TSExternalModuleReference: ['expression'],
    TSNonNullExpression: ['expression'],
    TSExportAssignment: ['expression'],
    TSNamespaceExportDeclaration: ['id'],
    TSTypeAnnotation: ['typeAnnotation'],
    TSTypeParameterInstantiation: ['params'],
    TSTypeParameterDeclaration: ['params'],
    TSTypeParameter: ['constraint', 'default', 'name'],
    ChainExpression: ['expression'],
    ExperimentalRestProperty: ['argument'],
    ExperimentalSpreadProperty: ['argument'],
    ImportExpression: ['source', 'attributes'],
    Literal: [],
    MethodDefinition: ['decorators', 'key', 'value'],
    PrivateIdentifier: [],
    Property: ['key', 'value'],
    PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'],
    AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'],
    TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'],
    TSAbstractKeyword: [],
    TSAbstractMethodDefinition: ['key', 'value'],
    TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'],
    TSAsyncKeyword: [],
    TSClassImplements: ['expression', 'typeArguments', 'typeParameters'],
    TSDeclareKeyword: [],
    TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'],
    TSExportKeyword: [],
    TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'],
    TSPrivateKeyword: [],
    TSProtectedKeyword: [],
    TSPublicKeyword: [],
    TSReadonlyKeyword: [],
    TSStaticKeyword: [],
    TSTemplateLiteralType: ['quasis', 'types'],
    BigIntLiteralTypeAnnotation: [],
    BigIntTypeAnnotation: [],
    ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'],
    DeclareEnum: ['id', 'body'],
    InferTypeAnnotation: ['typeParameter'],
    KeyofTypeAnnotation: ['argument'],
    ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'],
    QualifiedTypeofIdentifier: ['qualification', 'id'],
    TupleTypeLabeledElement: ['label', 'elementType', 'variance'],
    TupleTypeSpreadElement: ['label', 'typeAnnotation'],
    TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'],
    NGRoot: ['node'],
    NGPipeExpression: ['left', 'right', 'arguments'],
    NGChainedExpression: ['expressions'],
    NGEmptyExpression: [],
    NGMicrosyntax: ['body'],
    NGMicrosyntaxKey: [],
    NGMicrosyntaxExpression: ['expression', 'alias'],
    NGMicrosyntaxKeyedExpression: ['key', 'expression'],
    NGMicrosyntaxLet: ['key', 'value'],
    NGMicrosyntaxAs: ['key', 'alias'],
    JsExpressionRoot: ['node'],
    JsonRoot: ['node'],
    TSJSDocAllType: [],
    TSJSDocUnknownType: [],
    TSJSDocNullableType: ['typeAnnotation'],
    TSJSDocNonNullableType: ['typeAnnotation'],
    NeverTypeAnnotation: [],
    UndefinedTypeAnnotation: [],
    UnknownTypeAnnotation: [],
  },
  EL = eF(AL),
  tF = EL;
function vL(t) {
  return (t = new Set(t)), (e) => t.has(e == null ? void 0 : e.type);
}
var ir = vL,
  FL = ir(['Block', 'CommentBlock', 'MultiLine']),
  ys = FL;
function SL(t, e) {
  let r = e.split('.');
  for (let n = r.length - 1; n >= 0; n--) {
    let i = r[n];
    if (n === 0) return t.type === 'Identifier' && t.name === i;
    if (
      t.type !== 'MemberExpression' ||
      t.optional ||
      t.computed ||
      t.property.type !== 'Identifier' ||
      t.property.name !== i
    )
      return !1;
    t = t.object;
  }
}
function wL(t, e) {
  return e.some((r) => SL(t, r));
}
var TL = wL,
  kL = ir([
    'AnyTypeAnnotation',
    'ThisTypeAnnotation',
    'NumberTypeAnnotation',
    'VoidTypeAnnotation',
    'BooleanTypeAnnotation',
    'BigIntTypeAnnotation',
    'SymbolTypeAnnotation',
    'StringTypeAnnotation',
    'NeverTypeAnnotation',
    'UndefinedTypeAnnotation',
    'UnknownTypeAnnotation',
    'EmptyTypeAnnotation',
    'MixedTypeAnnotation',
  ]),
  rF = kL;
function PL({ type: t }) {
  return t.startsWith('TS') && t.endsWith('Keyword');
}
var nF = PL;
function rg(t, e) {
  return e(t) || sL(t, { getVisitorKeys: tF, predicate: e });
}
function Ty(t) {
  return (
    t.type === 'AssignmentExpression' ||
    t.type === 'BinaryExpression' ||
    t.type === 'LogicalExpression' ||
    t.type === 'NGPipeExpression' ||
    t.type === 'ConditionalExpression' ||
    It(t) ||
    or(t) ||
    t.type === 'SequenceExpression' ||
    t.type === 'TaggedTemplateExpression' ||
    t.type === 'BindExpression' ||
    (t.type === 'UpdateExpression' && !t.prefix) ||
    Qs(t) ||
    t.type === 'TSNonNullExpression' ||
    t.type === 'ChainExpression'
  );
}
function BL(t) {
  return t.expressions
    ? t.expressions[0]
    : t.left ?? t.test ?? t.callee ?? t.object ?? t.tag ?? t.argument ?? t.expression;
}
function iF(t) {
  if (t.expressions) return ['expressions', 0];
  if (t.left) return ['left'];
  if (t.test) return ['test'];
  if (t.object) return ['object'];
  if (t.callee) return ['callee'];
  if (t.tag) return ['tag'];
  if (t.argument) return ['argument'];
  if (t.expression) return ['expression'];
  throw new Error('Unexpected node has no left side.');
}
var ky = ir([
    'Line',
    'CommentLine',
    'SingleLine',
    'HashbangComment',
    'HTMLOpen',
    'HTMLClose',
    'Hashbang',
    'InterpreterDirective',
  ]),
  IL = ir([
    'ExportDefaultDeclaration',
    'DeclareExportDeclaration',
    'ExportNamedDeclaration',
    'ExportAllDeclaration',
    'DeclareExportAllDeclaration',
  ]),
  $r = ir(['ArrayExpression', 'TupleExpression']),
  mi = ir(['ObjectExpression', 'RecordExpression']);
function co(t) {
  return t.type === 'NumericLiteral' || (t.type === 'Literal' && typeof t.value == 'number');
}
function sF(t) {
  return t.type === 'UnaryExpression' && (t.operator === '+' || t.operator === '-') && co(t.argument);
}
function Bn(t) {
  return t.type === 'StringLiteral' || (t.type === 'Literal' && typeof t.value == 'string');
}
function oF(t) {
  return t.type === 'RegExpLiteral' || (t.type === 'Literal' && !!t.regex);
}
var ho = ir(['ObjectTypeAnnotation', 'TSTypeLiteral', 'TSMappedType']),
  tc = ir(['FunctionExpression', 'ArrowFunctionExpression']);
function NL(t) {
  return t.type === 'FunctionExpression' || (t.type === 'ArrowFunctionExpression' && t.body.type === 'BlockStatement');
}
function vm(t) {
  return (
    It(t) && t.callee.type === 'Identifier' && ['async', 'inject', 'fakeAsync', 'waitForAsync'].includes(t.callee.name)
  );
}
var _r = ir(['JSXElement', 'JSXFragment']);
function aF(t) {
  return t.kind === 'get' || t.kind === 'set';
}
function lF(t) {
  return aF(t) || mc(t, t.value);
}
function uF(t) {
  return (
    (t.type === 'ObjectTypeProperty' || t.type === 'ObjectTypeInternalSlot') &&
    t.value.type === 'FunctionTypeAnnotation' &&
    !t.static &&
    !lF(t)
  );
}
function ML(t) {
  return (
    (t.type === 'TypeAnnotation' || t.type === 'TSTypeAnnotation') &&
    t.typeAnnotation.type === 'FunctionTypeAnnotation' &&
    !t.static &&
    !mc(t, t.typeAnnotation)
  );
}
var hs = ir(['BinaryExpression', 'LogicalExpression', 'NGPipeExpression']);
function ja(t) {
  return or(t) || (t.type === 'BindExpression' && !!t.object);
}
var OL = ir([
  'TSThisType',
  'NullLiteralTypeAnnotation',
  'BooleanLiteralTypeAnnotation',
  'StringLiteralTypeAnnotation',
  'BigIntLiteralTypeAnnotation',
  'NumberLiteralTypeAnnotation',
  'TSLiteralType',
  'TSTemplateLiteralType',
]);
function Py(t) {
  return (
    nF(t) ||
    rF(t) ||
    OL(t) ||
    ((t.type === 'GenericTypeAnnotation' || t.type === 'TSTypeReference') && !t.typeParameters)
  );
}
function LL(t) {
  let e = /^(?:before|after)(?:Each|All)$/;
  return t.callee.type === 'Identifier' && t.arguments.length === 1 && e.test(t.callee.name);
}
var _L = [
  'it',
  'it.only',
  'it.skip',
  'describe',
  'describe.only',
  'describe.skip',
  'test',
  'test.only',
  'test.skip',
  'test.step',
  'test.describe',
  'test.describe.only',
  'test.describe.parallel',
  'test.describe.parallel.only',
  'test.describe.serial',
  'test.describe.serial.only',
  'skip',
  'xit',
  'xdescribe',
  'xtest',
  'fit',
  'fdescribe',
  'ftest',
];
function RL(t) {
  return TL(t, _L);
}
function _f(t, e) {
  if (t.type !== 'CallExpression') return !1;
  if (t.arguments.length === 1) {
    if (vm(t) && e && _f(e)) return tc(t.arguments[0]);
    if (LL(t)) return vm(t.arguments[0]);
  } else if (
    (t.arguments.length === 2 || t.arguments.length === 3) &&
    (t.arguments[0].type === 'TemplateLiteral' || Bn(t.arguments[0])) &&
    RL(t.callee)
  )
    return t.arguments[2] && !co(t.arguments[2])
      ? !1
      : (t.arguments.length === 2 ? tc(t.arguments[1]) : NL(t.arguments[1]) && Vr(t.arguments[1]).length <= 1) ||
          vm(t.arguments[1]);
  return !1;
}
var It = ir(['CallExpression', 'OptionalCallExpression']),
  or = ir(['MemberExpression', 'OptionalMemberExpression']);
function jL(t) {
  let e = 'expressions';
  t.type === 'TSTemplateLiteralType' && (e = 'types');
  let r = t[e];
  return r.length === 0
    ? !1
    : r.every((n) => {
        if (Me(n)) return !1;
        if (n.type === 'Identifier' || n.type === 'ThisExpression') return !0;
        if ((n.type === 'ChainExpression' && (n = n.expression), or(n))) {
          let i = n;
          for (; or(i); )
            if (
              (i.property.type !== 'Identifier' &&
                i.property.type !== 'Literal' &&
                i.property.type !== 'StringLiteral' &&
                i.property.type !== 'NumericLiteral') ||
              ((i = i.object), Me(i))
            )
              return !1;
          return i.type === 'Identifier' || i.type === 'ThisExpression';
        }
        return !1;
      });
}
function sa(t, e) {
  return _r(e) ? Rf(e) : Me(e, qe.Leading, (r) => Pn(t, zt(r)));
}
function BC(t, e) {
  return (
    e.parser !== 'json' &&
    Bn(t.key) &&
    qn(t.key).slice(1, -1) === t.key.value &&
    ((eL(t.key.value) &&
      !(
        (e.parser === 'babel-ts' && t.type === 'ClassProperty') ||
        (e.parser === 'typescript' && t.type === 'PropertyDefinition')
      )) ||
      (cF(t.key.value) &&
        String(Number(t.key.value)) === t.key.value &&
        (e.parser === 'babel' ||
          e.parser === 'acorn' ||
          e.parser === 'espree' ||
          e.parser === 'meriyah' ||
          e.parser === '__babel_estree')))
  );
}
function cF(t) {
  return /^(?:\d+|\d+\.\d+)$/.test(t);
}
function IC(t) {
  return t.quasis.some((e) =>
    e.value.raw.includes(`
`),
  );
}
function hF(t, e) {
  return (
    ((t.type === 'TemplateLiteral' && IC(t)) || (t.type === 'TaggedTemplateExpression' && IC(t.quasi))) &&
    !Pn(e, Er(t), { backwards: !0 })
  );
}
function pF(t) {
  if (!Me(t)) return !1;
  let e = Lt(!1, Iy(t, qe.Dangling), -1);
  return e && !ys(e);
}
function $L(t) {
  if (t.length <= 1) return !1;
  let e = 0;
  for (let r of t)
    if (tc(r)) {
      if (((e += 1), e > 1)) return !0;
    } else if (It(r)) {
      for (let n of r.arguments) if (tc(n)) return !0;
    }
  return !1;
}
function fF(t) {
  let { node: e, parent: r, key: n } = t;
  return n === 'callee' && It(e) && It(r) && r.arguments.length > 0 && e.arguments.length > r.arguments.length;
}
var VL = new Set(['!', '-', '+', '~']);
function ri(t, e = 2) {
  if (e <= 0) return !1;
  let r = (n) => ri(n, e - 1);
  if (oF(t)) return fl(t.pattern ?? t.regex.pattern) <= 5;
  if (
    t.type === 'Literal' ||
    t.type === 'BigIntLiteral' ||
    t.type === 'DecimalLiteral' ||
    t.type === 'BooleanLiteral' ||
    t.type === 'NullLiteral' ||
    t.type === 'NumericLiteral' ||
    t.type === 'StringLiteral' ||
    t.type === 'Identifier' ||
    t.type === 'ThisExpression' ||
    t.type === 'Super' ||
    t.type === 'PrivateName' ||
    t.type === 'PrivateIdentifier' ||
    t.type === 'ArgumentPlaceholder' ||
    t.type === 'Import'
  )
    return !0;
  if (t.type === 'TemplateLiteral')
    return (
      t.quasis.every(
        (n) =>
          !n.value.raw.includes(`
`),
      ) && t.expressions.every(r)
    );
  if (mi(t)) return t.properties.every((n) => !n.computed && (n.shorthand || (n.value && r(n.value))));
  if ($r(t)) return t.elements.every((n) => n === null || r(n));
  if (dl(t)) {
    if (t.type === 'ImportExpression' || ri(t.callee, e)) {
      let n = yo(t);
      return n.length <= e && n.every(r);
    }
    return !1;
  }
  return or(t)
    ? ri(t.object, e) && ri(t.property, e)
    : (t.type === 'UnaryExpression' && VL.has(t.operator)) || t.type === 'UpdateExpression'
    ? ri(t.argument, e)
    : t.type === 'TSNonNullExpression'
    ? ri(t.expression, e)
    : !1;
}
function qn(t) {
  var e;
  return ((e = t.extra) == null ? void 0 : e.raw) ?? t.raw;
}
function zL(t) {
  return t;
}
function go(t, e = 'es5') {
  return (t.trailingComma === 'es5' && e === 'es5') || (t.trailingComma === 'all' && (e === 'all' || e === 'es5'));
}
function rn(t, e) {
  switch (t.type) {
    case 'BinaryExpression':
    case 'LogicalExpression':
    case 'AssignmentExpression':
    case 'NGPipeExpression':
      return rn(t.left, e);
    case 'MemberExpression':
    case 'OptionalMemberExpression':
      return rn(t.object, e);
    case 'TaggedTemplateExpression':
      return t.tag.type === 'FunctionExpression' ? !1 : rn(t.tag, e);
    case 'CallExpression':
    case 'OptionalCallExpression':
      return t.callee.type === 'FunctionExpression' ? !1 : rn(t.callee, e);
    case 'ConditionalExpression':
      return rn(t.test, e);
    case 'UpdateExpression':
      return !t.prefix && rn(t.argument, e);
    case 'BindExpression':
      return t.object && rn(t.object, e);
    case 'SequenceExpression':
      return rn(t.expressions[0], e);
    case 'ChainExpression':
    case 'TSSatisfiesExpression':
    case 'TSAsExpression':
    case 'TSNonNullExpression':
      return rn(t.expression, e);
    default:
      return e(t);
  }
}
var NC = { '==': !0, '!=': !0, '===': !0, '!==': !0 },
  _h = { '*': !0, '/': !0, '%': !0 },
  ng = { '>>': !0, '>>>': !0, '<<': !0 };
function By(t, e) {
  return !(
    Vp(e) !== Vp(t) ||
    t === '**' ||
    (NC[t] && NC[e]) ||
    (e === '%' && _h[t]) ||
    (t === '%' && _h[e]) ||
    (e !== t && _h[e] && _h[t]) ||
    (ng[t] && ng[e])
  );
}
var HL = new Map(
  [
    ['|>'],
    ['??'],
    ['||'],
    ['&&'],
    ['|'],
    ['^'],
    ['&'],
    ['==', '===', '!=', '!=='],
    ['<', '>', '<=', '>=', 'in', 'instanceof'],
    ['>>', '<<', '>>>'],
    ['+', '-'],
    ['*', '/', '%'],
    ['**'],
  ].flatMap((t, e) => t.map((r) => [r, e])),
);
function Vp(t) {
  return HL.get(t);
}
function WL(t) {
  return !!ng[t] || t === '|' || t === '^' || t === '&';
}
function UL(t) {
  var e;
  if (t.rest) return !0;
  let r = Vr(t);
  return ((e = Lt(!1, r, -1)) == null ? void 0 : e.type) === 'RestElement';
}
var Fm = new WeakMap();
function Vr(t) {
  if (Fm.has(t)) return Fm.get(t);
  let e = [];
  return (
    t.this && e.push(t.this),
    Array.isArray(t.parameters) ? e.push(...t.parameters) : Array.isArray(t.params) && e.push(...t.params),
    t.rest && e.push(t.rest),
    Fm.set(t, e),
    e
  );
}
function qL(t, e) {
  let { node: r } = t,
    n = 0,
    i = (s) => e(s, n++);
  r.this && t.call(i, 'this'),
    Array.isArray(r.parameters) ? t.each(i, 'parameters') : Array.isArray(r.params) && t.each(i, 'params'),
    r.rest && t.call(i, 'rest');
}
var Sm = new WeakMap();
function yo(t) {
  if (Sm.has(t)) return Sm.get(t);
  let e = t.arguments;
  return t.type === 'ImportExpression' && ((e = [t.source]), t.attributes && e.push(t.attributes)), Sm.set(t, e), e;
}
function dF(t, e) {
  let { node: r } = t;
  r.type === 'ImportExpression'
    ? (t.call((n) => e(n, 0), 'source'), r.attributes && t.call((n) => e(n, 1), 'attributes'))
    : t.each(e, 'arguments');
}
function MC(t, e) {
  if (t.type === 'ImportExpression') {
    if (e === 0 || e === (t.attributes ? -2 : -1)) return 'source';
    if (t.attributes && (e === 1 || e === -1)) return 'attributes';
    throw new RangeError('Invalid argument index');
  }
  if ((e < 0 && (e = t.arguments.length + e), e < 0 || e >= t.arguments.length))
    throw new RangeError('Invalid argument index');
  return ['arguments', e];
}
function zp(t) {
  return t.value.trim() === 'prettier-ignore' && !t.unignore;
}
function Rf(t) {
  return (t == null ? void 0 : t.prettierIgnore) || Me(t, qe.PrettierIgnore);
}
var qe = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 },
  mF = (t, e) => {
    if ((typeof t == 'function' && ((e = t), (t = 0)), t || e))
      return (r, n, i) =>
        !(
          (t & qe.Leading && !r.leading) ||
          (t & qe.Trailing && !r.trailing) ||
          (t & qe.Dangling && (r.leading || r.trailing)) ||
          (t & qe.Block && !ys(r)) ||
          (t & qe.Line && !ky(r)) ||
          (t & qe.First && n !== 0) ||
          (t & qe.Last && n !== i.length - 1) ||
          (t & qe.PrettierIgnore && !zp(r)) ||
          (e && !e(r))
        );
  };
function Me(t, e, r) {
  if (!kt(t == null ? void 0 : t.comments)) return !1;
  let n = mF(e, r);
  return n ? t.comments.some(n) : !0;
}
function Iy(t, e, r) {
  if (!Array.isArray(t == null ? void 0 : t.comments)) return [];
  let n = mF(e, r);
  return n ? t.comments.filter(n) : t.comments;
}
var Do = (t, { originalText: e }) => wy(e, zt(t));
function dl(t) {
  return It(t) || t.type === 'NewExpression' || t.type === 'ImportExpression';
}
function Ds(t) {
  return t && (t.type === 'ObjectProperty' || (t.type === 'Property' && !t.method && t.kind === 'init'));
}
var ig = Symbol('ifWithoutBlockAndSameLineComment'),
  Qs = ir(['TSAsExpression', 'TSSatisfiesExpression']);
function sg(t, e) {
  var r, n, i, s, o, l, c;
  if (t.isRoot) return !1;
  let { node: p, key: f, parent: m } = t;
  if (e.__isInHtmlInterpolation && !e.bracketSpacing && GL(p) && du(t)) return !0;
  if (KL(p)) return !1;
  if (p.type === 'Identifier') {
    if (
      ((r = p.extra) != null && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(p.name)) ||
      (f === 'left' && ((p.name === 'async' && !m.await) || p.name === 'let') && m.type === 'ForOfStatement')
    )
      return !0;
    if (p.name === 'let') {
      let g = (n = t.findAncestor((x) => x.type === 'ForOfStatement')) == null ? void 0 : n.left;
      if (g && rn(g, (x) => x === p)) return !0;
    }
    if (f === 'object' && p.name === 'let' && m.type === 'MemberExpression' && m.computed && !m.optional) {
      let g = t.findAncestor(
          (b) => b.type === 'ExpressionStatement' || b.type === 'ForStatement' || b.type === 'ForInStatement',
        ),
        x = g
          ? g.type === 'ExpressionStatement'
            ? g.expression
            : g.type === 'ForStatement'
            ? g.init
            : g.left
          : void 0;
      if (x && rn(x, (b) => b === p)) return !0;
    }
    return !1;
  }
  if (
    p.type === 'ObjectExpression' ||
    p.type === 'FunctionExpression' ||
    p.type === 'ClassExpression' ||
    p.type === 'DoExpression'
  ) {
    let g = (i = t.findAncestor((x) => x.type === 'ExpressionStatement')) == null ? void 0 : i.expression;
    if (g && rn(g, (x) => x === p)) return !0;
  }
  if (p.type === 'ObjectExpression') {
    let g = (s = t.findAncestor((x) => x.type === 'ArrowFunctionExpression')) == null ? void 0 : s.body;
    if (g && g.type !== 'SequenceExpression' && g.type !== 'AssignmentExpression' && rn(g, (x) => x === p)) return !0;
  }
  switch (m.type) {
    case 'ParenthesizedExpression':
      return !1;
    case 'ClassDeclaration':
    case 'ClassExpression':
      if (
        f === 'superClass' &&
        (p.type === 'ArrowFunctionExpression' ||
          p.type === 'AssignmentExpression' ||
          p.type === 'AwaitExpression' ||
          p.type === 'BinaryExpression' ||
          p.type === 'ConditionalExpression' ||
          p.type === 'LogicalExpression' ||
          p.type === 'NewExpression' ||
          p.type === 'ObjectExpression' ||
          p.type === 'SequenceExpression' ||
          p.type === 'TaggedTemplateExpression' ||
          p.type === 'UnaryExpression' ||
          p.type === 'UpdateExpression' ||
          p.type === 'YieldExpression' ||
          p.type === 'TSNonNullExpression' ||
          (p.type === 'ClassExpression' && kt(p.decorators)))
      )
        return !0;
      break;
    case 'ExportDefaultDeclaration':
      return gF(t, e) || p.type === 'SequenceExpression';
    case 'Decorator':
      if (f === 'expression') {
        if (or(p) && p.computed) return !0;
        let g = !1,
          x = !1,
          b = p;
        for (; b; )
          switch (b.type) {
            case 'MemberExpression':
              (x = !0), (b = b.object);
              break;
            case 'CallExpression':
              if (x || g) return e.parser !== 'typescript';
              (g = !0), (b = b.callee);
              break;
            case 'Identifier':
              return !1;
            case 'TaggedTemplateExpression':
              return e.parser !== 'typescript';
            default:
              return !0;
          }
        return !0;
      }
      break;
    case 'TypeAnnotation':
      if (t.match(void 0, void 0, (g, x) => x === 'returnType' && g.type === 'ArrowFunctionExpression') && XL(p))
        return !0;
      break;
  }
  switch (p.type) {
    case 'UpdateExpression':
      if (m.type === 'UnaryExpression')
        return p.prefix && ((p.operator === '++' && m.operator === '+') || (p.operator === '--' && m.operator === '-'));
    case 'UnaryExpression':
      switch (m.type) {
        case 'UnaryExpression':
          return p.operator === m.operator && (p.operator === '+' || p.operator === '-');
        case 'BindExpression':
          return !0;
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return f === 'object';
        case 'TaggedTemplateExpression':
          return !0;
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return f === 'callee';
        case 'BinaryExpression':
          return f === 'left' && m.operator === '**';
        case 'TSNonNullExpression':
          return !0;
        default:
          return !1;
      }
    case 'BinaryExpression':
      if (m.type === 'UpdateExpression' || (p.operator === 'in' && JL(t))) return !0;
      if (p.operator === '|>' && (o = p.extra) != null && o.parenthesized) {
        let g = t.grandparent;
        if (g.type === 'BinaryExpression' && g.operator === '|>') return !0;
      }
    case 'TSTypeAssertion':
    case 'TSAsExpression':
    case 'TSSatisfiesExpression':
    case 'LogicalExpression':
      switch (m.type) {
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
          return !Qs(p);
        case 'ConditionalExpression':
          return Qs(p);
        case 'CallExpression':
        case 'NewExpression':
        case 'OptionalCallExpression':
          return f === 'callee';
        case 'ClassExpression':
        case 'ClassDeclaration':
          return f === 'superClass';
        case 'TSTypeAssertion':
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'JSXSpreadAttribute':
        case 'SpreadElement':
        case 'BindExpression':
        case 'AwaitExpression':
        case 'TSNonNullExpression':
        case 'UpdateExpression':
          return !0;
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return f === 'object';
        case 'AssignmentExpression':
        case 'AssignmentPattern':
          return f === 'left' && (p.type === 'TSTypeAssertion' || Qs(p));
        case 'LogicalExpression':
          if (p.type === 'LogicalExpression') return m.operator !== p.operator;
        case 'BinaryExpression': {
          let { operator: g, type: x } = p;
          if (!g && x !== 'TSTypeAssertion') return !0;
          let b = Vp(g),
            F = m.operator,
            E = Vp(F);
          return E > b || (f === 'right' && E === b) || (E === b && !By(F, g))
            ? !0
            : E < b && g === '%'
            ? F === '+' || F === '-'
            : !!WL(F);
        }
        default:
          return !1;
      }
    case 'SequenceExpression':
      switch (m.type) {
        case 'ReturnStatement':
          return !1;
        case 'ForStatement':
          return !1;
        case 'ExpressionStatement':
          return f !== 'expression';
        case 'ArrowFunctionExpression':
          return f !== 'body';
        default:
          return !0;
      }
    case 'YieldExpression':
      if (m.type === 'AwaitExpression') return !0;
    case 'AwaitExpression':
      switch (m.type) {
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'LogicalExpression':
        case 'SpreadElement':
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
        case 'TSNonNullExpression':
        case 'BindExpression':
          return !0;
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return f === 'object';
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return f === 'callee';
        case 'ConditionalExpression':
          return f === 'test';
        case 'BinaryExpression':
          return !(!p.argument && m.operator === '|>');
        default:
          return !1;
      }
    case 'TSFunctionType':
      if (
        t.match(
          (g) => g.type === 'TSFunctionType',
          (g, x) => x === 'typeAnnotation' && g.type === 'TSTypeAnnotation',
          (g, x) => x === 'returnType' && g.type === 'ArrowFunctionExpression',
        )
      )
        return !0;
    case 'TSConditionalType':
    case 'TSConstructorType':
      if (f === 'extendsType' && m.type === 'TSConditionalType') {
        if (p.type === 'TSConditionalType') return !0;
        let { typeAnnotation: g } = p.returnType || p.typeAnnotation;
        if (
          (g.type === 'TSTypePredicate' && g.typeAnnotation && (g = g.typeAnnotation.typeAnnotation),
          g.type === 'TSInferType' && g.typeParameter.constraint)
        )
          return !0;
      }
      if (f === 'checkType' && m.type === 'TSConditionalType') return !0;
    case 'TSUnionType':
    case 'TSIntersectionType':
      if (
        (m.type === 'TSUnionType' || m.type === 'TSIntersectionType') &&
        m.types.length > 1 &&
        (!p.types || p.types.length > 1)
      )
        return !0;
    case 'TSInferType':
      if (p.type === 'TSInferType' && m.type === 'TSRestType') return !1;
    case 'TSTypeOperator':
      return (
        m.type === 'TSArrayType' ||
        m.type === 'TSOptionalType' ||
        m.type === 'TSRestType' ||
        (f === 'objectType' && m.type === 'TSIndexedAccessType') ||
        m.type === 'TSTypeOperator' ||
        (m.type === 'TSTypeAnnotation' && t.grandparent.type.startsWith('TSJSDoc'))
      );
    case 'TSTypeQuery':
      return (
        (f === 'objectType' && m.type === 'TSIndexedAccessType') || (f === 'elementType' && m.type === 'TSArrayType')
      );
    case 'TypeofTypeAnnotation':
      return (
        (f === 'objectType' && (m.type === 'IndexedAccessType' || m.type === 'OptionalIndexedAccessType')) ||
        (f === 'elementType' && m.type === 'ArrayTypeAnnotation')
      );
    case 'ArrayTypeAnnotation':
      return m.type === 'NullableTypeAnnotation';
    case 'IntersectionTypeAnnotation':
    case 'UnionTypeAnnotation':
      return (
        m.type === 'ArrayTypeAnnotation' ||
        m.type === 'NullableTypeAnnotation' ||
        m.type === 'IntersectionTypeAnnotation' ||
        m.type === 'UnionTypeAnnotation' ||
        (f === 'objectType' && (m.type === 'IndexedAccessType' || m.type === 'OptionalIndexedAccessType'))
      );
    case 'InferTypeAnnotation':
    case 'NullableTypeAnnotation':
      return (
        m.type === 'ArrayTypeAnnotation' ||
        (f === 'objectType' && (m.type === 'IndexedAccessType' || m.type === 'OptionalIndexedAccessType'))
      );
    case 'FunctionTypeAnnotation': {
      if (
        t.match(
          void 0,
          (x, b) => b === 'typeAnnotation' && x.type === 'TypeAnnotation',
          (x, b) => b === 'returnType' && x.type === 'ArrowFunctionExpression',
        ) ||
        t.match(
          void 0,
          (x, b) => b === 'typeAnnotation' && x.type === 'TypePredicate',
          (x, b) => b === 'typeAnnotation' && x.type === 'TypeAnnotation',
          (x, b) => b === 'returnType' && x.type === 'ArrowFunctionExpression',
        )
      )
        return !0;
      let g = m.type === 'NullableTypeAnnotation' ? t.grandparent : m;
      return (
        g.type === 'UnionTypeAnnotation' ||
        g.type === 'IntersectionTypeAnnotation' ||
        g.type === 'ArrayTypeAnnotation' ||
        (f === 'objectType' && (g.type === 'IndexedAccessType' || g.type === 'OptionalIndexedAccessType')) ||
        (f === 'checkType' && m.type === 'ConditionalTypeAnnotation') ||
        (f === 'extendsType' &&
          m.type === 'ConditionalTypeAnnotation' &&
          p.returnType.type === 'InferTypeAnnotation' &&
          p.returnType.typeParameter.bound) ||
        g.type === 'NullableTypeAnnotation' ||
        (m.type === 'FunctionTypeParam' &&
          m.name === null &&
          Vr(p).some((x) => {
            var b;
            return ((b = x.typeAnnotation) == null ? void 0 : b.type) === 'NullableTypeAnnotation';
          }))
      );
    }
    case 'ConditionalTypeAnnotation':
      if (
        (f === 'extendsType' && m.type === 'ConditionalTypeAnnotation' && p.type === 'ConditionalTypeAnnotation') ||
        (f === 'checkType' && m.type === 'ConditionalTypeAnnotation')
      )
        return !0;
    case 'OptionalIndexedAccessType':
      return f === 'objectType' && m.type === 'IndexedAccessType';
    case 'StringLiteral':
    case 'NumericLiteral':
    case 'Literal':
      if (typeof p.value == 'string' && m.type === 'ExpressionStatement' && !m.directive) {
        let g = t.grandparent;
        return g.type === 'Program' || g.type === 'BlockStatement';
      }
      return f === 'object' && m.type === 'MemberExpression' && typeof p.value == 'number';
    case 'AssignmentExpression': {
      let g = t.grandparent;
      return f === 'body' && m.type === 'ArrowFunctionExpression'
        ? !0
        : (f === 'key' && (m.type === 'ClassProperty' || m.type === 'PropertyDefinition') && m.computed) ||
          ((f === 'init' || f === 'update') && m.type === 'ForStatement')
        ? !1
        : m.type === 'ExpressionStatement'
        ? p.left.type === 'ObjectPattern'
        : !(
            (f === 'key' && m.type === 'TSPropertySignature') ||
            m.type === 'AssignmentExpression' ||
            (m.type === 'SequenceExpression' && g.type === 'ForStatement' && (g.init === m || g.update === m)) ||
            (f === 'value' && m.type === 'Property' && g.type === 'ObjectPattern' && g.properties.includes(m)) ||
            m.type === 'NGChainedExpression'
          );
    }
    case 'ConditionalExpression':
      switch (m.type) {
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'SpreadElement':
        case 'BinaryExpression':
        case 'LogicalExpression':
        case 'NGPipeExpression':
        case 'ExportDefaultDeclaration':
        case 'AwaitExpression':
        case 'JSXSpreadAttribute':
        case 'TSTypeAssertion':
        case 'TypeCastExpression':
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
        case 'TSNonNullExpression':
          return !0;
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return f === 'callee';
        case 'ConditionalExpression':
          return f === 'test';
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return f === 'object';
        default:
          return !1;
      }
    case 'FunctionExpression':
      switch (m.type) {
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return f === 'callee';
        case 'TaggedTemplateExpression':
          return !0;
        default:
          return !1;
      }
    case 'ArrowFunctionExpression':
      switch (m.type) {
        case 'BinaryExpression':
          return m.operator !== '|>' || ((l = p.extra) == null ? void 0 : l.parenthesized);
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return f === 'callee';
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return f === 'object';
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
        case 'TSNonNullExpression':
        case 'BindExpression':
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'LogicalExpression':
        case 'AwaitExpression':
        case 'TSTypeAssertion':
          return !0;
        case 'ConditionalExpression':
          return f === 'test';
        default:
          return !1;
      }
    case 'ClassExpression':
      switch (m.type) {
        case 'NewExpression':
          return f === 'callee';
        default:
          return !1;
      }
    case 'OptionalMemberExpression':
    case 'OptionalCallExpression':
    case 'CallExpression':
    case 'MemberExpression':
      if (YL(t)) return !0;
    case 'TaggedTemplateExpression':
    case 'TSNonNullExpression':
      if (f === 'callee' && (m.type === 'BindExpression' || m.type === 'NewExpression')) {
        let g = p;
        for (; g; )
          switch (g.type) {
            case 'CallExpression':
            case 'OptionalCallExpression':
              return !0;
            case 'MemberExpression':
            case 'OptionalMemberExpression':
            case 'BindExpression':
              g = g.object;
              break;
            case 'TaggedTemplateExpression':
              g = g.tag;
              break;
            case 'TSNonNullExpression':
              g = g.expression;
              break;
            default:
              return !1;
          }
      }
      return !1;
    case 'BindExpression':
      return (
        (f === 'callee' && (m.type === 'BindExpression' || m.type === 'NewExpression')) || (f === 'object' && or(m))
      );
    case 'NGPipeExpression':
      return !(
        m.type === 'NGRoot' ||
        m.type === 'NGMicrosyntaxExpression' ||
        (m.type === 'ObjectProperty' && !((c = p.extra) != null && c.parenthesized)) ||
        $r(m) ||
        (f === 'arguments' && It(m)) ||
        (f === 'right' && m.type === 'NGPipeExpression') ||
        (f === 'property' && m.type === 'MemberExpression') ||
        m.type === 'AssignmentExpression'
      );
    case 'JSXFragment':
    case 'JSXElement':
      return (
        f === 'callee' ||
        (f === 'left' && m.type === 'BinaryExpression' && m.operator === '<') ||
        (!$r(m) &&
          m.type !== 'ArrowFunctionExpression' &&
          m.type !== 'AssignmentExpression' &&
          m.type !== 'AssignmentPattern' &&
          m.type !== 'BinaryExpression' &&
          m.type !== 'NewExpression' &&
          m.type !== 'ConditionalExpression' &&
          m.type !== 'ExpressionStatement' &&
          m.type !== 'JsExpressionRoot' &&
          m.type !== 'JSXAttribute' &&
          m.type !== 'JSXElement' &&
          m.type !== 'JSXExpressionContainer' &&
          m.type !== 'JSXFragment' &&
          m.type !== 'LogicalExpression' &&
          !It(m) &&
          !Ds(m) &&
          m.type !== 'ReturnStatement' &&
          m.type !== 'ThrowStatement' &&
          m.type !== 'TypeCastExpression' &&
          m.type !== 'VariableDeclarator' &&
          m.type !== 'YieldExpression')
      );
    case 'TSInstantiationExpression':
      return f === 'object' && or(m);
  }
  return !1;
}
var KL = ir([
  'BlockStatement',
  'BreakStatement',
  'ClassBody',
  'ClassDeclaration',
  'ClassMethod',
  'ClassProperty',
  'PropertyDefinition',
  'ClassPrivateProperty',
  'ContinueStatement',
  'DebuggerStatement',
  'DeclareClass',
  'DeclareExportAllDeclaration',
  'DeclareExportDeclaration',
  'DeclareFunction',
  'DeclareInterface',
  'DeclareModule',
  'DeclareModuleExports',
  'DeclareVariable',
  'DeclareEnum',
  'DoWhileStatement',
  'EnumDeclaration',
  'ExportAllDeclaration',
  'ExportDefaultDeclaration',
  'ExportNamedDeclaration',
  'ExpressionStatement',
  'ForInStatement',
  'ForOfStatement',
  'ForStatement',
  'FunctionDeclaration',
  'IfStatement',
  'ImportDeclaration',
  'InterfaceDeclaration',
  'LabeledStatement',
  'MethodDefinition',
  'ReturnStatement',
  'SwitchStatement',
  'ThrowStatement',
  'TryStatement',
  'TSDeclareFunction',
  'TSEnumDeclaration',
  'TSImportEqualsDeclaration',
  'TSInterfaceDeclaration',
  'TSModuleDeclaration',
  'TSNamespaceExportDeclaration',
  'TypeAlias',
  'VariableDeclaration',
  'WhileStatement',
  'WithStatement',
]);
function JL(t) {
  let e = 0,
    { node: r } = t;
  for (; r; ) {
    let n = t.getParentNode(e++);
    if ((n == null ? void 0 : n.type) === 'ForStatement' && n.init === r) return !0;
    r = n;
  }
  return !1;
}
function XL(t) {
  return rg(t, (e) => e.type === 'ObjectTypeAnnotation' && rg(e, (r) => r.type === 'FunctionTypeAnnotation'));
}
function GL(t) {
  return mi(t);
}
function du(t) {
  let { parent: e, key: r } = t;
  switch (e.type) {
    case 'NGPipeExpression':
      if (r === 'arguments' && t.isLast) return t.callParent(du);
      break;
    case 'ObjectProperty':
      if (r === 'value') return t.callParent(() => t.key === 'properties' && t.isLast);
      break;
    case 'BinaryExpression':
    case 'LogicalExpression':
      if (r === 'right') return t.callParent(du);
      break;
    case 'ConditionalExpression':
      if (r === 'alternate') return t.callParent(du);
      break;
    case 'UnaryExpression':
      if (e.prefix) return t.callParent(du);
      break;
  }
  return !1;
}
function gF(t, e) {
  let { node: r, parent: n } = t;
  return r.type === 'FunctionExpression' || r.type === 'ClassExpression'
    ? n.type === 'ExportDefaultDeclaration' || !sg(t, e)
    : !Ty(r) || (n.type !== 'ExportDefaultDeclaration' && sg(t, e))
    ? !1
    : t.call(() => gF(t, e), ...iF(r));
}
function YL(t) {
  let { node: e, parent: r, grandparent: n, key: i } = t;
  return !!(
    ((e.type === 'OptionalMemberExpression' || e.type === 'OptionalCallExpression') &&
      ((i === 'object' && r.type === 'MemberExpression') ||
        (i === 'callee' && (r.type === 'CallExpression' || r.type === 'NewExpression')) ||
        (r.type === 'TSNonNullExpression' && n.type === 'MemberExpression' && n.object === r))) ||
    (t.match(
      () => e.type === 'CallExpression' || e.type === 'MemberExpression',
      (s, o) => o === 'expression' && s.type === 'ChainExpression',
    ) &&
      (t.match(
        void 0,
        void 0,
        (s, o) =>
          (o === 'callee' && ((s.type === 'CallExpression' && !s.optional) || s.type === 'NewExpression')) ||
          (o === 'object' && s.type === 'MemberExpression' && !s.optional),
      ) ||
        t.match(
          void 0,
          void 0,
          (s, o) => o === 'expression' && s.type === 'TSNonNullExpression',
          (s, o) => o === 'object' && s.type === 'MemberExpression',
        ))) ||
    t.match(
      () => e.type === 'CallExpression' || e.type === 'MemberExpression',
      (s, o) => o === 'expression' && s.type === 'TSNonNullExpression',
      (s, o) => o === 'expression' && s.type === 'ChainExpression',
      (s, o) => o === 'object' && s.type === 'MemberExpression',
    )
  );
}
var kl = sg,
  QL = (t, e, r, n) => {
    if (!(t && e == null)) return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
  },
  Tn = QL;
function ZL(t, e) {
  let r = e - 1;
  (r = hl(t, r, { backwards: !0 })), (r = pl(t, r, { backwards: !0 })), (r = hl(t, r, { backwards: !0 }));
  let n = pl(t, r, { backwards: !0 });
  return r !== n;
}
var e_ = ZL,
  t_ = () => !0;
function Ny(t, e) {
  let r = t.node;
  return (r.printed = !0), e.printer.printComment(t, e);
}
function r_(t, e) {
  var r;
  let n = t.node,
    i = [Ny(t, e)],
    { printer: s, originalText: o, locStart: l, locEnd: c } = e;
  if ((r = s.isBlockComment) != null && r.call(s, n)) {
    let f = Pn(o, c(n)) ? (Pn(o, l(n), { backwards: !0 }) ? Ee : We) : ' ';
    i.push(f);
  } else i.push(Ee);
  let p = pl(o, hl(o, c(n)));
  return p !== !1 && Pn(o, p) && i.push(Ee), i;
}
function n_(t, e, r) {
  var n;
  let i = t.node,
    s = Ny(t, e),
    { printer: o, originalText: l, locStart: c } = e,
    p = (n = o.isBlockComment) == null ? void 0 : n.call(o, i);
  if ((r != null && r.hasLineSuffix && !(r != null && r.isBlock)) || Pn(l, c(i), { backwards: !0 })) {
    let f = e_(l, c(i));
    return { doc: TC([Ee, f ? Ee : '', s]), isBlock: p, hasLineSuffix: !0 };
  }
  return !p || (r != null && r.hasLineSuffix)
    ? { doc: [TC([' ', s]), uo], isBlock: p, hasLineSuffix: !0 }
    : { doc: [' ', s], isBlock: p, hasLineSuffix: !1 };
}
function dr(t, e, r = {}) {
  let { node: n } = t;
  if (!kt(n == null ? void 0 : n.comments)) return '';
  let { indent: i = !1, marker: s, filter: o = t_ } = r,
    l = [];
  if (
    (t.each(({ node: p }) => {
      p.leading || p.trailing || p.marker !== s || !o(p) || l.push(Ny(t, e));
    }, 'comments'),
    l.length === 0)
  )
    return '';
  let c = vt(Ee, l);
  return i ? Se([Ee, c]) : c;
}
function yF(t, e) {
  let r = t.node;
  if (!r) return {};
  let n = e[Symbol.for('printedComments')];
  if ((r.comments || []).filter((l) => !n.has(l)).length === 0) return { leading: '', trailing: '' };
  let i = [],
    s = [],
    o;
  return (
    t.each(() => {
      let l = t.node;
      if (n != null && n.has(l)) return;
      let { leading: c, trailing: p } = l;
      c ? i.push(r_(t, e)) : p && ((o = n_(t, e, o)), s.push(o.doc));
    }, 'comments'),
    { leading: i, trailing: s }
  );
}
function hi(t, e, r) {
  let { leading: n, trailing: i } = yF(t, r);
  return !n && !i ? e : tg(e, (s) => [n, s, i]);
}
var i_ = class extends Error {
    constructor(e, r, n = 'type') {
      super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`);
      ko(this, 'name', 'UnexpectedNodeError');
      this.node = e;
    }
  },
  Pl = i_,
  Rh = "'",
  OC = '"';
function s_(t, e) {
  let r = e === !0 || e === Rh ? Rh : OC,
    n = r === Rh ? OC : Rh,
    i = 0,
    s = 0;
  for (let o of t) o === r ? i++ : o === n && s++;
  return i > s ? n : r;
}
var DF = s_;
function o_(t) {
  if (typeof t != 'string') throw new TypeError('Expected a string');
  return t.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
var ei,
  a_ = class {
    constructor(t) {
      T5(this, ei, void 0), k5(this, ei, new Set(t));
    }
    getLeadingWhitespaceCount(t) {
      let e = Ps(this, ei),
        r = 0;
      for (let n = 0; n < t.length && e.has(t.charAt(n)); n++) r++;
      return r;
    }
    getTrailingWhitespaceCount(t) {
      let e = Ps(this, ei),
        r = 0;
      for (let n = t.length - 1; n >= 0 && e.has(t.charAt(n)); n--) r++;
      return r;
    }
    getLeadingWhitespace(t) {
      let e = this.getLeadingWhitespaceCount(t);
      return t.slice(0, e);
    }
    getTrailingWhitespace(t) {
      let e = this.getTrailingWhitespaceCount(t);
      return t.slice(t.length - e);
    }
    hasLeadingWhitespace(t) {
      return Ps(this, ei).has(t.charAt(0));
    }
    hasTrailingWhitespace(t) {
      return Ps(this, ei).has(Lt(!1, t, -1));
    }
    trimStart(t) {
      let e = this.getLeadingWhitespaceCount(t);
      return t.slice(e);
    }
    trimEnd(t) {
      let e = this.getTrailingWhitespaceCount(t);
      return t.slice(0, t.length - e);
    }
    trim(t) {
      return this.trimEnd(this.trimStart(t));
    }
    split(t, e = !1) {
      let r = `[${o_([...Ps(this, ei)].join(''))}]+`,
        n = new RegExp(e ? `(${r})` : r);
      return t.split(n);
    }
    hasWhitespaceCharacter(t) {
      let e = Ps(this, ei);
      return Array.prototype.some.call(t, (r) => e.has(r));
    }
    hasNonWhitespaceCharacter(t) {
      let e = Ps(this, ei);
      return Array.prototype.some.call(t, (r) => !e.has(r));
    }
    isWhitespaceOnly(t) {
      let e = Ps(this, ei);
      return Array.prototype.every.call(t, (r) => e.has(r));
    }
  };
ei = new WeakMap();
var l_ = a_,
  xF = {};
Of(xF, { endOfLine: () => g_, ownLine: () => m_, remaining: () => y_ });
function u_(t, e) {
  let r = null,
    n = e;
  for (; n !== r; ) (r = n), (n = hl(t, n)), (n = Fy(t, n)), (n = Sy(t, n)), (n = pl(t, n));
  return n;
}
var Qo = u_;
function c_(t, e) {
  let r = Qo(t, e);
  return r === !1 ? '' : t.charAt(r);
}
var ps = c_;
function h_(t, e, r) {
  for (let n = e; n < r; ++n)
    if (
      t.charAt(n) ===
      `
`
    )
      return !0;
  return !1;
}
var gc = h_;
function p_(t) {
  let e = t.type || t.kind || '(unknown type)',
    r = String(
      t.name ||
        (t.id && (typeof t.id == 'object' ? t.id.name : t.id)) ||
        (t.key && (typeof t.key == 'object' ? t.key.name : t.key)) ||
        (t.value && (typeof t.value == 'object' ? '' : String(t.value))) ||
        t.operator ||
        '',
    );
  return r.length > 20 && (r = r.slice(0, 19) + '…'), e + (r ? ' ' + r : '');
}
function My(t, e) {
  (t.comments ?? (t.comments = [])).push(e), (e.printed = !1), (e.nodeDescription = p_(t));
}
function zr(t, e) {
  (e.leading = !0), (e.trailing = !1), My(t, e);
}
function pi(t, e, r) {
  (e.leading = !1), (e.trailing = !1), r && (e.marker = r), My(t, e);
}
function kr(t, e) {
  (e.leading = !1), (e.trailing = !0), My(t, e);
}
function f_(t) {
  return ys(t) && t.value[0] === '*' && /@(?:type|satisfies)\b/.test(t.value);
}
var d_ = f_;
function m_(t) {
  return [SF, EF, x_, Oy, Ly, CF, bF, B_, k_, Ry, FF, I_, AF, vF, _y].some((e) => e(t));
}
function g_(t) {
  return [D_, EF, C_, FF, Oy, Ly, CF, bF, vF, T_, P_, Ry, O_, _y, R_].some((e) => e(t));
}
function y_(t) {
  return [SF, Oy, Ly, b_, w_, AF, Ry, S_, F_, __, _y, L_].some((e) => e(t));
}
function da(t, e) {
  let r = (t.body || t.properties).find(({ type: n }) => n !== 'EmptyStatement');
  r ? zr(r, e) : pi(t, e);
}
function og(t, e) {
  t.type === 'BlockStatement' ? da(t, e) : zr(t, e);
}
function D_({ comment: t, followingNode: e }) {
  return e && d_(t) ? (zr(e, t), !0) : !1;
}
function Oy({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  if ((r == null ? void 0 : r.type) !== 'IfStatement' || !n) return !1;
  if (ps(i, zt(t)) === ')') return kr(e, t), !0;
  if (e === r.consequent && n === r.alternate) {
    if (e.type === 'BlockStatement') kr(e, t);
    else {
      let s = t.type === 'SingleLine' || t.loc.start.line === t.loc.end.line,
        o = t.loc.start.line === e.loc.start.line;
      s && o ? pi(e, t, e.type === 'ExpressionStatement' ? ig : void 0) : pi(r, t);
    }
    return !0;
  }
  return n.type === 'BlockStatement'
    ? (da(n, t), !0)
    : n.type === 'IfStatement'
    ? (og(n.consequent, t), !0)
    : r.consequent === n
    ? (zr(n, t), !0)
    : !1;
}
function Ly({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  return (r == null ? void 0 : r.type) !== 'WhileStatement' || !n
    ? !1
    : ps(i, zt(t)) === ')'
    ? (kr(e, t), !0)
    : n.type === 'BlockStatement'
    ? (da(n, t), !0)
    : r.body === n
    ? (zr(n, t), !0)
    : !1;
}
function CF({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return ((r == null ? void 0 : r.type) !== 'TryStatement' && (r == null ? void 0 : r.type) !== 'CatchClause') || !n
    ? !1
    : r.type === 'CatchClause' && e
    ? (kr(e, t), !0)
    : n.type === 'BlockStatement'
    ? (da(n, t), !0)
    : n.type === 'TryStatement'
    ? (og(n.finalizer, t), !0)
    : n.type === 'CatchClause'
    ? (og(n.body, t), !0)
    : !1;
}
function x_({ comment: t, enclosingNode: e, followingNode: r }) {
  return or(e) && (r == null ? void 0 : r.type) === 'Identifier' ? (zr(e, t), !0) : !1;
}
function C_({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  let s = e && !gc(i, zt(e), Er(t));
  return (!e || !s) &&
    ((r == null ? void 0 : r.type) === 'ConditionalExpression' ||
      (r == null ? void 0 : r.type) === 'TSConditionalType') &&
    n
    ? (zr(n, t), !0)
    : !1;
}
function b_({ comment: t, precedingNode: e, enclosingNode: r }) {
  return Ds(r) && r.shorthand && r.key === e && r.value.type === 'AssignmentPattern' ? (kr(r.value.left, t), !0) : !1;
}
var A_ = new Set([
  'ClassDeclaration',
  'ClassExpression',
  'DeclareClass',
  'DeclareInterface',
  'InterfaceDeclaration',
  'TSInterfaceDeclaration',
]);
function bF({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  if (A_.has(r == null ? void 0 : r.type)) {
    if (kt(r.decorators) && (n == null ? void 0 : n.type) !== 'Decorator') return kr(Lt(!1, r.decorators, -1), t), !0;
    if (r.body && n === r.body) return da(r.body, t), !0;
    if (n) {
      if (r.superClass && n === r.superClass && e && (e === r.id || e === r.typeParameters)) return kr(e, t), !0;
      for (let i of ['implements', 'extends', 'mixins'])
        if (r[i] && n === r[i][0])
          return e && (e === r.id || e === r.typeParameters || e === r.superClass) ? kr(e, t) : pi(r, t, i), !0;
    }
  }
  return !1;
}
var E_ = new Set([
  'ClassMethod',
  'ClassProperty',
  'PropertyDefinition',
  'TSAbstractPropertyDefinition',
  'TSAbstractMethodDefinition',
  'TSDeclareMethod',
  'MethodDefinition',
  'ClassAccessorProperty',
  'AccessorProperty',
  'TSAbstractAccessorProperty',
]);
function AF({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  return (r &&
    e &&
    ps(n, zt(t)) === '(' &&
    (r.type === 'Property' || r.type === 'TSDeclareMethod' || r.type === 'TSAbstractMethodDefinition') &&
    e.type === 'Identifier' &&
    r.key === e &&
    ps(n, zt(e)) !== ':') ||
    ((e == null ? void 0 : e.type) === 'Decorator' && E_.has(r == null ? void 0 : r.type))
    ? (kr(e, t), !0)
    : !1;
}
var v_ = new Set(['FunctionDeclaration', 'FunctionExpression', 'ClassMethod', 'MethodDefinition', 'ObjectMethod']);
function F_({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  return ps(n, zt(t)) !== '(' ? !1 : e && v_.has(r == null ? void 0 : r.type) ? (kr(e, t), !0) : !1;
}
function S_({ comment: t, enclosingNode: e, text: r }) {
  if ((e == null ? void 0 : e.type) !== 'ArrowFunctionExpression') return !1;
  let n = Qo(r, zt(t));
  return n !== !1 && r.slice(n, n + 2) === '=>' ? (pi(e, t), !0) : !1;
}
function w_({ comment: t, enclosingNode: e, text: r }) {
  return ps(r, zt(t)) !== ')'
    ? !1
    : e && ((wF(e) && Vr(e).length === 0) || (dl(e) && yo(e).length === 0))
    ? (pi(e, t), !0)
    : ((e == null ? void 0 : e.type) === 'MethodDefinition' ||
        (e == null ? void 0 : e.type) === 'TSAbstractMethodDefinition') &&
      Vr(e.value).length === 0
    ? (pi(e.value, t), !0)
    : !1;
}
function EF({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  if (
    ((e == null ? void 0 : e.type) === 'FunctionTypeParam' &&
      (r == null ? void 0 : r.type) === 'FunctionTypeAnnotation' &&
      (n == null ? void 0 : n.type) !== 'FunctionTypeParam') ||
    (((e == null ? void 0 : e.type) === 'Identifier' ||
      (e == null ? void 0 : e.type) === 'AssignmentPattern' ||
      (e == null ? void 0 : e.type) === 'ObjectPattern' ||
      (e == null ? void 0 : e.type) === 'ArrayPattern' ||
      (e == null ? void 0 : e.type) === 'RestElement') &&
      r &&
      wF(r) &&
      ps(i, zt(t)) === ')')
  )
    return kr(e, t), !0;
  if ((r == null ? void 0 : r.type) === 'FunctionDeclaration' && (n == null ? void 0 : n.type) === 'BlockStatement') {
    let s = (() => {
      let o = Vr(r);
      if (o.length > 0) return Qo(i, zt(Lt(!1, o, -1)));
      let l = Qo(i, zt(r.id));
      return l !== !1 && Qo(i, l + 1);
    })();
    if (Er(t) > s) return da(n, t), !0;
  }
  return !1;
}
function vF({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === 'LabeledStatement' ? (zr(e, t), !0) : !1;
}
function _y({ comment: t, enclosingNode: e }) {
  return ((e == null ? void 0 : e.type) === 'ContinueStatement' ||
    (e == null ? void 0 : e.type) === 'BreakStatement') &&
    !e.label
    ? (kr(e, t), !0)
    : !1;
}
function T_({ comment: t, precedingNode: e, enclosingNode: r }) {
  return It(r) && e && r.callee === e && r.arguments.length > 0 ? (zr(r.arguments[0], t), !0) : !1;
}
function k_({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return (r == null ? void 0 : r.type) === 'UnionTypeAnnotation' || (r == null ? void 0 : r.type) === 'TSUnionType'
    ? (zp(t) && ((n.prettierIgnore = !0), (t.unignore = !0)), e ? (kr(e, t), !0) : !1)
    : (((n == null ? void 0 : n.type) === 'UnionTypeAnnotation' || (n == null ? void 0 : n.type) === 'TSUnionType') &&
        zp(t) &&
        ((n.types[0].prettierIgnore = !0), (t.unignore = !0)),
      !1);
}
function P_({ comment: t, enclosingNode: e }) {
  return Ds(e) ? (zr(e, t), !0) : !1;
}
function Ry({ comment: t, enclosingNode: e, followingNode: r, ast: n, isLastComment: i }) {
  var s;
  return ((s = n == null ? void 0 : n.body) == null ? void 0 : s.length) === 0
    ? (i ? pi(n, t) : zr(n, t), !0)
    : (e == null ? void 0 : e.type) === 'Program' && e.body.length === 0 && !kt(e.directives)
    ? (i ? pi(e, t) : zr(e, t), !0)
    : (r == null ? void 0 : r.type) === 'Program' &&
      r.body.length === 0 &&
      (e == null ? void 0 : e.type) === 'ModuleExpression'
    ? (pi(r, t), !0)
    : !1;
}
function B_({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === 'ForInStatement' || (e == null ? void 0 : e.type) === 'ForOfStatement'
    ? (zr(e, t), !0)
    : !1;
}
function FF({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  if ((r == null ? void 0 : r.type) === 'ImportSpecifier' || (r == null ? void 0 : r.type) === 'ExportSpecifier')
    return zr(r, t), !0;
  let i = (e == null ? void 0 : e.type) === 'ImportSpecifier' && (r == null ? void 0 : r.type) === 'ImportDeclaration',
    s =
      (e == null ? void 0 : e.type) === 'ExportSpecifier' && (r == null ? void 0 : r.type) === 'ExportNamedDeclaration';
  return (i || s) && Pn(n, zt(t)) ? (kr(e, t), !0) : !1;
}
function I_({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === 'AssignmentPattern' ? (zr(e, t), !0) : !1;
}
var N_ = new Set(['VariableDeclarator', 'AssignmentExpression', 'TypeAlias', 'TSTypeAliasDeclaration']),
  M_ = new Set([
    'ObjectExpression',
    'RecordExpression',
    'ArrayExpression',
    'TupleExpression',
    'TemplateLiteral',
    'TaggedTemplateExpression',
    'ObjectTypeAnnotation',
    'TSTypeLiteral',
  ]);
function O_({ comment: t, enclosingNode: e, followingNode: r }) {
  return N_.has(e == null ? void 0 : e.type) && r && (M_.has(r.type) || ys(t)) ? (zr(r, t), !0) : !1;
}
function L_({ comment: t, enclosingNode: e, followingNode: r, text: n }) {
  return !r &&
    ((e == null ? void 0 : e.type) === 'TSMethodSignature' ||
      (e == null ? void 0 : e.type) === 'TSDeclareFunction' ||
      (e == null ? void 0 : e.type) === 'TSAbstractMethodDefinition') &&
    ps(n, zt(t)) === ';'
    ? (kr(e, t), !0)
    : !1;
}
function SF({ comment: t, enclosingNode: e, followingNode: r }) {
  if (
    zp(t) &&
    (e == null ? void 0 : e.type) === 'TSMappedType' &&
    (r == null ? void 0 : r.type) === 'TSTypeParameter' &&
    r.constraint
  )
    return (e.prettierIgnore = !0), (t.unignore = !0), !0;
}
function __({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return (r == null ? void 0 : r.type) !== 'TSMappedType'
    ? !1
    : (n == null ? void 0 : n.type) === 'TSTypeParameter' && n.name
    ? (zr(n.name, t), !0)
    : (e == null ? void 0 : e.type) === 'TSTypeParameter' && e.constraint
    ? (kr(e.constraint, t), !0)
    : !1;
}
function R_({ comment: t, enclosingNode: e, followingNode: r }) {
  return !e || e.type !== 'SwitchCase' || e.test || !r || r !== e.consequent[0]
    ? !1
    : (r.type === 'BlockStatement' && ky(t) ? da(r, t) : pi(e, t), !0);
}
var wF = ir([
  'ArrowFunctionExpression',
  'FunctionExpression',
  'FunctionDeclaration',
  'ObjectMethod',
  'ClassMethod',
  'TSDeclareFunction',
  'TSCallSignatureDeclaration',
  'TSConstructSignatureDeclaration',
  'TSMethodSignature',
  'TSConstructorType',
  'TSFunctionType',
  'TSDeclareMethod',
]);
function j_(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === '*');
}
var $_ = j_;
function V_(t, e) {
  let r = t.node;
  if (ky(r)) return e.originalText.slice(Er(r), zt(r)).trimEnd();
  if (ys(r)) return $_(r) ? z_(r) : ['/*', ia(r.value), '*/'];
  throw new Error('Not a comment: ' + JSON.stringify(r));
}
function z_(t) {
  let e = t.value.split(`
`);
  return [
    '/*',
    vt(
      Ee,
      e.map((r, n) => (n === 0 ? r.trimEnd() : ' ' + (n < e.length - 1 ? r.trim() : r.trimStart()))),
    ),
    '*/',
  ];
}
var H_ = new Set(['EmptyStatement', 'TemplateElement', 'Import', 'TSEmptyBodyFunctionExpression', 'ChainExpression']);
function W_(t) {
  return !H_.has(t.type);
}
function U_(t, e) {
  var r;
  if (
    (e.parser === 'typescript' ||
      e.parser === 'flow' ||
      e.parser === 'acorn' ||
      e.parser === 'espree' ||
      e.parser === 'meriyah' ||
      e.parser === '__babel_estree') &&
    t.type === 'MethodDefinition' &&
    ((r = t.value) == null ? void 0 : r.type) === 'FunctionExpression' &&
    Vr(t.value).length === 0 &&
    !t.value.returnType &&
    !kt(t.value.typeParameters) &&
    t.value.body
  )
    return [...(t.decorators || []), t.key, t.value.body];
}
function TF(t) {
  let { node: e, parent: r } = t;
  return (
    (_r(e) ||
      (r &&
        (r.type === 'JSXSpreadAttribute' ||
          r.type === 'JSXSpreadChild' ||
          r.type === 'UnionTypeAnnotation' ||
          r.type === 'TSUnionType' ||
          ((r.type === 'ClassDeclaration' || r.type === 'ClassExpression') && r.superClass === e)))) &&
    (!Rf(e) || r.type === 'UnionTypeAnnotation' || r.type === 'TSUnionType')
  );
}
function q_(t, { parser: e }) {
  if (e === 'flow' || e === 'babel-flow') return (t = Tn(!1, t, /[\s(]/g, '')), t === '' || t === '/*' || t === '/*::';
}
var np = new l_(` 
\r	`),
  wm = (t) => t === '' || t === We || t === Ee || t === Ae;
function K_(t, e, r) {
  var n, i, s;
  let { node: o } = t;
  if (o.type === 'JSXElement' && lR(o)) return [r('openingElement'), r('closingElement')];
  let l = o.type === 'JSXElement' ? r('openingElement') : r('openingFragment'),
    c = o.type === 'JSXElement' ? r('closingElement') : r('closingFragment');
  if (
    o.children.length === 1 &&
    o.children[0].type === 'JSXExpressionContainer' &&
    (o.children[0].expression.type === 'TemplateLiteral' ||
      o.children[0].expression.type === 'TaggedTemplateExpression')
  )
    return [l, ...t.map(r, 'children'), c];
  o.children = o.children.map((L) => (uR(L) ? { type: 'JSXText', value: ' ', raw: ' ' } : L));
  let p = o.children.some(_r),
    f = o.children.filter((L) => L.type === 'JSXExpressionContainer').length > 1,
    m = o.type === 'JSXElement' && o.openingElement.attributes.length > 1,
    g = an(l) || p || m || f,
    x = t.parent.rootMarker === 'mdx',
    b = e.singleQuote ? "{' '}" : '{" "}',
    F = x ? ' ' : Nt([b, Ae], ' '),
    E = ((i = (n = o.openingElement) == null ? void 0 : n.name) == null ? void 0 : i.name) === 'fbt',
    w = J_(t, e, r, F, E),
    I = o.children.some((L) => rc(L));
  for (let L = w.length - 2; L >= 0; L--) {
    let se = w[L] === '' && w[L + 1] === '',
      Y = w[L] === Ee && w[L + 1] === '' && w[L + 2] === Ee,
      W = (w[L] === Ae || w[L] === Ee) && w[L + 1] === '' && w[L + 2] === F,
      X = w[L] === F && w[L + 1] === '' && (w[L + 2] === Ae || w[L + 2] === Ee),
      q = w[L] === F && w[L + 1] === '' && w[L + 2] === F,
      xe = (w[L] === Ae && w[L + 1] === '' && w[L + 2] === Ee) || (w[L] === Ee && w[L + 1] === '' && w[L + 2] === Ae);
    (Y && I) || se || W || q || xe ? w.splice(L, 2) : X && w.splice(L + 1, 2);
  }
  for (; w.length > 0 && wm(Lt(!1, w, -1)); ) w.pop();
  for (; w.length > 1 && wm(w[0]) && wm(w[1]); ) w.shift(), w.shift();
  let T = [];
  for (let [L, se] of w.entries()) {
    if (se === F) {
      if (L === 1 && w[L - 1] === '') {
        if (w.length === 2) {
          T.push(b);
          continue;
        }
        T.push([b, Ee]);
        continue;
      } else if (L === w.length - 1) {
        T.push(b);
        continue;
      } else if (w[L - 1] === '' && w[L - 2] === Ee) {
        T.push(b);
        continue;
      }
    }
    T.push(se), an(se) && (g = !0);
  }
  let j = I ? Ay(T) : oe(T, { shouldBreak: !0 });
  if (
    (((s = e.cursorNode) == null ? void 0 : s.type) === 'JSXText' &&
      o.children.includes(e.cursorNode) &&
      (j = [kC, j, kC]),
    x)
  )
    return j;
  let $ = oe([l, Se([Ee, j]), Ee, c]);
  return g ? $ : Jo([oe([l, ...w, c]), $]);
}
function J_(t, e, r, n, i) {
  let s = [];
  return (
    t.each(({ node: o, next: l }) => {
      if (o.type === 'JSXText') {
        let c = qn(o);
        if (rc(o)) {
          let p = np.split(c, !0);
          p[0] === '' && (s.push(''), p.shift(), /\n/.test(p[0]) ? s.push(_C(i, p[1], o, l)) : s.push(n), p.shift());
          let f;
          if ((Lt(!1, p, -1) === '' && (p.pop(), (f = p.pop())), p.length === 0)) return;
          for (let [m, g] of p.entries()) m % 2 === 1 ? s.push(We) : s.push(g);
          f !== void 0
            ? /\n/.test(f)
              ? s.push(_C(i, Lt(!1, s, -1), o, l))
              : s.push(n)
            : s.push(LC(i, Lt(!1, s, -1), o, l));
        } else /\n/.test(c) ? c.match(/\n/g).length > 1 && s.push('', Ee) : s.push('', n);
      } else {
        let c = r();
        if ((s.push(c), l && rc(l))) {
          let p = np.trim(qn(l)),
            [f] = np.split(p);
          s.push(LC(i, f, o, l));
        } else s.push(Ee);
      }
    }, 'children'),
    s
  );
}
function LC(t, e, r, n) {
  return t
    ? ''
    : (r.type === 'JSXElement' && !r.closingElement) ||
      ((n == null ? void 0 : n.type) === 'JSXElement' && !n.closingElement)
    ? e.length === 1
      ? Ae
      : Ee
    : Ae;
}
function _C(t, e, r, n) {
  return t
    ? Ee
    : e.length === 1
    ? (r.type === 'JSXElement' && !r.closingElement) ||
      ((n == null ? void 0 : n.type) === 'JSXElement' && !n.closingElement)
      ? Ee
      : Ae
    : Ee;
}
var X_ = new Set([
  'ArrayExpression',
  'TupleExpression',
  'JSXAttribute',
  'JSXElement',
  'JSXExpressionContainer',
  'JSXFragment',
  'ExpressionStatement',
  'CallExpression',
  'OptionalCallExpression',
  'ConditionalExpression',
  'JsExpressionRoot',
]);
function G_(t, e, r) {
  let { parent: n } = t;
  if (X_.has(n.type)) return e;
  let i = t.match(
      void 0,
      (o) => o.type === 'ArrowFunctionExpression',
      It,
      (o) => o.type === 'JSXExpressionContainer',
    ),
    s = kl(t, r);
  return oe([s ? '' : Nt('('), Se([Ae, e]), Ae, s ? '' : Nt(')')], { shouldBreak: i });
}
function Y_(t, e, r) {
  let { node: n } = t,
    i = [];
  if ((i.push(r('name')), n.value)) {
    let s;
    if (Bn(n.value)) {
      let o = qn(n.value),
        l = Tn(!1, Tn(!1, o.slice(1, -1), '&apos;', "'"), '&quot;', '"'),
        c = DF(l, e.jsxSingleQuote);
      (l = c === '"' ? Tn(!1, l, '"', '&quot;') : Tn(!1, l, "'", '&apos;')),
        (s = t.call(() => hi(t, ia(c + l + c), e), 'value'));
    } else s = r('value');
    i.push('=', s);
  }
  return i;
}
function Q_(t, e, r) {
  let { node: n } = t,
    i = (s, o) =>
      s.type === 'JSXEmptyExpression' ||
      (!Me(s) &&
        ($r(s) ||
          mi(s) ||
          s.type === 'ArrowFunctionExpression' ||
          (s.type === 'AwaitExpression' && (i(s.argument, s) || s.argument.type === 'JSXElement')) ||
          It(s) ||
          (s.type === 'ChainExpression' && It(s.expression)) ||
          s.type === 'FunctionExpression' ||
          s.type === 'TemplateLiteral' ||
          s.type === 'TaggedTemplateExpression' ||
          s.type === 'DoExpression' ||
          (_r(o) && (s.type === 'ConditionalExpression' || hs(s)))));
  return i(n.expression, t.parent)
    ? oe(['{', r('expression'), cs, '}'])
    : oe(['{', Se([Ae, r('expression')]), Ae, cs, '}']);
}
function Z_(t, e, r) {
  var n, i;
  let { node: s } = t,
    o = Me(s.name) || Me(s.typeParameters);
  if (s.selfClosing && s.attributes.length === 0 && !o) return ['<', r('name'), r('typeParameters'), ' />'];
  if (
    ((n = s.attributes) == null ? void 0 : n.length) === 1 &&
    s.attributes[0].value &&
    Bn(s.attributes[0].value) &&
    !s.attributes[0].value.value.includes(`
`) &&
    !o &&
    !Me(s.attributes[0])
  )
    return oe(['<', r('name'), r('typeParameters'), ' ', ...t.map(r, 'attributes'), s.selfClosing ? ' />' : '>']);
  let l =
      (i = s.attributes) == null
        ? void 0
        : i.some(
            (p) =>
              p.value &&
              Bn(p.value) &&
              p.value.value.includes(`
`),
          ),
    c = e.singleAttributePerLine && s.attributes.length > 1 ? Ee : We;
  return oe(['<', r('name'), r('typeParameters'), Se(t.map(() => [c, r()], 'attributes')), ...eR(s, e, o)], {
    shouldBreak: l,
  });
}
function eR(t, e, r) {
  return t.selfClosing ? [We, '/>'] : tR(t, e, r) ? ['>'] : [Ae, '>'];
}
function tR(t, e, r) {
  let n = t.attributes.length > 0 && Me(Lt(!1, t.attributes, -1), qe.Trailing);
  return (
    (t.attributes.length === 0 && !r) ||
    ((e.bracketSameLine || e.jsxBracketSameLine) && (!r || t.attributes.length > 0) && !n)
  );
}
function rR(t, e, r) {
  let { node: n } = t,
    i = [];
  i.push('</');
  let s = r('name');
  return (
    Me(n.name, qe.Leading | qe.Line)
      ? i.push(Se([Ee, s]), Ee)
      : Me(n.name, qe.Leading | qe.Block)
      ? i.push(' ', s)
      : i.push(s),
    i.push('>'),
    i
  );
}
function nR(t, e) {
  let { node: r } = t,
    n = Me(r),
    i = Me(r, qe.Line),
    s = r.type === 'JSXOpeningFragment';
  return [s ? '<' : '</', Se([i ? Ee : n && !s ? ' ' : '', dr(t, e)]), i ? Ee : '', '>'];
}
function iR(t, e, r) {
  let n = hi(t, K_(t, e, r), e);
  return G_(t, n, e);
}
function sR(t, e) {
  let { node: r } = t,
    n = Me(r, qe.Line);
  return [dr(t, e, { indent: n }), n ? Ee : ''];
}
function oR(t, e, r) {
  let { node: n } = t;
  return [
    '{',
    t.call(
      ({ node: i }) => {
        let s = ['...', r()];
        return !Me(i) || !TF(t) ? s : [Se([Ae, hi(t, s, e)]), Ae];
      },
      n.type === 'JSXSpreadAttribute' ? 'argument' : 'expression',
    ),
    '}',
  ];
}
function aR(t, e, r) {
  let { node: n } = t;
  if (n.type.startsWith('JSX'))
    switch (n.type) {
      case 'JSXAttribute':
        return Y_(t, e, r);
      case 'JSXIdentifier':
        return n.name;
      case 'JSXNamespacedName':
        return vt(':', [r('namespace'), r('name')]);
      case 'JSXMemberExpression':
        return vt('.', [r('object'), r('property')]);
      case 'JSXSpreadAttribute':
      case 'JSXSpreadChild':
        return oR(t, e, r);
      case 'JSXExpressionContainer':
        return Q_(t, e, r);
      case 'JSXFragment':
      case 'JSXElement':
        return iR(t, e, r);
      case 'JSXOpeningElement':
        return Z_(t, e, r);
      case 'JSXClosingElement':
        return rR(t, e, r);
      case 'JSXOpeningFragment':
      case 'JSXClosingFragment':
        return nR(t, e);
      case 'JSXEmptyExpression':
        return sR(t, e);
      case 'JSXText':
        throw new Error('JSXText should be handled by JSXElement');
      default:
        throw new Pl(n, 'JSX');
    }
}
function lR(t) {
  if (t.children.length === 0) return !0;
  if (t.children.length > 1) return !1;
  let e = t.children[0];
  return e.type === 'JSXText' && !rc(e);
}
function rc(t) {
  return t.type === 'JSXText' && (np.hasNonWhitespaceCharacter(qn(t)) || !/\n/.test(qn(t)));
}
function uR(t) {
  return t.type === 'JSXExpressionContainer' && Bn(t.expression) && t.expression.value === ' ' && !Me(t.expression);
}
function cR(t) {
  let { node: e, parent: r } = t;
  if (!_r(e) || !_r(r)) return !1;
  let { index: n, siblings: i } = t,
    s;
  for (let o = n; o > 0; o--) {
    let l = i[o - 1];
    if (!(l.type === 'JSXText' && !rc(l))) {
      s = l;
      break;
    }
  }
  return (
    (s == null ? void 0 : s.type) === 'JSXExpressionContainer' &&
    s.expression.type === 'JSXEmptyExpression' &&
    Rf(s.expression)
  );
}
function hR(t) {
  return Rf(t.node) || cR(t);
}
var kF = hR,
  pR = 0;
function PF(t, e, r) {
  var n;
  let { node: i, parent: s, grandparent: o, key: l } = t,
    c =
      l !== 'body' &&
      (s.type === 'IfStatement' ||
        s.type === 'WhileStatement' ||
        s.type === 'SwitchStatement' ||
        s.type === 'DoWhileStatement'),
    p = i.operator === '|>' && ((n = t.root.extra) == null ? void 0 : n.__isUsingHackPipeline),
    f = ag(t, r, e, !1, c);
  if (c) return f;
  if (p) return oe(f);
  if ((It(s) && s.callee === i) || s.type === 'UnaryExpression' || (or(s) && !s.computed))
    return oe([Se([Ae, ...f]), Ae]);
  let m =
      s.type === 'ReturnStatement' ||
      s.type === 'ThrowStatement' ||
      (s.type === 'JSXExpressionContainer' && o.type === 'JSXAttribute') ||
      (i.operator !== '|' && s.type === 'JsExpressionRoot') ||
      (i.type !== 'NGPipeExpression' &&
        ((s.type === 'NGRoot' && e.parser === '__ng_binding') ||
          (s.type === 'NGMicrosyntaxExpression' && o.type === 'NGMicrosyntax' && o.body.length === 1))) ||
      (i === s.body && s.type === 'ArrowFunctionExpression') ||
      (i !== s.body && s.type === 'ForStatement') ||
      (s.type === 'ConditionalExpression' && o.type !== 'ReturnStatement' && o.type !== 'ThrowStatement' && !It(o)) ||
      s.type === 'TemplateLiteral',
    g =
      s.type === 'AssignmentExpression' ||
      s.type === 'VariableDeclarator' ||
      s.type === 'ClassProperty' ||
      s.type === 'PropertyDefinition' ||
      s.type === 'TSAbstractPropertyDefinition' ||
      s.type === 'ClassPrivateProperty' ||
      Ds(s),
    x = hs(i.left) && By(i.operator, i.left.operator);
  if (m || (nc(i) && !x) || (!nc(i) && g)) return oe(f);
  if (f.length === 0) return '';
  let b = _r(i.right),
    F = f.findIndex(($) => typeof $ != 'string' && !Array.isArray($) && $.type === Un),
    E = f.slice(0, F === -1 ? 1 : F + 1),
    w = f.slice(E.length, b ? -1 : void 0),
    I = Symbol('logicalChain-' + ++pR),
    T = oe([...E, Se(w)], { id: I });
  if (!b) return T;
  let j = Lt(!1, f, -1);
  return oe([T, Lf(j, { groupId: I })]);
}
function ag(t, e, r, n, i) {
  var s;
  let { node: o } = t;
  if (!hs(o)) return [oe(e())];
  let l = [];
  By(o.operator, o.left.operator) ? (l = t.call((E) => ag(E, e, r, !0, i), 'left')) : l.push(oe(e('left')));
  let c = nc(o),
    p = (o.operator === '|>' || o.type === 'NGPipeExpression' || fR(t, r)) && !sa(r.originalText, o.right),
    f = o.type === 'NGPipeExpression' ? '|' : o.operator,
    m =
      o.type === 'NGPipeExpression' && o.arguments.length > 0
        ? oe(
            Se([
              Ae,
              ': ',
              vt(
                [We, ': '],
                t.map(() => ci(2, oe(e())), 'arguments'),
              ),
            ]),
          )
        : '',
    g;
  if (c) g = [f, ' ', e('right'), m];
  else {
    let E =
      f === '|>' && (s = t.root.extra) != null && s.__isUsingHackPipeline
        ? t.call((w) => ag(w, e, r, !0, i), 'right')
        : e('right');
    g = [p ? We : '', f, p ? ' ' : We, E, m];
  }
  let { parent: x } = t,
    b = Me(o.left, qe.Trailing | qe.Line),
    F =
      b ||
      (!(i && o.type === 'LogicalExpression') &&
        x.type !== o.type &&
        o.left.type !== o.type &&
        o.right.type !== o.type);
  if ((l.push(p ? '' : ' ', F ? oe(g, { shouldBreak: b }) : g), n && Me(o))) {
    let E = Ey(hi(t, l, r));
    return Array.isArray(E) || E.type === Hi ? Qv(E) : [E];
  }
  return l;
}
function nc(t) {
  return t.type !== 'LogicalExpression'
    ? !1
    : !!((mi(t.right) && t.right.properties.length > 0) || ($r(t.right) && t.right.elements.length > 0) || _r(t.right));
}
var RC = (t) => t.type === 'BinaryExpression' && t.operator === '|';
function fR(t, e) {
  return (
    (e.parser === '__vue_expression' || e.parser === '__vue_ts_expression') &&
    RC(t.node) &&
    !t.hasAncestor((r) => !RC(r) && r.type !== 'JsExpressionRoot')
  );
}
var Hp = class extends Error {
  constructor() {
    super(...arguments);
    ko(this, 'name', 'ArgExpansionBailout');
  }
};
function dR(t, e, r, n) {
  let { node: i } = t;
  return Me(i, qe.Dangling) ? oe([r, dr(t, e, { indent: !0 }), Ae, n]) : [r, n];
}
function jy(t, e, r) {
  let { node: n } = t,
    i = [],
    s = n.type === 'TupleExpression' ? '#[' : '[',
    o = ']',
    l =
      n.type === 'TupleTypeAnnotation' && n.types
        ? 'types'
        : n.type === 'TSTupleType' || n.type === 'TupleTypeAnnotation'
        ? 'elementTypes'
        : 'elements',
    c = n[l];
  if (c.length === 0) i.push(dR(t, e, s, o));
  else {
    let p = Lt(!1, c, -1),
      f = (p == null ? void 0 : p.type) !== 'RestElement',
      m = p === null,
      g = Symbol('array'),
      x =
        !e.__inJestEach &&
        c.length > 1 &&
        c.every((E, w, I) => {
          let T = E == null ? void 0 : E.type;
          if (!$r(E) && !mi(E)) return !1;
          let j = I[w + 1];
          if (j && T !== j.type) return !1;
          let $ = $r(E) ? 'elements' : 'properties';
          return E[$] && E[$].length > 1;
        }),
      b = BF(n, e),
      F = f ? (m ? ',' : go(e) ? (b ? Nt(',', '', { groupId: g }) : Nt(',')) : '') : '';
    i.push(oe([s, Se([Ae, b ? gR(t, e, r, F) : [mR(t, e, l, r), F], dr(t, e)]), Ae, o], { shouldBreak: x, id: g }));
  }
  return i.push(cn(t), Rr(t, r)), i;
}
function BF(t, e) {
  return (
    $r(t) &&
    t.elements.length > 1 &&
    t.elements.every(
      (r) =>
        r &&
        (co(r) || (sF(r) && !Me(r.argument))) &&
        !Me(r, qe.Trailing | qe.Line, (n) => !Pn(e.originalText, Er(n), { backwards: !0 })),
    )
  );
}
function IF({ node: t }, { originalText: e }) {
  let r = (i) => Fy(e, Sy(e, i)),
    n = (i) => (e[i] === ',' ? i : n(r(i + 1)));
  return wy(e, n(zt(t)));
}
function mR(t, e, r, n) {
  let i = [];
  return (
    t.each(({ node: s, isLast: o }) => {
      i.push(s ? oe(n()) : ''), o || i.push([',', We, s && IF(t, e) ? Ae : '']);
    }, r),
    i
  );
}
function gR(t, e, r, n) {
  let i = [];
  return (
    t.each(({ isLast: s, next: o }) => {
      i.push([r(), s ? n : ',']), s || i.push(IF(t, e) ? [Ee, Ee] : Me(o, qe.Leading | qe.Line) ? Ee : We);
    }, 'elements'),
    Ay(i)
  );
}
function yR(t, e, r) {
  let { node: n } = t,
    i = yo(n);
  if (i.length === 0) return ['(', dr(t, e), ')'];
  if (CR(i)) return ['(', r(['arguments', 0]), ', ', r(['arguments', 1]), ')'];
  let s = !1,
    o = i.length - 1,
    l = [];
  dF(t, ({ node: m }, g) => {
    let x = r();
    g === o || (Do(m, e) ? ((s = !0), (x = [x, ',', Ee, Ee])) : (x = [x, ',', We])), l.push(x);
  });
  let c = !(n.type === 'ImportExpression' || n.callee.type === 'Import') && go(e, 'all') ? ',' : '';
  function p() {
    return oe(['(', Se([We, ...l]), c, We, ')'], { shouldBreak: !0 });
  }
  if (s || (t.parent.type !== 'Decorator' && $L(i))) return p();
  if (xR(i)) {
    let m = l.slice(1);
    if (m.some(an)) return p();
    let g;
    try {
      g = r(MC(n, 0), { expandFirstArg: !0 });
    } catch (x) {
      if (x instanceof Hp) return p();
      throw x;
    }
    return an(g)
      ? [uo, Jo([['(', oe(g, { shouldBreak: !0 }), ', ', ...m, ')'], p()])]
      : Jo([['(', g, ', ', ...m, ')'], ['(', oe(g, { shouldBreak: !0 }), ', ', ...m, ')'], p()]);
  }
  if (DR(i, l, e)) {
    let m = l.slice(0, -1);
    if (m.some(an)) return p();
    let g;
    try {
      g = r(MC(n, -1), { expandLastArg: !0 });
    } catch (x) {
      if (x instanceof Hp) return p();
      throw x;
    }
    return an(g)
      ? [uo, Jo([['(', ...m, oe(g, { shouldBreak: !0 }), ')'], p()])]
      : Jo([['(', ...m, g, ')'], ['(', ...m, oe(g, { shouldBreak: !0 }), ')'], p()]);
  }
  let f = ['(', Se([Ae, ...l]), Nt(c), Ae, ')'];
  return fF(t) ? f : oe(f, { shouldBreak: l.some(an) || s });
}
function Tu(t, e = !1) {
  return (
    (mi(t) && (t.properties.length > 0 || Me(t))) ||
    ($r(t) && (t.elements.length > 0 || Me(t))) ||
    (t.type === 'TSTypeAssertion' && Tu(t.expression)) ||
    (Qs(t) && Tu(t.expression)) ||
    t.type === 'FunctionExpression' ||
    (t.type === 'ArrowFunctionExpression' &&
      (!t.returnType ||
        !t.returnType.typeAnnotation ||
        t.returnType.typeAnnotation.type !== 'TSTypeReference' ||
        bR(t.body)) &&
      (t.body.type === 'BlockStatement' ||
        (t.body.type === 'ArrowFunctionExpression' && Tu(t.body, !0)) ||
        mi(t.body) ||
        $r(t.body) ||
        (!e && (It(t.body) || t.body.type === 'ConditionalExpression')) ||
        _r(t.body))) ||
    t.type === 'DoExpression' ||
    t.type === 'ModuleExpression'
  );
}
function DR(t, e, r) {
  var n, i;
  let s = Lt(!1, t, -1);
  if (t.length === 1) {
    let l = Lt(!1, e, -1);
    if ((n = l.label) != null && n.embed && ((i = l.label) == null ? void 0 : i.hug) !== !1) return !0;
  }
  let o = Lt(!1, t, -2);
  return (
    !Me(s, qe.Leading) &&
    !Me(s, qe.Trailing) &&
    Tu(s) &&
    (!o || o.type !== s.type) &&
    (t.length !== 2 || o.type !== 'ArrowFunctionExpression' || !$r(s)) &&
    !(t.length > 1 && BF(s, r))
  );
}
function xR(t) {
  if (t.length !== 2) return !1;
  let [e, r] = t;
  return e.type === 'ModuleExpression' && AR(r)
    ? !0
    : !Me(e) &&
        (e.type === 'FunctionExpression' ||
          (e.type === 'ArrowFunctionExpression' && e.body.type === 'BlockStatement')) &&
        r.type !== 'FunctionExpression' &&
        r.type !== 'ArrowFunctionExpression' &&
        r.type !== 'ConditionalExpression' &&
        NF(r) &&
        !Tu(r);
}
function NF(t) {
  var e;
  if (t.type === 'ParenthesizedExpression') return NF(t.expression);
  if (Qs(t) || t.type === 'TypeCastExpression') {
    let { typeAnnotation: r } = t;
    return (
      r.type === 'TypeAnnotation' && (r = r.typeAnnotation),
      r.type === 'TSArrayType' && ((r = r.elementType), r.type === 'TSArrayType' && (r = r.elementType)),
      (r.type === 'GenericTypeAnnotation' || r.type === 'TSTypeReference') &&
        ((e = r.typeParameters) == null ? void 0 : e.params.length) === 1 &&
        (r = r.typeParameters.params[0]),
      Py(r) && ri(t.expression, 1)
    );
  }
  return dl(t) && yo(t).length > 1 ? !1 : hs(t) ? ri(t.left, 1) && ri(t.right, 1) : oF(t) || ri(t);
}
function CR(t) {
  return (
    t.length === 2 &&
    t[0].type === 'ArrowFunctionExpression' &&
    Vr(t[0]).length === 0 &&
    t[0].body.type === 'BlockStatement' &&
    t[1].type === 'ArrayExpression' &&
    !t.some((e) => Me(e))
  );
}
function bR(t) {
  return t.type === 'BlockStatement' && (t.body.some((e) => e.type !== 'EmptyStatement') || Me(t, qe.Dangling));
}
function AR(t) {
  return (
    t.type === 'ObjectExpression' &&
    t.properties.length === 1 &&
    Ds(t.properties[0]) &&
    t.properties[0].key.type === 'Identifier' &&
    t.properties[0].key.name === 'type' &&
    Bn(t.properties[0].value) &&
    t.properties[0].value.value === 'module'
  );
}
var lg = yR;
function ER(t, e, r) {
  var n;
  let i = r('object'),
    s = MF(t, e, r),
    { node: o, parent: l } = t,
    c = t.findAncestor((f) => !(or(f) || f.type === 'TSNonNullExpression')),
    p =
      (c &&
        (c.type === 'NewExpression' ||
          c.type === 'BindExpression' ||
          (c.type === 'AssignmentExpression' && c.left.type !== 'Identifier'))) ||
      o.computed ||
      (o.object.type === 'Identifier' && o.property.type === 'Identifier' && !or(l)) ||
      ((l.type === 'AssignmentExpression' || l.type === 'VariableDeclarator') &&
        ((It(o.object) && o.object.arguments.length > 0) ||
          (o.object.type === 'TSNonNullExpression' &&
            It(o.object.expression) &&
            o.object.expression.arguments.length > 0) ||
          ((n = i.label) == null ? void 0 : n.memberChain)));
  return dc(i.label, [i, p ? s : oe(Se([Ae, s]))]);
}
function MF(t, e, r) {
  let n = r('property'),
    { node: i } = t,
    s = cn(t);
  return i.computed
    ? !i.property || co(i.property)
      ? [s, '[', n, ']']
      : oe([s, '[', Se([Ae, n]), Ae, ']'])
    : [s, '.', n];
}
function vR(t, e, r) {
  let { parent: n } = t,
    i = !n || n.type === 'ExpressionStatement',
    s = [];
  function o(re) {
    let { originalText: ie } = e,
      Q = Qo(ie, zt(re));
    return ie.charAt(Q) === ')' ? Q !== !1 && wy(ie, Q + 1) : Do(re, e);
  }
  function l(re) {
    let { node: ie } = re;
    It(ie) && (ja(ie.callee) || It(ie.callee))
      ? (s.unshift({ node: ie, printed: [hi(re, [cn(re), oa(re, e, r), lg(re, e, r)], e), o(ie) ? Ee : ''] }),
        re.call((Q) => l(Q), 'callee'))
      : ja(ie)
      ? (s.unshift({ node: ie, needsParens: kl(re, e), printed: hi(re, or(ie) ? MF(re, e, r) : rS(re, e, r), e) }),
        re.call((Q) => l(Q), 'object'))
      : ie.type === 'TSNonNullExpression'
      ? (s.unshift({ node: ie, printed: hi(re, '!', e) }), re.call((Q) => l(Q), 'expression'))
      : s.unshift({ node: ie, printed: r() });
  }
  let { node: c } = t;
  s.unshift({ node: c, printed: [cn(t), oa(t, e, r), lg(t, e, r)] }), c.callee && t.call((re) => l(re), 'callee');
  let p = [],
    f = [s[0]],
    m = 1;
  for (
    ;
    m < s.length &&
    (s[m].node.type === 'TSNonNullExpression' ||
      It(s[m].node) ||
      (or(s[m].node) && s[m].node.computed && co(s[m].node.property)));
    ++m
  )
    f.push(s[m]);
  if (!It(s[0].node)) for (; m + 1 < s.length && ja(s[m].node) && ja(s[m + 1].node); ++m) f.push(s[m]);
  p.push(f), (f = []);
  let g = !1;
  for (; m < s.length; ++m) {
    if (g && ja(s[m].node)) {
      if (s[m].node.computed && co(s[m].node.property)) {
        f.push(s[m]);
        continue;
      }
      p.push(f), (f = []), (g = !1);
    }
    (It(s[m].node) || s[m].node.type === 'ImportExpression') && (g = !0),
      f.push(s[m]),
      Me(s[m].node, qe.Trailing) && (p.push(f), (f = []), (g = !1));
  }
  f.length > 0 && p.push(f);
  function x(re) {
    return /^[A-Z]|^[$_]+$/.test(re);
  }
  function b(re) {
    return re.length <= e.tabWidth;
  }
  function F(re) {
    var ie;
    let Q = (ie = re[1][0]) == null ? void 0 : ie.node.computed;
    if (re[0].length === 1) {
      let G = re[0][0].node;
      return G.type === 'ThisExpression' || (G.type === 'Identifier' && (x(G.name) || (i && b(G.name)) || Q));
    }
    let ce = Lt(!1, re[0], -1).node;
    return or(ce) && ce.property.type === 'Identifier' && (x(ce.property.name) || Q);
  }
  let E = p.length >= 2 && !Me(p[1][0].node) && F(p);
  function w(re) {
    let ie = re.map((Q) => Q.printed);
    return re.length > 0 && Lt(!1, re, -1).needsParens ? ['(', ...ie, ')'] : ie;
  }
  function I(re) {
    return re.length === 0 ? '' : Se(oe([Ee, vt(Ee, re.map(w))]));
  }
  let T = p.map(w),
    j = T,
    $ = E ? 3 : 2,
    L = p.flat(),
    se =
      L.slice(1, -1).some((re) => Me(re.node, qe.Leading)) ||
      L.slice(0, -1).some((re) => Me(re.node, qe.Trailing)) ||
      (p[$] && Me(p[$][0].node, qe.Leading));
  if (p.length <= $ && !se) return fF(t) ? j : oe(j);
  let Y = Lt(!1, p[E ? 1 : 0], -1).node,
    W = !It(Y) && o(Y),
    X = [w(p[0]), E ? p.slice(1, 2).map(w) : '', W ? Ee : '', I(p.slice(E ? 2 : 1))],
    q = s.map(({ node: re }) => re).filter(It);
  function xe() {
    let re = Lt(!1, Lt(!1, p, -1), -1).node,
      ie = Lt(!1, T, -1);
    return It(re) && an(ie) && q.slice(0, -1).some((Q) => Q.arguments.some(tc));
  }
  let Re;
  return (
    se || (q.length > 2 && q.some((re) => !re.arguments.every((ie) => ri(ie)))) || T.slice(0, -1).some(an) || xe()
      ? (Re = oe(X))
      : (Re = [an(j) || W ? uo : '', Jo([j, X])]),
    dc({ memberChain: !0 }, Re)
  );
}
var FR = vR;
function OF(t, e, r) {
  var n;
  let { node: i, parent: s } = t,
    o = i.type === 'NewExpression',
    l = i.type === 'ImportExpression',
    c = cn(t),
    p = yo(i),
    f = p.length === 1 && hF(p[0], e.originalText);
  if (f || (p.length > 0 && !o && !l && (SR(i, s) || _f(i, s)))) {
    let g = [];
    if (
      (dF(t, () => {
        g.push(r());
      }),
      !(f && (n = g[0].label) != null && n.embed))
    )
      return [o ? 'new ' : '', r('callee'), c, oa(t, e, r), '(', vt(', ', g), ')'];
  }
  if (!l && !o && ja(i.callee) && !t.call((g) => kl(g, e), 'callee')) return FR(t, e, r);
  let m = [o ? 'new ' : '', l ? 'import' : r('callee'), c, oa(t, e, r), lg(t, e, r)];
  return l || It(i.callee) ? oe(m) : m;
}
function SR(t, e) {
  if (t.callee.type !== 'Identifier') return !1;
  if (t.callee.name === 'require') return !0;
  if (t.callee.name === 'define') {
    let r = yo(t);
    return (
      e.type === 'ExpressionStatement' &&
      (r.length === 1 ||
        (r.length === 2 && r[0].type === 'ArrayExpression') ||
        (r.length === 3 && Bn(r[0]) && r[1].type === 'ArrayExpression'))
    );
  }
  return !1;
}
function wR(t, e, r) {
  let n = e === '"' ? "'" : '"',
    i = Tn(!1, t, /\\(.)|(["'])/gs, (s, o, l) =>
      o === n ? o : l === e ? '\\' + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o) ? o : '\\' + o),
    );
  return e + i + e;
}
var TR = wR;
function kR(t, e) {
  let r = t.slice(1, -1),
    n =
      e.parser === 'json' || (e.parser === 'json5' && e.quoteProps === 'preserve' && !e.singleQuote)
        ? '"'
        : e.__isInHtmlAttribute
        ? "'"
        : DF(r, e.singleQuote);
  return TR(r, n, !(e.parser === 'css' || e.parser === 'less' || e.parser === 'scss' || e.__embeddedInHtml));
}
var Wp = kR;
function PR(t) {
  return t
    .toLowerCase()
    .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, '$1$2')
    .replace(/^([+-]?[\d.]+)e[+-]?0+$/, '$1')
    .replace(/^([+-])?\./, '$10.')
    .replace(/(\.\d+?)0+(?=e|$)/, '$1')
    .replace(/\.(?=e|$)/, '');
}
var Ws = PR;
function BR(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case 'RegExpLiteral':
      return jC(r);
    case 'BigIntLiteral':
      return ug(r.extra.raw);
    case 'NumericLiteral':
      return Ws(r.extra.raw);
    case 'StringLiteral':
      return ia(Wp(r.extra.raw, e));
    case 'NullLiteral':
      return 'null';
    case 'BooleanLiteral':
      return String(r.value);
    case 'DecimalLiteral':
      return Ws(r.value) + 'm';
    case 'DirectiveLiteral':
      return $C(r.extra.raw, e);
    case 'Literal': {
      if (r.regex) return jC(r.regex);
      if (r.bigint) return ug(r.raw);
      if (r.decimal) return Ws(r.decimal) + 'm';
      let { value: n } = r;
      return typeof n == 'number'
        ? Ws(r.raw)
        : typeof n == 'string'
        ? IR(t)
          ? $C(r.raw, e)
          : ia(Wp(r.raw, e))
        : String(n);
    }
  }
}
function IR(t) {
  if (t.key !== 'expression') return;
  let { parent: e } = t;
  return e.type === 'ExpressionStatement' && e.directive;
}
function ug(t) {
  return t.toLowerCase();
}
function jC({ pattern: t, flags: e }) {
  return (e = [...e].sort().join('')), `/${t}/${e}`;
}
function $C(t, e) {
  let r = t.slice(1, -1);
  if (r.includes('"') || r.includes("'")) return t;
  let n = e.singleQuote ? "'" : '"';
  return n + r + n;
}
var LF = ir([
  'Literal',
  'BigIntLiteral',
  'BooleanLiteral',
  'DecimalLiteral',
  'DirectiveLiteral',
  'NullLiteral',
  'NumericLiteral',
  'RegExpLiteral',
  'StringLiteral',
]);
function yc(t, e, r, n, i, s) {
  let o = OR(t, e, r, n, s),
    l = s ? r(s, { assignmentLayout: o }) : '';
  switch (o) {
    case 'break-after-operator':
      return oe([oe(n), i, oe(Se([We, l]))]);
    case 'never-break-after-operator':
      return oe([oe(n), i, ' ', l]);
    case 'fluid': {
      let c = Symbol('assignment');
      return oe([oe(n), i, oe(Se(We), { id: c }), cs, Lf(l, { groupId: c })]);
    }
    case 'break-lhs':
      return oe([n, i, ' ', oe(l)]);
    case 'chain':
      return [oe(n), i, We, l];
    case 'chain-tail':
      return [oe(n), i, Se([We, l])];
    case 'chain-tail-arrow-chain':
      return [oe(n), i, l];
    case 'only-left':
      return n;
  }
}
function NR(t, e, r) {
  let { node: n } = t;
  return yc(t, e, r, r('left'), [' ', n.operator], 'right');
}
function MR(t, e, r) {
  return yc(t, e, r, r('id'), ' =', 'init');
}
function OR(t, e, r, n, i) {
  let { node: s } = t,
    o = s[i];
  if (!o) return 'only-left';
  let l = !ip(o);
  if (t.match(ip, _F, (p) => !l || (p.type !== 'ExpressionStatement' && p.type !== 'VariableDeclaration')))
    return l
      ? o.type === 'ArrowFunctionExpression' && o.body.type === 'ArrowFunctionExpression'
        ? 'chain-tail-arrow-chain'
        : 'chain-tail'
      : 'chain';
  if ((!l && ip(o.right)) || sa(e.originalText, o)) return 'break-after-operator';
  if ((o.type === 'CallExpression' && o.callee.name === 'require') || e.parser === 'json5' || e.parser === 'json')
    return 'never-break-after-operator';
  if (_R(s) || RR(s) || VR(s) || (RF(s) && G5(n))) return 'break-lhs';
  let c = UR(s, n, e);
  return t.call(() => LR(t, e, r, c), i)
    ? 'break-after-operator'
    : c ||
      o.type === 'TemplateLiteral' ||
      o.type === 'TaggedTemplateExpression' ||
      o.type === 'BooleanLiteral' ||
      co(o) ||
      o.type === 'ClassExpression'
    ? 'never-break-after-operator'
    : 'fluid';
}
function LR(t, e, r, n) {
  let i = t.node;
  if (hs(i) && !nc(i)) return !0;
  switch (i.type) {
    case 'StringLiteralTypeAnnotation':
    case 'SequenceExpression':
      return !0;
    case 'ConditionalExpression': {
      let { test: l } = i;
      return hs(l) && !nc(l);
    }
    case 'ClassExpression':
      return kt(i.decorators);
  }
  if (n) return !1;
  let s = i,
    o = [];
  for (;;)
    if (
      s.type === 'UnaryExpression' ||
      s.type === 'AwaitExpression' ||
      (s.type === 'YieldExpression' && s.argument !== null)
    )
      (s = s.argument), o.push('argument');
    else if (s.type === 'TSNonNullExpression') (s = s.expression), o.push('expression');
    else break;
  return !!(Bn(s) || t.call(() => jF(t, e, r), ...o));
}
function _R(t) {
  if (_F(t)) {
    let e = t.left || t.id;
    return (
      e.type === 'ObjectPattern' &&
      e.properties.length > 2 &&
      e.properties.some((r) => {
        var n;
        return Ds(r) && (!r.shorthand || ((n = r.value) == null ? void 0 : n.type) === 'AssignmentPattern');
      })
    );
  }
  return !1;
}
function ip(t) {
  return t.type === 'AssignmentExpression';
}
function _F(t) {
  return ip(t) || t.type === 'VariableDeclarator';
}
function RR(t) {
  let e = $R(t);
  if (kt(e)) {
    let r = t.type === 'TSTypeAliasDeclaration' ? 'constraint' : 'bound';
    if (e.length > 1 && e.some((n) => n[r] || n.default)) return !0;
  }
  return !1;
}
var jR = ir(['TSTypeAliasDeclaration', 'TypeAlias']);
function $R(t) {
  var e;
  if (jR(t)) return (e = t.typeParameters) == null ? void 0 : e.params;
}
function VR(t) {
  if (t.type !== 'VariableDeclarator') return !1;
  let { typeAnnotation: e } = t.id;
  if (!e || !e.typeAnnotation) return !1;
  let r = VC(e.typeAnnotation);
  return kt(r) && r.length > 1 && r.some((n) => kt(VC(n)) || n.type === 'TSConditionalType');
}
function RF(t) {
  var e;
  return t.type === 'VariableDeclarator' && ((e = t.init) == null ? void 0 : e.type) === 'ArrowFunctionExpression';
}
var zR = ir(['TSTypeReference', 'GenericTypeAnnotation']);
function VC(t) {
  var e;
  if (zR(t)) return (e = t.typeParameters) == null ? void 0 : e.params;
}
function jF(t, e, r, n = !1) {
  var i;
  let { node: s } = t,
    o = () => jF(t, e, r, !0);
  if (s.type === 'ChainExpression' || s.type === 'TSNonNullExpression') return t.call(o, 'expression');
  if (It(s)) {
    if ((i = OF(t, e, r).label) != null && i.memberChain) return !1;
    let l = yo(s);
    return !(l.length === 0 || (l.length === 1 && WR(l[0], e))) || qR(s, r) ? !1 : t.call(o, 'callee');
  }
  return or(s) ? t.call(o, 'object') : n && (s.type === 'Identifier' || s.type === 'ThisExpression');
}
var HR = 0.25;
function WR(t, { printWidth: e }) {
  if (Me(t)) return !1;
  let r = e * HR;
  if (t.type === 'ThisExpression' || (t.type === 'Identifier' && t.name.length <= r) || (sF(t) && !Me(t.argument)))
    return !0;
  let n = (t.type === 'Literal' && 'regex' in t && t.regex.pattern) || (t.type === 'RegExpLiteral' && t.pattern);
  return n
    ? n.length <= r
    : Bn(t)
    ? qn(t).length <= r
    : t.type === 'TemplateLiteral'
    ? t.expressions.length === 0 &&
      t.quasis[0].value.raw.length <= r &&
      !t.quasis[0].value.raw.includes(`
`)
    : LF(t);
}
function UR(t, e, r) {
  if (!Ds(t)) return !1;
  e = Ey(e);
  let n = 3;
  return typeof e == 'string' && fl(e) < r.tabWidth + n;
}
function qR(t, e) {
  let r = KR(t);
  if (kt(r)) {
    if (r.length > 1) return !0;
    if (r.length === 1) {
      let i = r[0];
      if (
        i.type === 'TSUnionType' ||
        i.type === 'UnionTypeAnnotation' ||
        i.type === 'TSIntersectionType' ||
        i.type === 'IntersectionTypeAnnotation' ||
        i.type === 'TSTypeLiteral' ||
        i.type === 'ObjectTypeAnnotation'
      )
        return !0;
    }
    let n = t.typeParameters ? 'typeParameters' : 'typeArguments';
    if (an(e(n))) return !0;
  }
  return !1;
}
function KR(t) {
  var e;
  return (e = t.typeParameters ?? t.typeArguments) == null ? void 0 : e.params;
}
function Dc(t, e, r, n, i) {
  let s = t.node,
    o = Vr(s),
    l = i ? oa(t, r, e) : '';
  if (o.length === 0) return [l, '(', dr(t, r, { filter: (x) => ps(r.originalText, zt(x)) === ')' }), ')'];
  let { parent: c } = t,
    p = _f(c),
    f = $F(s),
    m = [];
  if (
    (qL(t, (x, b) => {
      let F = b === o.length - 1;
      F && s.rest && m.push('...'),
        m.push(e()),
        !F && (m.push(','), p || f ? m.push(' ') : Do(o[b], r) ? m.push(Ee, Ee) : m.push(We));
    }),
    n && !XR(t))
  ) {
    if (an(l) || an(m)) throw new Hp();
    return oe([eg(l), '(', eg(m), ')']);
  }
  let g = o.every((x) => !kt(x.decorators));
  return f && g
    ? [l, '(', ...m, ')']
    : p
    ? [l, '(', ...m, ')']
    : (uF(c) ||
        ML(c) ||
        c.type === 'TypeAlias' ||
        c.type === 'UnionTypeAnnotation' ||
        c.type === 'TSUnionType' ||
        c.type === 'IntersectionTypeAnnotation' ||
        (c.type === 'FunctionTypeAnnotation' && c.returnType === s)) &&
      o.length === 1 &&
      o[0].name === null &&
      s.this !== o[0] &&
      o[0].typeAnnotation &&
      s.typeParameters === null &&
      Py(o[0].typeAnnotation) &&
      !s.rest
    ? r.arrowParens === 'always'
      ? ['(', ...m, ')']
      : m
    : [l, '(', Se([Ae, ...m]), Nt(!UL(s) && go(r, 'all') ? ',' : ''), Ae, ')'];
}
function $F(t) {
  if (!t) return !1;
  let e = Vr(t);
  if (e.length !== 1) return !1;
  let [r] = e;
  return (
    !Me(r) &&
    (r.type === 'ObjectPattern' ||
      r.type === 'ArrayPattern' ||
      (r.type === 'Identifier' &&
        r.typeAnnotation &&
        (r.typeAnnotation.type === 'TypeAnnotation' || r.typeAnnotation.type === 'TSTypeAnnotation') &&
        ho(r.typeAnnotation.typeAnnotation)) ||
      (r.type === 'FunctionTypeParam' && ho(r.typeAnnotation) && r !== t.rest) ||
      (r.type === 'AssignmentPattern' &&
        (r.left.type === 'ObjectPattern' || r.left.type === 'ArrayPattern') &&
        (r.right.type === 'Identifier' ||
          (mi(r.right) && r.right.properties.length === 0) ||
          ($r(r.right) && r.right.elements.length === 0))))
  );
}
function JR(t) {
  let e;
  return (
    t.returnType
      ? ((e = t.returnType), e.typeAnnotation && (e = e.typeAnnotation))
      : t.typeAnnotation && (e = t.typeAnnotation),
    e
  );
}
function jf(t, e) {
  var r;
  let n = JR(t);
  if (!n) return !1;
  let i = (r = t.typeParameters) == null ? void 0 : r.params;
  if (i) {
    if (i.length > 1) return !1;
    if (i.length === 1) {
      let s = i[0];
      if (s.constraint || s.default) return !1;
    }
  }
  return Vr(t).length === 1 && (ho(n) || an(e));
}
function XR(t) {
  return t.match(
    (e) => e.type === 'ArrowFunctionExpression' && e.body.type === 'BlockStatement',
    (e, r) => {
      if (
        e.type === 'CallExpression' &&
        r === 'arguments' &&
        e.arguments.length === 1 &&
        e.callee.type === 'CallExpression'
      ) {
        let n = e.callee.callee;
        return (
          n.type === 'Identifier' ||
          (n.type === 'MemberExpression' &&
            !n.computed &&
            n.object.type === 'Identifier' &&
            n.property.type === 'Identifier')
        );
      }
      return !1;
    },
    (e, r) =>
      (e.type === 'VariableDeclarator' && r === 'init') ||
      (e.type === 'ExportDefaultDeclaration' && r === 'declaration') ||
      (e.type === 'TSExportAssignment' && r === 'expression') ||
      (e.type === 'AssignmentExpression' &&
        r === 'right' &&
        e.left.type === 'MemberExpression' &&
        e.left.object.type === 'Identifier' &&
        e.left.object.name === 'module' &&
        e.left.property.type === 'Identifier' &&
        e.left.property.name === 'exports'),
    (e) => e.type !== 'VariableDeclaration' || (e.kind === 'const' && e.declarations.length === 1),
  );
}
function GR(t) {
  let e = Vr(t);
  return e.length > 1 && e.some((r) => r.type === 'TSParameterProperty');
}
function VF(t) {
  if (Py(t) || ho(t)) return !0;
  if (t.type === 'UnionTypeAnnotation' || t.type === 'TSUnionType') {
    let e = t.types.filter(
        (i) =>
          i.type === 'VoidTypeAnnotation' ||
          i.type === 'TSVoidKeyword' ||
          i.type === 'NullLiteralTypeAnnotation' ||
          i.type === 'TSNullKeyword',
      ).length,
      r = t.types.some(
        (i) =>
          i.type === 'ObjectTypeAnnotation' ||
          i.type === 'TSTypeLiteral' ||
          i.type === 'GenericTypeAnnotation' ||
          i.type === 'TSTypeReference',
      ),
      n = t.types.some((i) => Me(i));
    if (t.types.length - 1 === e && r && !n) return !0;
  }
  return !1;
}
function YR(t, e, r) {
  let n = e.semi ? ';' : '',
    { node: i } = t,
    s = [Kn(t), 'opaque type ', r('id'), r('typeParameters')];
  return i.supertype && s.push(': ', r('supertype')), i.impltype && s.push(' = ', r('impltype')), s.push(n), s;
}
function zF(t, e, r) {
  let n = e.semi ? ';' : '',
    { node: i } = t,
    s = [Kn(t)];
  s.push('type ', r('id'), r('typeParameters'));
  let o = i.type === 'TSTypeAliasDeclaration' ? 'typeAnnotation' : 'right';
  return [yc(t, e, r, s, ' =', o), n];
}
function HF(t, e, r) {
  let n = !1;
  return oe(
    t.map(({ isFirst: i, previous: s, node: o, index: l }) => {
      let c = r();
      if (i) return c;
      let p = ho(o),
        f = ho(s);
      return f && p
        ? [' & ', n ? Se(c) : c]
        : !f && !p
        ? Se([' &', We, c])
        : (l > 1 && (n = !0), [' & ', l > 1 ? Se(c) : c]);
    }, 'types'),
  );
}
function WF(t, e, r) {
  let { node: n } = t,
    { parent: i } = t,
    s =
      i.type !== 'TypeParameterInstantiation' &&
      i.type !== 'TSTypeParameterInstantiation' &&
      i.type !== 'GenericTypeAnnotation' &&
      i.type !== 'TSTypeReference' &&
      i.type !== 'TSTypeAssertion' &&
      i.type !== 'TupleTypeAnnotation' &&
      i.type !== 'TSTupleType' &&
      !(i.type === 'FunctionTypeParam' && !i.name && t.grandparent.this !== i) &&
      !(
        (i.type === 'TypeAlias' || i.type === 'VariableDeclarator' || i.type === 'TSTypeAliasDeclaration') &&
        sa(e.originalText, n)
      ),
    o = VF(n),
    l = t.map((f) => {
      let m = r();
      return o || (m = ci(2, m)), hi(f, m, e);
    }, 'types');
  if (o) return vt(' | ', l);
  let c = s && !sa(e.originalText, n),
    p = [Nt([c ? We : '', '| ']), vt([We, '| '], l)];
  return kl(t, e)
    ? oe([Se(p), Ae])
    : (i.type === 'TupleTypeAnnotation' || i.type === 'TSTupleType') &&
      i[i.type === 'TupleTypeAnnotation' && i.types ? 'types' : 'elementTypes'].length > 1
    ? oe([Se([Nt(['(', Ae]), p]), Ae, Nt(')')])
    : oe(s ? Se(p) : p);
}
function QR(t) {
  var e;
  let { node: r, parent: n } = t;
  return (
    r.type === 'FunctionTypeAnnotation' &&
    (uF(n) ||
      !(
        ((n.type === 'ObjectTypeProperty' || n.type === 'ObjectTypeInternalSlot') &&
          !n.variance &&
          !n.optional &&
          mc(n, r)) ||
        n.type === 'ObjectTypeCallProperty' ||
        ((e = t.getParentNode(2)) == null ? void 0 : e.type) === 'DeclareFunction'
      ))
  );
}
function UF(t, e, r) {
  let { node: n } = t,
    i = [$f(t)];
  (n.type === 'TSConstructorType' || n.type === 'TSConstructSignatureDeclaration') && i.push('new ');
  let s = Dc(t, r, e, !1, !0),
    o = [];
  return (
    n.type === 'FunctionTypeAnnotation'
      ? o.push(QR(t) ? ' => ' : ': ', r('returnType'))
      : o.push(Rr(t, r, n.returnType ? 'returnType' : 'typeAnnotation')),
    jf(n, o) && (s = oe(s)),
    i.push(s, o),
    oe(i)
  );
}
function qF(t, e, r) {
  return [r('objectType'), cn(t), '[', r('indexType'), ']'];
}
function KF(t, e, r) {
  return ['infer ', r('typeParameter')];
}
function zC(t, e, r) {
  let { node: n } = t;
  return [n.postfix ? '' : r, Rr(t, e), n.postfix ? r : ''];
}
function JF(t, e, r) {
  let { node: n } = t;
  return ['...', ...(n.type === 'TupleTypeSpreadElement' && n.label ? [r('label'), ': '] : []), r('typeAnnotation')];
}
function XF(t, e, r) {
  let { node: n } = t;
  return [n.variance ? r('variance') : '', r('label'), n.optional ? '?' : '', ': ', r('elementType')];
}
var ZR = new WeakSet();
function Rr(t, e, r = 'typeAnnotation') {
  let {
    node: { [r]: n },
  } = t;
  if (!n) return '';
  let i = !1;
  if (n.type === 'TSTypeAnnotation' || n.type === 'TypeAnnotation') {
    let s = t.call(GF, r);
    (s === '=>' || (s === ':' && Me(n, qe.Leading))) && (i = !0), ZR.add(n);
  }
  return i ? [' ', e(r)] : e(r);
}
var GF = (t) =>
  t.match(
    (e) => e.type === 'TSTypeAnnotation',
    (e, r) =>
      (r === 'returnType' || r === 'typeAnnotation') && (e.type === 'TSFunctionType' || e.type === 'TSConstructorType'),
  )
    ? '=>'
    : t.match(
        (e) => e.type === 'TSTypeAnnotation',
        (e, r) =>
          r === 'typeAnnotation' &&
          (e.type === 'TSJSDocNullableType' || e.type === 'TSJSDocNonNullableType' || e.type === 'TSTypePredicate'),
      ) ||
      t.match(
        (e) => e.type === 'TypeAnnotation',
        (e, r) => r === 'typeAnnotation' && e.type === 'Identifier',
        (e, r) => r === 'id' && e.type === 'DeclareFunction',
      ) ||
      t.match(
        (e) => e.type === 'TypeAnnotation',
        (e, r) => r === 'bound' && e.type === 'TypeParameter' && e.usesExtendsBound,
      )
    ? ''
    : ':';
function YF(t, e, r) {
  let n = GF(t);
  return n ? [n, ' ', r('typeAnnotation')] : r('typeAnnotation');
}
function QF(t) {
  return [t('elementType'), '[]'];
}
function ZF({ node: t }, e) {
  return ['typeof ', ...(t.type === 'TSTypeQuery' ? [e('exprName'), e('typeParameters')] : [e('argument')])];
}
function eS(t, e) {
  let { node: r } = t;
  return [r.asserts ? 'asserts ' : '', e('parameterName'), r.typeAnnotation ? [' is ', Rr(t, e)] : ''];
}
function cn(t) {
  let { node: e } = t;
  return !e.optional || (e.type === 'Identifier' && e === t.parent.key)
    ? ''
    : It(e) || (or(e) && e.computed) || e.type === 'OptionalIndexedAccessType'
    ? '?.'
    : '?';
}
function tS(t) {
  return t.node.definite || t.match(void 0, (e, r) => r === 'id' && e.type === 'VariableDeclarator' && e.definite)
    ? '!'
    : '';
}
var ej = new Set([
  'DeclareClass',
  'DeclareFunction',
  'DeclareVariable',
  'DeclareExportDeclaration',
  'DeclareExportAllDeclaration',
  'DeclareOpaqueType',
  'DeclareTypeAlias',
  'DeclareEnum',
  'DeclareInterface',
]);
function Kn(t) {
  let { node: e } = t;
  return e.declare || (ej.has(e.type) && t.parent.type !== 'DeclareExportDeclaration') ? 'declare ' : '';
}
var tj = new Set(['TSAbstractMethodDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
function $f({ node: t }) {
  return t.abstract || tj.has(t.type) ? 'abstract ' : '';
}
function oa(t, e, r) {
  let n = t.node;
  return n.typeArguments ? r('typeArguments') : n.typeParameters ? r('typeParameters') : '';
}
function rS(t, e, r) {
  return ['::', r('callee')];
}
function Bs(t, e, r) {
  return t.type === 'EmptyStatement' ? ';' : t.type === 'BlockStatement' || r ? [' ', e] : Se([We, e]);
}
function nS(t, e) {
  return ['...', e('argument'), Rr(t, e)];
}
function Up(t) {
  return t.accessibility ? t.accessibility + ' ' : '';
}
function iS(t, e, r) {
  let { node: n } = t;
  return oe([vt(We, t.map(r, 'decorators')), sS(n, e) ? Ee : We]);
}
function rj(t, e, r) {
  return oS(t.node) ? [vt(Ee, t.map(r, 'declaration', 'decorators')), Ee] : '';
}
function nj(t, e, r) {
  let { node: n, parent: i } = t,
    { decorators: s } = n;
  if (!kt(s) || oS(i) || kF(t)) return '';
  let o = n.type === 'ClassExpression' || n.type === 'ClassDeclaration' || sS(n, e);
  return [t.key === 'declaration' && IL(i) ? Ee : o ? uo : '', vt(We, t.map(r, 'decorators')), We];
}
function sS(t, e) {
  return t.decorators.some((r) => Pn(e.originalText, zt(r)));
}
function oS(t) {
  var e;
  if (
    t.type !== 'ExportDefaultDeclaration' &&
    t.type !== 'ExportNamedDeclaration' &&
    t.type !== 'DeclareExportDeclaration'
  )
    return !1;
  let r = (e = t.declaration) == null ? void 0 : e.decorators;
  return kt(r) && mc(t, r[0]);
}
function ij(t, e, r) {
  let { node: n } = t;
  return ['import', n.module ? ' module' : '', uS(n), hS(t, e, r), cS(t, e, r), fS(t, e, r), e.semi ? ';' : ''];
}
var aS = (t) => t.type === 'ExportDefaultDeclaration' || (t.type === 'DeclareExportDeclaration' && t.default);
function lS(t, e, r) {
  let { node: n } = t,
    i = [rj(t, e, r), Kn(t), 'export', aS(n) ? ' default' : ''],
    { declaration: s, exported: o } = n;
  return (
    Me(n, qe.Dangling) && (i.push(' ', dr(t, e)), pF(n) && i.push(Ee)),
    s
      ? i.push(' ', r('declaration'))
      : (i.push(aj(n)),
        n.type === 'ExportAllDeclaration' || n.type === 'DeclareExportAllDeclaration'
          ? (i.push(' *'), o && i.push(' as ', r('exported')))
          : i.push(hS(t, e, r)),
        i.push(cS(t, e, r), fS(t, e, r))),
    i.push(oj(n, e)),
    i
  );
}
var sj = ir([
  'ClassDeclaration',
  'FunctionDeclaration',
  'TSInterfaceDeclaration',
  'DeclareClass',
  'DeclareFunction',
  'TSDeclareFunction',
  'EnumDeclaration',
]);
function oj(t, e) {
  return e.semi && (!t.declaration || (aS(t) && !sj(t.declaration))) ? ';' : '';
}
function $y(t, e = !0) {
  return t && t !== 'value' ? `${e ? ' ' : ''}${t}${e ? '' : ' '}` : '';
}
function uS(t, e) {
  return $y(t.importKind, e);
}
function aj(t) {
  return $y(t.exportKind);
}
function cS(t, e, r) {
  let { node: n } = t;
  if (!n.source) return '';
  let i = [];
  return pS(n, e) || i.push(' from'), i.push(' ', r('source')), i;
}
function hS(t, e, r) {
  let { node: n } = t;
  if (pS(n, e)) return '';
  let i = [' '];
  if (kt(n.specifiers)) {
    let s = [],
      o = [];
    t.each(() => {
      let l = t.node.type;
      if (
        l === 'ExportNamespaceSpecifier' ||
        l === 'ExportDefaultSpecifier' ||
        l === 'ImportNamespaceSpecifier' ||
        l === 'ImportDefaultSpecifier'
      )
        s.push(r());
      else if (l === 'ExportSpecifier' || l === 'ImportSpecifier') o.push(r());
      else throw new Pl(n, 'specifier');
    }, 'specifiers'),
      i.push(vt(', ', s)),
      o.length > 0 &&
        (s.length > 0 && i.push(', '),
        o.length > 1 || s.length > 0 || n.specifiers.some((l) => Me(l))
          ? i.push(
              oe([
                '{',
                Se([e.bracketSpacing ? We : Ae, vt([',', We], o)]),
                Nt(go(e) ? ',' : ''),
                e.bracketSpacing ? We : Ae,
                '}',
              ]),
            )
          : i.push(['{', e.bracketSpacing ? ' ' : '', ...o, e.bracketSpacing ? ' ' : '', '}']));
  } else i.push('{}');
  return i;
}
function pS(t, e) {
  let { type: r, importKind: n, source: i, specifiers: s } = t;
  return r !== 'ImportDeclaration' || kt(s) || n === 'type' ? !1 : !/{\s*}/.test(e.originalText.slice(Er(t), Er(i)));
}
function fS(t, e, r) {
  var n;
  let { node: i } = t,
    s = kt(i.attributes) ? 'attributes' : kt(i.assertions) ? 'assertions' : void 0;
  return s
    ? [
        ` ${s === 'assertions' || ((n = i.extra) != null && n.deprecatedAssertSyntax) ? 'assert' : 'with'} {`,
        e.bracketSpacing ? ' ' : '',
        vt(', ', t.map(r, s)),
        e.bracketSpacing ? ' ' : '',
        '}',
      ]
    : '';
}
function lj(t, e, r) {
  let { node: n } = t,
    { type: i } = n,
    s = i.startsWith('Import'),
    o = s ? 'imported' : 'local',
    l = s ? 'local' : 'exported',
    c = n[o],
    p = n[l],
    f = '',
    m = '';
  return (
    i === 'ExportNamespaceSpecifier' || i === 'ImportNamespaceSpecifier' ? (f = '*') : c && (f = r(o)),
    p && !uj(n) && (m = r(l)),
    [$y(i === 'ImportSpecifier' ? n.importKind : n.exportKind, !1), f, f && m ? ' as ' : '', m]
  );
}
function uj(t) {
  if (t.type !== 'ImportSpecifier' && t.type !== 'ExportSpecifier') return !1;
  let { local: e, [t.type === 'ImportSpecifier' ? 'imported' : 'exported']: r } = t;
  if (e.type !== r.type || !DL(e, r)) return !1;
  if (Bn(e)) return e.value === r.value && qn(e) === qn(r);
  switch (e.type) {
    case 'Identifier':
      return e.name === r.name;
    default:
      return !1;
  }
}
function cj(t) {
  let e = [t];
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    for (let i of ['test', 'consequent', 'alternate']) {
      let s = n[i];
      if (_r(s)) return !0;
      s.type === 'ConditionalExpression' && e.push(s);
    }
  }
  return !1;
}
function hj(t, e, r) {
  let { node: n } = t,
    i = n.type === 'ConditionalExpression',
    s = i ? 'alternate' : 'falseType',
    { parent: o } = t,
    l = i ? r('test') : [r('checkType'), ' ', 'extends', ' ', r('extendsType')];
  return o.type === n.type && o[s] === n ? ci(2, l) : l;
}
var pj = new Map([
  ['AssignmentExpression', 'right'],
  ['VariableDeclarator', 'init'],
  ['ReturnStatement', 'argument'],
  ['ThrowStatement', 'argument'],
  ['UnaryExpression', 'argument'],
  ['YieldExpression', 'argument'],
]);
function fj(t) {
  let { node: e } = t;
  if (e.type !== 'ConditionalExpression') return !1;
  let r,
    n = e;
  for (let i = 0; !r; i++) {
    let s = t.getParentNode(i);
    if (
      (s.type === 'ChainExpression' && s.expression === n) ||
      (It(s) && s.callee === n) ||
      (or(s) && s.object === n) ||
      (s.type === 'TSNonNullExpression' && s.expression === n)
    ) {
      n = s;
      continue;
    }
    (s.type === 'NewExpression' && s.callee === n) || (Qs(s) && s.expression === n)
      ? ((r = t.getParentNode(i + 1)), (n = s))
      : (r = s);
  }
  return n === e ? !1 : r[pj.get(r.type)] === n;
}
function Vy(t, e, r) {
  let { node: n } = t,
    i = n.type === 'ConditionalExpression',
    s = i ? 'consequent' : 'trueType',
    o = i ? 'alternate' : 'falseType',
    l = i ? ['test'] : ['checkType', 'extendsType'],
    c = n[s],
    p = n[o],
    f = [],
    m = !1,
    { parent: g } = t,
    x = g.type === n.type && l.some((W) => g[W] === n),
    b = g.type === n.type && !x,
    F,
    E,
    w = 0;
  do (E = F || n), (F = t.getParentNode(w)), w++;
  while (F && F.type === n.type && l.every((W) => F[W] !== E));
  let I = F || g,
    T = E;
  if (i && (_r(n[l[0]]) || _r(c) || _r(p) || cj(T))) {
    (m = !0), (b = !0);
    let W = (q) => [Nt('('), Se([Ae, q]), Ae, Nt(')')],
      X = (q) =>
        q.type === 'NullLiteral' ||
        (q.type === 'Literal' && q.value === null) ||
        (q.type === 'Identifier' && q.name === 'undefined');
    f.push(' ? ', X(c) ? r(s) : W(r(s)), ' : ', p.type === n.type || X(p) ? r(o) : W(r(o)));
  } else {
    let W = [
      We,
      '? ',
      c.type === n.type ? Nt('', '(') : '',
      ci(2, r(s)),
      c.type === n.type ? Nt('', ')') : '',
      We,
      ': ',
      p.type === n.type ? r(o) : ci(2, r(o)),
    ];
    f.push(g.type !== n.type || g[o] === n || x ? W : e.useTabs ? V5(Se(W)) : ci(Math.max(0, e.tabWidth - 2), W));
  }
  let j = [s, o, ...l].some((W) => Me(n[W], (X) => ys(X) && gc(e.originalText, Er(X), zt(X)))),
    $ = (W) => (g === I ? oe(W, { shouldBreak: j }) : j ? [W, uo] : W),
    L = !m && (or(g) || (g.type === 'NGPipeExpression' && g.left === n)) && !g.computed,
    se = fj(t),
    Y = $([hj(t, e, r), b ? f : Se(f), i && L && !se ? Ae : '']);
  return x || se ? oe([Se([Ae, Y]), Ae]) : Y;
}
function dj(t, e, r = 0) {
  let n = 0;
  for (let i = r; i < t.length; ++i) t[i] === '	' ? (n = n + e - (n % e)) : n++;
  return n;
}
var mj = dj;
function gj(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : mj(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var yj = gj;
function Dj(t) {
  switch (t) {
    case 'cr':
      return '\r';
    case 'crlf':
      return `\r
`;
    default:
      return `
`;
  }
}
var dn = Symbol('MODE_BREAK'),
  wi = Symbol('MODE_FLAT'),
  ku = Symbol('cursor');
function dS() {
  return { value: '', length: 0, queue: [] };
}
function xj(t, e) {
  return cg(t, { type: 'indent' }, e);
}
function Cj(t, e, r) {
  return e === Number.NEGATIVE_INFINITY
    ? t.root || dS()
    : e < 0
    ? cg(t, { type: 'dedent' }, r)
    : e
    ? e.type === 'root'
      ? { ...t, root: t }
      : cg(t, { type: typeof e == 'string' ? 'stringAlign' : 'numberAlign', n: e }, r)
    : t;
}
function cg(t, e, r) {
  let n = e.type === 'dedent' ? t.queue.slice(0, -1) : [...t.queue, e],
    i = '',
    s = 0,
    o = 0,
    l = 0;
  for (let b of n)
    switch (b.type) {
      case 'indent':
        f(), r.useTabs ? c(1) : p(r.tabWidth);
        break;
      case 'stringAlign':
        f(), (i += b.n), (s += b.n.length);
        break;
      case 'numberAlign':
        (o += 1), (l += b.n);
        break;
      default:
        throw new Error(`Unexpected type '${b.type}'`);
    }
  return g(), { ...t, value: i, length: s, queue: n };
  function c(b) {
    (i += '	'.repeat(b)), (s += r.tabWidth * b);
  }
  function p(b) {
    (i += ' '.repeat(b)), (s += b);
  }
  function f() {
    r.useTabs ? m() : g();
  }
  function m() {
    o > 0 && c(o), x();
  }
  function g() {
    l > 0 && p(l), x();
  }
  function x() {
    (o = 0), (l = 0);
  }
}
function hg(t) {
  let e = 0,
    r = 0,
    n = t.length;
  e: for (; n--; ) {
    let i = t[n];
    if (i === ku) {
      r++;
      continue;
    }
    for (let s = i.length - 1; s >= 0; s--) {
      let o = i[s];
      if (o === ' ' || o === '	') e++;
      else {
        t[n] = i.slice(0, s + 1);
        break e;
      }
    }
  }
  if (e > 0 || r > 0) for (t.length = n + 1; r-- > 0; ) t.push(ku);
  return e;
}
function jh(t, e, r, n, i, s) {
  if (r === Number.POSITIVE_INFINITY) return !0;
  let o = e.length,
    l = [t],
    c = [];
  for (; r >= 0; ) {
    if (l.length === 0) {
      if (o === 0) return !0;
      l.push(e[--o]);
      continue;
    }
    let { mode: p, doc: f } = l.pop();
    switch (wl(f)) {
      case vl:
        c.push(f), (r -= fl(f));
        break;
      case na:
      case Hi: {
        let m = Qv(f);
        for (let g = m.length - 1; g >= 0; g--) l.push({ mode: p, doc: m[g] });
        break;
      }
      case ua:
      case ca:
      case ha:
      case fo:
        l.push({ mode: p, doc: f.contents });
        break;
      case Sl:
        r += hg(c);
        break;
      case Un: {
        if (s && f.break) return !1;
        let m = f.break ? dn : p,
          g = f.expandedStates && m === dn ? Lt(!1, f.expandedStates, -1) : f.contents;
        l.push({ mode: m, doc: g });
        break;
      }
      case ji: {
        let m = (f.groupId ? i[f.groupId] || wi : p) === dn ? f.breakContents : f.flatContents;
        m && l.push({ mode: p, doc: m });
        break;
      }
      case Nn:
        if (p === dn || f.hard) return !0;
        f.soft || (c.push(' '), r--);
        break;
      case pa:
        n = !0;
        break;
      case fa:
        if (n) return !1;
        break;
    }
  }
  return !1;
}
function mS(t, e) {
  let r = {},
    n = e.printWidth,
    i = Dj(e.endOfLine),
    s = 0,
    o = [{ ind: dS(), mode: dn, doc: t }],
    l = [],
    c = !1,
    p = [],
    f = 0;
  for (q5(t); o.length > 0; ) {
    let { ind: g, mode: x, doc: b } = o.pop();
    switch (wl(b)) {
      case vl: {
        let F =
          i !==
          `
`
            ? Tn(
                !1,
                b,
                `
`,
                i,
              )
            : b;
        l.push(F), o.length > 0 && (s += fl(F));
        break;
      }
      case na:
        for (let F = b.length - 1; F >= 0; F--) o.push({ ind: g, mode: x, doc: b[F] });
        break;
      case Fl:
        if (f >= 2) throw new Error("There are too many 'cursor' in doc.");
        l.push(ku), f++;
        break;
      case ua:
        o.push({ ind: xj(g, e), mode: x, doc: b.contents });
        break;
      case ca:
        o.push({ ind: Cj(g, b.n, e), mode: x, doc: b.contents });
        break;
      case Sl:
        s -= hg(l);
        break;
      case Un:
        switch (x) {
          case wi:
            if (!c) {
              o.push({ ind: g, mode: b.break ? dn : wi, doc: b.contents });
              break;
            }
          case dn: {
            c = !1;
            let F = { ind: g, mode: wi, doc: b.contents },
              E = n - s,
              w = p.length > 0;
            if (!b.break && jh(F, o, E, w, r)) o.push(F);
            else if (b.expandedStates) {
              let I = Lt(!1, b.expandedStates, -1);
              if (b.break) {
                o.push({ ind: g, mode: dn, doc: I });
                break;
              } else
                for (let T = 1; T < b.expandedStates.length + 1; T++)
                  if (T >= b.expandedStates.length) {
                    o.push({ ind: g, mode: dn, doc: I });
                    break;
                  } else {
                    let j = b.expandedStates[T],
                      $ = { ind: g, mode: wi, doc: j };
                    if (jh($, o, E, w, r)) {
                      o.push($);
                      break;
                    }
                  }
            } else o.push({ ind: g, mode: dn, doc: b.contents });
            break;
          }
        }
        b.id && (r[b.id] = Lt(!1, o, -1).mode);
        break;
      case Hi: {
        let F = n - s,
          { parts: E } = b;
        if (E.length === 0) break;
        let [w, I] = E,
          T = { ind: g, mode: wi, doc: w },
          j = { ind: g, mode: dn, doc: w },
          $ = jh(T, [], F, p.length > 0, r, !0);
        if (E.length === 1) {
          $ ? o.push(T) : o.push(j);
          break;
        }
        let L = { ind: g, mode: wi, doc: I },
          se = { ind: g, mode: dn, doc: I };
        if (E.length === 2) {
          $ ? o.push(L, T) : o.push(se, j);
          break;
        }
        E.splice(0, 2);
        let Y = { ind: g, mode: x, doc: Ay(E) },
          W = E[0];
        jh({ ind: g, mode: wi, doc: [w, I, W] }, [], F, p.length > 0, r, !0)
          ? o.push(Y, L, T)
          : $
          ? o.push(Y, se, T)
          : o.push(Y, se, j);
        break;
      }
      case ji:
      case ha: {
        let F = b.groupId ? r[b.groupId] : x;
        if (F === dn) {
          let E = b.type === ji ? b.breakContents : b.negate ? b.contents : Se(b.contents);
          E && o.push({ ind: g, mode: x, doc: E });
        }
        if (F === wi) {
          let E = b.type === ji ? b.flatContents : b.negate ? Se(b.contents) : b.contents;
          E && o.push({ ind: g, mode: x, doc: E });
        }
        break;
      }
      case pa:
        p.push({ ind: g, mode: x, doc: b.contents });
        break;
      case fa:
        p.length > 0 && o.push({ ind: g, mode: x, doc: Gv });
        break;
      case Nn:
        switch (x) {
          case wi:
            if (b.hard) c = !0;
            else {
              b.soft || (l.push(' '), (s += 1));
              break;
            }
          case dn:
            if (p.length > 0) {
              o.push({ ind: g, mode: x, doc: b }, ...p.reverse()), (p.length = 0);
              break;
            }
            b.literal
              ? g.root
                ? (l.push(i, g.root.value), (s = g.root.length))
                : (l.push(i), (s = 0))
              : ((s -= hg(l)), l.push(i + g.value), (s = g.length));
            break;
        }
        break;
      case fo:
        o.push({ ind: g, mode: x, doc: b.contents });
        break;
      case mo:
        break;
      default:
        throw new ec(b);
    }
    o.length === 0 && p.length > 0 && (o.push(...p.reverse()), (p.length = 0));
  }
  let m = l.indexOf(ku);
  if (m !== -1) {
    let g = l.indexOf(ku, m + 1),
      x = l.slice(0, m).join(''),
      b = l.slice(m + 1, g).join(''),
      F = l.slice(g + 1).join('');
    return { formatted: x + b + F, cursorNodeStart: x.length, cursorNodeText: b };
  }
  return { formatted: l.join('') };
}
function gS(t, e, r) {
  let { node: n } = t;
  if (n.type === 'TemplateLiteral' && vj(t)) {
    let p = Aj(t, r, e);
    if (p) return p;
  }
  let i = 'expressions';
  n.type === 'TSTemplateLiteralType' && (i = 'types');
  let s = [],
    o = t.map(e, i),
    l = jL(n);
  l && (o = o.map((p) => mS(p, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted)), s.push(cs, '`');
  let c = 0;
  return (
    t.each(({ index: p, node: f }) => {
      if ((s.push(e()), f.tail)) return;
      let { tabWidth: m } = r,
        g = f.value.raw,
        x = g.includes(`
`)
          ? yj(g, m)
          : c;
      c = x;
      let b = o[p];
      if (!l) {
        let E = n[i][p];
        (Me(E) || or(E) || E.type === 'ConditionalExpression' || E.type === 'SequenceExpression' || Qs(E) || hs(E)) &&
          (b = [Se([Ae, b]), Ae]);
      }
      let F =
        x === 0 &&
        g.endsWith(`
`)
          ? ci(Number.NEGATIVE_INFINITY, b)
          : H5(b, x, m);
      s.push(oe(['${', F, cs, '}']));
    }, 'quasis'),
    s.push('`'),
    s
  );
}
function bj(t) {
  let e = t('quasi');
  return dc(e.label && { tagged: !0, ...e.label }, [t('tag'), t('typeParameters'), cs, e]);
}
function Aj(t, e, r) {
  let { node: n } = t,
    i = n.quasis[0].value.raw.trim().split(/\s*\|\s*/);
  if (i.length > 1 || i.some((s) => s.length > 0)) {
    e.__inJestEach = !0;
    let s = t.map(r, 'expressions');
    e.__inJestEach = !1;
    let o = [],
      l = s.map((g) => '${' + mS(g, { ...e, printWidth: Number.POSITIVE_INFINITY, endOfLine: 'lf' }).formatted + '}'),
      c = [{ hasLineBreak: !1, cells: [] }];
    for (let g = 1; g < n.quasis.length; g++) {
      let x = Lt(!1, c, -1),
        b = l[g - 1];
      x.cells.push(b),
        b.includes(`
`) && (x.hasLineBreak = !0),
        n.quasis[g].value.raw.includes(`
`) && c.push({ hasLineBreak: !1, cells: [] });
    }
    let p = Math.max(i.length, ...c.map((g) => g.cells.length)),
      f = Array.from({ length: p }).fill(0),
      m = [{ cells: i }, ...c.filter((g) => g.cells.length > 0)];
    for (let { cells: g } of m.filter((x) => !x.hasLineBreak))
      for (let [x, b] of g.entries()) f[x] = Math.max(f[x], fl(b));
    return (
      o.push(
        cs,
        '`',
        Se([
          Ee,
          vt(
            Ee,
            m.map((g) =>
              vt(
                ' | ',
                g.cells.map((x, b) => (g.hasLineBreak ? x : x + ' '.repeat(f[b] - fl(x)))),
              ),
            ),
          ),
        ]),
        Ee,
        '`',
      ),
      o
    );
  }
}
function Ej(t, e) {
  let { node: r } = t,
    n = e();
  return Me(r) && (n = oe([Se([Ae, n]), Ae])), ['${', n, cs, '}'];
}
function zy(t, e) {
  return t.map((r) => Ej(r, e), 'expressions');
}
function yS(t, e) {
  return Tl(t, (r) => (typeof r == 'string' ? (e ? Tn(!1, r, /(\\*)`/g, '$1$1\\`') : DS(r)) : r));
}
function DS(t) {
  return Tn(!1, t, /([\\`]|\${)/g, '\\$1');
}
function vj({ node: t, parent: e }) {
  let r = /^[fx]?(?:describe|it|test)$/;
  return (
    e.type === 'TaggedTemplateExpression' &&
    e.quasi === t &&
    e.tag.type === 'MemberExpression' &&
    e.tag.property.type === 'Identifier' &&
    e.tag.property.name === 'each' &&
    ((e.tag.object.type === 'Identifier' && r.test(e.tag.object.name)) ||
      (e.tag.object.type === 'MemberExpression' &&
        e.tag.object.property.type === 'Identifier' &&
        (e.tag.object.property.name === 'only' || e.tag.object.property.name === 'skip') &&
        e.tag.object.object.type === 'Identifier' &&
        r.test(e.tag.object.object.name)))
  );
}
function Fj(t) {
  let e = new WeakMap();
  return function (r) {
    return e.has(r) || e.set(r, Symbol(t)), e.get(r);
  };
}
var xS = Fj;
function Sj(t) {
  switch (t) {
    case null:
      return '';
    case 'PlusOptional':
      return '+?';
    case 'MinusOptional':
      return '-?';
    case 'Optional':
      return '?';
  }
}
function wj(t, e, r) {
  let { node: n } = t;
  return oe([
    n.variance ? r('variance') : '',
    '[',
    Se([r('keyTparam'), ' in ', r('sourceType')]),
    ']',
    Sj(n.optional),
    ': ',
    r('propType'),
  ]);
}
function CS(t, e) {
  return t === '+' || t === '-' ? t + e : e;
}
function Tj(t, e, r) {
  let { node: n } = t,
    i = gc(e.originalText, Er(n), Er(n.typeParameter));
  return oe(
    [
      '{',
      Se([
        e.bracketSpacing ? We : Ae,
        oe([
          r('typeParameter'),
          n.optional ? CS(n.optional, '?') : '',
          n.typeAnnotation ? ': ' : '',
          r('typeAnnotation'),
        ]),
        e.semi ? Nt(';') : '',
      ]),
      dr(t, e),
      e.bracketSpacing ? We : Ae,
      '}',
    ],
    { shouldBreak: i },
  );
}
var Hy = xS('typeParameters');
function kj(t, e, r) {
  let { node: n } = t;
  return (
    Vr(n).length === 1 &&
    n.type.startsWith('TS') &&
    !n[r][0].constraint &&
    t.parent.type === 'ArrowFunctionExpression' &&
    !(e.filepath && /\.ts$/.test(e.filepath))
  );
}
function Pu(t, e, r, n) {
  let { node: i } = t;
  if (!i[n]) return '';
  if (!Array.isArray(i[n])) return r(n);
  let s = t.getNode(2),
    o = s && _f(s),
    l = t.match(
      (p) => !(p[n].length === 1 && ho(p[n][0])),
      void 0,
      (p, f) => f === 'typeAnnotation',
      (p) => p.type === 'Identifier',
      RF,
    );
  if (
    i[n].length === 0 ||
    (!l && (o || (i[n].length === 1 && (i[n][0].type === 'NullableTypeAnnotation' || VF(i[n][0])))))
  )
    return ['<', vt(', ', t.map(r, n)), Pj(t, e), '>'];
  let c = i.type === 'TSTypeParameterInstantiation' ? '' : kj(t, e, n) ? ',' : go(e) ? Nt(',') : '';
  return oe(['<', Se([Ae, vt([',', We], t.map(r, n))]), c, Ae, '>'], { id: Hy(i) });
}
function Pj(t, e) {
  let { node: r } = t;
  if (!Me(r, qe.Dangling)) return '';
  let n = !Me(r, qe.Line),
    i = dr(t, e, { indent: !n });
  return n ? i : [i, Ee];
}
function bS(t, e, r) {
  let { node: n, parent: i } = t,
    s = [n.type === 'TSTypeParameter' && n.const ? 'const ' : ''],
    o = n.type === 'TSTypeParameter' ? r('name') : n.name;
  if (i.type === 'TSMappedType')
    return (
      i.readonly && s.push(CS(i.readonly, 'readonly'), ' '),
      s.push('[', o),
      n.constraint && s.push(' in ', r('constraint')),
      i.nameType &&
        s.push(
          ' as ',
          t.callParent(() => r('nameType')),
        ),
      s.push(']'),
      s
    );
  if (
    (n.variance && s.push(r('variance')),
    n.in && s.push('in '),
    n.out && s.push('out '),
    s.push(o),
    n.bound && (n.usesExtendsBound && s.push(' extends '), s.push(Rr(t, r, 'bound'))),
    n.constraint)
  ) {
    let l = Symbol('constraint');
    s.push(' extends', oe(Se(We), { id: l }), cs, Lf(r('constraint'), { groupId: l }));
  }
  return n.default && s.push(' = ', r('default')), oe(s);
}
var AS = new Proxy(() => {}, { get: () => AS }),
  ES = AS,
  $h = new WeakMap();
function xc(t, e, r) {
  let { node: n } = t;
  if (n.computed) return ['[', r('key'), ']'];
  let { parent: i } = t,
    { key: s } = n;
  if (e.quoteProps === 'consistent' && !$h.has(i)) {
    let o = (i.properties || i.body || i.members).some((l) => !l.computed && l.key && Bn(l.key) && !BC(l, e));
    $h.set(i, o);
  }
  if (
    (s.type === 'Identifier' ||
      (co(s) &&
        cF(Ws(qn(s))) &&
        String(s.value) === Ws(qn(s)) &&
        !(e.parser === 'typescript' || e.parser === 'babel-ts'))) &&
    (e.parser === 'json' || (e.quoteProps === 'consistent' && $h.get(i)))
  ) {
    let o = Wp(JSON.stringify(s.type === 'Identifier' ? s.name : s.value.toString()), e);
    return t.call((l) => hi(l, o, e), 'key');
  }
  return BC(n, e) && (e.quoteProps === 'as-needed' || (e.quoteProps === 'consistent' && !$h.get(i)))
    ? t.call((o) => hi(o, /^\d/.test(s.value) ? Ws(s.value) : s.value, e), 'key')
    : r('key');
}
function Bj(t, e, r) {
  let { node: n } = t;
  return n.shorthand ? r('value') : yc(t, e, r, xc(t, e, r), ':', 'value');
}
var Ij = (t) =>
    t.type === 'ObjectMethod' ||
    t.type === 'ClassMethod' ||
    t.type === 'ClassPrivateMethod' ||
    t.type === 'MethodDefinition' ||
    t.type === 'TSAbstractMethodDefinition' ||
    t.type === 'TSDeclareMethod' ||
    ((t.type === 'Property' || t.type === 'ObjectProperty') && (t.method || t.kind === 'get' || t.kind === 'set')),
  Nj = (t) => t.node.type === 'FunctionExpression' && t.key === 'value' && Ij(t.parent);
function vS(t, e, r, n) {
  if (Nj(t)) return Wy(t, r, e);
  let { node: i } = t,
    s = !1;
  if ((i.type === 'FunctionDeclaration' || i.type === 'FunctionExpression') && n != null && n.expandLastArg) {
    let { parent: f } = t;
    It(f) && (yo(f).length > 1 || Vr(i).every((m) => m.type === 'Identifier' && !m.typeAnnotation)) && (s = !0);
  }
  let o = [Kn(t), i.async ? 'async ' : '', `function${i.generator ? '*' : ''} `, i.id ? e('id') : ''],
    l = Dc(t, e, r, s),
    c = Uy(t, e),
    p = jf(i, c);
  return (
    o.push(oa(t, r, e), oe([p ? oe(l) : l, c]), i.body ? ' ' : '', e('body')),
    r.semi && (i.declare || !i.body) && o.push(';'),
    o
  );
}
function pg(t, e, r) {
  let { node: n } = t,
    { kind: i } = n,
    s = n.value || n,
    o = [];
  return (
    !i || i === 'init' || i === 'method' || i === 'constructor'
      ? s.async && o.push('async ')
      : (ES.ok(i === 'get' || i === 'set'), o.push(i, ' ')),
    s.generator && o.push('*'),
    o.push(xc(t, e, r), n.optional || n.key.optional ? '?' : '', n === s ? Wy(t, e, r) : r('value')),
    o
  );
}
function Wy(t, e, r) {
  let { node: n } = t,
    i = Dc(t, r, e),
    s = Uy(t, r),
    o = GR(n),
    l = jf(n, s),
    c = [oa(t, e, r), oe([o ? oe(i, { shouldBreak: !0 }) : l ? oe(i) : i, s])];
  return n.body ? c.push(' ', r('body')) : c.push(e.semi ? ';' : ''), c;
}
function Mj(t) {
  let e = Vr(t);
  return (
    e.length === 1 &&
    !t.typeParameters &&
    !Me(t, qe.Dangling) &&
    e[0].type === 'Identifier' &&
    !e[0].typeAnnotation &&
    !Me(e[0]) &&
    !e[0].optional &&
    !t.predicate &&
    !t.returnType
  );
}
function FS(t, e) {
  if (e.arrowParens === 'always') return !1;
  if (e.arrowParens === 'avoid') {
    let { node: r } = t;
    return Mj(r);
  }
  return !1;
}
function Uy(t, e) {
  let { node: r } = t,
    n = [Rr(t, e, 'returnType')];
  return r.predicate && n.push(e('predicate')), n;
}
function SS(t, e, r) {
  let { node: n } = t,
    i = e.semi ? ';' : '',
    s = [];
  if (n.argument) {
    let c = r('argument');
    _j(e, n.argument)
      ? (c = ['(', Se([Ee, c]), Ee, ')'])
      : (hs(n.argument) || n.argument.type === 'SequenceExpression') && (c = oe([Nt('('), Se([Ae, c]), Ae, Nt(')')])),
      s.push(' ', c);
  }
  let o = Me(n, qe.Dangling),
    l = i && o && Me(n, qe.Last | qe.Line);
  return l && s.push(i), o && s.push(' ', dr(t, e)), l || s.push(i), s;
}
function Oj(t, e, r) {
  return ['return', SS(t, e, r)];
}
function Lj(t, e, r) {
  return ['throw', SS(t, e, r)];
}
function _j(t, e) {
  if (sa(t.originalText, e) || (Me(e, qe.Leading, (r) => gc(t.originalText, Er(r), zt(r))) && !_r(e))) return !0;
  if (Ty(e)) {
    let r = e,
      n;
    for (; (n = BL(r)); ) if (((r = n), sa(t.originalText, r))) return !0;
  }
  return !1;
}
var wS = ir([
  'ClassProperty',
  'PropertyDefinition',
  'ClassPrivateProperty',
  'ClassAccessorProperty',
  'AccessorProperty',
  'TSAbstractPropertyDefinition',
  'TSAbstractAccessorProperty',
]);
function TS(t, e, r) {
  let { node: n } = t,
    i = [Kn(t), $f(t), 'class'],
    s =
      Me(n.id, qe.Trailing) ||
      Me(n.typeParameters, qe.Trailing) ||
      Me(n.superClass) ||
      kt(n.extends) ||
      kt(n.mixins) ||
      kt(n.implements),
    o = [],
    l = [];
  if ((n.id && o.push(' ', r('id')), o.push(r('typeParameters')), n.superClass)) {
    let c = [jj(t, e, r), r('superTypeParameters')],
      p = t.call((f) => ['extends ', hi(f, c, e)], 'superClass');
    s ? l.push(We, oe(p)) : l.push(' ', p);
  } else l.push(Tm(t, e, r, 'extends'));
  if ((l.push(Tm(t, e, r, 'mixins'), Tm(t, e, r, 'implements')), s)) {
    let c;
    BS(n) ? (c = [...o, Se(l)]) : (c = Se([...o, l])), i.push(oe(c, { id: kS(n) }));
  } else i.push(...o, ...l);
  return i.push(' ', r('body')), i;
}
var kS = xS('heritageGroup');
function PS(t) {
  return Nt(Ee, '', { groupId: kS(t) });
}
function Rj(t) {
  return (
    ['extends', 'mixins', 'implements'].reduce(
      (e, r) => e + (Array.isArray(t[r]) ? t[r].length : 0),
      t.superClass ? 1 : 0,
    ) > 1
  );
}
function BS(t) {
  return t.typeParameters && !Me(t.typeParameters, qe.Trailing | qe.Line) && !Rj(t);
}
function Tm(t, e, r, n) {
  let { node: i } = t;
  if (!kt(i[n])) return '';
  let s = dr(t, e, { marker: n });
  return [
    BS(i) ? Nt(' ', We, { groupId: Hy(i.typeParameters) }) : We,
    s,
    s && Ee,
    n,
    oe(Se([We, vt([',', We], t.map(r, n))])),
  ];
}
function jj(t, e, r) {
  let n = r('superClass'),
    { parent: i } = t;
  return i.type === 'AssignmentExpression' ? oe(Nt(['(', Se([Ae, n]), Ae, ')'], n)) : n;
}
function IS(t, e, r) {
  let { node: n } = t,
    i = [];
  return (
    kt(n.decorators) && i.push(iS(t, e, r)),
    i.push(Up(n)),
    n.static && i.push('static '),
    i.push($f(t)),
    n.override && i.push('override '),
    i.push(pg(t, e, r)),
    i
  );
}
function NS(t, e, r) {
  let { node: n } = t,
    i = [],
    s = e.semi ? ';' : '';
  kt(n.decorators) && i.push(iS(t, e, r)),
    i.push(Up(n), Kn(t)),
    n.static && i.push('static '),
    i.push($f(t)),
    n.override && i.push('override '),
    n.readonly && i.push('readonly '),
    n.variance && i.push(r('variance')),
    (n.type === 'ClassAccessorProperty' || n.type === 'AccessorProperty' || n.type === 'TSAbstractAccessorProperty') &&
      i.push('accessor '),
    i.push(xc(t, e, r), cn(t), tS(t), Rr(t, r));
  let o = n.type === 'TSAbstractPropertyDefinition' || n.type === 'TSAbstractAccessorProperty';
  return [yc(t, e, r, i, ' =', o ? void 0 : 'value'), s];
}
function $j(t, e, r) {
  let { node: n } = t,
    i = [];
  return (
    t.each(({ node: s, next: o, isLast: l }) => {
      i.push(r()), !e.semi && wS(s) && Vj(s, o) && i.push(';'), l || (i.push(Ee), Do(s, e) && i.push(Ee));
    }, 'body'),
    Me(n, qe.Dangling) && i.push(dr(t, e)),
    [kt(n.body) ? PS(t.parent) : '', '{', i.length > 0 ? [Se([Ee, i]), Ee] : '', '}']
  );
}
function Vj(t, e) {
  var r;
  let { type: n, name: i } = t.key;
  if (
    !t.computed &&
    n === 'Identifier' &&
    (i === 'static' || i === 'get' || i === 'set') &&
    !t.value &&
    !t.typeAnnotation
  )
    return !0;
  if (!e || e.static || e.accessibility) return !1;
  if (!e.computed) {
    let s = (r = e.key) == null ? void 0 : r.name;
    if (s === 'in' || s === 'instanceof') return !0;
  }
  if (wS(e) && e.variance && !e.static && !e.declare) return !0;
  switch (e.type) {
    case 'ClassProperty':
    case 'PropertyDefinition':
    case 'TSAbstractPropertyDefinition':
      return e.computed;
    case 'MethodDefinition':
    case 'TSAbstractMethodDefinition':
    case 'ClassMethod':
    case 'ClassPrivateMethod': {
      if ((e.value ? e.value.async : e.async) || e.kind === 'get' || e.kind === 'set') return !1;
      let s = e.value ? e.value.generator : e.generator;
      return !!(e.computed || s);
    }
    case 'TSIndexSignature':
      return !0;
  }
  return !1;
}
function Vf(t, e, r) {
  var n;
  let i = e.semi ? ';' : '',
    { node: s } = t,
    o = s.type === 'ObjectTypeAnnotation',
    l =
      s.type === 'TSEnumDeclaration' ||
      s.type === 'EnumBooleanBody' ||
      s.type === 'EnumNumberBody' ||
      s.type === 'EnumStringBody' ||
      s.type === 'EnumSymbolBody',
    c = [s.type === 'TSTypeLiteral' || l ? 'members' : s.type === 'TSInterfaceBody' ? 'body' : 'properties'];
  o && c.push('indexers', 'callProperties', 'internalSlots');
  let p = c.flatMap((L) => t.map(({ node: se }) => ({ node: se, printed: r(), loc: Er(se) }), L));
  c.length > 1 && p.sort((L, se) => L.loc - se.loc);
  let { parent: f, key: m } = t,
    g =
      o &&
      m === 'body' &&
      (f.type === 'InterfaceDeclaration' || f.type === 'DeclareInterface' || f.type === 'DeclareClass'),
    x =
      s.type === 'TSInterfaceBody' ||
      l ||
      g ||
      (s.type === 'ObjectPattern' &&
        f.type !== 'FunctionDeclaration' &&
        f.type !== 'FunctionExpression' &&
        f.type !== 'ArrowFunctionExpression' &&
        f.type !== 'ObjectMethod' &&
        f.type !== 'ClassMethod' &&
        f.type !== 'ClassPrivateMethod' &&
        f.type !== 'AssignmentPattern' &&
        f.type !== 'CatchClause' &&
        s.properties.some((L) => L.value && (L.value.type === 'ObjectPattern' || L.value.type === 'ArrayPattern'))) ||
      (s.type !== 'ObjectPattern' && p.length > 0 && gc(e.originalText, Er(s), p[0].loc)),
    b = g ? ';' : s.type === 'TSInterfaceBody' || s.type === 'TSTypeLiteral' ? Nt(i, ';') : ',',
    F = s.type === 'RecordExpression' ? '#{' : s.exact ? '{|' : '{',
    E = s.exact ? '|}' : '}',
    w = [],
    I = p.map((L) => {
      let se = [...w, oe(L.printed)];
      return (
        (w = [b, We]),
        (L.node.type === 'TSPropertySignature' ||
          L.node.type === 'TSMethodSignature' ||
          L.node.type === 'TSConstructSignatureDeclaration' ||
          L.node.type === 'TSCallSignatureDeclaration') &&
          Me(L.node, qe.PrettierIgnore) &&
          w.shift(),
        Do(L.node, e) && w.push(Ee),
        se
      );
    });
  if (s.inexact || s.hasUnknownMembers) {
    let L;
    if (Me(s, qe.Dangling)) {
      let se = Me(s, qe.Line);
      L = [dr(t, e), se || Pn(e.originalText, zt(Lt(!1, Iy(s), -1))) ? Ee : We, '...'];
    } else L = ['...'];
    I.push([...w, ...L]);
  }
  let T = (n = Lt(!1, p, -1)) == null ? void 0 : n.node,
    j = !(
      s.inexact ||
      s.hasUnknownMembers ||
      (T &&
        (T.type === 'RestElement' ||
          ((T.type === 'TSPropertySignature' ||
            T.type === 'TSCallSignatureDeclaration' ||
            T.type === 'TSMethodSignature' ||
            T.type === 'TSConstructSignatureDeclaration') &&
            Me(T, qe.PrettierIgnore))))
    ),
    $;
  if (I.length === 0) {
    if (!Me(s, qe.Dangling)) return [F, E, Rr(t, r)];
    $ = oe([F, dr(t, e, { indent: !0 }), Ae, E, cn(t), Rr(t, r)]);
  } else
    $ = [
      g && kt(s.properties) ? PS(f) : '',
      F,
      Se([e.bracketSpacing ? We : Ae, ...I]),
      Nt(j && (b !== ',' || go(e)) ? b : ''),
      e.bracketSpacing ? We : Ae,
      E,
      cn(t),
      Rr(t, r),
    ];
  return t.match((L) => L.type === 'ObjectPattern' && !kt(L.decorators), km) ||
    (ho(s) &&
      (t.match(
        void 0,
        (L, se) => se === 'typeAnnotation',
        (L, se) => se === 'typeAnnotation',
        km,
      ) ||
        t.match(void 0, (L, se) => L.type === 'FunctionTypeParam' && se === 'typeAnnotation', km))) ||
    (!x &&
      t.match(
        (L) => L.type === 'ObjectPattern',
        (L) => L.type === 'AssignmentExpression' || L.type === 'VariableDeclarator',
      ))
    ? $
    : oe($, { shouldBreak: x });
}
function km(t, e) {
  return (e === 'params' || e === 'parameters' || e === 'this' || e === 'rest') && $F(t);
}
var Pm = new WeakMap();
function MS(t) {
  return (
    Pm.has(t) || Pm.set(t, t.type === 'ConditionalExpression' && !rn(t, (e) => e.type === 'ObjectExpression')),
    Pm.get(t)
  );
}
var OS = (t) => t.type === 'SequenceExpression';
function zj(t, e, r, n = {}) {
  let i = [],
    s,
    o = [],
    l = !1,
    c = !n.expandLastArg && t.node.body.type === 'ArrowFunctionExpression',
    p;
  (function E() {
    let { node: w } = t,
      I = Hj(t, e, r, n);
    if (i.length === 0) i.push(I);
    else {
      let { leading: T, trailing: j } = yF(t, e);
      i.push([T, I]), o.unshift(j);
    }
    c &&
      (l || (l = (w.returnType && Vr(w).length > 0) || w.typeParameters || Vr(w).some((T) => T.type !== 'Identifier'))),
      !c || w.body.type !== 'ArrowFunctionExpression' ? ((s = r('body', n)), (p = w.body)) : t.call(E, 'body');
  })();
  let f = !sa(e.originalText, p) && (OS(p) || Wj(p, s, e) || (!l && MS(p))),
    m = t.key === 'callee' && dl(t.parent),
    g = Symbol('arrow-chain'),
    x = Uj(t, n, { signatureDocs: i, shouldBreak: l }),
    b,
    F = !1;
  return (
    c && (m || n.assignmentLayout) && ((F = !0), (b = n.assignmentLayout === 'chain-tail-arrow-chain' || (m && !f))),
    (s = qj(t, e, n, { bodyDoc: s, bodyComments: o, functionBody: p, shouldPutBodyOnSameLine: f })),
    oe([
      oe(F ? Se([Ae, x]) : x, { shouldBreak: b, id: g }),
      ' =>',
      c ? Lf(s, { groupId: g }) : oe(s),
      c && m ? Nt(Ae, '', { groupId: g }) : '',
    ])
  );
}
function Hj(t, e, r, n) {
  let { node: i } = t,
    s = [];
  if ((i.async && s.push('async '), FS(t, e))) s.push(r(['params', 0]));
  else {
    let l = n.expandLastArg || n.expandFirstArg,
      c = Uy(t, r);
    if (l) {
      if (an(c)) throw new Hp();
      c = oe(eg(c));
    }
    s.push(oe([Dc(t, r, e, l, !0), c]));
  }
  let o = dr(t, e, {
    filter(l) {
      let c = Qo(e.originalText, zt(l));
      return c !== !1 && e.originalText.slice(c, c + 2) === '=>';
    },
  });
  return o && s.push(' ', o), s;
}
function Wj(t, e, r) {
  var n, i;
  return (
    $r(t) ||
    mi(t) ||
    t.type === 'ArrowFunctionExpression' ||
    t.type === 'DoExpression' ||
    t.type === 'BlockStatement' ||
    _r(t) ||
    (((n = e.label) == null ? void 0 : n.hug) !== !1 &&
      (((i = e.label) == null ? void 0 : i.embed) || hF(t, r.originalText)))
  );
}
function Uj(t, e, { signatureDocs: r, shouldBreak: n }) {
  if (r.length === 1) return r[0];
  let { parent: i, key: s } = t;
  return (s !== 'callee' && dl(i)) || hs(i)
    ? oe([r[0], ' =>', Se([We, vt([' =>', We], r.slice(1))])], { shouldBreak: n })
    : (s === 'callee' && dl(i)) || e.assignmentLayout
    ? oe(vt([' =>', We], r), { shouldBreak: n })
    : oe(Se(vt([' =>', We], r)), { shouldBreak: n });
}
function qj(t, e, r, { bodyDoc: n, bodyComments: i, functionBody: s, shouldPutBodyOnSameLine: o }) {
  let { node: l, parent: c } = t,
    p = r.expandLastArg && go(e, 'all') ? Nt(',') : '',
    f = (r.expandLastArg || c.type === 'JSXExpressionContainer') && !Me(l) ? Ae : '';
  return o && MS(s)
    ? [' ', oe([Nt('', '('), Se([Ae, n]), Nt('', ')'), p, f]), i]
    : (OS(s) && (n = oe(['(', Se([Ae, n]), Ae, ')'])), o ? [' ', n, i] : [Se([We, n, i]), p, f]);
}
function fg(t, e, r, n) {
  let { node: i } = t,
    s = [],
    o = Kj(i[n]);
  return (
    t.each(({ node: l }) => {
      l.type !== 'EmptyStatement' && (s.push(r()), l !== o && (s.push(Ee), Do(l, e) && s.push(Ee)));
    }, n),
    s
  );
}
function Kj(t) {
  for (let e = t.length - 1; e >= 0; e--) {
    let r = t[e];
    if (r.type !== 'EmptyStatement') return r;
  }
}
function LS(t, e, r) {
  let { node: n } = t,
    i = [];
  n.type === 'StaticBlock' && i.push('static '), i.push('{');
  let s = _S(t, e, r);
  if (s) i.push(Se([Ee, s]), Ee);
  else {
    let { parent: o } = t,
      l = t.grandparent;
    o.type === 'ArrowFunctionExpression' ||
      o.type === 'FunctionExpression' ||
      o.type === 'FunctionDeclaration' ||
      o.type === 'ObjectMethod' ||
      o.type === 'ClassMethod' ||
      o.type === 'ClassPrivateMethod' ||
      o.type === 'ForStatement' ||
      o.type === 'WhileStatement' ||
      o.type === 'DoWhileStatement' ||
      o.type === 'DoExpression' ||
      (o.type === 'CatchClause' && !l.finalizer) ||
      o.type === 'TSModuleDeclaration' ||
      o.type === 'TSDeclareFunction' ||
      n.type === 'StaticBlock' ||
      i.push(Ee);
  }
  return i.push('}'), i;
}
function _S(t, e, r) {
  var n;
  let { node: i } = t,
    s = kt(i.directives),
    o = i.body.some((p) => p.type !== 'EmptyStatement'),
    l = Me(i, qe.Dangling);
  if (!s && !o && !l) return '';
  let c = [];
  return (
    s && (c.push(fg(t, e, r, 'directives')), (o || l) && (c.push(Ee), Do(Lt(!1, i.directives, -1), e) && c.push(Ee))),
    o && c.push(fg(t, e, r, 'body')),
    l && c.push(dr(t, e)),
    i.type === 'Program' && ((n = t.parent) == null ? void 0 : n.type) !== 'ModuleExpression' && c.push(Ee),
    c
  );
}
function Jj(t, e) {
  if (e.semi || jS(t, e) || VS(t, e)) return !1;
  let { node: r, key: n, parent: i } = t;
  return !!(
    r.type === 'ExpressionStatement' &&
    ((n === 'body' &&
      (i.type === 'Program' ||
        i.type === 'BlockStatement' ||
        i.type === 'StaticBlock' ||
        i.type === 'TSModuleBlock')) ||
      (n === 'consequent' && i.type === 'SwitchCase')) &&
    t.call(() => RS(t, e), 'expression')
  );
}
function RS(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case 'ParenthesizedExpression':
    case 'TypeCastExpression':
    case 'ArrayExpression':
    case 'ArrayPattern':
    case 'TemplateLiteral':
    case 'TemplateElement':
    case 'RegExpLiteral':
      return !0;
    case 'ArrowFunctionExpression':
      if (!FS(t, e)) return !0;
      break;
    case 'UnaryExpression': {
      let { prefix: n, operator: i } = r;
      if (n && (i === '+' || i === '-')) return !0;
      break;
    }
    case 'BindExpression':
      if (!r.object) return !0;
      break;
    case 'Literal':
      if (r.regex) return !0;
      break;
    default:
      if (_r(r)) return !0;
  }
  return kl(t, e) ? !0 : Ty(r) ? t.call(() => RS(t, e), ...iF(r)) : !1;
}
function jS({ node: t, parent: e }, r) {
  return (
    (r.parentParser === 'markdown' || r.parentParser === 'mdx') &&
    t.type === 'ExpressionStatement' &&
    _r(t.expression) &&
    e.type === 'Program' &&
    e.body.length === 1
  );
}
function $S(t) {
  switch (t.type) {
    case 'MemberExpression':
      switch (t.property.type) {
        case 'Identifier':
        case 'NumericLiteral':
        case 'StringLiteral':
          return $S(t.object);
      }
      return !1;
    case 'Identifier':
      return !0;
    default:
      return !1;
  }
}
function VS({ node: t, parent: e }, r) {
  return (
    (r.parser === '__vue_event_binding' || r.parser === '__vue_ts_event_binding') &&
    t.type === 'ExpressionStatement' &&
    e.type === 'Program' &&
    e.body.length === 1
  );
}
function Xj(t, e, r) {
  let n = [r('expression')];
  return (
    VS(t, e) ? $S(t.node.expression) && n.push(';') : jS(t, e) || (e.semi && n.push(';')),
    Me(t.node, qe.Dangling, ({ marker: i }) => i === ig) && n.push(' ', dr(t, e, { marker: ig })),
    n
  );
}
function Gj(t, e, r) {
  if (e.__isVueBindings || e.__isVueForBindingLeft) {
    let n = t.map(r, 'program', 'body', 0, 'params');
    if (n.length === 1) return n[0];
    let i = vt([',', We], n);
    return e.__isVueForBindingLeft ? ['(', Se([Ae, oe(i)]), Ae, ')'] : i;
  }
  if (e.__isEmbeddedTypescriptGenericParameters) {
    let n = t.map(r, 'program', 'body', 0, 'typeParameters', 'params');
    return vt([',', We], n);
  }
}
function Yj(t, e, r, n) {
  let { node: i } = t;
  if (LF(i)) return BR(t, e);
  let s = e.semi ? ';' : '',
    o = [];
  switch (i.type) {
    case 'JsExpressionRoot':
      return r('node');
    case 'JsonRoot':
      return [r('node'), Ee];
    case 'File':
      return Gj(t, e, r) ?? r('program');
    case 'Program':
      return _S(t, e, r);
    case 'EmptyStatement':
      return '';
    case 'ExpressionStatement':
      return Xj(t, e, r);
    case 'ChainExpression':
      return r('expression');
    case 'ParenthesizedExpression':
      return !Me(i.expression) && (mi(i.expression) || $r(i.expression))
        ? ['(', r('expression'), ')']
        : oe(['(', Se([Ae, r('expression')]), Ae, ')']);
    case 'AssignmentExpression':
      return NR(t, e, r);
    case 'VariableDeclarator':
      return MR(t, e, r);
    case 'BinaryExpression':
    case 'LogicalExpression':
      return PF(t, e, r);
    case 'AssignmentPattern':
      return [r('left'), ' = ', r('right')];
    case 'OptionalMemberExpression':
    case 'MemberExpression':
      return ER(t, e, r);
    case 'MetaProperty':
      return [r('meta'), '.', r('property')];
    case 'BindExpression':
      return i.object && o.push(r('object')), o.push(oe(Se([Ae, rS(t, e, r)]))), o;
    case 'Identifier':
      return [i.name, cn(t), tS(t), Rr(t, r)];
    case 'V8IntrinsicIdentifier':
      return ['%', i.name];
    case 'SpreadElement':
    case 'SpreadElementPattern':
    case 'SpreadPropertyPattern':
    case 'RestElement':
      return nS(t, r);
    case 'FunctionDeclaration':
    case 'FunctionExpression':
      return vS(t, r, e, n);
    case 'ArrowFunctionExpression':
      return zj(t, e, r, n);
    case 'YieldExpression':
      return o.push('yield'), i.delegate && o.push('*'), i.argument && o.push(' ', r('argument')), o;
    case 'AwaitExpression':
      if ((o.push('await'), i.argument)) {
        o.push(' ', r('argument'));
        let { parent: l } = t;
        if ((It(l) && l.callee === i) || (or(l) && l.object === i)) {
          o = [Se([Ae, ...o]), Ae];
          let c = t.findAncestor((p) => p.type === 'AwaitExpression' || p.type === 'BlockStatement');
          if ((c == null ? void 0 : c.type) !== 'AwaitExpression' || !rn(c.argument, (p) => p === i)) return oe(o);
        }
      }
      return o;
    case 'ExportDefaultDeclaration':
    case 'ExportNamedDeclaration':
    case 'ExportAllDeclaration':
      return lS(t, e, r);
    case 'ImportDeclaration':
      return ij(t, e, r);
    case 'ImportSpecifier':
    case 'ExportSpecifier':
    case 'ImportNamespaceSpecifier':
    case 'ExportNamespaceSpecifier':
    case 'ImportDefaultSpecifier':
    case 'ExportDefaultSpecifier':
      return lj(t, e, r);
    case 'ImportAttribute':
      return [r('key'), ': ', r('value')];
    case 'Import':
      return 'import';
    case 'BlockStatement':
    case 'StaticBlock':
      return LS(t, e, r);
    case 'ClassBody':
      return $j(t, e, r);
    case 'ThrowStatement':
      return Lj(t, e, r);
    case 'ReturnStatement':
      return Oj(t, e, r);
    case 'NewExpression':
    case 'ImportExpression':
    case 'OptionalCallExpression':
    case 'CallExpression':
      return OF(t, e, r);
    case 'ObjectExpression':
    case 'ObjectPattern':
    case 'RecordExpression':
      return Vf(t, e, r);
    case 'ObjectProperty':
    case 'Property':
      return i.method || i.kind === 'get' || i.kind === 'set' ? pg(t, e, r) : Bj(t, e, r);
    case 'ObjectMethod':
      return pg(t, e, r);
    case 'Decorator':
      return ['@', r('expression')];
    case 'ArrayExpression':
    case 'ArrayPattern':
    case 'TupleExpression':
      return jy(t, e, r);
    case 'SequenceExpression': {
      let { parent: l } = t;
      if (l.type === 'ExpressionStatement' || l.type === 'ForStatement') {
        let c = [];
        return (
          t.each(({ isFirst: p }) => {
            p ? c.push(r()) : c.push(',', Se([We, r()]));
          }, 'expressions'),
          oe(c)
        );
      }
      return oe(vt([',', We], t.map(r, 'expressions')));
    }
    case 'ThisExpression':
      return 'this';
    case 'Super':
      return 'super';
    case 'Directive':
      return [r('value'), s];
    case 'UnaryExpression':
      return (
        o.push(i.operator),
        /[a-z]$/.test(i.operator) && o.push(' '),
        Me(i.argument) ? o.push(oe(['(', Se([Ae, r('argument')]), Ae, ')'])) : o.push(r('argument')),
        o
      );
    case 'UpdateExpression':
      return o.push(r('argument'), i.operator), i.prefix && o.reverse(), o;
    case 'ConditionalExpression':
      return Vy(t, e, r);
    case 'VariableDeclaration': {
      let l = t.map(r, 'declarations'),
        c = t.parent,
        p = c.type === 'ForStatement' || c.type === 'ForInStatement' || c.type === 'ForOfStatement',
        f = i.declarations.some((g) => g.init),
        m;
      return (
        l.length === 1 && !Me(i.declarations[0]) ? (m = l[0]) : l.length > 0 && (m = Se(l[0])),
        (o = [Kn(t), i.kind, m ? [' ', m] : '', Se(l.slice(1).map((g) => [',', f && !p ? Ee : We, g]))]),
        (p && c.body !== i) || o.push(s),
        oe(o)
      );
    }
    case 'WithStatement':
      return oe(['with (', r('object'), ')', Bs(i.body, r('body'))]);
    case 'IfStatement': {
      let l = Bs(i.consequent, r('consequent')),
        c = oe(['if (', oe([Se([Ae, r('test')]), Ae]), ')', l]);
      if ((o.push(c), i.alternate)) {
        let p = Me(i.consequent, qe.Trailing | qe.Line) || pF(i),
          f = i.consequent.type === 'BlockStatement' && !p;
        o.push(f ? ' ' : Ee),
          Me(i, qe.Dangling) && o.push(dr(t, e), p ? Ee : ' '),
          o.push('else', oe(Bs(i.alternate, r('alternate'), i.alternate.type === 'IfStatement')));
      }
      return o;
    }
    case 'ForStatement': {
      let l = Bs(i.body, r('body')),
        c = dr(t, e),
        p = c ? [c, Ae] : '';
      return !i.init && !i.test && !i.update
        ? [p, oe(['for (;;)', l])]
        : [p, oe(['for (', oe([Se([Ae, r('init'), ';', We, r('test'), ';', We, r('update')]), Ae]), ')', l])];
    }
    case 'WhileStatement':
      return oe(['while (', oe([Se([Ae, r('test')]), Ae]), ')', Bs(i.body, r('body'))]);
    case 'ForInStatement':
      return oe(['for (', r('left'), ' in ', r('right'), ')', Bs(i.body, r('body'))]);
    case 'ForOfStatement':
      return oe(['for', i.await ? ' await' : '', ' (', r('left'), ' of ', r('right'), ')', Bs(i.body, r('body'))]);
    case 'DoWhileStatement': {
      let l = Bs(i.body, r('body'));
      return (
        (o = [oe(['do', l])]),
        i.body.type === 'BlockStatement' ? o.push(' ') : o.push(Ee),
        o.push('while (', oe([Se([Ae, r('test')]), Ae]), ')', s),
        o
      );
    }
    case 'DoExpression':
      return [i.async ? 'async ' : '', 'do ', r('body')];
    case 'BreakStatement':
    case 'ContinueStatement':
      return (
        o.push(i.type === 'BreakStatement' ? 'break' : 'continue'), i.label && o.push(' ', r('label')), o.push(s), o
      );
    case 'LabeledStatement':
      return i.body.type === 'EmptyStatement' ? [r('label'), ':;'] : [r('label'), ': ', r('body')];
    case 'TryStatement':
      return [
        'try ',
        r('block'),
        i.handler ? [' ', r('handler')] : '',
        i.finalizer ? [' finally ', r('finalizer')] : '',
      ];
    case 'CatchClause':
      if (i.param) {
        let l = Me(
            i.param,
            (p) =>
              !ys(p) ||
              (p.leading && Pn(e.originalText, zt(p))) ||
              (p.trailing && Pn(e.originalText, Er(p), { backwards: !0 })),
          ),
          c = r('param');
        return ['catch ', l ? ['(', Se([Ae, c]), Ae, ') '] : ['(', c, ') '], r('body')];
      }
      return ['catch ', r('body')];
    case 'SwitchStatement':
      return [
        oe(['switch (', Se([Ae, r('discriminant')]), Ae, ')']),
        ' {',
        i.cases.length > 0
          ? Se([
              Ee,
              vt(
                Ee,
                t.map(({ node: l, isLast: c }) => [r(), !c && Do(l, e) ? Ee : ''], 'cases'),
              ),
            ])
          : '',
        Ee,
        '}',
      ];
    case 'SwitchCase': {
      i.test ? o.push('case ', r('test'), ':') : o.push('default:'), Me(i, qe.Dangling) && o.push(' ', dr(t, e));
      let l = i.consequent.filter((c) => c.type !== 'EmptyStatement');
      if (l.length > 0) {
        let c = fg(t, e, r, 'consequent');
        o.push(l.length === 1 && l[0].type === 'BlockStatement' ? [' ', c] : Se([Ee, c]));
      }
      return o;
    }
    case 'DebuggerStatement':
      return ['debugger', s];
    case 'ClassDeclaration':
    case 'ClassExpression':
      return TS(t, e, r);
    case 'ClassMethod':
    case 'ClassPrivateMethod':
    case 'MethodDefinition':
      return IS(t, e, r);
    case 'ClassProperty':
    case 'PropertyDefinition':
    case 'ClassPrivateProperty':
    case 'ClassAccessorProperty':
    case 'AccessorProperty':
      return NS(t, e, r);
    case 'TemplateElement':
      return ia(i.value.raw);
    case 'TemplateLiteral':
      return gS(t, r, e);
    case 'TaggedTemplateExpression':
      return bj(r);
    case 'PrivateIdentifier':
      return ['#', i.name];
    case 'PrivateName':
      return ['#', r('id')];
    case 'TopicReference':
      return '%';
    case 'ArgumentPlaceholder':
      return '?';
    case 'ModuleExpression': {
      o.push('module {');
      let l = r('body');
      return l && o.push(Se([Ee, l]), Ee), o.push('}'), o;
    }
    case 'InterpreterDirective':
    default:
      throw new Pl(i, 'ESTree');
  }
}
function Qj(t, e, r) {
  let { node: n } = t;
  if (n.type.startsWith('NG'))
    switch (n.type) {
      case 'NGRoot':
        return [r('node'), Me(n.node) ? ' //' + Iy(n.node)[0].value.trimEnd() : ''];
      case 'NGPipeExpression':
        return PF(t, e, r);
      case 'NGChainedExpression':
        return oe(
          vt(
            [';', We],
            t.map(() => (e$(t) ? r() : ['(', r(), ')']), 'expressions'),
          ),
        );
      case 'NGEmptyExpression':
        return '';
      case 'NGMicrosyntax':
        return t.map(() => [t.isFirst ? '' : HC(t) ? ' ' : [';', We], r()], 'body');
      case 'NGMicrosyntaxKey':
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);
      case 'NGMicrosyntaxExpression':
        return [r('expression'), n.alias === null ? '' : [' as ', r('alias')]];
      case 'NGMicrosyntaxKeyedExpression': {
        let { index: i, parent: s } = t,
          o =
            HC(t) ||
            (((i === 1 && (n.key.name === 'then' || n.key.name === 'else')) ||
              (i === 2 &&
                n.key.name === 'else' &&
                s.body[i - 1].type === 'NGMicrosyntaxKeyedExpression' &&
                s.body[i - 1].key.name === 'then')) &&
              s.body[0].type === 'NGMicrosyntaxExpression');
        return [r('key'), o ? ' ' : ': ', r('expression')];
      }
      case 'NGMicrosyntaxLet':
        return ['let ', r('key'), n.value === null ? '' : [' = ', r('value')]];
      case 'NGMicrosyntaxAs':
        return [r('key'), ' as ', r('alias')];
      default:
        throw new Pl(n, 'Angular');
    }
}
function HC({ node: t, index: e, parent: r }) {
  return (
    t.type === 'NGMicrosyntaxKeyedExpression' &&
    t.key.name === 'of' &&
    e === 1 &&
    r.body[0].type === 'NGMicrosyntaxLet' &&
    r.body[0].value === null
  );
}
var Zj = ir(['CallExpression', 'OptionalCallExpression', 'AssignmentExpression']);
function e$({ node: t }) {
  return rg(t, Zj);
}
function zS(t, e, r) {
  let { node: n } = t,
    i = [Kn(t), 'interface'],
    s = [],
    o = [];
  n.type !== 'InterfaceTypeAnnotation' && s.push(' ', r('id'), r('typeParameters'));
  let l = n.typeParameters && !Me(n.typeParameters, qe.Trailing | qe.Line);
  return (
    kt(n.extends) &&
      o.push(
        l ? Nt(' ', We, { groupId: Hy(n.typeParameters) }) : We,
        'extends ',
        (n.extends.length === 1 ? zL : Se)(vt([',', We], t.map(r, 'extends'))),
      ),
    Me(n.id, qe.Trailing) || kt(n.extends)
      ? l
        ? i.push(oe([...s, Se(o)]))
        : i.push(oe(Se([...s, ...o])))
      : i.push(...s, ...o),
    i.push(' ', r('body')),
    oe(i)
  );
}
function HS(t, e, r) {
  return Vf(t, r, e);
}
function WS(t, e) {
  let { node: r } = t,
    n = e('id');
  r.computed && (n = ['[', n, ']']);
  let i = '';
  return r.initializer && (i = e('initializer')), r.init && (i = e('init')), i ? [n, ' = ', i] : n;
}
function t$(t, e, r) {
  let { node: n } = t,
    i;
  if (n.type === 'EnumSymbolBody' || n.explicitType)
    switch (n.type) {
      case 'EnumBooleanBody':
        i = 'boolean';
        break;
      case 'EnumNumberBody':
        i = 'number';
        break;
      case 'EnumStringBody':
        i = 'string';
        break;
      case 'EnumSymbolBody':
        i = 'symbol';
        break;
    }
  return [i ? `of ${i} ` : '', HS(t, e, r)];
}
function US(t, e, r) {
  let { node: n } = t;
  return [
    Kn(t),
    n.const ? 'const ' : '',
    'enum ',
    e('id'),
    ' ',
    n.type === 'TSEnumDeclaration' ? HS(t, e, r) : e('body'),
  ];
}
function r$(t, e, r) {
  let { node: n } = t;
  if (rF(n)) return n.type.slice(0, -14).toLowerCase();
  let i = e.semi ? ';' : '';
  switch (n.type) {
    case 'DeclareClass':
      return TS(t, e, r);
    case 'DeclareFunction':
      return [Kn(t), 'function ', r('id'), r('predicate'), i];
    case 'DeclareModule':
      return ['declare module ', r('id'), ' ', r('body')];
    case 'DeclareModuleExports':
      return ['declare module.exports', Rr(t, r), i];
    case 'DeclareVariable':
      return [Kn(t), n.kind ?? 'var', ' ', r('id'), i];
    case 'DeclareExportDeclaration':
    case 'DeclareExportAllDeclaration':
      return lS(t, e, r);
    case 'DeclareOpaqueType':
    case 'OpaqueType':
      return YR(t, e, r);
    case 'DeclareTypeAlias':
    case 'TypeAlias':
      return zF(t, e, r);
    case 'IntersectionTypeAnnotation':
      return HF(t, e, r);
    case 'UnionTypeAnnotation':
      return WF(t, e, r);
    case 'ConditionalTypeAnnotation':
      return Vy(t, e, r);
    case 'InferTypeAnnotation':
      return KF(t, e, r);
    case 'FunctionTypeAnnotation':
      return UF(t, e, r);
    case 'TupleTypeAnnotation':
      return jy(t, e, r);
    case 'TupleTypeLabeledElement':
      return XF(t, e, r);
    case 'TupleTypeSpreadElement':
      return JF(t, e, r);
    case 'GenericTypeAnnotation':
      return [r('id'), Pu(t, e, r, 'typeParameters')];
    case 'IndexedAccessType':
    case 'OptionalIndexedAccessType':
      return qF(t, e, r);
    case 'TypeAnnotation':
      return YF(t, e, r);
    case 'TypeParameter':
      return bS(t, e, r);
    case 'TypeofTypeAnnotation':
      return ZF(t, r);
    case 'ExistsTypeAnnotation':
      return '*';
    case 'ArrayTypeAnnotation':
      return QF(r);
    case 'DeclareEnum':
    case 'EnumDeclaration':
      return US(t, r, e);
    case 'EnumBooleanBody':
    case 'EnumNumberBody':
    case 'EnumStringBody':
    case 'EnumSymbolBody':
      return t$(t, r, e);
    case 'EnumBooleanMember':
    case 'EnumNumberMember':
    case 'EnumStringMember':
    case 'EnumDefaultedMember':
      return WS(t, r);
    case 'FunctionTypeParam': {
      let s = n.name ? r('name') : t.parent.this === n ? 'this' : '';
      return [s, cn(t), s ? ': ' : '', r('typeAnnotation')];
    }
    case 'DeclareInterface':
    case 'InterfaceDeclaration':
    case 'InterfaceTypeAnnotation':
      return zS(t, e, r);
    case 'ClassImplements':
    case 'InterfaceExtends':
      return [r('id'), r('typeParameters')];
    case 'NullableTypeAnnotation':
      return ['?', r('typeAnnotation')];
    case 'Variance': {
      let { kind: s } = n;
      return ES.ok(s === 'plus' || s === 'minus'), s === 'plus' ? '+' : '-';
    }
    case 'KeyofTypeAnnotation':
      return ['keyof ', r('argument')];
    case 'ObjectTypeCallProperty':
      return [n.static ? 'static ' : '', r('value')];
    case 'ObjectTypeMappedTypeProperty':
      return wj(t, e, r);
    case 'ObjectTypeIndexer':
      return [
        n.static ? 'static ' : '',
        n.variance ? r('variance') : '',
        '[',
        r('id'),
        n.id ? ': ' : '',
        r('key'),
        ']: ',
        r('value'),
      ];
    case 'ObjectTypeProperty': {
      let s = '';
      return (
        n.proto ? (s = 'proto ') : n.static && (s = 'static '),
        [
          s,
          aF(n) ? n.kind + ' ' : '',
          n.variance ? r('variance') : '',
          xc(t, e, r),
          cn(t),
          lF(n) ? '' : ': ',
          r('value'),
        ]
      );
    }
    case 'ObjectTypeAnnotation':
      return Vf(t, e, r);
    case 'ObjectTypeInternalSlot':
      return [n.static ? 'static ' : '', '[[', r('id'), ']]', cn(t), n.method ? '' : ': ', r('value')];
    case 'ObjectTypeSpreadProperty':
      return nS(t, r);
    case 'QualifiedTypeofIdentifier':
    case 'QualifiedTypeIdentifier':
      return [r('qualification'), '.', r('id')];
    case 'NullLiteralTypeAnnotation':
      return 'null';
    case 'BooleanLiteralTypeAnnotation':
      return String(n.value);
    case 'StringLiteralTypeAnnotation':
      return ia(Wp(qn(n), e));
    case 'NumberLiteralTypeAnnotation':
      return Ws(n.raw ?? n.extra.raw);
    case 'BigIntLiteralTypeAnnotation':
      return ug(n.raw ?? n.extra.raw);
    case 'TypeCastExpression':
      return ['(', r('expression'), Rr(t, r), ')'];
    case 'TypePredicate':
      return eS(t, r);
    case 'TypeParameterDeclaration':
    case 'TypeParameterInstantiation':
      return Pu(t, e, r, 'params');
    case 'InferredPredicate':
    case 'DeclaredPredicate':
      return [
        t.key === 'predicate' && t.parent.type !== 'DeclareFunction' && !t.parent.returnType ? ': ' : ' ',
        '%checks',
        ...(n.type === 'DeclaredPredicate' ? ['(', r('value'), ')'] : []),
      ];
  }
}
function n$(t, e, r) {
  var n;
  let { node: i } = t;
  if (!i.type.startsWith('TS')) return;
  if (nF(i)) return i.type.slice(2, -7).toLowerCase();
  let s = e.semi ? ';' : '',
    o = [];
  switch (i.type) {
    case 'TSThisType':
      return 'this';
    case 'TSTypeAssertion': {
      let l = !($r(i.expression) || mi(i.expression)),
        c = oe(['<', Se([Ae, r('typeAnnotation')]), Ae, '>']),
        p = [Nt('('), Se([Ae, r('expression')]), Ae, Nt(')')];
      return l
        ? Jo([
            [c, r('expression')],
            [c, oe(p, { shouldBreak: !0 })],
            [c, r('expression')],
          ])
        : oe([c, r('expression')]);
    }
    case 'TSDeclareFunction':
      return vS(t, r, e);
    case 'TSExportAssignment':
      return ['export = ', r('expression'), s];
    case 'TSModuleBlock':
      return LS(t, e, r);
    case 'TSInterfaceBody':
    case 'TSTypeLiteral':
      return Vf(t, e, r);
    case 'TSTypeAliasDeclaration':
      return zF(t, e, r);
    case 'TSQualifiedName':
      return [r('left'), '.', r('right')];
    case 'TSAbstractMethodDefinition':
    case 'TSDeclareMethod':
      return IS(t, e, r);
    case 'TSAbstractAccessorProperty':
    case 'TSAbstractPropertyDefinition':
      return NS(t, e, r);
    case 'TSInterfaceHeritage':
    case 'TSClassImplements':
    case 'TSExpressionWithTypeArguments':
    case 'TSInstantiationExpression':
      return [r('expression'), r('typeParameters')];
    case 'TSTemplateLiteralType':
      return gS(t, r, e);
    case 'TSNamedTupleMember':
      return XF(t, e, r);
    case 'TSRestType':
      return JF(t, e, r);
    case 'TSOptionalType':
      return [r('typeAnnotation'), '?'];
    case 'TSInterfaceDeclaration':
      return zS(t, e, r);
    case 'TSTypeParameterDeclaration':
    case 'TSTypeParameterInstantiation':
      return Pu(t, e, r, 'params');
    case 'TSTypeParameter':
      return bS(t, e, r);
    case 'TSAsExpression':
    case 'TSSatisfiesExpression': {
      let l = i.type === 'TSAsExpression' ? 'as' : 'satisfies';
      o.push(r('expression'), ` ${l} `, r('typeAnnotation'));
      let { parent: c } = t;
      return (It(c) && c.callee === i) || (or(c) && c.object === i) ? oe([Se([Ae, ...o]), Ae]) : o;
    }
    case 'TSArrayType':
      return QF(r);
    case 'TSPropertySignature':
      return [i.readonly ? 'readonly ' : '', xc(t, e, r), cn(t), Rr(t, r)];
    case 'TSParameterProperty':
      return [
        Up(i),
        i.static ? 'static ' : '',
        i.override ? 'override ' : '',
        i.readonly ? 'readonly ' : '',
        r('parameter'),
      ];
    case 'TSTypeQuery':
      return ZF(t, r);
    case 'TSIndexSignature': {
      let l = i.parameters.length > 1 ? Nt(go(e) ? ',' : '') : '',
        c = oe([Se([Ae, vt([', ', Ae], t.map(r, 'parameters'))]), l, Ae]),
        p = t.parent.type === 'ClassBody' && t.key === 'body';
      return [
        p && i.static ? 'static ' : '',
        i.readonly ? 'readonly ' : '',
        '[',
        i.parameters ? c : '',
        ']',
        Rr(t, r),
        p ? s : '',
      ];
    }
    case 'TSTypePredicate':
      return eS(t, r);
    case 'TSNonNullExpression':
      return [r('expression'), '!'];
    case 'TSImportType':
      return [
        i.isTypeOf ? 'typeof ' : '',
        'import(',
        r('argument'),
        ')',
        i.qualifier ? ['.', r('qualifier')] : '',
        Pu(t, e, r, i.typeArguments ? 'typeArguments' : 'typeParameters'),
      ];
    case 'TSLiteralType':
      return r('literal');
    case 'TSIndexedAccessType':
      return qF(t, e, r);
    case 'TSTypeOperator':
      return [i.operator, ' ', r('typeAnnotation')];
    case 'TSMappedType':
      return Tj(t, e, r);
    case 'TSMethodSignature': {
      let l = i.kind && i.kind !== 'method' ? `${i.kind} ` : '';
      o.push(Up(i), l, i.computed ? '[' : '', r('key'), i.computed ? ']' : '', cn(t));
      let c = Dc(t, r, e, !1, !0),
        p = i.returnType ? 'returnType' : 'typeAnnotation',
        f = i[p],
        m = f ? Rr(t, r, p) : '',
        g = jf(i, m);
      return o.push(g ? oe(c) : c), f && o.push(oe(m)), oe(o);
    }
    case 'TSNamespaceExportDeclaration':
      return ['export as namespace ', r('id'), e.semi ? ';' : ''];
    case 'TSEnumDeclaration':
      return US(t, r, e);
    case 'TSEnumMember':
      return WS(t, r);
    case 'TSImportEqualsDeclaration':
      return [
        i.isExport ? 'export ' : '',
        'import ',
        uS(i, !1),
        r('id'),
        ' = ',
        r('moduleReference'),
        e.semi ? ';' : '',
      ];
    case 'TSExternalModuleReference':
      return ['require(', r('expression'), ')'];
    case 'TSModuleDeclaration': {
      let { parent: l } = t,
        c = l.type === 'TSModuleDeclaration',
        p = ((n = i.body) == null ? void 0 : n.type) === 'TSModuleDeclaration';
      if (c) o.push('.');
      else if ((o.push(Kn(t)), !(i.kind === 'global' || i.global))) {
        let f =
          i.kind ??
          (Bn(i.id) || /(?:^|\s)module(?:\s|$)/.test(e.originalText.slice(Er(i), Er(i.id))) ? 'module' : 'namespace');
        o.push(f, ' ');
      }
      return o.push(r('id')), p ? o.push(r('body')) : i.body ? o.push(' ', oe(r('body'))) : o.push(s), o;
    }
    case 'TSConditionalType':
      return Vy(t, e, r);
    case 'TSInferType':
      return KF(t, e, r);
    case 'TSIntersectionType':
      return HF(t, e, r);
    case 'TSUnionType':
      return WF(t, e, r);
    case 'TSFunctionType':
    case 'TSCallSignatureDeclaration':
    case 'TSConstructorType':
    case 'TSConstructSignatureDeclaration':
      return UF(t, e, r);
    case 'TSTupleType':
      return jy(t, e, r);
    case 'TSTypeReference':
      return [r('typeName'), Pu(t, e, r, 'typeParameters')];
    case 'TSTypeAnnotation':
      return YF(t, e, r);
    case 'TSEmptyBodyFunctionExpression':
      return Wy(t, e, r);
    case 'TSJSDocAllType':
      return '*';
    case 'TSJSDocUnknownType':
      return '?';
    case 'TSJSDocNullableType':
      return zC(t, r, '?');
    case 'TSJSDocNonNullableType':
      return zC(t, r, '!');
    case 'TSParenthesizedType':
    default:
      throw new Pl(i, 'TypeScript');
  }
}
function i$(t, e, r, n) {
  if (kF(t)) return I5(t, e);
  for (let i of [Qj, aR, r$, n$, Yj]) {
    let s = i(t, e, r, n);
    if (s !== void 0) return s;
  }
}
var s$ = ir([
  'ClassMethod',
  'ClassPrivateMethod',
  'ClassProperty',
  'ClassAccessorProperty',
  'AccessorProperty',
  'TSAbstractAccessorProperty',
  'PropertyDefinition',
  'TSAbstractPropertyDefinition',
  'ClassPrivateProperty',
  'MethodDefinition',
  'TSAbstractMethodDefinition',
  'TSDeclareMethod',
]);
function o$(t, e, r, n) {
  var i;
  t.isRoot && ((i = e.__onHtmlBindingRoot) == null || i.call(e, t.node, e));
  let s = i$(t, e, r, n);
  if (!s) return '';
  let { node: o } = t;
  if (s$(o)) return s;
  let l = kt(o.decorators),
    c = nj(t, e, r),
    p = o.type === 'ClassExpression';
  if (l && !p) return tg(s, (g) => oe([c, g]));
  let f = kl(t, e),
    m = Jj(t, e);
  return !c && !f && !m
    ? s
    : tg(s, (g) => [m ? ';' : '', f ? '(' : '', f && p && l ? [Se([We, c, g]), We] : [c, g], f ? ')' : '']);
}
var a$ = o$,
  qS = [
    (t, e) => t.type === 'ObjectExpression' && e === 'properties',
    (t, e) =>
      t.type === 'CallExpression' &&
      t.callee.type === 'Identifier' &&
      t.callee.name === 'Component' &&
      e === 'arguments',
    (t, e) => t.type === 'Decorator' && e === 'expression',
  ];
function l$(t) {
  return t.match(
    (e) => e.type === 'TemplateLiteral',
    (e, r) => $r(e) && r === 'elements',
    (e, r) => Ds(e) && e.key.type === 'Identifier' && e.key.name === 'styles' && r === 'value',
    ...qS,
  );
}
function u$(t) {
  return t.match(
    (e) => e.type === 'TemplateLiteral',
    (e, r) => Ds(e) && e.key.type === 'Identifier' && e.key.name === 'template' && r === 'value',
    ...qS,
  );
}
function KS(t, e) {
  return Me(t, qe.Block | qe.Leading, ({ value: r }) => r === ` ${e} `);
}
async function c$(t, e, r) {
  let { node: n } = r,
    i = n.quasis.map((f) => f.value.raw),
    s = 0,
    o = i.reduce((f, m, g) => (g === 0 ? m : f + '@prettier-placeholder-' + s++ + '-id' + m), ''),
    l = await t(o, { parser: 'scss' }),
    c = zy(r, e),
    p = h$(l, c);
  if (!p) throw new Error("Couldn't insert all the expressions");
  return ['`', Se([Ee, p]), Ae, '`'];
}
function h$(t, e) {
  if (!kt(e)) return t;
  let r = 0,
    n = Tl(Ey(t), (i) =>
      typeof i != 'string' || !i.includes('@prettier-placeholder')
        ? i
        : i.split(/@prettier-placeholder-(\d+)-id/).map((s, o) => (o % 2 === 0 ? ia(s) : (r++, e[s]))),
    );
  return e.length === r ? n : null;
}
function p$({ node: t, parent: e, grandparent: r }) {
  return (
    (r &&
      t.quasis &&
      e.type === 'JSXExpressionContainer' &&
      r.type === 'JSXElement' &&
      r.openingElement.name.name === 'style' &&
      r.openingElement.attributes.some((n) => n.name.name === 'jsx')) ||
    ((e == null ? void 0 : e.type) === 'TaggedTemplateExpression' &&
      e.tag.type === 'Identifier' &&
      e.tag.name === 'css') ||
    ((e == null ? void 0 : e.type) === 'TaggedTemplateExpression' &&
      e.tag.type === 'MemberExpression' &&
      e.tag.object.name === 'css' &&
      (e.tag.property.name === 'global' || e.tag.property.name === 'resolve'))
  );
}
function Vh(t) {
  return t.type === 'Identifier' && t.name === 'styled';
}
function WC(t) {
  return /^[A-Z]/.test(t.object.name) && t.property.name === 'extend';
}
function f$({ parent: t }) {
  if (!t || t.type !== 'TaggedTemplateExpression') return !1;
  let e = t.tag.type === 'ParenthesizedExpression' ? t.tag.expression : t.tag;
  switch (e.type) {
    case 'MemberExpression':
      return Vh(e.object) || WC(e);
    case 'CallExpression':
      return (
        Vh(e.callee) ||
        (e.callee.type === 'MemberExpression' &&
          ((e.callee.object.type === 'MemberExpression' && (Vh(e.callee.object.object) || WC(e.callee.object))) ||
            (e.callee.object.type === 'CallExpression' && Vh(e.callee.object.callee))))
      );
    case 'Identifier':
      return e.name === 'css';
    default:
      return !1;
  }
}
function d$({ parent: t, grandparent: e }) {
  return (
    (e == null ? void 0 : e.type) === 'JSXAttribute' &&
    t.type === 'JSXExpressionContainer' &&
    e.name.type === 'JSXIdentifier' &&
    e.name.name === 'css'
  );
}
function m$(t) {
  if (p$(t) || f$(t) || d$(t) || l$(t)) return c$;
}
var g$ = m$;
async function y$(t, e, r) {
  let { node: n } = r,
    i = n.quasis.length,
    s = zy(r, e),
    o = [];
  for (let l = 0; l < i; l++) {
    let c = n.quasis[l],
      p = l === 0,
      f = l === i - 1,
      m = c.value.cooked,
      g = m.split(`
`),
      x = g.length,
      b = s[l],
      F = x > 2 && g[0].trim() === '' && g[1].trim() === '',
      E = x > 2 && g[x - 1].trim() === '' && g[x - 2].trim() === '',
      w = g.every((T) => /^\s*(?:#[^\n\r]*)?$/.test(T));
    if (!f && /#[^\n\r]*$/.test(g[x - 1])) return null;
    let I = null;
    w ? (I = D$(g)) : (I = await t(m, { parser: 'graphql' })),
      I ? ((I = yS(I, !1)), !p && F && o.push(''), o.push(I), !f && E && o.push('')) : !p && !f && F && o.push(''),
      b && o.push(b);
  }
  return ['`', Se([Ee, vt(Ee, o)]), Ee, '`'];
}
function D$(t) {
  let e = [],
    r = !1,
    n = t.map((i) => i.trim());
  for (let [i, s] of n.entries()) s !== '' && (n[i - 1] === '' && r ? e.push([Ee, s]) : e.push(s), (r = !0));
  return e.length === 0 ? null : vt(Ee, e);
}
function x$({ node: t, parent: e }) {
  return (
    KS(t, 'GraphQL') ||
    (e &&
      ((e.type === 'TaggedTemplateExpression' &&
        ((e.tag.type === 'MemberExpression' &&
          e.tag.object.name === 'graphql' &&
          e.tag.property.name === 'experimental') ||
          (e.tag.type === 'Identifier' && (e.tag.name === 'gql' || e.tag.name === 'graphql')))) ||
        (e.type === 'CallExpression' && e.callee.type === 'Identifier' && e.callee.name === 'graphql')))
  );
}
function C$(t) {
  if (x$(t)) return y$;
}
var b$ = C$,
  Bm = 0;
async function JS(t, e, r, n, i) {
  let { node: s } = n,
    o = Bm;
  Bm = (Bm + 1) >>> 0;
  let l = (w) => `PRETTIER_HTML_PLACEHOLDER_${w}_${o}_IN_JS`,
    c = s.quasis.map((w, I, T) => (I === T.length - 1 ? w.value.cooked : w.value.cooked + l(I))).join(''),
    p = zy(n, r),
    f = new RegExp(l('(\\d+)'), 'g'),
    m = 0,
    g = await e(c, {
      parser: t,
      __onHtmlRoot(w) {
        m = w.children.length;
      },
    }),
    x = Tl(g, (w) => {
      if (typeof w != 'string') return w;
      let I = [],
        T = w.split(f);
      for (let j = 0; j < T.length; j++) {
        let $ = T[j];
        if (j % 2 === 0) {
          $ && (($ = DS($)), i.__embeddedInHtml && ($ = Tn(!1, $, /<\/(?=script\b)/gi, '<\\/')), I.push($));
          continue;
        }
        let L = Number($);
        I.push(p[L]);
      }
      return I;
    }),
    b = /^\s/.test(c) ? ' ' : '',
    F = /\s$/.test(c) ? ' ' : '',
    E = i.htmlWhitespaceSensitivity === 'ignore' ? Ee : b && F ? We : null;
  return E ? oe(['`', Se([E, oe(x)]), E, '`']) : dc({ hug: !1 }, oe(['`', b, m > 1 ? Se(oe(x)) : oe(x), F, '`']));
}
function A$(t) {
  return (
    KS(t.node, 'HTML') ||
    t.match(
      (e) => e.type === 'TemplateLiteral',
      (e, r) =>
        e.type === 'TaggedTemplateExpression' && e.tag.type === 'Identifier' && e.tag.name === 'html' && r === 'quasi',
    )
  );
}
var E$ = JS.bind(void 0, 'html'),
  v$ = JS.bind(void 0, 'angular');
function F$(t) {
  if (A$(t)) return E$;
  if (u$(t)) return v$;
}
var S$ = F$;
async function w$(t, e, r) {
  let { node: n } = r,
    i = Tn(!1, n.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (c, p) => '\\'.repeat(p.length / 2) + '`'),
    s = T$(i),
    o = s !== '';
  o && (i = Tn(!1, i, new RegExp(`^${s}`, 'gm'), ''));
  let l = yS(await t(i, { parser: 'markdown', __inJsTemplate: !0 }), !0);
  return ['`', o ? Se([Ae, l]) : [Yv, $5(l)], Ae, '`'];
}
function T$(t) {
  let e = t.match(/^([^\S\n]*)\S/m);
  return e === null ? '' : e[1];
}
function k$(t) {
  if (P$(t)) return w$;
}
function P$({ node: t, parent: e }) {
  return (
    (e == null ? void 0 : e.type) === 'TaggedTemplateExpression' &&
    t.quasis.length === 1 &&
    e.tag.type === 'Identifier' &&
    (e.tag.name === 'md' || e.tag.name === 'markdown')
  );
}
var B$ = k$;
function I$(t) {
  let { node: e } = t;
  if (e.type !== 'TemplateLiteral' || N$(e)) return;
  let r;
  for (let n of [g$, b$, S$, B$])
    if (((r = n(t)), !!r))
      return e.quasis.length === 1 && e.quasis[0].value.raw.trim() === ''
        ? '``'
        : async (...i) => {
            let s = await r(...i);
            return s && dc({ embed: !0, ...s.label }, s);
          };
}
function N$({ quasis: t }) {
  return t.some(({ value: { cooked: e } }) => e === null);
}
var M$ = I$,
  O$ = new Set([
    'range',
    'raw',
    'comments',
    'leadingComments',
    'trailingComments',
    'innerComments',
    'extra',
    'start',
    'end',
    'loc',
    'flags',
    'errors',
    'tokens',
  ]),
  Ia = (t) => {
    for (let e of t.quasis) delete e.value;
  };
function XS(t, e, r) {
  var n, i;
  if (
    (t.type === 'Program' && delete e.sourceType,
    (t.type === 'BigIntLiteral' || t.type === 'BigIntLiteralTypeAnnotation') &&
      e.value &&
      (e.value = e.value.toLowerCase()),
    (t.type === 'BigIntLiteral' || t.type === 'Literal') && e.bigint && (e.bigint = e.bigint.toLowerCase()),
    t.type === 'DecimalLiteral' && (e.value = Number(e.value)),
    t.type === 'Literal' && e.decimal && (e.decimal = Number(e.decimal)),
    t.type === 'EmptyStatement' ||
      t.type === 'JSXText' ||
      (t.type === 'JSXExpressionContainer' &&
        (t.expression.type === 'Literal' || t.expression.type === 'StringLiteral') &&
        t.expression.value === ' '))
  )
    return null;
  if (
    ((t.type === 'Property' ||
      t.type === 'ObjectProperty' ||
      t.type === 'MethodDefinition' ||
      t.type === 'ClassProperty' ||
      t.type === 'ClassMethod' ||
      t.type === 'PropertyDefinition' ||
      t.type === 'TSDeclareMethod' ||
      t.type === 'TSPropertySignature' ||
      t.type === 'ObjectTypeProperty') &&
      typeof t.key == 'object' &&
      t.key &&
      (t.key.type === 'Literal' ||
        t.key.type === 'NumericLiteral' ||
        t.key.type === 'StringLiteral' ||
        t.key.type === 'Identifier') &&
      delete e.key,
    t.type === 'JSXElement' &&
      t.openingElement.name.name === 'style' &&
      t.openingElement.attributes.some((o) => o.type === 'JSXAttribute' && o.name.name === 'jsx'))
  )
    for (let { type: o, expression: l } of e.children)
      o === 'JSXExpressionContainer' && l.type === 'TemplateLiteral' && Ia(l);
  t.type === 'JSXAttribute' &&
    t.name.name === 'css' &&
    t.value.type === 'JSXExpressionContainer' &&
    t.value.expression.type === 'TemplateLiteral' &&
    Ia(e.value.expression),
    t.type === 'JSXAttribute' &&
      ((n = t.value) == null ? void 0 : n.type) === 'Literal' &&
      /["']|&quot;|&apos;/.test(t.value.value) &&
      (e.value.value = Tn(!1, e.value.value, /["']|&quot;|&apos;/g, '"'));
  let s = t.expression || t.callee;
  if (
    t.type === 'Decorator' &&
    s.type === 'CallExpression' &&
    s.callee.name === 'Component' &&
    s.arguments.length === 1
  ) {
    let o = t.expression.arguments[0].properties;
    for (let [l, c] of e.expression.arguments[0].properties.entries())
      switch (o[l].key.name) {
        case 'styles':
          $r(c.value) && Ia(c.value.elements[0]);
          break;
        case 'template':
          c.value.type === 'TemplateLiteral' && Ia(c.value);
          break;
      }
  }
  if (
    (t.type === 'TaggedTemplateExpression' &&
      (t.tag.type === 'MemberExpression' ||
        (t.tag.type === 'Identifier' &&
          (t.tag.name === 'gql' ||
            t.tag.name === 'graphql' ||
            t.tag.name === 'css' ||
            t.tag.name === 'md' ||
            t.tag.name === 'markdown' ||
            t.tag.name === 'html')) ||
        t.tag.type === 'CallExpression') &&
      Ia(e.quasi),
    t.type === 'TemplateLiteral' &&
      (((i = t.leadingComments) != null &&
        i.some((o) => ys(o) && ['GraphQL', 'HTML'].some((l) => o.value === ` ${l} `))) ||
        (r.type === 'CallExpression' && r.callee.name === 'graphql') ||
        !t.leadingComments) &&
      Ia(e),
    (t.type === 'TSIntersectionType' || t.type === 'TSUnionType') && t.types.length === 1)
  )
    return e.types[0];
  t.type === 'ChainExpression' &&
    t.expression.type === 'TSNonNullExpression' &&
    ([e.type, e.expression.type] = [e.expression.type, e.type]);
}
XS.ignoredProperties = O$;
var L$ = XS,
  qp = w5(P5(), 1);
function _$(t) {
  if (!t.startsWith('#!')) return '';
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var R$ = _$;
function j$(t) {
  let e = R$(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, qp.extract)(t),
    { pragmas: n, comments: i } = (0, qp.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function $$(t) {
  let { shebang: e, text: r, pragmas: n, comments: i } = j$(t),
    s = (0, qp.strip)(r),
    o = (0, qp.print)({ pragmas: { format: '', ...n }, comments: i.trimStart() });
  return (
    (e
      ? `${e}
`
      : '') +
    o +
    (s.startsWith(`
`)
      ? `
`
      : `

`) +
    s
  );
}
var V$ = { avoidAstMutation: !0 },
  z$ = [
    {
      linguistLanguageId: 183,
      name: 'JavaScript',
      type: 'programming',
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'text/javascript',
      color: '#f1e05a',
      aliases: ['js', 'node'],
      extensions: [
        '.js',
        '._js',
        '.bones',
        '.cjs',
        '.es',
        '.es6',
        '.frag',
        '.gs',
        '.jake',
        '.javascript',
        '.jsb',
        '.jscad',
        '.jsfl',
        '.jslib',
        '.jsm',
        '.jspre',
        '.jss',
        '.mjs',
        '.njs',
        '.pac',
        '.sjs',
        '.ssjs',
        '.xsjs',
        '.xsjslib',
        '.wxs',
      ],
      filenames: ['Jakefile'],
      interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell', 'zx'],
      parsers: ['babel', 'acorn', 'espree', 'meriyah', 'babel-flow', 'babel-ts', 'flow', 'typescript'],
      vscodeLanguageIds: ['javascript', 'mongo'],
    },
    {
      linguistLanguageId: 183,
      name: 'Flow',
      type: 'programming',
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'text/javascript',
      color: '#f1e05a',
      aliases: [],
      extensions: ['.js.flow'],
      filenames: [],
      interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell'],
      parsers: ['flow', 'babel-flow'],
      vscodeLanguageIds: ['javascript'],
    },
    {
      linguistLanguageId: 183,
      name: 'JSX',
      type: 'programming',
      tmScope: 'source.js.jsx',
      aceMode: 'javascript',
      codemirrorMode: 'jsx',
      codemirrorMimeType: 'text/jsx',
      color: void 0,
      aliases: void 0,
      extensions: ['.jsx'],
      filenames: void 0,
      interpreters: void 0,
      parsers: ['babel', 'babel-flow', 'babel-ts', 'flow', 'typescript', 'espree', 'meriyah'],
      vscodeLanguageIds: ['javascriptreact'],
      group: 'JavaScript',
    },
    {
      linguistLanguageId: 378,
      name: 'TypeScript',
      type: 'programming',
      color: '#3178c6',
      aliases: ['ts'],
      interpreters: ['deno', 'ts-node'],
      extensions: ['.ts', '.cts', '.mts'],
      tmScope: 'source.ts',
      aceMode: 'typescript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/typescript',
      parsers: ['typescript', 'babel-ts'],
      vscodeLanguageIds: ['typescript'],
    },
    {
      linguistLanguageId: 94901924,
      name: 'TSX',
      type: 'programming',
      color: '#3178c6',
      group: 'TypeScript',
      extensions: ['.tsx'],
      tmScope: 'source.tsx',
      aceMode: 'javascript',
      codemirrorMode: 'jsx',
      codemirrorMimeType: 'text/jsx',
      parsers: ['typescript', 'babel-ts'],
      vscodeLanguageIds: ['typescriptreact'],
    },
  ],
  GS = {};
Of(GS, { getVisitorKeys: () => q$, massageAstNode: () => YS, print: () => K$ });
var H$ = {
    JsonRoot: ['node'],
    ArrayExpression: ['elements'],
    ObjectExpression: ['properties'],
    ObjectProperty: ['key', 'value'],
    UnaryExpression: ['argument'],
    NullLiteral: [],
    BooleanLiteral: [],
    StringLiteral: [],
    NumericLiteral: [],
    Identifier: [],
    TemplateLiteral: ['quasis'],
    TemplateElement: [],
  },
  W$ = H$,
  U$ = eF(W$),
  q$ = U$;
function K$(t, e, r) {
  let { node: n } = t;
  switch (n.type) {
    case 'JsonRoot':
      return [r('node'), Ee];
    case 'ArrayExpression': {
      if (n.elements.length === 0) return '[]';
      let i = t.map(() => (t.node === null ? 'null' : r()), 'elements');
      return ['[', Se([Ee, vt([',', Ee], i)]), Ee, ']'];
    }
    case 'ObjectExpression':
      return n.properties.length === 0 ? '{}' : ['{', Se([Ee, vt([',', Ee], t.map(r, 'properties'))]), Ee, '}'];
    case 'ObjectProperty':
      return [r('key'), ': ', r('value')];
    case 'UnaryExpression':
      return [n.operator === '+' ? '' : n.operator, r('argument')];
    case 'NullLiteral':
      return 'null';
    case 'BooleanLiteral':
      return n.value ? 'true' : 'false';
    case 'StringLiteral':
      return JSON.stringify(n.value);
    case 'NumericLiteral':
      return UC(t) ? JSON.stringify(String(n.value)) : JSON.stringify(n.value);
    case 'Identifier':
      return UC(t) ? JSON.stringify(n.name) : n.name;
    case 'TemplateLiteral':
      return r(['quasis', 0]);
    case 'TemplateElement':
      return JSON.stringify(n.value.cooked);
    default:
      throw new Pl(n, 'JSON');
  }
}
function UC(t) {
  return t.key === 'key' && t.parent.type === 'ObjectProperty';
}
var J$ = new Set([
  'start',
  'end',
  'extra',
  'loc',
  'comments',
  'leadingComments',
  'trailingComments',
  'innerComments',
  'errors',
  'range',
  'tokens',
]);
function YS(t, e) {
  let { type: r } = t;
  if (r === 'ObjectProperty') {
    let { key: n } = t;
    n.type === 'Identifier'
      ? (e.key = { type: 'StringLiteral', value: n.name })
      : n.type === 'NumericLiteral' && (e.key = { type: 'StringLiteral', value: String(n.value) });
    return;
  }
  if (r === 'UnaryExpression' && t.operator === '+') return e.argument;
  if (r === 'ArrayExpression') {
    for (let [n, i] of t.elements.entries()) i === null && e.elements.splice(n, 0, { type: 'NullLiteral' });
    return;
  }
  if (r === 'TemplateLiteral') return { type: 'StringLiteral', value: t.quasis[0].value.cooked };
}
YS.ignoredProperties = J$;
var X$ = [
    {
      linguistLanguageId: 174,
      name: 'JSON.stringify',
      type: 'data',
      color: '#292929',
      tmScope: 'source.json',
      aceMode: 'json',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/json',
      aliases: ['geojson', 'jsonl', 'topojson'],
      extensions: ['.importmap'],
      filenames: ['package.json', 'package-lock.json', 'composer.json'],
      parsers: ['json-stringify'],
      vscodeLanguageIds: ['json'],
    },
    {
      linguistLanguageId: 174,
      name: 'JSON',
      type: 'data',
      color: '#292929',
      tmScope: 'source.json',
      aceMode: 'json',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/json',
      aliases: ['geojson', 'jsonl', 'topojson'],
      extensions: [
        '.json',
        '.4DForm',
        '.4DProject',
        '.avsc',
        '.geojson',
        '.gltf',
        '.har',
        '.ice',
        '.JSON-tmLanguage',
        '.mcmeta',
        '.tfstate',
        '.tfstate.backup',
        '.topojson',
        '.webapp',
        '.webmanifest',
        '.yy',
        '.yyp',
      ],
      filenames: [
        '.all-contributorsrc',
        '.arcconfig',
        '.auto-changelog',
        '.c8rc',
        '.htmlhintrc',
        '.imgbotconfig',
        '.nycrc',
        '.tern-config',
        '.tern-project',
        '.watchmanconfig',
        'Pipfile.lock',
        'composer.lock',
        'flake.lock',
        'mcmod.info',
      ],
      parsers: ['json'],
      vscodeLanguageIds: ['json'],
    },
    {
      linguistLanguageId: 423,
      name: 'JSON with Comments',
      type: 'data',
      color: '#292929',
      group: 'JSON',
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'text/javascript',
      aliases: ['jsonc'],
      extensions: [
        '.jsonc',
        '.code-snippets',
        '.sublime-build',
        '.sublime-commands',
        '.sublime-completions',
        '.sublime-keymap',
        '.sublime-macro',
        '.sublime-menu',
        '.sublime-mousemap',
        '.sublime-project',
        '.sublime-settings',
        '.sublime-theme',
        '.sublime-workspace',
        '.sublime_metrics',
        '.sublime_session',
      ],
      filenames: [
        '.babelrc',
        '.devcontainer.json',
        '.eslintrc.json',
        '.jscsrc',
        '.jshintrc',
        '.jslintrc',
        '.swcrc',
        'api-extractor.json',
        'devcontainer.json',
        'jsconfig.json',
        'language-configuration.json',
        'tsconfig.json',
        'tslint.json',
        '.eslintrc',
      ],
      parsers: ['json'],
      vscodeLanguageIds: ['jsonc'],
    },
    {
      linguistLanguageId: 175,
      name: 'JSON5',
      type: 'data',
      color: '#267CB9',
      extensions: ['.json5'],
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/json',
      parsers: ['json5'],
      vscodeLanguageIds: ['json5'],
    },
  ],
  zh = {
    bracketSpacing: {
      category: 'Common',
      type: 'boolean',
      default: !0,
      description: 'Print spaces between brackets.',
      oppositeDescription: 'Do not print spaces between brackets.',
    },
    singleQuote: {
      category: 'Common',
      type: 'boolean',
      default: !1,
      description: 'Use single quotes instead of double quotes.',
    },
    proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
        { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
        { value: 'never', description: 'Do not wrap prose.' },
        { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
    },
    bracketSameLine: {
      category: 'Common',
      type: 'boolean',
      default: !1,
      description: 'Put > of opening tags on the last line instead of on a new line.',
    },
    singleAttributePerLine: {
      category: 'Common',
      type: 'boolean',
      default: !1,
      description: 'Enforce single attribute per line in HTML, Vue and JSX.',
    },
  },
  Na = 'JavaScript',
  G$ = {
    arrowParens: {
      category: Na,
      type: 'choice',
      default: 'always',
      description: 'Include parentheses around a sole arrow function parameter.',
      choices: [
        { value: 'always', description: 'Always include parens. Example: `(x) => x`' },
        { value: 'avoid', description: 'Omit parens when possible. Example: `x => x`' },
      ],
    },
    bracketSameLine: zh.bracketSameLine,
    bracketSpacing: zh.bracketSpacing,
    jsxBracketSameLine: {
      category: Na,
      type: 'boolean',
      description: 'Put > on the last line instead of at a new line.',
      deprecated: '2.4.0',
    },
    semi: {
      category: Na,
      type: 'boolean',
      default: !0,
      description: 'Print semicolons.',
      oppositeDescription: 'Do not print semicolons, except at the beginning of lines which may need them.',
    },
    singleQuote: zh.singleQuote,
    jsxSingleQuote: { category: Na, type: 'boolean', default: !1, description: 'Use single quotes in JSX.' },
    quoteProps: {
      category: Na,
      type: 'choice',
      default: 'as-needed',
      description: 'Change when properties in objects are quoted.',
      choices: [
        { value: 'as-needed', description: 'Only add quotes around object properties where required.' },
        {
          value: 'consistent',
          description: 'If at least one property in an object requires quotes, quote all properties.',
        },
        { value: 'preserve', description: 'Respect the input use of quotes in object properties.' },
      ],
    },
    trailingComma: {
      category: Na,
      type: 'choice',
      default: 'all',
      description: 'Print trailing commas wherever possible when multi-line.',
      choices: [
        { value: 'all', description: 'Trailing commas wherever possible (including function arguments).' },
        { value: 'es5', description: 'Trailing commas where valid in ES5 (objects, arrays, etc.)' },
        { value: 'none', description: 'No trailing commas.' },
      ],
    },
    singleAttributePerLine: zh.singleAttributePerLine,
  },
  Y$ = G$,
  Q$ = { 'estree': Kv, 'estree-json': GS },
  Z$ = [...z$, ...X$],
  eV = qv,
  Kp = ((t) => (
    (t.DetailResizeLayout = 'mockya-detail-resize-layout'),
    (t.ConfigResizeLayout = 'mockya-config-resize-layout'),
    (t.EditorLineWrap = 'mockya-editor-line-wrap'),
    t
  ))(Kp || {});
const QS = { ChangeSelectMock: Symbol('change-select-mock') },
  qy = 250,
  tV = { class: 'flex flex-col' },
  rV = { class: 'flex items-center justify-end' },
  nV = St({
    __name: 'Editor',
    props: { modelValue: {} },
    emits: ['update:modelValue', 'change'],
    setup(t, { expose: e, emit: r }) {
      const n = t;
      e({ format: p });
      const i = Ua(),
        s = nt({
          get() {
            return n.modelValue;
          },
          set(m) {
            r('update:modelValue', m), r('change', m);
          },
        }),
        o = kA(Kp.EditorLineWrap, !1),
        l = nt(() => (o.value ? [...mC, ze.lineWrapping] : mC));
      function c() {
        var g;
        const m = (g = i.value) == null ? void 0 : g.state.selection.ranges;
        return (m == null ? void 0 : m[0].anchor) ?? 0;
      }
      async function p() {
        const m = await f7.formatWithCursor(n.modelValue, { cursorOffset: c(), parser: 'json5', plugins: [x5, eV] });
        r('update:modelValue', m.formatted),
          r('change', m.formatted),
          gi(() => {
            var x, b;
            const g = Math.max(0, m.cursorOffset);
            (x = i.value) == null || x.dispatch({ selection: { anchor: g, head: g } }),
              (b = i.value) == null || b.focus();
          });
      }
      function f() {
        o.value = !o.value;
      }
      return (m, g) => (
        Ne(),
        rt('div', tV, [
          $e('div', rV, [
            z(
              te(ro),
              { content: 'Line Wrap' },
              {
                default: Ke(() => [
                  z(
                    te(Lr),
                    { class: Gt({ 'text-success': te(o) }), size: 28, onClick: f },
                    { default: Ke(() => [z(te(G8), { size: 16 })]), _: 1 },
                    8,
                    ['class'],
                  ),
                ]),
                _: 1,
              },
            ),
            z(
              te(ro),
              { class: 'ml-1', content: 'Format' },
              {
                default: Ke(() => [
                  z(te(Lr), { size: 28, onClick: p }, { default: Ke(() => [z(te(L8), { size: 16 })]), _: 1 }),
                ]),
                _: 1,
              },
            ),
          ]),
          z(
            te(M9),
            {
              'modelValue': s.value,
              'onUpdate:modelValue': g[0] || (g[0] = (x) => (s.value = x)),
              'placeholder': 'Please enter your mock json data',
              'extensions': l.value,
              'onReady': g[1] || (g[1] = (x) => (i.value = x.view)),
            },
            null,
            8,
            ['modelValue', 'extensions'],
          ),
        ])
      );
    },
  });
function zf(t, e = 1500) {
  const r = tt(!1),
    { start: n, stop: i } = SB(() => {
      r.value = !1;
    }, e);
  function s() {
    r.value ? (i(), t()) : ((r.value = !0), n());
  }
  function o() {
    r.value = !1;
  }
  return { confirmed: r, trigger: s, cancel: o };
}
function iV(t) {
  return t;
}
function sV(t) {
  return t.length === 0
    ? iV
    : t.length === 1
    ? t[0]
    : function (r) {
        return t.reduce((n, i) => i(n), r);
      };
}
function ZS(t) {
  const e = {
    subscribe(r) {
      let n = null,
        i = !1,
        s = !1,
        o = !1;
      function l() {
        if (n === null) {
          o = !0;
          return;
        }
        s || ((s = !0), typeof n == 'function' ? n() : n && n.unsubscribe());
      }
      return (
        (n = t({
          next(c) {
            var p;
            i || (p = r.next) == null || p.call(r, c);
          },
          error(c) {
            var p;
            i || ((i = !0), (p = r.error) == null || p.call(r, c), l());
          },
          complete() {
            var c;
            i || ((i = !0), (c = r.complete) == null || c.call(r), l());
          },
        })),
        o && l(),
        { unsubscribe: l }
      );
    },
    pipe(...r) {
      return sV(r)(e);
    },
  };
  return e;
}
function oV(t) {
  return (e) => {
    let r = 0,
      n = null;
    const i = [];
    function s() {
      n ||
        (n = e.subscribe({
          next(l) {
            var c;
            for (const p of i) (c = p.next) == null || c.call(p, l);
          },
          error(l) {
            var c;
            for (const p of i) (c = p.error) == null || c.call(p, l);
          },
          complete() {
            var l;
            for (const c of i) (l = c.complete) == null || l.call(c);
          },
        }));
    }
    function o() {
      if (r === 0 && n) {
        const l = n;
        (n = null), l.unsubscribe();
      }
    }
    return {
      subscribe(l) {
        return (
          r++,
          i.push(l),
          s(),
          {
            unsubscribe() {
              r--, o();
              const c = i.findIndex((p) => p === l);
              c > -1 && i.splice(c, 1);
            },
          }
        );
      },
    };
  };
}
class Ky extends Error {
  constructor(e) {
    super(e), (this.name = 'ObservableAbortError'), Object.setPrototypeOf(this, Ky.prototype);
  }
}
function aV(t) {
  let e;
  return {
    promise: new Promise((n, i) => {
      let s = !1;
      function o() {
        s || ((s = !0), i(new Ky('This operation was aborted.')), l.unsubscribe());
      }
      const l = t.subscribe({
        next(c) {
          (s = !0), n(c), o();
        },
        error(c) {
          (s = !0), i(c), o();
        },
        complete() {
          (s = !0), o();
        },
      });
      e = o;
    }),
    abort: e,
  };
}
function lV(t) {
  return ZS((e) => {
    function r(i = 0, s = t.op) {
      const o = t.links[i];
      if (!o) throw new Error('No more links to execute - did you forget to add an ending link?');
      return o({
        op: s,
        next(c) {
          return r(i + 1, c);
        },
      });
    }
    return r().subscribe(e);
  });
}
function Jp(t) {
  return !!t && !Array.isArray(t) && typeof t == 'object';
}
function uV(t, e) {
  if ('error' in t) {
    const n = e.transformer.deserialize(t.error);
    return { ok: !1, error: { ...t, error: n } };
  }
  return {
    ok: !0,
    result: {
      ...t.result,
      ...((!t.result.type || t.result.type === 'data') && {
        type: 'data',
        data: e.transformer.deserialize(t.result.data),
      }),
    },
  };
}
class Im extends Error {
  constructor() {
    super('Unable to transform response from server');
  }
}
function cV(t, e) {
  let r;
  try {
    r = uV(t, e);
  } catch {
    throw new Im();
  }
  if (!r.ok && (!Jp(r.error.error) || typeof r.error.error.code != 'number')) throw new Im();
  if (r.ok && !Jp(r.result)) throw new Im();
  return r;
}
function hV(t) {
  return t instanceof Li || (t instanceof Error && t.name === 'TRPCClientError');
}
function pV(t) {
  return Jp(t) && Jp(t.error) && typeof t.error.code == 'number' && typeof t.error.message == 'string';
}
class Li extends Error {
  static from(e, r = {}) {
    const n = e;
    return hV(n)
      ? (r.meta && (n.meta = { ...n.meta, ...r.meta }), n)
      : pV(n)
      ? new Li(n.error.message, { ...r, result: n })
      : n instanceof Error
      ? new Li(n.message, { ...r, cause: n })
      : new Li('Unknown error', { ...r, cause: n });
  }
  constructor(e, r) {
    var i, s;
    const n = r == null ? void 0 : r.cause;
    super(e, { cause: n }),
      (this.meta = r == null ? void 0 : r.meta),
      (this.cause = n),
      (this.shape = (i = r == null ? void 0 : r.result) == null ? void 0 : i.error),
      (this.data = (s = r == null ? void 0 : r.result) == null ? void 0 : s.error.data),
      (this.name = 'TRPCClientError'),
      Object.setPrototypeOf(this, Li.prototype);
  }
}
function ew(t) {
  const e = Object.create(null);
  for (const r in t) {
    const n = t[r];
    e[n] = r;
  }
  return e;
}
const tw = {
  PARSE_ERROR: -32700,
  BAD_REQUEST: -32600,
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099,
};
ew(tw);
ew(tw);
const rw = () => {};
function nw(t, e) {
  return new Proxy(rw, {
    get(n, i) {
      if (!(typeof i != 'string' || i === 'then')) return nw(t, [...e, i]);
    },
    apply(n, i, s) {
      const o = e[e.length - 1] === 'apply';
      return t({ args: o ? (s.length >= 2 ? s[1] : []) : s, path: o ? e.slice(0, -1) : e });
    },
  });
}
const fV = (t) => nw(t, []),
  dV = (t) =>
    new Proxy(rw, {
      get(e, r) {
        if (!(typeof r != 'string' || r === 'then')) return t(r);
      },
    }),
  qC = (t) => typeof t == 'function';
function mV(t) {
  if (t) return t;
  if (typeof window < 'u' && qC(window.fetch)) return window.fetch;
  if (typeof globalThis < 'u' && qC(globalThis.fetch)) return globalThis.fetch;
  throw new Error('No fetch implementation found');
}
function gV(t) {
  return (
    t ||
    (typeof window < 'u' && window.AbortController
      ? window.AbortController
      : typeof globalThis < 'u' && globalThis.AbortController
      ? globalThis.AbortController
      : null)
  );
}
function yV(t) {
  return { url: t.url.toString().replace(/\/$/, ''), fetch: t.fetch, AbortController: gV(t.AbortController) };
}
function DV(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e[r] = n;
  }
  return e;
}
const xV = { query: 'GET', mutation: 'POST' };
function iw(t) {
  return 'input' in t
    ? t.runtime.transformer.serialize(t.input)
    : DV(t.inputs.map((e) => t.runtime.transformer.serialize(e)));
}
const sw = (t) => {
    let e = t.url + '/' + t.path;
    const r = [];
    if (('inputs' in t && r.push('batch=1'), t.type === 'query')) {
      const n = iw(t);
      n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
    }
    return r.length && (e += '?' + r.join('&')), e;
  },
  CV = (t) => {
    if (t.type === 'query') return;
    const e = iw(t);
    return e !== void 0 ? JSON.stringify(e) : void 0;
  },
  bV = (t) => EV({ ...t, contentTypeHeader: 'application/json', getUrl: sw, getBody: CV });
async function AV(t, e) {
  const r = t.getUrl(t),
    n = t.getBody(t),
    { type: i } = t,
    s = await t.headers();
  /* istanbul ignore if -- @preserve */ if (i === 'subscription') throw new Error('Subscriptions should use wsLink');
  const o = {
    ...(t.contentTypeHeader ? { 'content-type': t.contentTypeHeader } : {}),
    ...(t.batchModeHeader ? { 'trpc-batch-mode': t.batchModeHeader } : {}),
    ...s,
  };
  return mV(t.fetch)(r, { method: xV[i], signal: e == null ? void 0 : e.signal, body: n, headers: o });
}
function EV(t) {
  const e = t.AbortController ? new t.AbortController() : null,
    r = {};
  let n = !1;
  return {
    promise: new Promise((o, l) => {
      AV(t, e)
        .then((c) => ((r.response = c), (n = !0), c.json()))
        .then((c) => {
          (r.responseJSON = c), o({ json: c, meta: r });
        })
        .catch((c) => {
          (n = !0), l(Li.from(c, { meta: r }));
        });
    }),
    cancel: () => {
      n || e == null || e.abort();
    },
  };
}
const Nm = () => {
  throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');
};
function Mm(t) {
  let e = null,
    r = null;
  const n = () => {
    clearTimeout(r), (r = null), (e = null);
  };
  function i(l) {
    var f, m;
    const c = [[]];
    let p = 0;
    for (;;) {
      const g = l[p];
      if (!g) break;
      const x = c[c.length - 1];
      if (g.aborted) {
        (f = g.reject) == null || f.call(g, new Error('Aborted')), p++;
        continue;
      }
      if (t.validate(x.concat(g).map((F) => F.key))) {
        x.push(g), p++;
        continue;
      }
      if (x.length === 0) {
        (m = g.reject) == null || m.call(g, new Error('Input is too big for a single dispatch')), p++;
        continue;
      }
      c.push([]);
    }
    return c;
  }
  function s() {
    const l = i(e);
    n();
    for (const c of l) {
      if (!c.length) continue;
      const p = { items: c, cancel: Nm };
      for (const x of c) x.batch = p;
      const f = (x, b) => {
          var E;
          const F = p.items[x];
          (E = F.resolve) == null || E.call(F, b), (F.batch = null), (F.reject = null), (F.resolve = null);
        },
        { promise: m, cancel: g } = t.fetch(
          p.items.map((x) => x.key),
          f,
        );
      (p.cancel = g),
        m
          .then((x) => {
            var b;
            for (let F = 0; F < x.length; F++) {
              const E = x[F];
              f(F, E);
            }
            for (const F of p.items) (b = F.reject) == null || b.call(F, new Error('Missing result')), (F.batch = null);
          })
          .catch((x) => {
            var b;
            for (const F of p.items) (b = F.reject) == null || b.call(F, x), (F.batch = null);
          });
    }
  }
  function o(l) {
    const c = { aborted: !1, key: l, batch: null, resolve: Nm, reject: Nm },
      p = new Promise((m, g) => {
        (c.reject = g), (c.resolve = m), e || (e = []), e.push(c);
      });
    return (
      r || (r = setTimeout(s)),
      {
        promise: p,
        cancel: () => {
          var m;
          (c.aborted = !0),
            (m = c.batch) != null && m.items.every((g) => g.aborted) && (c.batch.cancel(), (c.batch = null));
        },
      }
    );
  }
  return { load: o };
}
function vV(t) {
  return function (r) {
    const n = yV(r),
      i = r.maxURLLength ?? 1 / 0;
    return (s) => {
      const o = (m) => {
          const g = (b) => {
              if (i === 1 / 0) return !0;
              const F = b.map((I) => I.path).join(','),
                E = b.map((I) => I.input);
              return sw({ ...n, runtime: s, type: m, path: F, inputs: E }).length <= i;
            },
            x = t({ ...n, runtime: s, type: m, opts: r });
          return { validate: g, fetch: x };
        },
        l = Mm(o('query')),
        c = Mm(o('mutation')),
        p = Mm(o('subscription')),
        f = { query: l, subscription: p, mutation: c };
      return ({ op: m }) =>
        ZS((g) => {
          const x = f[m.type],
            { promise: b, cancel: F } = x.load(m);
          let E;
          return (
            b
              .then((w) => {
                E = w;
                const I = cV(w.json, s);
                if (!I.ok) {
                  g.error(Li.from(I.error, { meta: w.meta }));
                  return;
                }
                g.next({ context: w.meta, result: I.result }), g.complete();
              })
              .catch((w) => {
                g.error(Li.from(w, { meta: E == null ? void 0 : E.meta }));
              }),
            () => {
              F();
            }
          );
        });
    };
  };
}
const FV = (t) => (e) => {
    const r = e.map((o) => o.path).join(','),
      n = e.map((o) => o.input),
      { promise: i, cancel: s } = bV({
        ...t,
        path: r,
        inputs: n,
        headers() {
          return t.opts.headers
            ? typeof t.opts.headers == 'function'
              ? t.opts.headers({ opList: e })
              : t.opts.headers
            : {};
        },
      });
    return {
      promise: i.then((o) =>
        (Array.isArray(o.json) ? o.json : e.map(() => o.json)).map((p) => ({ meta: o.meta, json: p })),
      ),
      cancel: s,
    };
  },
  SV = vV(FV);
class wV {
  $request({ type: e, input: r, path: n, context: i = {} }) {
    return lV({ links: this.links, op: { id: ++this.requestId, type: e, path: n, input: r, context: i } }).pipe(oV());
  }
  requestAsPromise(e) {
    const r = this.$request(e),
      { promise: n, abort: i } = aV(r);
    return new Promise((o, l) => {
      var c;
      (c = e.signal) == null || c.addEventListener('abort', i),
        n
          .then((p) => {
            o(p.result.data);
          })
          .catch((p) => {
            l(Li.from(p));
          });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: 'query',
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal,
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: 'mutation',
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal,
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: 'subscription',
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
    }).subscribe({
      next(s) {
        var o, l, c;
        s.result.type === 'started'
          ? (o = n.onStarted) == null || o.call(n)
          : s.result.type === 'stopped'
          ? (l = n.onStopped) == null || l.call(n)
          : (c = n.onData) == null || c.call(n, s.result.data);
      },
      error(s) {
        var o;
        (o = n.onError) == null || o.call(n, s);
      },
      complete() {
        var s;
        (s = n.onComplete) == null || s.call(n);
      },
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n
        ? 'input' in n
          ? e.transformer
          : { input: n, output: n }
        : {
            input: { serialize: (i) => i, deserialize: (i) => i },
            output: { serialize: (i) => i, deserialize: (i) => i },
          };
    })();
    (this.runtime = {
      transformer: { serialize: (n) => r.input.serialize(n), deserialize: (n) => r.output.deserialize(n) },
      combinedTransformer: r,
    }),
      (this.links = e.links.map((n) => n(this.runtime)));
  }
}
const TV = { query: 'query', mutate: 'mutation', subscribe: 'subscription' },
  kV = (t) => TV[t];
function PV(t) {
  return dV((e) =>
    t.hasOwnProperty(e)
      ? t[e]
      : e === '__untypedClient'
      ? t
      : fV(({ path: r, args: n }) => {
          const i = [e, ...r],
            s = kV(i.pop()),
            o = i.join('.');
          return t[s](o, ...n);
        }),
  );
}
function BV(t) {
  const e = new wV(t);
  return PV(e);
}
const IV = '/whistle.mockya',
  yr = BV({ links: [SV({ url: `${IV}/trpc` })] });
function Dr(t) {
  console.error(t), Vg.error(t.message.trim());
}
function Hf(t) {
  return () => {
    const e = t(),
      r = u3(e);
    return { ...e, ...r };
  };
}
const Jy = Hf(
    df('collections', {
      state: () => ({ fetched: !1, collections: [] }),
      actions: {
        async fetchCollections() {
          try {
            (this.collections = await yr.getAllCollections.query()), (this.fetched = !0);
          } catch (t) {
            Dr(t);
          }
        },
        checkIdDuplicated(t) {
          return this.collections.some((e) => e.id === t);
        },
        async upsertCollection(t) {
          try {
            await yr.upsertCollection.mutate(t), await this.fetchCollections();
          } catch (e) {
            Dr(e);
          }
        },
        async deleteCollection(t) {
          try {
            await yr.deleteCollection.mutate(t), await this.fetchCollections();
          } catch (e) {
            Dr(e);
          }
        },
      },
    }),
  ),
  ow = Hf(
    df('detail', () => {
      const t = tt(''),
        e = tt('');
      Zt(t, r);
      async function r() {
        if (t.value)
          try {
            const { name: i } = await yr.getCollection.query(t.value);
            e.value = i;
          } catch (i) {
            Dr(i);
          }
      }
      function n(i) {
        t.value = i;
      }
      return { collectionId: t, collectionName: e, setDetailCollectionId: n, fetchCollectionInfo: r };
    }),
  ),
  Xy = Hf(
    df('rule-list', () => {
      const { collectionId: t } = ow(),
        e = tt(0),
        r = tt([]);
      Zt(t, n);
      async function n() {
        if (t.value)
          try {
            const l = await yr.getRuleList.query(t.value);
            r.value = l;
          } catch (l) {
            Dr(l);
          }
      }
      async function i(l) {
        try {
          await yr.createRule.mutate({ collectionId: t.value, name: l }), await n();
        } catch (c) {
          Dr(c);
        }
      }
      async function s(l) {
        try {
          await yr.updateRule.mutate(l);
        } catch (c) {
          Dr(c);
        }
      }
      async function o(l) {
        try {
          await yr.deleteRule.mutate(l), await n();
        } catch (c) {
          Dr(c);
        }
      }
      return { selectedRuleId: e, rules: r, fetchRuleList: n, createRule: i, updateRule: s, deleteRule: o };
    }),
  ),
  Bl = Hf(
    df('rule-config', () => {
      const { selectedRuleId: t } = Xy(),
        e = tt(),
        r = nt(() => {
          var F;
          return ((F = e.value) == null ? void 0 : F.mocks) ?? [];
        }),
        n = nt(() => {
          var F;
          return ((F = e.value) == null ? void 0 : F.matchers) ?? [];
        });
      Zt(t, i);
      async function i() {
        if (t)
          try {
            const F = await yr.getRuleFull.query(t.value);
            e.value = F;
          } catch (F) {
            Dr(F);
          }
      }
      async function s(F) {
        try {
          await yr.updateRule.mutate({ id: t.value, ...F });
        } catch (E) {
          Dr(E);
        }
      }
      async function o(F) {
        try {
          const E = await yr.createMock.mutate({ name: F, ruleId: t.value });
          return console.log('cr', E), await i(), E;
        } catch (E) {
          Dr(E);
        }
      }
      async function l(F) {
        try {
          await yr.deleteMock.mutate(F), await i();
        } catch (E) {
          Dr(E);
        }
      }
      async function c(F) {
        try {
          await yr.updateMock.mutate(F);
        } catch (E) {
          Dr(E);
        }
      }
      async function p() {
        try {
          await yr.createMatcher.mutate(t.value), await i();
        } catch (F) {
          Dr(F);
        }
      }
      async function f(F) {
        try {
          await yr.updateMatcher.mutate(F);
        } catch (E) {
          Dr(E);
        }
      }
      async function m(F) {
        try {
          await yr.deleteMatcher.mutate(F), await i();
        } catch (E) {
          Dr(E);
        }
      }
      async function g(F) {
        try {
          await yr.createMatcherConfig.mutate(F), await i();
        } catch (E) {
          Dr(E);
        }
      }
      async function x(F) {
        try {
          await yr.updateMatcherConfig.mutate(F);
        } catch (E) {
          Dr(E);
        }
      }
      async function b(F) {
        try {
          await yr.deleteMatcherConfig.mutate(F), await i();
        } catch (E) {
          Dr(E);
        }
      }
      return {
        selectedRuleId: t,
        selectedRule: e,
        mockList: r,
        matcherList: n,
        updateRuleConfig: s,
        createMock: o,
        updateMock: c,
        deleteMock: l,
        createMatcher: p,
        updateMatcher: f,
        deleteMatcher: m,
        createMatcherConfig: g,
        updateMatcherConfig: x,
        deleteMatcherConfig: b,
      };
    }),
  );
var NV = function () {
    var t = document.getSelection();
    if (!t.rangeCount) return function () {};
    for (var e = document.activeElement, r = [], n = 0; n < t.rangeCount; n++) r.push(t.getRangeAt(n));
    switch (e.tagName.toUpperCase()) {
      case 'INPUT':
      case 'TEXTAREA':
        e.blur();
        break;
      default:
        e = null;
        break;
    }
    return (
      t.removeAllRanges(),
      function () {
        t.type === 'Caret' && t.removeAllRanges(),
          t.rangeCount ||
            r.forEach(function (i) {
              t.addRange(i);
            }),
          e && e.focus();
      }
    );
  },
  MV = NV,
  KC = { 'text/plain': 'Text', 'text/html': 'Url', 'default': 'Text' },
  OV = 'Copy to clipboard: #{key}, Enter';
function LV(t) {
  var e = (/mac os x/i.test(navigator.userAgent) ? '⌘' : 'Ctrl') + '+C';
  return t.replace(/#{\s*key\s*}/g, e);
}
function _V(t, e) {
  var r,
    n,
    i,
    s,
    o,
    l,
    c = !1;
  e || (e = {}), (r = e.debug || !1);
  try {
    (i = MV()),
      (s = document.createRange()),
      (o = document.getSelection()),
      (l = document.createElement('span')),
      (l.textContent = t),
      (l.ariaHidden = 'true'),
      (l.style.all = 'unset'),
      (l.style.position = 'fixed'),
      (l.style.top = 0),
      (l.style.clip = 'rect(0, 0, 0, 0)'),
      (l.style.whiteSpace = 'pre'),
      (l.style.webkitUserSelect = 'text'),
      (l.style.MozUserSelect = 'text'),
      (l.style.msUserSelect = 'text'),
      (l.style.userSelect = 'text'),
      l.addEventListener('copy', function (f) {
        if ((f.stopPropagation(), e.format))
          if ((f.preventDefault(), typeof f.clipboardData > 'u')) {
            r && console.warn('unable to use e.clipboardData'),
              r && console.warn('trying IE specific stuff'),
              window.clipboardData.clearData();
            var m = KC[e.format] || KC.default;
            window.clipboardData.setData(m, t);
          } else f.clipboardData.clearData(), f.clipboardData.setData(e.format, t);
        e.onCopy && (f.preventDefault(), e.onCopy(f.clipboardData));
      }),
      document.body.appendChild(l),
      s.selectNodeContents(l),
      o.addRange(s);
    var p = document.execCommand('copy');
    if (!p) throw new Error('copy command was unsuccessful');
    c = !0;
  } catch (f) {
    r && console.error('unable to copy using execCommand: ', f), r && console.warn('trying IE specific stuff');
    try {
      window.clipboardData.setData(e.format || 'text', t), e.onCopy && e.onCopy(window.clipboardData), (c = !0);
    } catch (m) {
      r && console.error('unable to copy using clipboardData: ', m),
        r && console.error('falling back to prompt'),
        (n = LV('message' in e ? e.message : OV)),
        window.prompt(n, t);
    }
  } finally {
    o && (typeof o.removeRange == 'function' ? o.removeRange(s) : o.removeAllRanges()),
      l && document.body.removeChild(l),
      i();
  }
  return c;
}
var RV = _V;
const jV = mg(RV),
  $V = { class: 'collection-card transition-hover' },
  VV = { class: 'flex justify-between' },
  zV = ['onClick'],
  HV = { class: 'id-icon-container transition-hover flex-center bg-base-300 h-full px-1 rounded-l' },
  WV = { class: 'mx-2 truncate max-w-50 text-sm' },
  UV = { class: 'operation-list flex-center gap-1 transition-hover opacity-0' },
  qV = { key: 0, class: 'flex-1 py-2 font-semibold text-lg truncate' },
  KV = { class: 'text-xs flex w-fit items-center text-neural' },
  JV = St({
    __name: 'CollectionCard',
    props: { collection: {} },
    setup(t) {
      const e = t,
        { deleteCollection: r, upsertCollection: n } = Jy(),
        i = nt(() => YC(e.collection.updatedAt).fromNow()),
        {
          confirmed: s,
          trigger: o,
          cancel: l,
        } = zf(() => {
          r(e.collection.id);
        }),
        c = tt(!1),
        p = tt(e.collection.name),
        f = tt(null);
      il(c, () => {
        (p.value = e.collection.name),
          gi(() => {
            var x, b;
            (x = f.value) == null || x.focus(), (b = f.value) == null || b.select();
          });
      });
      async function m() {
        const x = p.value.trim();
        x && x !== e.collection.name && (await n({ id: e.collection.id, name: x })), (c.value = !1);
      }
      function g() {
        jV(e.collection.id), Vg.success(`ID "${e.collection.id}" Copied!`);
      }
      return (x, b) => (
        Ne(),
        rt('div', $V, [
          $e('div', VV, [
            z(
              te(ro),
              { class: 'id-tooltip w-fit', content: 'Copy ID', position: 'right' },
              {
                default: Ke(() => [
                  $e(
                    'div',
                    { class: 'id-marker transition-hover', onClick: Or(g, ['stop']) },
                    [
                      $e('div', HV, [z(te(J8), { class: 'id-icon transition-hover hover:text-base-100' })]),
                      $e('div', WV, ai(x.collection.id), 1),
                    ],
                    8,
                    zV,
                  ),
                ]),
                _: 1,
              },
            ),
            $e('div', UV, [
              z(
                te(Lr),
                { onClick: b[0] || (b[0] = Or((F) => (c.value = !0), ['stop'])) },
                { default: Ke(() => [z(te(jg))]), _: 1 },
              ),
              z(
                te(Lr),
                {
                  class: Gt(['delete-btn', { '!bg-error text-base-100': te(s) }]),
                  onClick: Or(te(o), ['stop']),
                  onMouseleave: te(l),
                },
                { default: Ke(() => [z(te(yf))]), _: 1 },
                8,
                ['class', 'onClick', 'onMouseleave'],
              ),
            ]),
          ]),
          c.value
            ? (Ne(),
              rt('div', { key: 1, class: 'flex-1 py-2', onClick: b[2] || (b[2] = Or(() => {}, ['stop'])) }, [
                z(
                  te(to),
                  {
                    'ref_key': 'editInput',
                    'ref': f,
                    'modelValue': p.value,
                    'onUpdate:modelValue': b[1] || (b[1] = (F) => (p.value = F)),
                    'bordered': '',
                    'size': 'sm',
                    'onBlur': m,
                    'onKeydown': Vi(m, ['enter']),
                  },
                  null,
                  8,
                  ['modelValue', 'onKeydown'],
                ),
              ]))
            : (Ne(), rt('div', qV, ai(x.collection.name), 1)),
          $e('div', KV, [z(te(eB), { class: 'mr-2' }), Dn(' ' + ai(i.value), 1)]),
        ])
      );
    },
  });
const XV = In(JV, [['__scopeId', 'data-v-5dc986e5']]),
  GV = { class: 'add-collection-card' },
  YV = St({
    __name: 'CreateCollectionCard',
    setup(t) {
      return (e, r) => (Ne(), rt('div', GV, [z(te(EA), { class: 'mr-2', size: 20 }), Dn(' New Collection ')]));
    },
  });
const QV = In(YV, [['__scopeId', 'data-v-9de0f07b']]),
  ZV = St({
    __name: 'CreateCollectionModal',
    props: { modelValue: { type: Boolean } },
    emits: ['update:modelValue'],
    setup(t, { emit: e }) {
      const r = t,
        n = nt({
          get() {
            return r.modelValue;
          },
          set(x) {
            e('update:modelValue', x);
          },
        }),
        i = yl({ id: '', name: '' }),
        { checkIdDuplicated: s, upsertCollection: o } = Jy(),
        l = tt(null),
        c = tt(null);
      il(n, () => {
        var x, b, F;
        (i.id = ''),
          (i.name = ''),
          (x = l.value) == null || x.clearValidation(),
          (b = c.value) == null || b.clearValidation(),
          (F = l.value) == null || F.focus();
      });
      function p(x) {
        return (
          (x = x.trim()),
          x === '' ? 'ID cannot be empty' : /\s+/.test(x) ? 'ID cannot contain space' : s(x) ? 'ID already exists' : ''
        );
      }
      function f(x) {
        return (x = x.trim()), x === '' ? 'Name cannot be empty' : '';
      }
      async function m() {
        var F, E;
        const x = (F = l.value) == null ? void 0 : F.validate(),
          b = (E = c.value) == null ? void 0 : E.validate();
        x && b && (await o(i), g());
      }
      function g() {
        e('update:modelValue', !1);
      }
      return (x, b) => (
        Ne(),
        nr(
          te(CA),
          {
            'modelValue': n.value,
            'onUpdate:modelValue': b[3] || (b[3] = (F) => (n.value = F)),
            'title': 'Create Collection',
          },
          {
            default: Ke(() => [
              z(
                te(Zm),
                {
                  'ref_key': 'idInput',
                  'ref': l,
                  'modelValue': i.id,
                  'onUpdate:modelValue': b[0] || (b[0] = (F) => (i.id = F)),
                  'title': 'ID',
                  'tip': 'unique string without space',
                  'validate-fn': p,
                  'onKeydown':
                    b[1] ||
                    (b[1] = Vi(
                      Or(
                        (F) => {
                          var E;
                          return (E = c.value) == null ? void 0 : E.focus();
                        },
                        ['prevent'],
                      ),
                      ['enter'],
                    )),
                },
                null,
                8,
                ['modelValue'],
              ),
              z(
                te(Zm),
                {
                  'ref_key': 'nameInput',
                  'ref': c,
                  'modelValue': i.name,
                  'onUpdate:modelValue': b[2] || (b[2] = (F) => (i.name = F)),
                  'title': 'Name',
                  'validate-fn': f,
                  'onKeydown': Vi(Or(m, ['prevent']), ['enter']),
                },
                null,
                8,
                ['modelValue', 'onKeydown'],
              ),
            ]),
            action: Ke(() => [
              z(te(Wn), { type: 'ghost', onClick: g }, { default: Ke(() => [Dn('Cancel')]), _: 1 }),
              z(te(Wn), { type: 'primary', onClick: m }, { default: Ke(() => [Dn('Create')]), _: 1 }),
            ]),
            _: 1,
          },
          8,
          ['modelValue'],
        )
      );
    },
  }),
  ez = St({
    __name: 'CreateMockModal',
    props: { modelValue: { type: Boolean } },
    emits: ['update:modelValue', 'created'],
    setup(t, { emit: e }) {
      const r = t,
        { createMock: n } = Bl(),
        i = nt({
          get() {
            return r.modelValue;
          },
          set(f) {
            e('update:modelValue', f);
          },
        }),
        s = tt(''),
        o = tt();
      il(i, () => {
        var f, m;
        (s.value = ''), (f = o.value) == null || f.clearValidation(), (m = o.value) == null || m.focus();
      });
      function l() {
        e('update:modelValue', !1);
      }
      function c(f) {
        return (f = f.trim()), f === '' ? 'Name cannot be empty' : '';
      }
      async function p() {
        var f;
        if ((f = o.value) != null && f.validate()) {
          const m = await n(s.value);
          e('created', m == null ? void 0 : m.id), l();
        }
      }
      return (f, m) => (
        Ne(),
        nr(
          te(CA),
          {
            'modelValue': i.value,
            'onUpdate:modelValue': m[1] || (m[1] = (g) => (i.value = g)),
            'title': 'Create Mock Data',
          },
          {
            default: Ke(() => [
              z(
                te(Zm),
                {
                  'ref_key': 'nameInput',
                  'ref': o,
                  'modelValue': s.value,
                  'onUpdate:modelValue': m[0] || (m[0] = (g) => (s.value = g)),
                  'title': 'Name',
                  'validate-fn': c,
                  'onKeydown': Vi(Or(p, ['prevent']), ['enter']),
                },
                null,
                8,
                ['modelValue', 'onKeydown'],
              ),
            ]),
            action: Ke(() => [
              z(te(Wn), { type: 'ghost', onClick: l }, { default: Ke(() => [Dn('Cancel')]), _: 1 }),
              z(te(Wn), { type: 'primary', onClick: p }, { default: Ke(() => [Dn('Create')]), _: 1 }),
            ]),
            _: 1,
          },
          8,
          ['modelValue'],
        )
      );
    },
  }),
  tz = { key: 0, class: 'flex-1 min-w-0 truncate text-sm leading-6' },
  rz = St({
    __name: 'MockListItem',
    props: { mock: {}, selected: { type: Boolean }, dropdownOpen: { type: Boolean }, readOnly: { type: Boolean } },
    emits: ['edit-confirm', 'delete'],
    setup(t, { emit: e }) {
      const r = t,
        n = tt(!1),
        i = tt(!1),
        s = tt(),
        o = tt(r.mock.name),
        l = nt(() => r.mock.default),
        {
          confirmed: c,
          trigger: p,
          cancel: f,
        } = zf(() => {
          e('delete');
        });
      il(n, () => {
        (o.value = r.mock.name),
          gi(() => {
            var x, b;
            (x = s.value) == null || x.focus(), (b = s.value) == null || b.select();
          });
      }),
        il(
          () => !r.dropdownOpen,
          () => {
            n.value = !1;
          },
        );
      function m() {
        const x = o.value.trim();
        x && e('edit-confirm', x), (n.value = !1);
      }
      function g() {
        n.value = !1;
      }
      return (x, b) => (
        Ne(),
        rt(
          'div',
          {
            class: Gt([
              'py-1 px-2 flex items-center leading-6 cursor-pointer rounded',
              { 'hover:bg-base-200/80': !x.selected, 'bg-primary-content/30': x.selected },
            ]),
            onMouseenter: b[3] || (b[3] = (F) => (i.value = !0)),
            onMouseleave: b[4] || (b[4] = (F) => (i.value = !1)),
          },
          [
            n.value
              ? (Ne(),
                nr(
                  te(to),
                  {
                    'key': 1,
                    'ref_key': 'inputRef',
                    'ref': s,
                    'modelValue': o.value,
                    'onUpdate:modelValue': b[0] || (b[0] = (F) => (o.value = F)),
                    'class': 'flex-1 text-xs px-1 rounded',
                    'size': 'xs',
                    'bordered': '',
                    'onClick': b[1] || (b[1] = Or(() => {}, ['stop'])),
                    'onKeydown': [Vi(m, ['enter']), Vi(g, ['esc'])],
                  },
                  null,
                  8,
                  ['modelValue', 'onKeydown'],
                ))
              : (Ne(), rt('div', tz, ai(x.mock.name), 1)),
            x.readOnly || !n.value
              ? (Ne(),
                rt(
                  $t,
                  { key: 2 },
                  [
                    i.value && !l.value && !x.readOnly
                      ? (Ne(),
                        rt(
                          $t,
                          { key: 0 },
                          [
                            z(
                              te(Lr),
                              {
                                class: 'ml-2',
                                transparent: '',
                                onClick: b[2] || (b[2] = Or((F) => (n.value = !0), ['stop'])),
                              },
                              { default: Ke(() => [z(te(jg))]), _: 1 },
                            ),
                            z(
                              te(Lr),
                              { transparent: '', danger: te(c), onClick: Or(te(p), ['stop']), onMouseleave: te(f) },
                              { default: Ke(() => [z(te(yf))]), _: 1 },
                              8,
                              ['danger', 'onClick', 'onMouseleave'],
                            ),
                          ],
                          64,
                        ))
                      : Ni('', !0),
                  ],
                  64,
                ))
              : (Ne(),
                rt(
                  $t,
                  { key: 3 },
                  [
                    z(
                      te(Lr),
                      { class: 'ml-2', transparent: '', onClick: Or(m, ['stop']) },
                      { default: Ke(() => [z(te(bA))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                    z(
                      te(Lr),
                      { transparent: '', onClick: Or(g, ['stop']) },
                      { default: Ke(() => [z(te(AA))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                  ],
                  64,
                )),
          ],
          34,
        )
      );
    },
  }),
  nz = { class: 'relative' },
  iz = { class: 'min-w-0 truncate' },
  sz = {
    class:
      'flex flex-col gap-1 absolute p-2 shadow dropdown-content z-[1] bg-base-100 rounded w-full transform translate-y-2 overflow-auto max-h-60',
  },
  oz = { key: 1, class: 'flex-center py-2 text-sm' },
  aw = St({
    __name: 'MockDropdownList',
    props: { modelValue: {}, readOnly: { type: Boolean } },
    emits: ['update:modelValue', 'delete', 'update', 'change'],
    setup(t, { emit: e }) {
      const r = t,
        { mockList: n } = Bl(),
        i = nt(() => n.value.find((b) => b.id === r.modelValue)),
        s = tt(''),
        o = tt(!1),
        l = tt(),
        c = tt(),
        p = nt(() => {
          const b = s.value.trim().toLowerCase();
          return b ? n.value.filter((F) => F.name.toLowerCase().includes(b)) : n.value;
        });
      TB(l, () => {
        o.value = !1;
      }),
        Zt(o, (b) => {
          var F;
          (s.value = ''), b && ((F = c.value) == null || F.focus());
        });
      function f(b) {
        e('update:modelValue', b), e('change', b), (o.value = !1);
      }
      function m(b) {
        e('delete', b);
      }
      function g(b, F) {
        e('update', b, F);
      }
      function x() {
        var b;
        (o.value = !1), (b = c.value) == null || b.blur();
      }
      return (b, F) => {
        var E;
        return (
          Ne(),
          rt(
            'div',
            { ref_key: 'containerRef', ref: l, class: 'relative w-full' },
            [
              $e('div', nz, [
                o.value
                  ? Ni('', !0)
                  : (Ne(),
                    rt(
                      'div',
                      {
                        key: 0,
                        class: 'flex items-center pl-3 pr-8 inset-0 absolute cursor-pointer text-sm',
                        onClick: F[0] || (F[0] = (w) => (o.value = !0)),
                      },
                      [$e('span', iz, ai(((E = i.value) == null ? void 0 : E.name) ?? ''), 1)],
                    )),
                z(
                  te(to),
                  {
                    'ref_key': 'inputRef',
                    'ref': c,
                    'modelValue': s.value,
                    'onUpdate:modelValue': F[1] || (F[1] = (w) => (s.value = w)),
                    'class': 'pr-8',
                    'placeholder': o.value ? 'Search' : '',
                    'bordered': '',
                    'size': 'sm',
                    'onFocus': F[2] || (F[2] = (w) => (o.value = !0)),
                    'onClick': F[3] || (F[3] = (w) => (o.value = !0)),
                    'onKeydown': Vi(x, ['esc']),
                  },
                  null,
                  8,
                  ['modelValue', 'placeholder', 'onKeydown'],
                ),
                z(
                  te(z8),
                  {
                    class: Gt([
                      'absolute right-2 top-1/2 transform -translate-y-1/2 text-base-content/50 transition pointer-events-none',
                      { 'transform rotate-180': o.value },
                    ]),
                  },
                  null,
                  8,
                  ['class'],
                ),
              ]),
              Bb(
                $e(
                  'div',
                  sz,
                  [
                    p.value.length
                      ? (Ne(!0),
                        rt(
                          $t,
                          { key: 0 },
                          Zo(
                            p.value,
                            (w) => (
                              Ne(),
                              nr(
                                rz,
                                {
                                  'key': w.id,
                                  'mock': w,
                                  'selected': w.id === b.modelValue,
                                  'dropdown-open': o.value,
                                  'read-only': b.readOnly,
                                  'onClick': (I) => f(w.id),
                                  'onDelete': (I) => m(w.id),
                                  'onEditConfirm': (I) => g(w.id, I),
                                },
                                null,
                                8,
                                [
                                  'mock',
                                  'selected',
                                  'dropdown-open',
                                  'read-only',
                                  'onClick',
                                  'onDelete',
                                  'onEditConfirm',
                                ],
                              )
                            ),
                          ),
                          128,
                        ))
                      : (Ne(), rt('div', oz, 'No Data')),
                  ],
                  512,
                ),
                [[tA, o.value]],
              ),
            ],
            512,
          )
        );
      };
    },
  }),
  az = { class: 'flex-1 truncate mr-1' },
  JC = St({
    __name: 'RuleItem',
    props: { rule: {}, initEdit: { type: Boolean, default: !1 }, selected: { type: Boolean, default: !1 } },
    emits: ['edit-confirm', 'edit-cancel', 'delete'],
    setup(t, { expose: e, emit: r }) {
      const n = t;
      e({ focusEdit: x });
      const i = tt(n.initEdit),
        s = tt(n.rule.name),
        o = tt(),
        l = tt(!1),
        {
          confirmed: c,
          trigger: p,
          cancel: f,
        } = zf(() => {
          r('delete');
        });
      il(i, () => {
        (s.value = n.rule.name),
          gi(() => {
            x();
          });
      });
      function m() {
        r('edit-confirm', s.value), (i.value = !1);
      }
      function g() {
        r('edit-cancel'), (i.value = !1);
      }
      function x() {
        var F, E;
        (F = o.value) == null || F.focus(), (E = o.value) == null || E.select();
      }
      function b(F) {
        i.value && (F.stopPropagation(), x());
      }
      return (F, E) => (
        Ne(),
        rt(
          'div',
          {
            class: Gt([
              'flex items-center text-xs leading-6 cursor-pointer py-1 px-2 rounded',
              { 'hover:bg-base-200/80': !F.selected, 'bg-primary-content/30': F.selected },
            ]),
            onMouseenter: E[3] || (E[3] = (w) => (l.value = !0)),
            onMouseleave: E[4] || (E[4] = (w) => (l.value = !1)),
          },
          [
            z(te(H8), { class: Gt({ 'mr-1': i.value, 'mr-2': !i.value }), size: 14, onClick: b }, null, 8, ['class']),
            i.value
              ? (Ne(),
                rt(
                  $t,
                  { key: 1 },
                  [
                    z(
                      te(to),
                      {
                        'ref_key': 'inputRef',
                        'ref': o,
                        'modelValue': s.value,
                        'onUpdate:modelValue': E[1] || (E[1] = (w) => (s.value = w)),
                        'class': 'flex-1 text-xs px-1 rounded',
                        'size': 'xs',
                        'bordered': '',
                        'onClick': E[2] || (E[2] = Or(() => {}, ['stop'])),
                        'onKeydown': [Vi(m, ['enter']), Vi(g, ['esc'])],
                      },
                      null,
                      8,
                      ['modelValue', 'onKeydown'],
                    ),
                    z(
                      te(Lr),
                      { class: 'ml-2', transparent: '', onClick: Or(m, ['stop']) },
                      { default: Ke(() => [z(te(bA))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                    z(
                      te(Lr),
                      { transparent: '', onClick: Or(g, ['stop']) },
                      { default: Ke(() => [z(te(AA))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                  ],
                  64,
                ))
              : (Ne(),
                rt(
                  $t,
                  { key: 0 },
                  [
                    $e('div', az, ai(F.rule.name), 1),
                    l.value
                      ? (Ne(),
                        rt(
                          $t,
                          { key: 0 },
                          [
                            z(
                              te(Lr),
                              { transparent: '', onClick: E[0] || (E[0] = Or((w) => (i.value = !0), ['stop'])) },
                              { default: Ke(() => [z(te(jg))]), _: 1 },
                            ),
                            z(
                              te(Lr),
                              { transparent: '', danger: te(c), onClick: Or(te(p), ['stop']), onMouseleave: te(f) },
                              { default: Ke(() => [z(te(yf))]), _: 1 },
                              8,
                              ['danger', 'onClick', 'onMouseleave'],
                            ),
                          ],
                          64,
                        ))
                      : Ni('', !0),
                  ],
                  64,
                )),
            z(te(V8), { class: Gt(['ml-1', [F.rule.enabled ? 'text-success' : 'text-base-300']]) }, null, 8, ['class']),
          ],
          34,
        )
      );
    },
  }),
  lz = { class: 'py-2 h-screen w-10 bg-base-200 flex flex-col items-center justify-between' },
  uz = St({
    __name: 'SideBar',
    setup(t) {
      const e = xA(),
        i = [
          [
            {
              icon: q8,
              tip: 'Home',
              handler: () => {
                s('/');
              },
            },
            {
              icon: Q8,
              tip: 'Search',
              handler: () => {
                Vg.warning('Not Implemented 嘿嘿');
              },
            },
          ],
          [
            {
              icon: X8,
              tip: 'Traffic',
              handler: () => {
                s('/traffic');
              },
            },
            {
              icon: _8,
              tip: 'Statistics',
              handler: () => {
                s('/statistics');
              },
            },
            {
              icon: Z8,
              tip: 'Settings',
              handler: () => {
                s('/settings');
              },
            },
          ],
        ];
      function s(o) {
        e.push(o);
      }
      return (o, l) => (
        Ne(),
        rt('div', lz, [
          (Ne(),
          rt(
            $t,
            null,
            Zo(i, (c, p) =>
              $e('div', { key: p, class: 'flex flex-col items-center gap-2' }, [
                (Ne(!0),
                rt(
                  $t,
                  null,
                  Zo(
                    c,
                    (f) => (
                      Ne(),
                      nr(
                        te(ro),
                        { key: f.tip, class: 'sidebar-btn-wrapper', content: f.tip, position: 'right' },
                        {
                          default: Ke(() => [
                            z(
                              te(Wn),
                              {
                                class: 'sidebar-btn rounded w-8 h-8 hover:shadow',
                                shape: 'square',
                                onClick: f.handler,
                              },
                              { default: Ke(() => [(Ne(), nr(Rb(f.icon), { size: 20 }))]), _: 2 },
                              1032,
                              ['onClick'],
                            ),
                          ]),
                          _: 2,
                        },
                        1032,
                        ['content'],
                      )
                    ),
                  ),
                  128,
                )),
              ]),
            ),
            64,
          )),
        ])
      );
    },
  });
const cz = In(uz, [['__scopeId', 'data-v-9bdc50d8']]),
  ma = (t) => (sc('data-v-34b3e882'), (t = t()), oc(), t),
  hz = { class: 'flex-1 grid grid-cols-[auto,1fr] gap-x-4 gap-y-2' },
  pz = ma(() => $e('div', { class: 'info-label' }, 'When', -1)),
  fz = { class: 'grid grid-cols-[1fr,auto,1fr,auto] gap-y-2' },
  dz = ma(() => $e('span', { class: 'leading-8 mx-2' }, '=', -1)),
  mz = { class: 'ml-2 h-full flex-center' },
  gz = { class: 'flex items-center w-full' },
  yz = ma(() => $e('span', null, 'New Condition', -1)),
  Dz = ma(() => $e('div', { class: 'empty-placeholder' }, null, -1)),
  xz = ma(() => $e('div', { class: 'info-label' }, 'When', -1)),
  Cz = { class: 'info-label flex' },
  bz = ma(() => $e('div', { class: 'empty-placeholder' }, null, -1)),
  Az = ma(() => $e('div', { class: 'info-label' }, 'Use', -1)),
  Ez = { class: 'flex items-center' },
  vz = { key: 1, class: 'empty-placeholder' },
  Fz = St({
    __name: 'MatcherItem',
    props: { matcher: {} },
    emits: ['update', 'delete', 'create-config', 'delete-config', 'update-config'],
    setup(t, { emit: e }) {
      const r = t,
        n = nt(() => r.matcher.configs),
        i = nt(() => r.matcher.mock),
        s = nt(() => r.matcher.default),
        o = TA(QS.ChangeSelectMock),
        l = tt(!1),
        {
          confirmed: c,
          trigger: p,
          cancel: f,
        } = zf(() => {
          e('delete');
        }),
        m = zg((x) => {
          e('update-config', x);
        }, qy);
      function g(x) {
        o.emit({ id: x }), e('update', x);
      }
      return (x, b) => (
        Ne(),
        rt(
          'div',
          {
            class: 'flex items-center',
            onMouseenter: b[2] || (b[2] = (F) => (l.value = !0)),
            onMouseleave: b[3] || (b[3] = (F) => (l.value = !1)),
          },
          [
            $e('div', hz, [
              s.value
                ? (Ne(),
                  rt(
                    $t,
                    { key: 1 },
                    [
                      xz,
                      $e('div', Cz, [
                        z(
                          te(Wn),
                          { class: 'mr-2 flex-center flex-1 text-xs' },
                          { default: Ke(() => [Dn('Fallback')]), _: 1 },
                        ),
                        bz,
                      ]),
                    ],
                    64,
                  ))
                : (Ne(),
                  rt(
                    $t,
                    { key: 0 },
                    [
                      pz,
                      $e('div', null, [
                        $e('div', fz, [
                          (Ne(!0),
                          rt(
                            $t,
                            null,
                            Zo(
                              n.value,
                              (F) => (
                                Ne(),
                                rt(
                                  $t,
                                  { key: F.id },
                                  [
                                    z(
                                      te(to),
                                      {
                                        'modelValue': F.key,
                                        'onUpdate:modelValue': (E) => (F.key = E),
                                        'bordered': '',
                                        'size': 'sm',
                                        'onInput': (E) => te(m)({ id: F.id, key: E.trim() }),
                                      },
                                      null,
                                      8,
                                      ['modelValue', 'onUpdate:modelValue', 'onInput'],
                                    ),
                                    dz,
                                    z(
                                      te(to),
                                      {
                                        'modelValue': F.value,
                                        'onUpdate:modelValue': (E) => (F.value = E),
                                        'bordered': '',
                                        'size': 'sm',
                                        'onInput': (E) => te(m)({ id: F.id, value: E.trim() }),
                                      },
                                      null,
                                      8,
                                      ['modelValue', 'onUpdate:modelValue', 'onInput'],
                                    ),
                                    $e('div', mz, [
                                      z(
                                        te(Lr),
                                        { transparent: '', onClick: (E) => e('delete-config', F.id) },
                                        { default: Ke(() => [z(te(Y8))]), _: 2 },
                                        1032,
                                        ['onClick'],
                                      ),
                                    ]),
                                  ],
                                  64,
                                )
                              ),
                            ),
                            128,
                          )),
                        ]),
                        $e('div', gz, [
                          z(
                            te(Wn),
                            {
                              class: Gt(['flex-1 mr-2 normal-case text-xs', { 'mt-2': n.value.length }]),
                              size: 'sm',
                              onClick: b[0] || (b[0] = (F) => e('create-config')),
                            },
                            { default: Ke(() => [z(te(EA), { 'stroke-width': 5, 'size': 14 }), yz]), _: 1 },
                            8,
                            ['class'],
                          ),
                          Dz,
                        ]),
                      ]),
                    ],
                    64,
                  )),
              Az,
              $e('div', Ez, [
                z(
                  te(aw),
                  {
                    'modelValue': i.value.id,
                    'onUpdate:modelValue': b[1] || (b[1] = (F) => (i.value.id = F)),
                    'class': 'mr-2',
                    'read-only': '',
                    'onChange': g,
                  },
                  null,
                  8,
                  ['modelValue'],
                ),
                s.value
                  ? (Ne(), rt('div', vz))
                  : (Ne(),
                    nr(
                      te(Lr),
                      {
                        key: 0,
                        class: 'flex-none',
                        transparent: '',
                        danger: te(c),
                        onClick: te(p),
                        onMouseleave: te(f),
                      },
                      { default: Ke(() => [z(te(yf))]), _: 1 },
                      8,
                      ['danger', 'onClick', 'onMouseleave'],
                    )),
              ]),
            ]),
          ],
          32,
        )
      );
    },
  });
const Sz = In(Fz, [['__scopeId', 'data-v-34b3e882']]),
  wz = { class: 'h-screen w-screen flex' },
  Tz = { class: 'h-screen flex-1 relative min-w-0 py-2 pr-2 bg-base-200' },
  kz = St({
    __name: 'App',
    setup(t) {
      return (e, r) => (Ne(), rt('div', wz, [z(te(cz), { class: 'flex-none' }), $e('div', Tz, [z(te(DA))])]));
    },
  });
const Gy = (t) => (sc('data-v-dffe5ed4'), (t = t()), oc(), t),
  Pz = Gy(() => $e('div', { class: 'px-4 py-2' }, 'Basic Config', -1)),
  Bz = { class: 'h-full w-full p-4' },
  Iz = { class: 'grid grid-cols-[auto,1fr] gap-x-2 gap-y-4' },
  Nz = Gy(() => $e('label', { class: 'config-label' }, 'Enabled', -1)),
  Mz = Gy(() => $e('label', { class: 'config-label' }, 'URL Path', -1)),
  Oz = St({
    __name: 'BasicConfig',
    setup(t) {
      const { rules: e } = Xy(),
        { selectedRule: r, updateRuleConfig: n } = Bl();
      async function i(o) {
        await n({ enabled: o }),
          (e.value.find((l) => {
            var c;
            return l.id === ((c = r.value) == null ? void 0 : c.id);
          }).enabled = o);
      }
      const s = zg((o) => n({ path: o.trim() }), qy);
      return (o, l) => (
        Ne(),
        nr(te(ds), null, {
          header: Ke(() => [Pz]),
          default: Ke(() => [
            $e('div', Bz, [
              $e('div', Iz, [
                Nz,
                z(
                  te(uB),
                  {
                    'modelValue': te(r).enabled,
                    'onUpdate:modelValue': l[0] || (l[0] = (c) => (te(r).enabled = c)),
                    'type': 'success',
                    'onChange': i,
                  },
                  null,
                  8,
                  ['modelValue'],
                ),
                Mz,
                z(
                  te(to),
                  {
                    'modelValue': te(r).path,
                    'onUpdate:modelValue': l[1] || (l[1] = (c) => (te(r).path = c)),
                    'class': 'max-w-100',
                    'size': 'sm',
                    'bordered': '',
                    'onInput': te(s),
                  },
                  null,
                  8,
                  ['modelValue', 'onInput'],
                ),
              ]),
            ]),
          ]),
          _: 1,
        })
      );
    },
  });
const Lz = In(Oz, [['__scopeId', 'data-v-dffe5ed4']]),
  _z = (t) => (sc('data-v-cc45d921'), (t = t()), oc(), t),
  Rz = { class: 'px-4 py-2 pr-3 flex items-center justify-between' },
  jz = _z(() => $e('span', null, 'Matcher Config', -1)),
  $z = { class: 'p-4 text-sm overflow-auto h-full' },
  Vz = { key: 0, class: 'divider my-2' },
  zz = St({
    __name: 'MatcherConfig',
    setup(t) {
      const {
        matcherList: e,
        createMatcher: r,
        updateMatcher: n,
        deleteMatcher: i,
        createMatcherConfig: s,
        updateMatcherConfig: o,
        deleteMatcherConfig: l,
      } = Bl();
      return (c, p) => (
        Ne(),
        nr(te(ds), null, {
          header: Ke(() => [
            $e('div', Rz, [
              jz,
              z(
                te(ro),
                { class: 'flex text-xs', content: 'Add Matcher', position: 'left' },
                {
                  default: Ke(() => [
                    z(te(Lr), { onClick: te(r) }, { default: Ke(() => [z(te($g))]), _: 1 }, 8, ['onClick']),
                  ]),
                  _: 1,
                },
              ),
            ]),
          ]),
          default: Ke(() => [
            $e('div', $z, [
              (Ne(!0),
              rt(
                $t,
                null,
                Zo(
                  te(e),
                  (f, m) => (
                    Ne(),
                    rt(
                      $t,
                      { key: f.id },
                      [
                        m !== 0 ? (Ne(), rt('div', Vz)) : Ni('', !0),
                        z(
                          te(Sz),
                          {
                            matcher: f,
                            onUpdate: (g) => te(n)({ id: f.id, mockId: g }),
                            onDelete: (g) => te(i)(f.id),
                            onCreateConfig: (g) => te(s)(f.id),
                            onUpdateConfig: te(o),
                            onDeleteConfig: te(l),
                          },
                          null,
                          8,
                          ['matcher', 'onUpdate', 'onDelete', 'onCreateConfig', 'onUpdateConfig', 'onDeleteConfig'],
                        ),
                      ],
                      64,
                    )
                  ),
                ),
                128,
              )),
            ]),
          ]),
          _: 1,
        })
      );
    },
  });
const Hz = In(zz, [['__scopeId', 'data-v-cc45d921']]),
  Wz = { class: 'px-4 py-2 pr-3 flex items-center justify-between' },
  Uz = $e('span', null, 'Mock Config', -1),
  qz = { class: 'p-4 flex flex-col h-full' },
  Kz = { class: 'mb-1 flex items-center' },
  Jz = St({
    __name: 'MockConfig',
    setup(t) {
      const { selectedRule: e, deleteMock: r, updateMock: n } = Bl(),
        i = nt(() => e.value.mocks),
        s = tt(!1),
        o = nt(() => i.value.find((E) => E.default).id),
        l = tt(o.value),
        c = nt(() => i.value.find((E) => E.id === l.value)),
        p = tt(c.value.body);
      TA(QS.ChangeSelectMock).on((E) => {
        i.value.find((w) => w.id === E.id) && (l.value = E.id);
      }),
        Zt(l, () => {
          p.value = c.value.body;
        }),
        Zt(o, () => {
          l.value = o.value;
        });
      const m = zg((E) => {
        n(E);
      }, qy);
      function g() {
        const E = l.value,
          w = p.value;
        m({ id: E, body: w });
      }
      async function x(E) {
        E === l.value && (l.value = o.value), await r(E);
      }
      async function b(E, w) {
        (i.value.find((I) => I.id === E).name = w), await n({ id: E, name: w });
      }
      function F(E) {
        console.log(
          'created',
          E,
          i.value.find((w) => w.id === E),
        ),
          !(!E || !i.value.find((w) => w.id === E)) && (l.value = E);
      }
      return (E, w) => (
        Ne(),
        nr(te(ds), null, {
          header: Ke(() => [
            $e('div', Wz, [
              Uz,
              z(
                te(ro),
                { class: 'flex text-xs', content: 'Add Mock', position: 'left' },
                {
                  default: Ke(() => [
                    z(
                      te(Lr),
                      { onClick: w[0] || (w[0] = (I) => (s.value = !0)) },
                      { default: Ke(() => [z(te($g))]), _: 1 },
                    ),
                  ]),
                  _: 1,
                },
              ),
            ]),
          ]),
          default: Ke(() => [
            $e('div', qz, [
              $e('div', Kz, [
                z(
                  te(aw),
                  {
                    'modelValue': l.value,
                    'onUpdate:modelValue': w[1] || (w[1] = (I) => (l.value = I)),
                    'onDelete': x,
                    'onUpdate': b,
                  },
                  null,
                  8,
                  ['modelValue'],
                ),
              ]),
              z(
                te(nV),
                {
                  'modelValue': p.value,
                  'onUpdate:modelValue': w[2] || (w[2] = (I) => (p.value = I)),
                  'class': 'editor flex-1 min-h-0',
                  'onChange': g,
                },
                null,
                8,
                ['modelValue'],
              ),
            ]),
            z(
              te(ez),
              { 'modelValue': s.value, 'onUpdate:modelValue': w[3] || (w[3] = (I) => (s.value = I)), 'onCreated': F },
              null,
              8,
              ['modelValue'],
            ),
          ]),
          _: 1,
        })
      );
    },
  }),
  Xz = (t) => (sc('data-v-de83dfc6'), (t = t()), oc(), t),
  Gz = { class: 'px-4 py-2 pr-3 flex items-center justify-between' },
  Yz = Xz(() => $e('span', null, 'Rules', -1)),
  Qz = { class: 'w-full h-full p-2 flex flex-col overflow-auto' },
  Zz = { key: 0, class: 'rule-item create' },
  eH = St({
    __name: 'RuleList',
    setup(t) {
      const e = { name: 'new rule' },
        { rules: r, createRule: n, updateRule: i, deleteRule: s, selectedRuleId: o } = Xy(),
        l = tt(!1),
        c = tt(null);
      function p() {
        l.value || (l.value = !0),
          gi(() => {
            var x;
            (x = c.value) == null || x.focusEdit();
          });
      }
      async function f(x) {
        const b = x.trim();
        b && (await n(b)), (l.value = !1);
      }
      async function m(x) {
        await s(x);
      }
      async function g(x, b) {
        const F = b.trim(),
          E = r.value.find((w) => w.id === x);
        F && E && F !== E.name && ((E.name = F), await i({ id: x, name: F }));
      }
      return (x, b) => (
        Ne(),
        nr(te(ds), null, {
          header: Ke(() => [
            $e('div', Gz, [
              Yz,
              z(
                te(ro),
                { class: 'flex text-xs', content: 'Add Rule', position: 'left' },
                { default: Ke(() => [z(te(Lr), { onClick: p }, { default: Ke(() => [z(te($g))]), _: 1 })]), _: 1 },
              ),
            ]),
          ]),
          default: Ke(() => [
            $e('div', Qz, [
              (Ne(!0),
              rt(
                $t,
                null,
                Zo(
                  te(r),
                  (F) => (
                    Ne(),
                    rt('div', { key: F.name, class: 'rule-item' }, [
                      z(
                        te(JC),
                        {
                          class: 'rule-item',
                          rule: F,
                          selected: te(o) === F.id,
                          onDelete: (E) => m(F.id),
                          onEditConfirm: (E) => g(F.id, E),
                          onClick: (E) => (o.value = F.id),
                        },
                        null,
                        8,
                        ['rule', 'selected', 'onDelete', 'onEditConfirm', 'onClick'],
                      ),
                    ])
                  ),
                ),
                128,
              )),
              l.value
                ? (Ne(),
                  rt('div', Zz, [
                    z(
                      te(JC),
                      {
                        'ref_key': 'createRuleRef',
                        'ref': c,
                        'class': 'rule-item',
                        'rule': e,
                        'init-edit': '',
                        'onEditConfirm': f,
                        'onEditCancel': b[0] || (b[0] = (F) => (l.value = !1)),
                      },
                      null,
                      512,
                    ),
                  ]))
                : Ni('', !0),
            ]),
          ]),
          _: 1,
        })
      );
    },
  });
const tH = In(eH, [['__scopeId', 'data-v-de83dfc6']]),
  rH = { class: 'flex flex-col h-full gap-2' },
  nH = { class: 'flex-center flex-col text-xl' },
  iH = St({
    __name: 'index',
    props: { id: {} },
    setup(t) {
      const e = t,
        { setDetailCollectionId: r } = ow(),
        { selectedRule: n } = Bl();
      return (
        r(e.id),
        (i, s) => (
          Ne(),
          nr(
            te(A1),
            {
              'class': 'detail-layout',
              'init-start-size': '35%',
              'local-key': te(Kp).DetailResizeLayout,
              'start-min-size': 200,
              'start-max-size': 300,
            },
            {
              start: Ke(() => [z(tH)]),
              end: Ke(() => [
                te(n)
                  ? (Ne(),
                    nr(
                      te(A1),
                      {
                        'key': 0,
                        'class': 'flex-1 min-h-0',
                        'init-start-size': '40%',
                        'start-min-size': 300,
                        'start-max-size': 600,
                        'local-key': te(Kp).ConfigResizeLayout,
                      },
                      {
                        start: Ke(() => [
                          $e('div', rH, [z(Lz, { class: '!h-fit' }), z(Hz, { class: 'flex-1 min-h-0' })]),
                        ]),
                        end: Ke(() => [z(Jz)]),
                        _: 1,
                      },
                      8,
                      ['local-key'],
                    ))
                  : (Ne(),
                    nr(
                      te(ds),
                      { key: 1 },
                      {
                        default: Ke(() => [
                          z(te(A8), null, {
                            default: Ke(() => [
                              $e('div', nH, [z(te(W8), { class: 'mb-4', size: 48 }), Dn(' Select One Rule First ')]),
                            ]),
                            _: 1,
                          }),
                        ]),
                        _: 1,
                      },
                    )),
              ]),
              _: 1,
            },
            8,
            ['local-key'],
          )
        )
      );
    },
  }),
  sH = (t) => (sc('data-v-21f82af6'), (t = t()), oc(), t),
  oH = { class: 'h-full w-full' },
  aH = { key: 1, class: 'w-full h-full' },
  lH = { class: 'responsive-grid' },
  uH = sH(() => $e('div', { class: 'font-bold text-xl mt-8 mb-5' }, 'All Collections', -1)),
  cH = { class: 'responsive-grid' },
  hH = St({
    __name: 'index',
    setup(t) {
      const e = xA();
      function r(c) {
        e.push({ name: 'detail', params: { id: c } });
      }
      const { fetched: n, collections: i, fetchCollections: s } = Jy(),
        o = tt(!n.value);
      s().then(() => {
        o.value = !1;
      });
      const l = tt(!1);
      return (c, p) => (
        Ne(),
        rt('div', oH, [
          z(
            te(ds),
            { class: 'flex-center p-6' },
            {
              default: Ke(() => [
                o.value
                  ? (Ne(), nr(te(v8), { key: 0, shape: 'dots', size: 'lg' }))
                  : (Ne(),
                    rt('div', aH, [
                      $e('div', lH, [z(te(QV), { onClick: p[0] || (p[0] = (f) => (l.value = !0)) })]),
                      uH,
                      $e('div', cH, [
                        (Ne(!0),
                        rt(
                          $t,
                          null,
                          Zo(
                            te(i),
                            (f) => (
                              Ne(),
                              nr(
                                te(XV),
                                { key: f.id, collection: f, onClick: (m) => r(f.id) },
                                {
                                  default: Ke(() => {
                                    var m;
                                    return [Dn(ai((m = te(i)[0]) == null ? void 0 : m.name), 1)];
                                  }),
                                  _: 2,
                                },
                                1032,
                                ['collection', 'onClick'],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                    ])),
              ]),
              _: 1,
            },
          ),
          z(te(ZV), { 'modelValue': l.value, 'onUpdate:modelValue': p[1] || (p[1] = (f) => (l.value = f)) }, null, 8, [
            'modelValue',
          ]),
        ])
      );
    },
  });
const pH = In(hH, [['__scopeId', 'data-v-21f82af6']]),
  fH = { class: 'h-full w-full' },
  dH = St({
    __name: 'index',
    setup(t) {
      return (e, r) => (
        Ne(),
        rt('div', fH, [
          z(
            te(ds),
            { class: 'flex-center' },
            { default: Ke(() => [z(te(Wn), null, { default: Ke(() => [Dn('Settings')]), _: 1 })]), _: 1 },
          ),
        ])
      );
    },
  }),
  mH = { class: 'h-full w-full' },
  gH = St({
    __name: 'index',
    setup(t) {
      return (e, r) => (
        Ne(),
        rt('div', mH, [
          z(
            te(ds),
            { class: 'flex-center' },
            { default: Ke(() => [z(te(Wn), null, { default: Ke(() => [Dn('Statistics')]), _: 1 })]), _: 1 },
          ),
        ])
      );
    },
  }),
  yH = { class: 'h-full w-full' },
  DH = St({
    __name: 'index',
    setup(t) {
      return (e, r) => (
        Ne(),
        rt('div', yH, [
          z(
            te(ds),
            { class: 'flex-center' },
            { default: Ke(() => [z(te(Wn), null, { default: Ke(() => [Dn('Traffic')]), _: 1 })]), _: 1 },
          ),
        ])
      );
    },
  }),
  xH = [
    { path: '/', component: pH },
    { name: 'detail', path: '/collection/:id', component: iH, props: !0 },
    { name: 'settings', path: '/settings', component: dH },
    { name: 'statistics', path: '/statistics', component: gH },
    { name: 'traffic', path: '/traffic', component: DH },
  ],
  CH = h8({ history: T3(), routes: xH });
YC.extend(ET);
const Yy = e3(kz),
  bH = n3();
Yy.use(CH);
Yy.use(bH);
Yy.mount('#app');
