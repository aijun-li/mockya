var p1 = Object.defineProperty;
var d1 = (r, e, n) => (e in r ? p1(r, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (r[e] = n));
var Cf = (r, e, n) => (d1(r, typeof e != 'symbol' ? e + '' : e, n), n);
(function () {
  const e = document.createElement('link').relList;
  if (e && e.supports && e.supports('modulepreload')) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) s(o);
  new MutationObserver((o) => {
    for (const a of o)
      if (a.type === 'childList')
        for (const l of a.addedNodes) l.tagName === 'LINK' && l.rel === 'modulepreload' && s(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(o) {
    const a = {};
    return (
      o.integrity && (a.integrity = o.integrity),
      o.referrerPolicy && (a.referrerPolicy = o.referrerPolicy),
      o.crossOrigin === 'use-credentials'
        ? (a.credentials = 'include')
        : o.crossOrigin === 'anonymous'
        ? (a.credentials = 'omit')
        : (a.credentials = 'same-origin'),
      a
    );
  }
  function s(o) {
    if (o.ep) return;
    o.ep = !0;
    const a = n(o);
    fetch(o.href, a);
  }
})();
var commonjsGlobal =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {};
function getDefaultExportFromCjs(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, 'default') ? r.default : r;
}
var dayjs_min = { exports: {} },
  hasRequiredDayjs_min;
function requireDayjs_min() {
  return (
    hasRequiredDayjs_min ||
      ((hasRequiredDayjs_min = 1),
      (function (r, e) {
        (function (n, s) {
          r.exports = s();
        })(commonjsGlobal, function () {
          var n = 1e3,
            s = 6e4,
            o = 36e5,
            a = 'millisecond',
            l = 'second',
            f = 'minute',
            m = 'hour',
            v = 'day',
            I = 'week',
            L = 'month',
            V = 'quarter',
            se = 'year',
            Ee = 'date',
            ht = 'Invalid Date',
            ar = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
            $i = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
            tl = {
              name: 'en',
              weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
              months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_',
              ),
              ordinal: function (Il) {
                var Ll = ['th', 'st', 'nd', 'rd'],
                  Nl = Il % 100;
                return '[' + Il + (Ll[(Nl - 20) % 10] || Ll[Nl] || Ll[0]) + ']';
              },
            },
            Wi = function (Il, Ll, Nl) {
              var Hl = String(Il);
              return !Hl || Hl.length >= Ll ? Il : '' + Array(Ll + 1 - Hl.length).join(Nl) + Il;
            },
            hl = {
              s: Wi,
              z: function (Il) {
                var Ll = -Il.utcOffset(),
                  Nl = Math.abs(Ll),
                  Hl = Math.floor(Nl / 60),
                  Bl = Nl % 60;
                return (Ll <= 0 ? '+' : '-') + Wi(Hl, 2, '0') + ':' + Wi(Bl, 2, '0');
              },
              m: function Il(Ll, Nl) {
                if (Ll.date() < Nl.date()) return -Il(Nl, Ll);
                var Hl = 12 * (Nl.year() - Ll.year()) + (Nl.month() - Ll.month()),
                  Bl = Ll.clone().add(Hl, L),
                  ql = Nl - Bl < 0,
                  Yl = Ll.clone().add(Hl + (ql ? -1 : 1), L);
                return +(-(Hl + (Nl - Bl) / (ql ? Bl - Yl : Yl - Bl)) || 0);
              },
              a: function (Il) {
                return Il < 0 ? Math.ceil(Il) || 0 : Math.floor(Il);
              },
              p: function (Il) {
                return (
                  { M: L, y: se, w: I, d: v, D: Ee, h: m, m: f, s: l, ms: a, Q: V }[Il] ||
                  String(Il || '')
                    .toLowerCase()
                    .replace(/s$/, '')
                );
              },
              u: function (Il) {
                return Il === void 0;
              },
            },
            fl = 'en',
            dl = {};
          dl[fl] = tl;
          var Al = '$isDayjsObject',
            Fl = function (Il) {
              return Il instanceof Jl || !(!Il || !Il[Al]);
            },
            vl = function Il(Ll, Nl, Hl) {
              var Bl;
              if (!Ll) return fl;
              if (typeof Ll == 'string') {
                var ql = Ll.toLowerCase();
                dl[ql] && (Bl = ql), Nl && ((dl[ql] = Nl), (Bl = ql));
                var Yl = Ll.split('-');
                if (!Bl && Yl.length > 1) return Il(Yl[0]);
              } else {
                var ih = Ll.name;
                (dl[ih] = Ll), (Bl = ih);
              }
              return !Hl && Bl && (fl = Bl), Bl || (!Hl && fl);
            },
            kl = function (Il, Ll) {
              if (Fl(Il)) return Il.clone();
              var Nl = typeof Ll == 'object' ? Ll : {};
              return (Nl.date = Il), (Nl.args = arguments), new Jl(Nl);
            },
            El = hl;
          (El.l = vl),
            (El.i = Fl),
            (El.w = function (Il, Ll) {
              return kl(Il, { locale: Ll.$L, utc: Ll.$u, x: Ll.$x, $offset: Ll.$offset });
            });
          var Jl = (function () {
              function Il(Nl) {
                (this.$L = vl(Nl.locale, null, !0)), this.parse(Nl), (this.$x = this.$x || Nl.x || {}), (this[Al] = !0);
              }
              var Ll = Il.prototype;
              return (
                (Ll.parse = function (Nl) {
                  (this.$d = (function (Hl) {
                    var Bl = Hl.date,
                      ql = Hl.utc;
                    if (Bl === null) return new Date(NaN);
                    if (El.u(Bl)) return new Date();
                    if (Bl instanceof Date) return new Date(Bl);
                    if (typeof Bl == 'string' && !/Z$/i.test(Bl)) {
                      var Yl = Bl.match(ar);
                      if (Yl) {
                        var ih = Yl[2] - 1 || 0,
                          ph = (Yl[7] || '0').substring(0, 3);
                        return ql
                          ? new Date(Date.UTC(Yl[1], ih, Yl[3] || 1, Yl[4] || 0, Yl[5] || 0, Yl[6] || 0, ph))
                          : new Date(Yl[1], ih, Yl[3] || 1, Yl[4] || 0, Yl[5] || 0, Yl[6] || 0, ph);
                      }
                    }
                    return new Date(Bl);
                  })(Nl)),
                    this.init();
                }),
                (Ll.init = function () {
                  var Nl = this.$d;
                  (this.$y = Nl.getFullYear()),
                    (this.$M = Nl.getMonth()),
                    (this.$D = Nl.getDate()),
                    (this.$W = Nl.getDay()),
                    (this.$H = Nl.getHours()),
                    (this.$m = Nl.getMinutes()),
                    (this.$s = Nl.getSeconds()),
                    (this.$ms = Nl.getMilliseconds());
                }),
                (Ll.$utils = function () {
                  return El;
                }),
                (Ll.isValid = function () {
                  return this.$d.toString() !== ht;
                }),
                (Ll.isSame = function (Nl, Hl) {
                  var Bl = kl(Nl);
                  return this.startOf(Hl) <= Bl && Bl <= this.endOf(Hl);
                }),
                (Ll.isAfter = function (Nl, Hl) {
                  return kl(Nl) < this.startOf(Hl);
                }),
                (Ll.isBefore = function (Nl, Hl) {
                  return this.endOf(Hl) < kl(Nl);
                }),
                (Ll.$g = function (Nl, Hl, Bl) {
                  return El.u(Nl) ? this[Hl] : this.set(Bl, Nl);
                }),
                (Ll.unix = function () {
                  return Math.floor(this.valueOf() / 1e3);
                }),
                (Ll.valueOf = function () {
                  return this.$d.getTime();
                }),
                (Ll.startOf = function (Nl, Hl) {
                  var Bl = this,
                    ql = !!El.u(Hl) || Hl,
                    Yl = El.p(Nl),
                    ih = function (zc, Ul) {
                      var Dh = El.w(Bl.$u ? Date.UTC(Bl.$y, Ul, zc) : new Date(Bl.$y, Ul, zc), Bl);
                      return ql ? Dh : Dh.endOf(v);
                    },
                    ph = function (zc, Ul) {
                      return El.w(
                        Bl.toDate()[zc].apply(Bl.toDate('s'), (ql ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Ul)),
                        Bl,
                      );
                    },
                    gh = this.$W,
                    xh = this.$M,
                    bh = this.$D,
                    Ah = 'set' + (this.$u ? 'UTC' : '');
                  switch (Yl) {
                    case se:
                      return ql ? ih(1, 0) : ih(31, 11);
                    case L:
                      return ql ? ih(1, xh) : ih(0, xh + 1);
                    case I:
                      var wl = this.$locale().weekStart || 0,
                        zl = (gh < wl ? gh + 7 : gh) - wl;
                      return ih(ql ? bh - zl : bh + (6 - zl), xh);
                    case v:
                    case Ee:
                      return ph(Ah + 'Hours', 0);
                    case m:
                      return ph(Ah + 'Minutes', 1);
                    case f:
                      return ph(Ah + 'Seconds', 2);
                    case l:
                      return ph(Ah + 'Milliseconds', 3);
                    default:
                      return this.clone();
                  }
                }),
                (Ll.endOf = function (Nl) {
                  return this.startOf(Nl, !1);
                }),
                (Ll.$set = function (Nl, Hl) {
                  var Bl,
                    ql = El.p(Nl),
                    Yl = 'set' + (this.$u ? 'UTC' : ''),
                    ih = ((Bl = {}),
                    (Bl[v] = Yl + 'Date'),
                    (Bl[Ee] = Yl + 'Date'),
                    (Bl[L] = Yl + 'Month'),
                    (Bl[se] = Yl + 'FullYear'),
                    (Bl[m] = Yl + 'Hours'),
                    (Bl[f] = Yl + 'Minutes'),
                    (Bl[l] = Yl + 'Seconds'),
                    (Bl[a] = Yl + 'Milliseconds'),
                    Bl)[ql],
                    ph = ql === v ? this.$D + (Hl - this.$W) : Hl;
                  if (ql === L || ql === se) {
                    var gh = this.clone().set(Ee, 1);
                    gh.$d[ih](ph), gh.init(), (this.$d = gh.set(Ee, Math.min(this.$D, gh.daysInMonth())).$d);
                  } else ih && this.$d[ih](ph);
                  return this.init(), this;
                }),
                (Ll.set = function (Nl, Hl) {
                  return this.clone().$set(Nl, Hl);
                }),
                (Ll.get = function (Nl) {
                  return this[El.p(Nl)]();
                }),
                (Ll.add = function (Nl, Hl) {
                  var Bl,
                    ql = this;
                  Nl = Number(Nl);
                  var Yl = El.p(Hl),
                    ih = function (xh) {
                      var bh = kl(ql);
                      return El.w(bh.date(bh.date() + Math.round(xh * Nl)), ql);
                    };
                  if (Yl === L) return this.set(L, this.$M + Nl);
                  if (Yl === se) return this.set(se, this.$y + Nl);
                  if (Yl === v) return ih(1);
                  if (Yl === I) return ih(7);
                  var ph = ((Bl = {}), (Bl[f] = s), (Bl[m] = o), (Bl[l] = n), Bl)[Yl] || 1,
                    gh = this.$d.getTime() + Nl * ph;
                  return El.w(gh, this);
                }),
                (Ll.subtract = function (Nl, Hl) {
                  return this.add(-1 * Nl, Hl);
                }),
                (Ll.format = function (Nl) {
                  var Hl = this,
                    Bl = this.$locale();
                  if (!this.isValid()) return Bl.invalidDate || ht;
                  var ql = Nl || 'YYYY-MM-DDTHH:mm:ssZ',
                    Yl = El.z(this),
                    ih = this.$H,
                    ph = this.$m,
                    gh = this.$M,
                    xh = Bl.weekdays,
                    bh = Bl.months,
                    Ah = Bl.meridiem,
                    wl = function (Ul, Dh, gl, bl) {
                      return (Ul && (Ul[Dh] || Ul(Hl, ql))) || gl[Dh].slice(0, bl);
                    },
                    zl = function (Ul) {
                      return El.s(ih % 12 || 12, Ul, '0');
                    },
                    zc =
                      Ah ||
                      function (Ul, Dh, gl) {
                        var bl = Ul < 12 ? 'AM' : 'PM';
                        return gl ? bl.toLowerCase() : bl;
                      };
                  return ql.replace($i, function (Ul, Dh) {
                    return (
                      Dh ||
                      (function (gl) {
                        switch (gl) {
                          case 'YY':
                            return String(Hl.$y).slice(-2);
                          case 'YYYY':
                            return El.s(Hl.$y, 4, '0');
                          case 'M':
                            return gh + 1;
                          case 'MM':
                            return El.s(gh + 1, 2, '0');
                          case 'MMM':
                            return wl(Bl.monthsShort, gh, bh, 3);
                          case 'MMMM':
                            return wl(bh, gh);
                          case 'D':
                            return Hl.$D;
                          case 'DD':
                            return El.s(Hl.$D, 2, '0');
                          case 'd':
                            return String(Hl.$W);
                          case 'dd':
                            return wl(Bl.weekdaysMin, Hl.$W, xh, 2);
                          case 'ddd':
                            return wl(Bl.weekdaysShort, Hl.$W, xh, 3);
                          case 'dddd':
                            return xh[Hl.$W];
                          case 'H':
                            return String(ih);
                          case 'HH':
                            return El.s(ih, 2, '0');
                          case 'h':
                            return zl(1);
                          case 'hh':
                            return zl(2);
                          case 'a':
                            return zc(ih, ph, !0);
                          case 'A':
                            return zc(ih, ph, !1);
                          case 'm':
                            return String(ph);
                          case 'mm':
                            return El.s(ph, 2, '0');
                          case 's':
                            return String(Hl.$s);
                          case 'ss':
                            return El.s(Hl.$s, 2, '0');
                          case 'SSS':
                            return El.s(Hl.$ms, 3, '0');
                          case 'Z':
                            return Yl;
                        }
                        return null;
                      })(Ul) ||
                      Yl.replace(':', '')
                    );
                  });
                }),
                (Ll.utcOffset = function () {
                  return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
                }),
                (Ll.diff = function (Nl, Hl, Bl) {
                  var ql,
                    Yl = this,
                    ih = El.p(Hl),
                    ph = kl(Nl),
                    gh = (ph.utcOffset() - this.utcOffset()) * s,
                    xh = this - ph,
                    bh = function () {
                      return El.m(Yl, ph);
                    };
                  switch (ih) {
                    case se:
                      ql = bh() / 12;
                      break;
                    case L:
                      ql = bh();
                      break;
                    case V:
                      ql = bh() / 3;
                      break;
                    case I:
                      ql = (xh - gh) / 6048e5;
                      break;
                    case v:
                      ql = (xh - gh) / 864e5;
                      break;
                    case m:
                      ql = xh / o;
                      break;
                    case f:
                      ql = xh / s;
                      break;
                    case l:
                      ql = xh / n;
                      break;
                    default:
                      ql = xh;
                  }
                  return Bl ? ql : El.a(ql);
                }),
                (Ll.daysInMonth = function () {
                  return this.endOf(L).$D;
                }),
                (Ll.$locale = function () {
                  return dl[this.$L];
                }),
                (Ll.locale = function (Nl, Hl) {
                  if (!Nl) return this.$L;
                  var Bl = this.clone(),
                    ql = vl(Nl, Hl, !0);
                  return ql && (Bl.$L = ql), Bl;
                }),
                (Ll.clone = function () {
                  return El.w(this.$d, this);
                }),
                (Ll.toDate = function () {
                  return new Date(this.valueOf());
                }),
                (Ll.toJSON = function () {
                  return this.isValid() ? this.toISOString() : null;
                }),
                (Ll.toISOString = function () {
                  return this.$d.toISOString();
                }),
                (Ll.toString = function () {
                  return this.$d.toUTCString();
                }),
                Il
              );
            })(),
            Kc = Jl.prototype;
          return (
            (kl.prototype = Kc),
            [
              ['$ms', a],
              ['$s', l],
              ['$m', f],
              ['$H', m],
              ['$W', v],
              ['$M', L],
              ['$y', se],
              ['$D', Ee],
            ].forEach(function (Il) {
              Kc[Il[1]] = function (Ll) {
                return this.$g(Ll, Il[0], Il[1]);
              };
            }),
            (kl.extend = function (Il, Ll) {
              return Il.$i || (Il(Ll, Jl, kl), (Il.$i = !0)), kl;
            }),
            (kl.locale = vl),
            (kl.isDayjs = Fl),
            (kl.unix = function (Il) {
              return kl(1e3 * Il);
            }),
            (kl.en = dl[fl]),
            (kl.Ls = dl),
            (kl.p = {}),
            kl
          );
        });
      })(dayjs_min)),
    dayjs_min.exports
  );
}
var dayjs_minExports = requireDayjs_min();
const dayjs = getDefaultExportFromCjs(dayjs_minExports);
var zhCn = { exports: {} };
(function (r, e) {
  (function (n, s) {
    r.exports = s(requireDayjs_min());
  })(commonjsGlobal, function (n) {
    function s(l) {
      return l && typeof l == 'object' && 'default' in l ? l : { default: l };
    }
    var o = s(n),
      a = {
        name: 'zh-cn',
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        ordinal: function (l, f) {
          return f === 'W' ? l + '周' : l + '日';
        },
        weekStart: 1,
        yearStart: 4,
        formats: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY年M月D日',
          LLL: 'YYYY年M月D日Ah点mm分',
          LLLL: 'YYYY年M月D日ddddAh点mm分',
          l: 'YYYY/M/D',
          ll: 'YYYY年M月D日',
          lll: 'YYYY年M月D日 HH:mm',
          llll: 'YYYY年M月D日dddd HH:mm',
        },
        relativeTime: {
          future: '%s内',
          past: '%s前',
          s: '几秒',
          m: '1 分钟',
          mm: '%d 分钟',
          h: '1 小时',
          hh: '%d 小时',
          d: '1 天',
          dd: '%d 天',
          M: '1 个月',
          MM: '%d 个月',
          y: '1 年',
          yy: '%d 年',
        },
        meridiem: function (l, f) {
          var m = 100 * l + f;
          return m < 600
            ? '凌晨'
            : m < 900
            ? '早上'
            : m < 1100
            ? '上午'
            : m < 1300
            ? '中午'
            : m < 1800
            ? '下午'
            : '晚上';
        },
      };
    return o.default.locale(a, null, !0), a;
  });
})(zhCn);
var relativeTime$1 = { exports: {} };
(function (r, e) {
  (function (n, s) {
    r.exports = s();
  })(commonjsGlobal, function () {
    return function (n, s, o) {
      n = n || {};
      var a = s.prototype,
        l = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
        };
      function f(v, I, L, V) {
        return a.fromToBase(v, I, L, V);
      }
      (o.en.relativeTime = l),
        (a.fromToBase = function (v, I, L, V, se) {
          for (
            var Ee,
              ht,
              ar,
              $i = L.$locale().relativeTime || l,
              tl = n.thresholds || [
                { l: 's', r: 44, d: 'second' },
                { l: 'm', r: 89 },
                { l: 'mm', r: 44, d: 'minute' },
                { l: 'h', r: 89 },
                { l: 'hh', r: 21, d: 'hour' },
                { l: 'd', r: 35 },
                { l: 'dd', r: 25, d: 'day' },
                { l: 'M', r: 45 },
                { l: 'MM', r: 10, d: 'month' },
                { l: 'y', r: 17 },
                { l: 'yy', d: 'year' },
              ],
              Wi = tl.length,
              hl = 0;
            hl < Wi;
            hl += 1
          ) {
            var fl = tl[hl];
            fl.d && (Ee = V ? o(v).diff(L, fl.d, !0) : L.diff(v, fl.d, !0));
            var dl = (n.rounding || Math.round)(Math.abs(Ee));
            if (((ar = Ee > 0), dl <= fl.r || !fl.r)) {
              dl <= 1 && hl > 0 && (fl = tl[hl - 1]);
              var Al = $i[fl.l];
              se && (dl = se('' + dl)), (ht = typeof Al == 'string' ? Al.replace('%d', dl) : Al(dl, I, fl.l, ar));
              break;
            }
          }
          if (I) return ht;
          var Fl = ar ? $i.future : $i.past;
          return typeof Fl == 'function' ? Fl(ht) : Fl.replace('%s', ht);
        }),
        (a.to = function (v, I) {
          return f(v, I, this, !0);
        }),
        (a.from = function (v, I) {
          return f(v, I, this);
        });
      var m = function (v) {
        return v.$u ? o.utc() : o();
      };
      (a.toNow = function (v) {
        return this.to(m(this), v);
      }),
        (a.fromNow = function (v) {
          return this.from(m(this), v);
        });
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = getDefaultExportFromCjs(relativeTimeExports);
function makeMap(r, e) {
  const n = Object.create(null),
    s = r.split(',');
  for (let o = 0; o < s.length; o++) n[s[o]] = !0;
  return e ? (o) => !!n[o.toLowerCase()] : (o) => !!n[o];
}
const EMPTY_OBJ = {},
  EMPTY_ARR = [],
  NOOP = () => {},
  NO = () => !1,
  onRE = /^on[^a-z]/,
  isOn = (r) => onRE.test(r),
  isModelListener = (r) => r.startsWith('onUpdate:'),
  extend$1 = Object.assign,
  remove$1 = (r, e) => {
    const n = r.indexOf(e);
    n > -1 && r.splice(n, 1);
  },
  hasOwnProperty$1 = Object.prototype.hasOwnProperty,
  hasOwn = (r, e) => hasOwnProperty$1.call(r, e),
  isArray$1 = Array.isArray,
  isMap = (r) => toTypeString(r) === '[object Map]',
  isSet = (r) => toTypeString(r) === '[object Set]',
  isFunction$1 = (r) => typeof r == 'function',
  isString = (r) => typeof r == 'string',
  isSymbol = (r) => typeof r == 'symbol',
  isObject$2 = (r) => r !== null && typeof r == 'object',
  isPromise = (r) => isObject$2(r) && isFunction$1(r.then) && isFunction$1(r.catch),
  objectToString = Object.prototype.toString,
  toTypeString = (r) => objectToString.call(r),
  toRawType = (r) => toTypeString(r).slice(8, -1),
  isPlainObject$1 = (r) => toTypeString(r) === '[object Object]',
  isIntegerKey = (r) => isString(r) && r !== 'NaN' && r[0] !== '-' && '' + parseInt(r, 10) === r,
  isReservedProp = makeMap(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted',
  ),
  cacheStringFunction = (r) => {
    const e = Object.create(null);
    return (n) => e[n] || (e[n] = r(n));
  },
  camelizeRE = /-(\w)/g,
  camelize = cacheStringFunction((r) => r.replace(camelizeRE, (e, n) => (n ? n.toUpperCase() : ''))),
  hyphenateRE = /\B([A-Z])/g,
  hyphenate = cacheStringFunction((r) => r.replace(hyphenateRE, '-$1').toLowerCase()),
  capitalize = cacheStringFunction((r) => r.charAt(0).toUpperCase() + r.slice(1)),
  toHandlerKey = cacheStringFunction((r) => (r ? `on${capitalize(r)}` : '')),
  hasChanged = (r, e) => !Object.is(r, e),
  invokeArrayFns = (r, e) => {
    for (let n = 0; n < r.length; n++) r[n](e);
  },
  def = (r, e, n) => {
    Object.defineProperty(r, e, { configurable: !0, enumerable: !1, value: n });
  },
  looseToNumber = (r) => {
    const e = parseFloat(r);
    return isNaN(e) ? r : e;
  },
  toNumber = (r) => {
    const e = isString(r) ? Number(r) : NaN;
    return isNaN(e) ? r : e;
  };
let _globalThis;
const getGlobalThis = () =>
  _globalThis ||
  (_globalThis =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
      ? self
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : {});
function normalizeStyle(r) {
  if (isArray$1(r)) {
    const e = {};
    for (let n = 0; n < r.length; n++) {
      const s = r[n],
        o = isString(s) ? parseStringStyle(s) : normalizeStyle(s);
      if (o) for (const a in o) e[a] = o[a];
    }
    return e;
  } else {
    if (isString(r)) return r;
    if (isObject$2(r)) return r;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g,
  propertyDelimiterRE = /:([^]+)/,
  styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(r) {
  const e = {};
  return (
    r
      .replace(styleCommentRE, '')
      .split(listDelimiterRE)
      .forEach((n) => {
        if (n) {
          const s = n.split(propertyDelimiterRE);
          s.length > 1 && (e[s[0].trim()] = s[1].trim());
        }
      }),
    e
  );
}
function normalizeClass(r) {
  let e = '';
  if (isString(r)) e = r;
  else if (isArray$1(r))
    for (let n = 0; n < r.length; n++) {
      const s = normalizeClass(r[n]);
      s && (e += s + ' ');
    }
  else if (isObject$2(r)) for (const n in r) r[n] && (e += n + ' ');
  return e.trim();
}
const specialBooleanAttrs = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
function includeBooleanAttr(r) {
  return !!r || r === '';
}
const toDisplayString = (r) =>
    isString(r)
      ? r
      : r == null
      ? ''
      : isArray$1(r) || (isObject$2(r) && (r.toString === objectToString || !isFunction$1(r.toString)))
      ? JSON.stringify(r, replacer, 2)
      : String(r),
  replacer = (r, e) =>
    e && e.__v_isRef
      ? replacer(r, e.value)
      : isMap(e)
      ? { [`Map(${e.size})`]: [...e.entries()].reduce((n, [s, o]) => ((n[`${s} =>`] = o), n), {}) }
      : isSet(e)
      ? { [`Set(${e.size})`]: [...e.values()] }
      : isObject$2(e) && !isArray$1(e) && !isPlainObject$1(e)
      ? String(e)
      : e;
let activeEffectScope;
class EffectScope {
  constructor(e = !1) {
    (this.detached = e),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this.parent = activeEffectScope),
      !e &&
        activeEffectScope &&
        (this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const n = activeEffectScope;
      try {
        return (activeEffectScope = this), e();
      } finally {
        activeEffectScope = n;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(e) {
    if (this._active) {
      let n, s;
      for (n = 0, s = this.effects.length; n < s; n++) this.effects[n].stop();
      for (n = 0, s = this.cleanups.length; n < s; n++) this.cleanups[n]();
      if (this.scopes) for (n = 0, s = this.scopes.length; n < s; n++) this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !e) {
        const o = this.parent.scopes.pop();
        o && o !== this && ((this.parent.scopes[this.index] = o), (o.index = this.index));
      }
      (this.parent = void 0), (this._active = !1);
    }
  }
}
function effectScope(r) {
  return new EffectScope(r);
}
function recordEffectScope(r, e = activeEffectScope) {
  e && e.active && e.effects.push(r);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(r) {
  activeEffectScope && activeEffectScope.cleanups.push(r);
}
const createDep = (r) => {
    const e = new Set(r);
    return (e.w = 0), (e.n = 0), e;
  },
  wasTracked = (r) => (r.w & trackOpBit) > 0,
  newTracked = (r) => (r.n & trackOpBit) > 0,
  initDepMarkers = ({ deps: r }) => {
    if (r.length) for (let e = 0; e < r.length; e++) r[e].w |= trackOpBit;
  },
  finalizeDepMarkers = (r) => {
    const { deps: e } = r;
    if (e.length) {
      let n = 0;
      for (let s = 0; s < e.length; s++) {
        const o = e[s];
        wasTracked(o) && !newTracked(o) ? o.delete(r) : (e[n++] = o), (o.w &= ~trackOpBit), (o.n &= ~trackOpBit);
      }
      e.length = n;
    }
  },
  targetMap = new WeakMap();
let effectTrackDepth = 0,
  trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(''),
  MAP_KEY_ITERATE_KEY = Symbol('');
class ReactiveEffect {
  constructor(e, n = null, s) {
    (this.fn = e),
      (this.scheduler = n),
      (this.active = !0),
      (this.deps = []),
      (this.parent = void 0),
      recordEffectScope(this, s);
  }
  run() {
    if (!this.active) return this.fn();
    let e = activeEffect,
      n = shouldTrack;
    for (; e; ) {
      if (e === this) return;
      e = e.parent;
    }
    try {
      return (
        (this.parent = activeEffect),
        (activeEffect = this),
        (shouldTrack = !0),
        (trackOpBit = 1 << ++effectTrackDepth),
        effectTrackDepth <= maxMarkerBits ? initDepMarkers(this) : cleanupEffect(this),
        this.fn()
      );
    } finally {
      effectTrackDepth <= maxMarkerBits && finalizeDepMarkers(this),
        (trackOpBit = 1 << --effectTrackDepth),
        (activeEffect = this.parent),
        (shouldTrack = n),
        (this.parent = void 0),
        this.deferStop && this.stop();
    }
  }
  stop() {
    activeEffect === this
      ? (this.deferStop = !0)
      : this.active && (cleanupEffect(this), this.onStop && this.onStop(), (this.active = !1));
  }
}
function cleanupEffect(r) {
  const { deps: e } = r;
  if (e.length) {
    for (let n = 0; n < e.length; n++) e[n].delete(r);
    e.length = 0;
  }
}
let shouldTrack = !0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack), (shouldTrack = !1);
}
function resetTracking() {
  const r = trackStack.pop();
  shouldTrack = r === void 0 ? !0 : r;
}
function track(r, e, n) {
  if (shouldTrack && activeEffect) {
    let s = targetMap.get(r);
    s || targetMap.set(r, (s = new Map()));
    let o = s.get(n);
    o || s.set(n, (o = createDep())), trackEffects(o);
  }
}
function trackEffects(r, e) {
  let n = !1;
  effectTrackDepth <= maxMarkerBits
    ? newTracked(r) || ((r.n |= trackOpBit), (n = !wasTracked(r)))
    : (n = !r.has(activeEffect)),
    n && (r.add(activeEffect), activeEffect.deps.push(r));
}
function trigger(r, e, n, s, o, a) {
  const l = targetMap.get(r);
  if (!l) return;
  let f = [];
  if (e === 'clear') f = [...l.values()];
  else if (n === 'length' && isArray$1(r)) {
    const m = Number(s);
    l.forEach((v, I) => {
      (I === 'length' || I >= m) && f.push(v);
    });
  } else
    switch ((n !== void 0 && f.push(l.get(n)), e)) {
      case 'add':
        isArray$1(r)
          ? isIntegerKey(n) && f.push(l.get('length'))
          : (f.push(l.get(ITERATE_KEY)), isMap(r) && f.push(l.get(MAP_KEY_ITERATE_KEY)));
        break;
      case 'delete':
        isArray$1(r) || (f.push(l.get(ITERATE_KEY)), isMap(r) && f.push(l.get(MAP_KEY_ITERATE_KEY)));
        break;
      case 'set':
        isMap(r) && f.push(l.get(ITERATE_KEY));
        break;
    }
  if (f.length === 1) f[0] && triggerEffects(f[0]);
  else {
    const m = [];
    for (const v of f) v && m.push(...v);
    triggerEffects(createDep(m));
  }
}
function triggerEffects(r, e) {
  const n = isArray$1(r) ? r : [...r];
  for (const s of n) s.computed && triggerEffect(s);
  for (const s of n) s.computed || triggerEffect(s);
}
function triggerEffect(r, e) {
  (r !== activeEffect || r.allowRecurse) && (r.scheduler ? r.scheduler() : r.run());
}
function getDepFromReactive(r, e) {
  var n;
  return (n = targetMap.get(r)) == null ? void 0 : n.get(e);
}
const isNonTrackableKeys = makeMap('__proto__,__v_isRef,__isVue'),
  builtInSymbols = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((r) => r !== 'arguments' && r !== 'caller')
      .map((r) => Symbol[r])
      .filter(isSymbol),
  ),
  get$1 = createGetter(),
  shallowGet = createGetter(!1, !0),
  readonlyGet = createGetter(!0),
  arrayInstrumentations = createArrayInstrumentations();
function createArrayInstrumentations() {
  const r = {};
  return (
    ['includes', 'indexOf', 'lastIndexOf'].forEach((e) => {
      r[e] = function (...n) {
        const s = toRaw(this);
        for (let a = 0, l = this.length; a < l; a++) track(s, 'get', a + '');
        const o = s[e](...n);
        return o === -1 || o === !1 ? s[e](...n.map(toRaw)) : o;
      };
    }),
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => {
      r[e] = function (...n) {
        pauseTracking();
        const s = toRaw(this)[e].apply(this, n);
        return resetTracking(), s;
      };
    }),
    r
  );
}
function hasOwnProperty(r) {
  const e = toRaw(this);
  return track(e, 'has', r), e.hasOwnProperty(r);
}
function createGetter(r = !1, e = !1) {
  return function (s, o, a) {
    if (o === '__v_isReactive') return !r;
    if (o === '__v_isReadonly') return r;
    if (o === '__v_isShallow') return e;
    if (
      o === '__v_raw' &&
      a === (r ? (e ? shallowReadonlyMap : readonlyMap) : e ? shallowReactiveMap : reactiveMap).get(s)
    )
      return s;
    const l = isArray$1(s);
    if (!r) {
      if (l && hasOwn(arrayInstrumentations, o)) return Reflect.get(arrayInstrumentations, o, a);
      if (o === 'hasOwnProperty') return hasOwnProperty;
    }
    const f = Reflect.get(s, o, a);
    return (isSymbol(o) ? builtInSymbols.has(o) : isNonTrackableKeys(o)) || (r || track(s, 'get', o), e)
      ? f
      : isRef(f)
      ? l && isIntegerKey(o)
        ? f
        : f.value
      : isObject$2(f)
      ? r
        ? readonly(f)
        : reactive(f)
      : f;
  };
}
const set$1 = createSetter(),
  shallowSet = createSetter(!0);
function createSetter(r = !1) {
  return function (n, s, o, a) {
    let l = n[s];
    if (isReadonly(l) && isRef(l) && !isRef(o)) return !1;
    if (
      !r &&
      (!isShallow(o) && !isReadonly(o) && ((l = toRaw(l)), (o = toRaw(o))), !isArray$1(n) && isRef(l) && !isRef(o))
    )
      return (l.value = o), !0;
    const f = isArray$1(n) && isIntegerKey(s) ? Number(s) < n.length : hasOwn(n, s),
      m = Reflect.set(n, s, o, a);
    return n === toRaw(a) && (f ? hasChanged(o, l) && trigger(n, 'set', s, o) : trigger(n, 'add', s, o)), m;
  };
}
function deleteProperty(r, e) {
  const n = hasOwn(r, e);
  r[e];
  const s = Reflect.deleteProperty(r, e);
  return s && n && trigger(r, 'delete', e, void 0), s;
}
function has$1(r, e) {
  const n = Reflect.has(r, e);
  return (!isSymbol(e) || !builtInSymbols.has(e)) && track(r, 'has', e), n;
}
function ownKeys(r) {
  return track(r, 'iterate', isArray$1(r) ? 'length' : ITERATE_KEY), Reflect.ownKeys(r);
}
const mutableHandlers = { get: get$1, set: set$1, deleteProperty, has: has$1, ownKeys },
  readonlyHandlers = {
    get: readonlyGet,
    set(r, e) {
      return !0;
    },
    deleteProperty(r, e) {
      return !0;
    },
  },
  shallowReactiveHandlers = extend$1({}, mutableHandlers, { get: shallowGet, set: shallowSet }),
  toShallow = (r) => r,
  getProto = (r) => Reflect.getPrototypeOf(r);
function get(r, e, n = !1, s = !1) {
  r = r.__v_raw;
  const o = toRaw(r),
    a = toRaw(e);
  n || (e !== a && track(o, 'get', e), track(o, 'get', a));
  const { has: l } = getProto(o),
    f = s ? toShallow : n ? toReadonly : toReactive;
  if (l.call(o, e)) return f(r.get(e));
  if (l.call(o, a)) return f(r.get(a));
  r !== o && r.get(e);
}
function has(r, e = !1) {
  const n = this.__v_raw,
    s = toRaw(n),
    o = toRaw(r);
  return e || (r !== o && track(s, 'has', r), track(s, 'has', o)), r === o ? n.has(r) : n.has(r) || n.has(o);
}
function size(r, e = !1) {
  return (r = r.__v_raw), !e && track(toRaw(r), 'iterate', ITERATE_KEY), Reflect.get(r, 'size', r);
}
function add$1(r) {
  r = toRaw(r);
  const e = toRaw(this);
  return getProto(e).has.call(e, r) || (e.add(r), trigger(e, 'add', r, r)), this;
}
function set(r, e) {
  e = toRaw(e);
  const n = toRaw(this),
    { has: s, get: o } = getProto(n);
  let a = s.call(n, r);
  a || ((r = toRaw(r)), (a = s.call(n, r)));
  const l = o.call(n, r);
  return n.set(r, e), a ? hasChanged(e, l) && trigger(n, 'set', r, e) : trigger(n, 'add', r, e), this;
}
function deleteEntry(r) {
  const e = toRaw(this),
    { has: n, get: s } = getProto(e);
  let o = n.call(e, r);
  o || ((r = toRaw(r)), (o = n.call(e, r))), s && s.call(e, r);
  const a = e.delete(r);
  return o && trigger(e, 'delete', r, void 0), a;
}
function clear() {
  const r = toRaw(this),
    e = r.size !== 0,
    n = r.clear();
  return e && trigger(r, 'clear', void 0, void 0), n;
}
function createForEach(r, e) {
  return function (s, o) {
    const a = this,
      l = a.__v_raw,
      f = toRaw(l),
      m = e ? toShallow : r ? toReadonly : toReactive;
    return !r && track(f, 'iterate', ITERATE_KEY), l.forEach((v, I) => s.call(o, m(v), m(I), a));
  };
}
function createIterableMethod(r, e, n) {
  return function (...s) {
    const o = this.__v_raw,
      a = toRaw(o),
      l = isMap(a),
      f = r === 'entries' || (r === Symbol.iterator && l),
      m = r === 'keys' && l,
      v = o[r](...s),
      I = n ? toShallow : e ? toReadonly : toReactive;
    return (
      !e && track(a, 'iterate', m ? MAP_KEY_ITERATE_KEY : ITERATE_KEY),
      {
        next() {
          const { value: L, done: V } = v.next();
          return V ? { value: L, done: V } : { value: f ? [I(L[0]), I(L[1])] : I(L), done: V };
        },
        [Symbol.iterator]() {
          return this;
        },
      }
    );
  };
}
function createReadonlyMethod(r) {
  return function (...e) {
    return r === 'delete' ? !1 : this;
  };
}
function createInstrumentations() {
  const r = {
      get(a) {
        return get(this, a);
      },
      get size() {
        return size(this);
      },
      has,
      add: add$1,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(!1, !1),
    },
    e = {
      get(a) {
        return get(this, a, !1, !0);
      },
      get size() {
        return size(this);
      },
      has,
      add: add$1,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(!1, !0),
    },
    n = {
      get(a) {
        return get(this, a, !0);
      },
      get size() {
        return size(this, !0);
      },
      has(a) {
        return has.call(this, a, !0);
      },
      add: createReadonlyMethod('add'),
      set: createReadonlyMethod('set'),
      delete: createReadonlyMethod('delete'),
      clear: createReadonlyMethod('clear'),
      forEach: createForEach(!0, !1),
    },
    s = {
      get(a) {
        return get(this, a, !0, !0);
      },
      get size() {
        return size(this, !0);
      },
      has(a) {
        return has.call(this, a, !0);
      },
      add: createReadonlyMethod('add'),
      set: createReadonlyMethod('set'),
      delete: createReadonlyMethod('delete'),
      clear: createReadonlyMethod('clear'),
      forEach: createForEach(!0, !0),
    };
  return (
    ['keys', 'values', 'entries', Symbol.iterator].forEach((a) => {
      (r[a] = createIterableMethod(a, !1, !1)),
        (n[a] = createIterableMethod(a, !0, !1)),
        (e[a] = createIterableMethod(a, !1, !0)),
        (s[a] = createIterableMethod(a, !0, !0));
    }),
    [r, n, e, s]
  );
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] =
  createInstrumentations();
function createInstrumentationGetter(r, e) {
  const n = e
    ? r
      ? shallowReadonlyInstrumentations
      : shallowInstrumentations
    : r
    ? readonlyInstrumentations
    : mutableInstrumentations;
  return (s, o, a) =>
    o === '__v_isReactive'
      ? !r
      : o === '__v_isReadonly'
      ? r
      : o === '__v_raw'
      ? s
      : Reflect.get(hasOwn(n, o) && o in s ? n : s, o, a);
}
const mutableCollectionHandlers = { get: createInstrumentationGetter(!1, !1) },
  shallowCollectionHandlers = { get: createInstrumentationGetter(!1, !0) },
  readonlyCollectionHandlers = { get: createInstrumentationGetter(!0, !1) },
  reactiveMap = new WeakMap(),
  shallowReactiveMap = new WeakMap(),
  readonlyMap = new WeakMap(),
  shallowReadonlyMap = new WeakMap();
function targetTypeMap(r) {
  switch (r) {
    case 'Object':
    case 'Array':
      return 1;
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2;
    default:
      return 0;
  }
}
function getTargetType(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : targetTypeMap(toRawType(r));
}
function reactive(r) {
  return isReadonly(r) ? r : createReactiveObject(r, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(r) {
  return createReactiveObject(r, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(r) {
  return createReactiveObject(r, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(r, e, n, s, o) {
  if (!isObject$2(r) || (r.__v_raw && !(e && r.__v_isReactive))) return r;
  const a = o.get(r);
  if (a) return a;
  const l = getTargetType(r);
  if (l === 0) return r;
  const f = new Proxy(r, l === 2 ? s : n);
  return o.set(r, f), f;
}
function isReactive(r) {
  return isReadonly(r) ? isReactive(r.__v_raw) : !!(r && r.__v_isReactive);
}
function isReadonly(r) {
  return !!(r && r.__v_isReadonly);
}
function isShallow(r) {
  return !!(r && r.__v_isShallow);
}
function isProxy(r) {
  return isReactive(r) || isReadonly(r);
}
function toRaw(r) {
  const e = r && r.__v_raw;
  return e ? toRaw(e) : r;
}
function markRaw(r) {
  return def(r, '__v_skip', !0), r;
}
const toReactive = (r) => (isObject$2(r) ? reactive(r) : r),
  toReadonly = (r) => (isObject$2(r) ? readonly(r) : r);
function trackRefValue(r) {
  shouldTrack && activeEffect && ((r = toRaw(r)), trackEffects(r.dep || (r.dep = createDep())));
}
function triggerRefValue(r, e) {
  r = toRaw(r);
  const n = r.dep;
  n && triggerEffects(n);
}
function isRef(r) {
  return !!(r && r.__v_isRef === !0);
}
function ref(r) {
  return createRef(r, !1);
}
function shallowRef(r) {
  return createRef(r, !0);
}
function createRef(r, e) {
  return isRef(r) ? r : new RefImpl(r, e);
}
class RefImpl {
  constructor(e, n) {
    (this.__v_isShallow = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._rawValue = n ? e : toRaw(e)),
      (this._value = n ? e : toReactive(e));
  }
  get value() {
    return trackRefValue(this), this._value;
  }
  set value(e) {
    const n = this.__v_isShallow || isShallow(e) || isReadonly(e);
    (e = n ? e : toRaw(e)),
      hasChanged(e, this._rawValue) &&
        ((this._rawValue = e), (this._value = n ? e : toReactive(e)), triggerRefValue(this));
  }
}
function unref(r) {
  return isRef(r) ? r.value : r;
}
const shallowUnwrapHandlers = {
  get: (r, e, n) => unref(Reflect.get(r, e, n)),
  set: (r, e, n, s) => {
    const o = r[e];
    return isRef(o) && !isRef(n) ? ((o.value = n), !0) : Reflect.set(r, e, n, s);
  },
};
function proxyRefs(r) {
  return isReactive(r) ? r : new Proxy(r, shallowUnwrapHandlers);
}
function toRefs(r) {
  const e = isArray$1(r) ? new Array(r.length) : {};
  for (const n in r) e[n] = propertyToRef(r, n);
  return e;
}
class ObjectRefImpl {
  constructor(e, n, s) {
    (this._object = e), (this._key = n), (this._defaultValue = s), (this.__v_isRef = !0);
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(e) {
    (this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0);
  }
  get value() {
    return this._getter();
  }
}
function toRef(r, e, n) {
  return isRef(r)
    ? r
    : isFunction$1(r)
    ? new GetterRefImpl(r)
    : isObject$2(r) && arguments.length > 1
    ? propertyToRef(r, e, n)
    : ref(r);
}
function propertyToRef(r, e, n) {
  const s = r[e];
  return isRef(s) ? s : new ObjectRefImpl(r, e, n);
}
class ComputedRefImpl {
  constructor(e, n, s, o) {
    (this._setter = n),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this.__v_isReadonly = !1),
      (this._dirty = !0),
      (this.effect = new ReactiveEffect(e, () => {
        this._dirty || ((this._dirty = !0), triggerRefValue(this));
      })),
      (this.effect.computed = this),
      (this.effect.active = this._cacheable = !o),
      (this.__v_isReadonly = s);
  }
  get value() {
    const e = toRaw(this);
    return trackRefValue(e), (e._dirty || !e._cacheable) && ((e._dirty = !1), (e._value = e.effect.run())), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
function computed$1(r, e, n = !1) {
  let s, o;
  const a = isFunction$1(r);
  return a ? ((s = r), (o = NOOP)) : ((s = r.get), (o = r.set)), new ComputedRefImpl(s, o, a || !o, n);
}
function warn(r, ...e) {}
function callWithErrorHandling(r, e, n, s) {
  let o;
  try {
    o = s ? r(...s) : r();
  } catch (a) {
    handleError$1(a, e, n);
  }
  return o;
}
function callWithAsyncErrorHandling(r, e, n, s) {
  if (isFunction$1(r)) {
    const a = callWithErrorHandling(r, e, n, s);
    return (
      a &&
        isPromise(a) &&
        a.catch((l) => {
          handleError$1(l, e, n);
        }),
      a
    );
  }
  const o = [];
  for (let a = 0; a < r.length; a++) o.push(callWithAsyncErrorHandling(r[a], e, n, s));
  return o;
}
function handleError$1(r, e, n, s = !0) {
  const o = e ? e.vnode : null;
  if (e) {
    let a = e.parent;
    const l = e.proxy,
      f = n;
    for (; a; ) {
      const v = a.ec;
      if (v) {
        for (let I = 0; I < v.length; I++) if (v[I](r, l, f) === !1) return;
      }
      a = a.parent;
    }
    const m = e.appContext.config.errorHandler;
    if (m) {
      callWithErrorHandling(m, null, 10, [r, l, f]);
      return;
    }
  }
  logError(r, n, o, s);
}
function logError(r, e, n, s = !0) {
  console.error(r);
}
let isFlushing = !1,
  isFlushPending = !1;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null,
  postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
function nextTick(r) {
  const e = currentFlushPromise || resolvedPromise;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function findInsertionIndex(r) {
  let e = flushIndex + 1,
    n = queue.length;
  for (; e < n; ) {
    const s = (e + n) >>> 1;
    getId(queue[s]) < r ? (e = s + 1) : (n = s);
  }
  return e;
}
function queueJob(r) {
  (!queue.length || !queue.includes(r, isFlushing && r.allowRecurse ? flushIndex + 1 : flushIndex)) &&
    (r.id == null ? queue.push(r) : queue.splice(findInsertionIndex(r.id), 0, r), queueFlush());
}
function queueFlush() {
  !isFlushing && !isFlushPending && ((isFlushPending = !0), (currentFlushPromise = resolvedPromise.then(flushJobs)));
}
function invalidateJob(r) {
  const e = queue.indexOf(r);
  e > flushIndex && queue.splice(e, 1);
}
function queuePostFlushCb(r) {
  isArray$1(r)
    ? pendingPostFlushCbs.push(...r)
    : (!activePostFlushCbs || !activePostFlushCbs.includes(r, r.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) &&
      pendingPostFlushCbs.push(r),
    queueFlush();
}
function flushPreFlushCbs(r, e = isFlushing ? flushIndex + 1 : 0) {
  for (; e < queue.length; e++) {
    const n = queue[e];
    n && n.pre && (queue.splice(e, 1), e--, n());
  }
}
function flushPostFlushCbs(r) {
  if (pendingPostFlushCbs.length) {
    const e = [...new Set(pendingPostFlushCbs)];
    if (((pendingPostFlushCbs.length = 0), activePostFlushCbs)) {
      activePostFlushCbs.push(...e);
      return;
    }
    for (
      activePostFlushCbs = e, activePostFlushCbs.sort((n, s) => getId(n) - getId(s)), postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    )
      activePostFlushCbs[postFlushIndex]();
    (activePostFlushCbs = null), (postFlushIndex = 0);
  }
}
const getId = (r) => (r.id == null ? 1 / 0 : r.id),
  comparator = (r, e) => {
    const n = getId(r) - getId(e);
    if (n === 0) {
      if (r.pre && !e.pre) return -1;
      if (e.pre && !r.pre) return 1;
    }
    return n;
  };
function flushJobs(r) {
  (isFlushPending = !1), (isFlushing = !0), queue.sort(comparator);
  const e = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const n = queue[flushIndex];
      n && n.active !== !1 && callWithErrorHandling(n, null, 14);
    }
  } finally {
    (flushIndex = 0),
      (queue.length = 0),
      flushPostFlushCbs(),
      (isFlushing = !1),
      (currentFlushPromise = null),
      (queue.length || pendingPostFlushCbs.length) && flushJobs();
  }
}
function emit(r, e, ...n) {
  if (r.isUnmounted) return;
  const s = r.vnode.props || EMPTY_OBJ;
  let o = n;
  const a = e.startsWith('update:'),
    l = a && e.slice(7);
  if (l && l in s) {
    const I = `${l === 'modelValue' ? 'model' : l}Modifiers`,
      { number: L, trim: V } = s[I] || EMPTY_OBJ;
    V && (o = n.map((se) => (isString(se) ? se.trim() : se))), L && (o = n.map(looseToNumber));
  }
  let f,
    m = s[(f = toHandlerKey(e))] || s[(f = toHandlerKey(camelize(e)))];
  !m && a && (m = s[(f = toHandlerKey(hyphenate(e)))]), m && callWithAsyncErrorHandling(m, r, 6, o);
  const v = s[f + 'Once'];
  if (v) {
    if (!r.emitted) r.emitted = {};
    else if (r.emitted[f]) return;
    (r.emitted[f] = !0), callWithAsyncErrorHandling(v, r, 6, o);
  }
}
function normalizeEmitsOptions(r, e, n = !1) {
  const s = e.emitsCache,
    o = s.get(r);
  if (o !== void 0) return o;
  const a = r.emits;
  let l = {},
    f = !1;
  if (!isFunction$1(r)) {
    const m = (v) => {
      const I = normalizeEmitsOptions(v, e, !0);
      I && ((f = !0), extend$1(l, I));
    };
    !n && e.mixins.length && e.mixins.forEach(m), r.extends && m(r.extends), r.mixins && r.mixins.forEach(m);
  }
  return !a && !f
    ? (isObject$2(r) && s.set(r, null), null)
    : (isArray$1(a) ? a.forEach((m) => (l[m] = null)) : extend$1(l, a), isObject$2(r) && s.set(r, l), l);
}
function isEmitListener(r, e) {
  return !r || !isOn(e)
    ? !1
    : ((e = e.slice(2).replace(/Once$/, '')),
      hasOwn(r, e[0].toLowerCase() + e.slice(1)) || hasOwn(r, hyphenate(e)) || hasOwn(r, e));
}
let currentRenderingInstance = null,
  currentScopeId = null;
function setCurrentRenderingInstance(r) {
  const e = currentRenderingInstance;
  return (currentRenderingInstance = r), (currentScopeId = (r && r.type.__scopeId) || null), e;
}
function pushScopeId(r) {
  currentScopeId = r;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(r, e = currentRenderingInstance, n) {
  if (!e || r._n) return r;
  const s = (...o) => {
    s._d && setBlockTracking(-1);
    const a = setCurrentRenderingInstance(e);
    let l;
    try {
      l = r(...o);
    } finally {
      setCurrentRenderingInstance(a), s._d && setBlockTracking(1);
    }
    return l;
  };
  return (s._n = !0), (s._c = !0), (s._d = !0), s;
}
function markAttrsAccessed() {}
function renderComponentRoot(r) {
  const {
    type: e,
    vnode: n,
    proxy: s,
    withProxy: o,
    props: a,
    propsOptions: [l],
    slots: f,
    attrs: m,
    emit: v,
    render: I,
    renderCache: L,
    data: V,
    setupState: se,
    ctx: Ee,
    inheritAttrs: ht,
  } = r;
  let ar, $i;
  const tl = setCurrentRenderingInstance(r);
  try {
    if (n.shapeFlag & 4) {
      const hl = o || s;
      (ar = normalizeVNode(I.call(hl, hl, L, a, se, V, Ee))), ($i = m);
    } else {
      const hl = e;
      (ar = normalizeVNode(hl.length > 1 ? hl(a, { attrs: m, slots: f, emit: v }) : hl(a, null))),
        ($i = e.props ? m : getFunctionalFallthrough(m));
    }
  } catch (hl) {
    (blockStack.length = 0), handleError$1(hl, r, 1), (ar = createVNode(Comment));
  }
  let Wi = ar;
  if ($i && ht !== !1) {
    const hl = Object.keys($i),
      { shapeFlag: fl } = Wi;
    hl.length &&
      fl & 7 &&
      (l && hl.some(isModelListener) && ($i = filterModelListeners($i, l)), (Wi = cloneVNode(Wi, $i)));
  }
  return (
    n.dirs && ((Wi = cloneVNode(Wi)), (Wi.dirs = Wi.dirs ? Wi.dirs.concat(n.dirs) : n.dirs)),
    n.transition && (Wi.transition = n.transition),
    (ar = Wi),
    setCurrentRenderingInstance(tl),
    ar
  );
}
const getFunctionalFallthrough = (r) => {
    let e;
    for (const n in r) (n === 'class' || n === 'style' || isOn(n)) && ((e || (e = {}))[n] = r[n]);
    return e;
  },
  filterModelListeners = (r, e) => {
    const n = {};
    for (const s in r) (!isModelListener(s) || !(s.slice(9) in e)) && (n[s] = r[s]);
    return n;
  };
function shouldUpdateComponent(r, e, n) {
  const { props: s, children: o, component: a } = r,
    { props: l, children: f, patchFlag: m } = e,
    v = a.emitsOptions;
  if (e.dirs || e.transition) return !0;
  if (n && m >= 0) {
    if (m & 1024) return !0;
    if (m & 16) return s ? hasPropsChanged(s, l, v) : !!l;
    if (m & 8) {
      const I = e.dynamicProps;
      for (let L = 0; L < I.length; L++) {
        const V = I[L];
        if (l[V] !== s[V] && !isEmitListener(v, V)) return !0;
      }
    }
  } else return (o || f) && (!f || !f.$stable) ? !0 : s === l ? !1 : s ? (l ? hasPropsChanged(s, l, v) : !0) : !!l;
  return !1;
}
function hasPropsChanged(r, e, n) {
  const s = Object.keys(e);
  if (s.length !== Object.keys(r).length) return !0;
  for (let o = 0; o < s.length; o++) {
    const a = s[o];
    if (e[a] !== r[a] && !isEmitListener(n, a)) return !0;
  }
  return !1;
}
function updateHOCHostEl({ vnode: r, parent: e }, n) {
  for (; e && e.subTree === r; ) ((r = e.vnode).el = n), (e = e.parent);
}
const isSuspense = (r) => r.__isSuspense;
function queueEffectWithSuspense(r, e) {
  e && e.pendingBranch ? (isArray$1(r) ? e.effects.push(...r) : e.effects.push(r)) : queuePostFlushCb(r);
}
function watchEffect(r, e) {
  return doWatch(r, null, e);
}
const INITIAL_WATCHER_VALUE = {};
function watch(r, e, n) {
  return doWatch(r, e, n);
}
function doWatch(r, e, { immediate: n, deep: s, flush: o, onTrack: a, onTrigger: l } = EMPTY_OBJ) {
  var f;
  const m = getCurrentScope() === ((f = currentInstance) == null ? void 0 : f.scope) ? currentInstance : null;
  let v,
    I = !1,
    L = !1;
  if (
    (isRef(r)
      ? ((v = () => r.value), (I = isShallow(r)))
      : isReactive(r)
      ? ((v = () => r), (s = !0))
      : isArray$1(r)
      ? ((L = !0),
        (I = r.some((hl) => isReactive(hl) || isShallow(hl))),
        (v = () =>
          r.map((hl) => {
            if (isRef(hl)) return hl.value;
            if (isReactive(hl)) return traverse(hl);
            if (isFunction$1(hl)) return callWithErrorHandling(hl, m, 2);
          })))
      : isFunction$1(r)
      ? e
        ? (v = () => callWithErrorHandling(r, m, 2))
        : (v = () => {
            if (!(m && m.isUnmounted)) return V && V(), callWithAsyncErrorHandling(r, m, 3, [se]);
          })
      : (v = NOOP),
    e && s)
  ) {
    const hl = v;
    v = () => traverse(hl());
  }
  let V,
    se = (hl) => {
      V = tl.onStop = () => {
        callWithErrorHandling(hl, m, 4);
      };
    },
    Ee;
  if (isInSSRComponentSetup)
    if (((se = NOOP), e ? n && callWithAsyncErrorHandling(e, m, 3, [v(), L ? [] : void 0, se]) : v(), o === 'sync')) {
      const hl = useSSRContext();
      Ee = hl.__watcherHandles || (hl.__watcherHandles = []);
    } else return NOOP;
  let ht = L ? new Array(r.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const ar = () => {
    if (tl.active)
      if (e) {
        const hl = tl.run();
        (s || I || (L ? hl.some((fl, dl) => hasChanged(fl, ht[dl])) : hasChanged(hl, ht))) &&
          (V && V(),
          callWithAsyncErrorHandling(e, m, 3, [
            hl,
            ht === INITIAL_WATCHER_VALUE ? void 0 : L && ht[0] === INITIAL_WATCHER_VALUE ? [] : ht,
            se,
          ]),
          (ht = hl));
      } else tl.run();
  };
  ar.allowRecurse = !!e;
  let $i;
  o === 'sync'
    ? ($i = ar)
    : o === 'post'
    ? ($i = () => queuePostRenderEffect(ar, m && m.suspense))
    : ((ar.pre = !0), m && (ar.id = m.uid), ($i = () => queueJob(ar)));
  const tl = new ReactiveEffect(v, $i);
  e ? (n ? ar() : (ht = tl.run())) : o === 'post' ? queuePostRenderEffect(tl.run.bind(tl), m && m.suspense) : tl.run();
  const Wi = () => {
    tl.stop(), m && m.scope && remove$1(m.scope.effects, tl);
  };
  return Ee && Ee.push(Wi), Wi;
}
function instanceWatch(r, e, n) {
  const s = this.proxy,
    o = isString(r) ? (r.includes('.') ? createPathGetter(s, r) : () => s[r]) : r.bind(s, s);
  let a;
  isFunction$1(e) ? (a = e) : ((a = e.handler), (n = e));
  const l = currentInstance;
  setCurrentInstance(this);
  const f = doWatch(o, a.bind(s), n);
  return l ? setCurrentInstance(l) : unsetCurrentInstance(), f;
}
function createPathGetter(r, e) {
  const n = e.split('.');
  return () => {
    let s = r;
    for (let o = 0; o < n.length && s; o++) s = s[n[o]];
    return s;
  };
}
function traverse(r, e) {
  if (!isObject$2(r) || r.__v_skip || ((e = e || new Set()), e.has(r))) return r;
  if ((e.add(r), isRef(r))) traverse(r.value, e);
  else if (isArray$1(r)) for (let n = 0; n < r.length; n++) traverse(r[n], e);
  else if (isSet(r) || isMap(r))
    r.forEach((n) => {
      traverse(n, e);
    });
  else if (isPlainObject$1(r)) for (const n in r) traverse(r[n], e);
  return r;
}
function withDirectives(r, e) {
  const n = currentRenderingInstance;
  if (n === null) return r;
  const s = getExposeProxy(n) || n.proxy,
    o = r.dirs || (r.dirs = []);
  for (let a = 0; a < e.length; a++) {
    let [l, f, m, v = EMPTY_OBJ] = e[a];
    l &&
      (isFunction$1(l) && (l = { mounted: l, updated: l }),
      l.deep && traverse(f),
      o.push({ dir: l, instance: s, value: f, oldValue: void 0, arg: m, modifiers: v }));
  }
  return r;
}
function invokeDirectiveHook(r, e, n, s) {
  const o = r.dirs,
    a = e && e.dirs;
  for (let l = 0; l < o.length; l++) {
    const f = o[l];
    a && (f.oldValue = a[l].value);
    let m = f.dir[s];
    m && (pauseTracking(), callWithAsyncErrorHandling(m, n, 8, [r.el, f, r, e]), resetTracking());
  }
}
function useTransitionState() {
  const r = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() };
  return (
    onMounted(() => {
      r.isMounted = !0;
    }),
    onBeforeUnmount(() => {
      r.isUnmounting = !0;
    }),
    r
  );
}
const TransitionHookValidator = [Function, Array],
  BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator,
  },
  BaseTransitionImpl = {
    name: 'BaseTransition',
    props: BaseTransitionPropsValidators,
    setup(r, { slots: e }) {
      const n = getCurrentInstance(),
        s = useTransitionState();
      let o;
      return () => {
        const a = e.default && getTransitionRawChildren(e.default(), !0);
        if (!a || !a.length) return;
        let l = a[0];
        if (a.length > 1) {
          for (const ht of a)
            if (ht.type !== Comment) {
              l = ht;
              break;
            }
        }
        const f = toRaw(r),
          { mode: m } = f;
        if (s.isLeaving) return emptyPlaceholder(l);
        const v = getKeepAliveChild(l);
        if (!v) return emptyPlaceholder(l);
        const I = resolveTransitionHooks(v, f, s, n);
        setTransitionHooks(v, I);
        const L = n.subTree,
          V = L && getKeepAliveChild(L);
        let se = !1;
        const { getTransitionKey: Ee } = v.type;
        if (Ee) {
          const ht = Ee();
          o === void 0 ? (o = ht) : ht !== o && ((o = ht), (se = !0));
        }
        if (V && V.type !== Comment && (!isSameVNodeType(v, V) || se)) {
          const ht = resolveTransitionHooks(V, f, s, n);
          if ((setTransitionHooks(V, ht), m === 'out-in'))
            return (
              (s.isLeaving = !0),
              (ht.afterLeave = () => {
                (s.isLeaving = !1), n.update.active !== !1 && n.update();
              }),
              emptyPlaceholder(l)
            );
          m === 'in-out' &&
            v.type !== Comment &&
            (ht.delayLeave = (ar, $i, tl) => {
              const Wi = getLeavingNodesForType(s, V);
              (Wi[String(V.key)] = V),
                (ar._leaveCb = () => {
                  $i(), (ar._leaveCb = void 0), delete I.delayedLeave;
                }),
                (I.delayedLeave = tl);
            });
        }
        return l;
      };
    },
  },
  BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(r, e) {
  const { leavingVNodes: n } = r;
  let s = n.get(e.type);
  return s || ((s = Object.create(null)), n.set(e.type, s)), s;
}
function resolveTransitionHooks(r, e, n, s) {
  const {
      appear: o,
      mode: a,
      persisted: l = !1,
      onBeforeEnter: f,
      onEnter: m,
      onAfterEnter: v,
      onEnterCancelled: I,
      onBeforeLeave: L,
      onLeave: V,
      onAfterLeave: se,
      onLeaveCancelled: Ee,
      onBeforeAppear: ht,
      onAppear: ar,
      onAfterAppear: $i,
      onAppearCancelled: tl,
    } = e,
    Wi = String(r.key),
    hl = getLeavingNodesForType(n, r),
    fl = (Fl, vl) => {
      Fl && callWithAsyncErrorHandling(Fl, s, 9, vl);
    },
    dl = (Fl, vl) => {
      const kl = vl[1];
      fl(Fl, vl), isArray$1(Fl) ? Fl.every((El) => El.length <= 1) && kl() : Fl.length <= 1 && kl();
    },
    Al = {
      mode: a,
      persisted: l,
      beforeEnter(Fl) {
        let vl = f;
        if (!n.isMounted)
          if (o) vl = ht || f;
          else return;
        Fl._leaveCb && Fl._leaveCb(!0);
        const kl = hl[Wi];
        kl && isSameVNodeType(r, kl) && kl.el._leaveCb && kl.el._leaveCb(), fl(vl, [Fl]);
      },
      enter(Fl) {
        let vl = m,
          kl = v,
          El = I;
        if (!n.isMounted)
          if (o) (vl = ar || m), (kl = $i || v), (El = tl || I);
          else return;
        let Jl = !1;
        const Kc = (Fl._enterCb = (Il) => {
          Jl ||
            ((Jl = !0), Il ? fl(El, [Fl]) : fl(kl, [Fl]), Al.delayedLeave && Al.delayedLeave(), (Fl._enterCb = void 0));
        });
        vl ? dl(vl, [Fl, Kc]) : Kc();
      },
      leave(Fl, vl) {
        const kl = String(r.key);
        if ((Fl._enterCb && Fl._enterCb(!0), n.isUnmounting)) return vl();
        fl(L, [Fl]);
        let El = !1;
        const Jl = (Fl._leaveCb = (Kc) => {
          El ||
            ((El = !0), vl(), Kc ? fl(Ee, [Fl]) : fl(se, [Fl]), (Fl._leaveCb = void 0), hl[kl] === r && delete hl[kl]);
        });
        (hl[kl] = r), V ? dl(V, [Fl, Jl]) : Jl();
      },
      clone(Fl) {
        return resolveTransitionHooks(Fl, e, n, s);
      },
    };
  return Al;
}
function emptyPlaceholder(r) {
  if (isKeepAlive(r)) return (r = cloneVNode(r)), (r.children = null), r;
}
function getKeepAliveChild(r) {
  return isKeepAlive(r) ? (r.children ? r.children[0] : void 0) : r;
}
function setTransitionHooks(r, e) {
  r.shapeFlag & 6 && r.component
    ? setTransitionHooks(r.component.subTree, e)
    : r.shapeFlag & 128
    ? ((r.ssContent.transition = e.clone(r.ssContent)), (r.ssFallback.transition = e.clone(r.ssFallback)))
    : (r.transition = e);
}
function getTransitionRawChildren(r, e = !1, n) {
  let s = [],
    o = 0;
  for (let a = 0; a < r.length; a++) {
    let l = r[a];
    const f = n == null ? l.key : String(n) + String(l.key != null ? l.key : a);
    l.type === Fragment
      ? (l.patchFlag & 128 && o++, (s = s.concat(getTransitionRawChildren(l.children, e, f))))
      : (e || l.type !== Comment) && s.push(f != null ? cloneVNode(l, { key: f }) : l);
  }
  if (o > 1) for (let a = 0; a < s.length; a++) s[a].patchFlag = -2;
  return s;
}
function defineComponent(r, e) {
  return isFunction$1(r) ? (() => extend$1({ name: r.name }, e, { setup: r }))() : r;
}
const isAsyncWrapper = (r) => !!r.type.__asyncLoader,
  isKeepAlive = (r) => r.type.__isKeepAlive;
function onActivated(r, e) {
  registerKeepAliveHook(r, 'a', e);
}
function onDeactivated(r, e) {
  registerKeepAliveHook(r, 'da', e);
}
function registerKeepAliveHook(r, e, n = currentInstance) {
  const s =
    r.__wdc ||
    (r.__wdc = () => {
      let o = n;
      for (; o; ) {
        if (o.isDeactivated) return;
        o = o.parent;
      }
      return r();
    });
  if ((injectHook(e, s, n), n)) {
    let o = n.parent;
    for (; o && o.parent; ) isKeepAlive(o.parent.vnode) && injectToKeepAliveRoot(s, e, n, o), (o = o.parent);
  }
}
function injectToKeepAliveRoot(r, e, n, s) {
  const o = injectHook(e, r, s, !0);
  onUnmounted(() => {
    remove$1(s[e], o);
  }, n);
}
function injectHook(r, e, n = currentInstance, s = !1) {
  if (n) {
    const o = n[r] || (n[r] = []),
      a =
        e.__weh ||
        (e.__weh = (...l) => {
          if (n.isUnmounted) return;
          pauseTracking(), setCurrentInstance(n);
          const f = callWithAsyncErrorHandling(e, n, r, l);
          return unsetCurrentInstance(), resetTracking(), f;
        });
    return s ? o.unshift(a) : o.push(a), a;
  }
}
const createHook =
    (r) =>
    (e, n = currentInstance) =>
      (!isInSSRComponentSetup || r === 'sp') && injectHook(r, (...s) => e(...s), n),
  onBeforeMount = createHook('bm'),
  onMounted = createHook('m'),
  onBeforeUpdate = createHook('bu'),
  onUpdated = createHook('u'),
  onBeforeUnmount = createHook('bum'),
  onUnmounted = createHook('um'),
  onServerPrefetch = createHook('sp'),
  onRenderTriggered = createHook('rtg'),
  onRenderTracked = createHook('rtc');
function onErrorCaptured(r, e = currentInstance) {
  injectHook('ec', r, e);
}
const COMPONENTS = 'components',
  NULL_DYNAMIC_COMPONENT = Symbol.for('v-ndc');
function resolveDynamicComponent(r) {
  return isString(r) ? resolveAsset(COMPONENTS, r, !1) || r : r || NULL_DYNAMIC_COMPONENT;
}
function resolveAsset(r, e, n = !0, s = !1) {
  const o = currentRenderingInstance || currentInstance;
  if (o) {
    const a = o.type;
    if (r === COMPONENTS) {
      const f = getComponentName(a, !1);
      if (f && (f === e || f === camelize(e) || f === capitalize(camelize(e)))) return a;
    }
    const l = resolve(o[r] || a[r], e) || resolve(o.appContext[r], e);
    return !l && s ? a : l;
  }
}
function resolve(r, e) {
  return r && (r[e] || r[camelize(e)] || r[capitalize(camelize(e))]);
}
function renderList(r, e, n, s) {
  let o;
  const a = n && n[s];
  if (isArray$1(r) || isString(r)) {
    o = new Array(r.length);
    for (let l = 0, f = r.length; l < f; l++) o[l] = e(r[l], l, void 0, a && a[l]);
  } else if (typeof r == 'number') {
    o = new Array(r);
    for (let l = 0; l < r; l++) o[l] = e(l + 1, l, void 0, a && a[l]);
  } else if (isObject$2(r))
    if (r[Symbol.iterator]) o = Array.from(r, (l, f) => e(l, f, void 0, a && a[f]));
    else {
      const l = Object.keys(r);
      o = new Array(l.length);
      for (let f = 0, m = l.length; f < m; f++) {
        const v = l[f];
        o[f] = e(r[v], v, f, a && a[f]);
      }
    }
  else o = [];
  return n && (n[s] = o), o;
}
function renderSlot(r, e, n = {}, s, o) {
  if (
    currentRenderingInstance.isCE ||
    (currentRenderingInstance.parent &&
      isAsyncWrapper(currentRenderingInstance.parent) &&
      currentRenderingInstance.parent.isCE)
  )
    return e !== 'default' && (n.name = e), createVNode('slot', n, s && s());
  let a = r[e];
  a && a._c && (a._d = !1), openBlock();
  const l = a && ensureValidVNode(a(n)),
    f = createBlock(Fragment, { key: n.key || (l && l.key) || `_${e}` }, l || (s ? s() : []), l && r._ === 1 ? 64 : -2);
  return !o && f.scopeId && (f.slotScopeIds = [f.scopeId + '-s']), a && a._c && (a._d = !0), f;
}
function ensureValidVNode(r) {
  return r.some((e) =>
    isVNode(e) ? !(e.type === Comment || (e.type === Fragment && !ensureValidVNode(e.children))) : !0,
  )
    ? r
    : null;
}
const getPublicInstance = (r) =>
    r ? (isStatefulComponent(r) ? getExposeProxy(r) || r.proxy : getPublicInstance(r.parent)) : null,
  publicPropertiesMap = extend$1(Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => r.props,
    $attrs: (r) => r.attrs,
    $slots: (r) => r.slots,
    $refs: (r) => r.refs,
    $parent: (r) => getPublicInstance(r.parent),
    $root: (r) => getPublicInstance(r.root),
    $emit: (r) => r.emit,
    $options: (r) => resolveMergedOptions(r),
    $forceUpdate: (r) => r.f || (r.f = () => queueJob(r.update)),
    $nextTick: (r) => r.n || (r.n = nextTick.bind(r.proxy)),
    $watch: (r) => instanceWatch.bind(r),
  }),
  hasSetupBinding = (r, e) => r !== EMPTY_OBJ && !r.__isScriptSetup && hasOwn(r, e),
  PublicInstanceProxyHandlers = {
    get({ _: r }, e) {
      const { ctx: n, setupState: s, data: o, props: a, accessCache: l, type: f, appContext: m } = r;
      let v;
      if (e[0] !== '$') {
        const se = l[e];
        if (se !== void 0)
          switch (se) {
            case 1:
              return s[e];
            case 2:
              return o[e];
            case 4:
              return n[e];
            case 3:
              return a[e];
          }
        else {
          if (hasSetupBinding(s, e)) return (l[e] = 1), s[e];
          if (o !== EMPTY_OBJ && hasOwn(o, e)) return (l[e] = 2), o[e];
          if ((v = r.propsOptions[0]) && hasOwn(v, e)) return (l[e] = 3), a[e];
          if (n !== EMPTY_OBJ && hasOwn(n, e)) return (l[e] = 4), n[e];
          shouldCacheAccess && (l[e] = 0);
        }
      }
      const I = publicPropertiesMap[e];
      let L, V;
      if (I) return e === '$attrs' && track(r, 'get', e), I(r);
      if ((L = f.__cssModules) && (L = L[e])) return L;
      if (n !== EMPTY_OBJ && hasOwn(n, e)) return (l[e] = 4), n[e];
      if (((V = m.config.globalProperties), hasOwn(V, e))) return V[e];
    },
    set({ _: r }, e, n) {
      const { data: s, setupState: o, ctx: a } = r;
      return hasSetupBinding(o, e)
        ? ((o[e] = n), !0)
        : s !== EMPTY_OBJ && hasOwn(s, e)
        ? ((s[e] = n), !0)
        : hasOwn(r.props, e) || (e[0] === '$' && e.slice(1) in r)
        ? !1
        : ((a[e] = n), !0);
    },
    has({ _: { data: r, setupState: e, accessCache: n, ctx: s, appContext: o, propsOptions: a } }, l) {
      let f;
      return (
        !!n[l] ||
        (r !== EMPTY_OBJ && hasOwn(r, l)) ||
        hasSetupBinding(e, l) ||
        ((f = a[0]) && hasOwn(f, l)) ||
        hasOwn(s, l) ||
        hasOwn(publicPropertiesMap, l) ||
        hasOwn(o.config.globalProperties, l)
      );
    },
    defineProperty(r, e, n) {
      return (
        n.get != null ? (r._.accessCache[e] = 0) : hasOwn(n, 'value') && this.set(r, e, n.value, null),
        Reflect.defineProperty(r, e, n)
      );
    },
  };
function useSlots() {
  return getContext().slots;
}
function getContext() {
  const r = getCurrentInstance();
  return r.setupContext || (r.setupContext = createSetupContext(r));
}
function normalizePropsOrEmits(r) {
  return isArray$1(r) ? r.reduce((e, n) => ((e[n] = null), e), {}) : r;
}
let shouldCacheAccess = !0;
function applyOptions(r) {
  const e = resolveMergedOptions(r),
    n = r.proxy,
    s = r.ctx;
  (shouldCacheAccess = !1), e.beforeCreate && callHook$1(e.beforeCreate, r, 'bc');
  const {
    data: o,
    computed: a,
    methods: l,
    watch: f,
    provide: m,
    inject: v,
    created: I,
    beforeMount: L,
    mounted: V,
    beforeUpdate: se,
    updated: Ee,
    activated: ht,
    deactivated: ar,
    beforeDestroy: $i,
    beforeUnmount: tl,
    destroyed: Wi,
    unmounted: hl,
    render: fl,
    renderTracked: dl,
    renderTriggered: Al,
    errorCaptured: Fl,
    serverPrefetch: vl,
    expose: kl,
    inheritAttrs: El,
    components: Jl,
    directives: Kc,
    filters: Il,
  } = e;
  if ((v && resolveInjections(v, s, null), l))
    for (const Hl in l) {
      const Bl = l[Hl];
      isFunction$1(Bl) && (s[Hl] = Bl.bind(n));
    }
  if (o) {
    const Hl = o.call(n, n);
    isObject$2(Hl) && (r.data = reactive(Hl));
  }
  if (((shouldCacheAccess = !0), a))
    for (const Hl in a) {
      const Bl = a[Hl],
        ql = isFunction$1(Bl) ? Bl.bind(n, n) : isFunction$1(Bl.get) ? Bl.get.bind(n, n) : NOOP,
        Yl = !isFunction$1(Bl) && isFunction$1(Bl.set) ? Bl.set.bind(n) : NOOP,
        ih = computed({ get: ql, set: Yl });
      Object.defineProperty(s, Hl, {
        enumerable: !0,
        configurable: !0,
        get: () => ih.value,
        set: (ph) => (ih.value = ph),
      });
    }
  if (f) for (const Hl in f) createWatcher(f[Hl], s, n, Hl);
  if (m) {
    const Hl = isFunction$1(m) ? m.call(n) : m;
    Reflect.ownKeys(Hl).forEach((Bl) => {
      provide(Bl, Hl[Bl]);
    });
  }
  I && callHook$1(I, r, 'c');
  function Nl(Hl, Bl) {
    isArray$1(Bl) ? Bl.forEach((ql) => Hl(ql.bind(n))) : Bl && Hl(Bl.bind(n));
  }
  if (
    (Nl(onBeforeMount, L),
    Nl(onMounted, V),
    Nl(onBeforeUpdate, se),
    Nl(onUpdated, Ee),
    Nl(onActivated, ht),
    Nl(onDeactivated, ar),
    Nl(onErrorCaptured, Fl),
    Nl(onRenderTracked, dl),
    Nl(onRenderTriggered, Al),
    Nl(onBeforeUnmount, tl),
    Nl(onUnmounted, hl),
    Nl(onServerPrefetch, vl),
    isArray$1(kl))
  )
    if (kl.length) {
      const Hl = r.exposed || (r.exposed = {});
      kl.forEach((Bl) => {
        Object.defineProperty(Hl, Bl, { get: () => n[Bl], set: (ql) => (n[Bl] = ql) });
      });
    } else r.exposed || (r.exposed = {});
  fl && r.render === NOOP && (r.render = fl),
    El != null && (r.inheritAttrs = El),
    Jl && (r.components = Jl),
    Kc && (r.directives = Kc);
}
function resolveInjections(r, e, n = NOOP) {
  isArray$1(r) && (r = normalizeInject(r));
  for (const s in r) {
    const o = r[s];
    let a;
    isObject$2(o)
      ? 'default' in o
        ? (a = inject(o.from || s, o.default, !0))
        : (a = inject(o.from || s))
      : (a = inject(o)),
      isRef(a)
        ? Object.defineProperty(e, s, {
            enumerable: !0,
            configurable: !0,
            get: () => a.value,
            set: (l) => (a.value = l),
          })
        : (e[s] = a);
  }
}
function callHook$1(r, e, n) {
  callWithAsyncErrorHandling(isArray$1(r) ? r.map((s) => s.bind(e.proxy)) : r.bind(e.proxy), e, n);
}
function createWatcher(r, e, n, s) {
  const o = s.includes('.') ? createPathGetter(n, s) : () => n[s];
  if (isString(r)) {
    const a = e[r];
    isFunction$1(a) && watch(o, a);
  } else if (isFunction$1(r)) watch(o, r.bind(n));
  else if (isObject$2(r))
    if (isArray$1(r)) r.forEach((a) => createWatcher(a, e, n, s));
    else {
      const a = isFunction$1(r.handler) ? r.handler.bind(n) : e[r.handler];
      isFunction$1(a) && watch(o, a, r);
    }
}
function resolveMergedOptions(r) {
  const e = r.type,
    { mixins: n, extends: s } = e,
    {
      mixins: o,
      optionsCache: a,
      config: { optionMergeStrategies: l },
    } = r.appContext,
    f = a.get(e);
  let m;
  return (
    f
      ? (m = f)
      : !o.length && !n && !s
      ? (m = e)
      : ((m = {}), o.length && o.forEach((v) => mergeOptions$1(m, v, l, !0)), mergeOptions$1(m, e, l)),
    isObject$2(e) && a.set(e, m),
    m
  );
}
function mergeOptions$1(r, e, n, s = !1) {
  const { mixins: o, extends: a } = e;
  a && mergeOptions$1(r, a, n, !0), o && o.forEach((l) => mergeOptions$1(r, l, n, !0));
  for (const l in e)
    if (!(s && l === 'expose')) {
      const f = internalOptionMergeStrats[l] || (n && n[l]);
      r[l] = f ? f(r[l], e[l]) : e[l];
    }
  return r;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject,
};
function mergeDataFn(r, e) {
  return e
    ? r
      ? function () {
          return extend$1(isFunction$1(r) ? r.call(this, this) : r, isFunction$1(e) ? e.call(this, this) : e);
        }
      : e
    : r;
}
function mergeInject(r, e) {
  return mergeObjectOptions(normalizeInject(r), normalizeInject(e));
}
function normalizeInject(r) {
  if (isArray$1(r)) {
    const e = {};
    for (let n = 0; n < r.length; n++) e[r[n]] = r[n];
    return e;
  }
  return r;
}
function mergeAsArray(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function mergeObjectOptions(r, e) {
  return r ? extend$1(Object.create(null), r, e) : e;
}
function mergeEmitsOrPropsOptions(r, e) {
  return r
    ? isArray$1(r) && isArray$1(e)
      ? [...new Set([...r, ...e])]
      : extend$1(Object.create(null), normalizePropsOrEmits(r), normalizePropsOrEmits(e ?? {}))
    : e;
}
function mergeWatchOptions(r, e) {
  if (!r) return e;
  if (!e) return r;
  const n = extend$1(Object.create(null), r);
  for (const s in e) n[s] = mergeAsArray(r[s], e[s]);
  return n;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap(),
  };
}
let uid$1 = 0;
function createAppAPI(r, e) {
  return function (s, o = null) {
    isFunction$1(s) || (s = extend$1({}, s)), o != null && !isObject$2(o) && (o = null);
    const a = createAppContext(),
      l = new Set();
    let f = !1;
    const m = (a.app = {
      _uid: uid$1++,
      _component: s,
      _props: o,
      _container: null,
      _context: a,
      _instance: null,
      version,
      get config() {
        return a.config;
      },
      set config(v) {},
      use(v, ...I) {
        return (
          l.has(v) ||
            (v && isFunction$1(v.install) ? (l.add(v), v.install(m, ...I)) : isFunction$1(v) && (l.add(v), v(m, ...I))),
          m
        );
      },
      mixin(v) {
        return a.mixins.includes(v) || a.mixins.push(v), m;
      },
      component(v, I) {
        return I ? ((a.components[v] = I), m) : a.components[v];
      },
      directive(v, I) {
        return I ? ((a.directives[v] = I), m) : a.directives[v];
      },
      mount(v, I, L) {
        if (!f) {
          const V = createVNode(s, o);
          return (
            (V.appContext = a),
            I && e ? e(V, v) : r(V, v, L),
            (f = !0),
            (m._container = v),
            (v.__vue_app__ = m),
            getExposeProxy(V.component) || V.component.proxy
          );
        }
      },
      unmount() {
        f && (r(null, m._container), delete m._container.__vue_app__);
      },
      provide(v, I) {
        return (a.provides[v] = I), m;
      },
      runWithContext(v) {
        currentApp = m;
        try {
          return v();
        } finally {
          currentApp = null;
        }
      },
    });
    return m;
  };
}
let currentApp = null;
function provide(r, e) {
  if (currentInstance) {
    let n = currentInstance.provides;
    const s = currentInstance.parent && currentInstance.parent.provides;
    s === n && (n = currentInstance.provides = Object.create(s)), (n[r] = e);
  }
}
function inject(r, e, n = !1) {
  const s = currentInstance || currentRenderingInstance;
  if (s || currentApp) {
    const o = s
      ? s.parent == null
        ? s.vnode.appContext && s.vnode.appContext.provides
        : s.parent.provides
      : currentApp._context.provides;
    if (o && r in o) return o[r];
    if (arguments.length > 1) return n && isFunction$1(e) ? e.call(s && s.proxy) : e;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(r, e, n, s = !1) {
  const o = {},
    a = {};
  def(a, InternalObjectKey, 1), (r.propsDefaults = Object.create(null)), setFullProps(r, e, o, a);
  for (const l in r.propsOptions[0]) l in o || (o[l] = void 0);
  n ? (r.props = s ? o : shallowReactive(o)) : r.type.props ? (r.props = o) : (r.props = a), (r.attrs = a);
}
function updateProps(r, e, n, s) {
  const {
      props: o,
      attrs: a,
      vnode: { patchFlag: l },
    } = r,
    f = toRaw(o),
    [m] = r.propsOptions;
  let v = !1;
  if ((s || l > 0) && !(l & 16)) {
    if (l & 8) {
      const I = r.vnode.dynamicProps;
      for (let L = 0; L < I.length; L++) {
        let V = I[L];
        if (isEmitListener(r.emitsOptions, V)) continue;
        const se = e[V];
        if (m)
          if (hasOwn(a, V)) se !== a[V] && ((a[V] = se), (v = !0));
          else {
            const Ee = camelize(V);
            o[Ee] = resolvePropValue(m, f, Ee, se, r, !1);
          }
        else se !== a[V] && ((a[V] = se), (v = !0));
      }
    }
  } else {
    setFullProps(r, e, o, a) && (v = !0);
    let I;
    for (const L in f)
      (!e || (!hasOwn(e, L) && ((I = hyphenate(L)) === L || !hasOwn(e, I)))) &&
        (m
          ? n && (n[L] !== void 0 || n[I] !== void 0) && (o[L] = resolvePropValue(m, f, L, void 0, r, !0))
          : delete o[L]);
    if (a !== f) for (const L in a) (!e || !hasOwn(e, L)) && (delete a[L], (v = !0));
  }
  v && trigger(r, 'set', '$attrs');
}
function setFullProps(r, e, n, s) {
  const [o, a] = r.propsOptions;
  let l = !1,
    f;
  if (e)
    for (let m in e) {
      if (isReservedProp(m)) continue;
      const v = e[m];
      let I;
      o && hasOwn(o, (I = camelize(m)))
        ? !a || !a.includes(I)
          ? (n[I] = v)
          : ((f || (f = {}))[I] = v)
        : isEmitListener(r.emitsOptions, m) || ((!(m in s) || v !== s[m]) && ((s[m] = v), (l = !0)));
    }
  if (a) {
    const m = toRaw(n),
      v = f || EMPTY_OBJ;
    for (let I = 0; I < a.length; I++) {
      const L = a[I];
      n[L] = resolvePropValue(o, m, L, v[L], r, !hasOwn(v, L));
    }
  }
  return l;
}
function resolvePropValue(r, e, n, s, o, a) {
  const l = r[n];
  if (l != null) {
    const f = hasOwn(l, 'default');
    if (f && s === void 0) {
      const m = l.default;
      if (l.type !== Function && !l.skipFactory && isFunction$1(m)) {
        const { propsDefaults: v } = o;
        n in v ? (s = v[n]) : (setCurrentInstance(o), (s = v[n] = m.call(null, e)), unsetCurrentInstance());
      } else s = m;
    }
    l[0] && (a && !f ? (s = !1) : l[1] && (s === '' || s === hyphenate(n)) && (s = !0));
  }
  return s;
}
function normalizePropsOptions(r, e, n = !1) {
  const s = e.propsCache,
    o = s.get(r);
  if (o) return o;
  const a = r.props,
    l = {},
    f = [];
  let m = !1;
  if (!isFunction$1(r)) {
    const I = (L) => {
      m = !0;
      const [V, se] = normalizePropsOptions(L, e, !0);
      extend$1(l, V), se && f.push(...se);
    };
    !n && e.mixins.length && e.mixins.forEach(I), r.extends && I(r.extends), r.mixins && r.mixins.forEach(I);
  }
  if (!a && !m) return isObject$2(r) && s.set(r, EMPTY_ARR), EMPTY_ARR;
  if (isArray$1(a))
    for (let I = 0; I < a.length; I++) {
      const L = camelize(a[I]);
      validatePropName(L) && (l[L] = EMPTY_OBJ);
    }
  else if (a)
    for (const I in a) {
      const L = camelize(I);
      if (validatePropName(L)) {
        const V = a[I],
          se = (l[L] = isArray$1(V) || isFunction$1(V) ? { type: V } : extend$1({}, V));
        if (se) {
          const Ee = getTypeIndex(Boolean, se.type),
            ht = getTypeIndex(String, se.type);
          (se[0] = Ee > -1), (se[1] = ht < 0 || Ee < ht), (Ee > -1 || hasOwn(se, 'default')) && f.push(L);
        }
      }
    }
  const v = [l, f];
  return isObject$2(r) && s.set(r, v), v;
}
function validatePropName(r) {
  return r[0] !== '$';
}
function getType(r) {
  const e = r && r.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : r === null ? 'null' : '';
}
function isSameType(r, e) {
  return getType(r) === getType(e);
}
function getTypeIndex(r, e) {
  return isArray$1(e) ? e.findIndex((n) => isSameType(n, r)) : isFunction$1(e) && isSameType(e, r) ? 0 : -1;
}
const isInternalKey = (r) => r[0] === '_' || r === '$stable',
  normalizeSlotValue = (r) => (isArray$1(r) ? r.map(normalizeVNode) : [normalizeVNode(r)]),
  normalizeSlot$1 = (r, e, n) => {
    if (e._n) return e;
    const s = withCtx((...o) => normalizeSlotValue(e(...o)), n);
    return (s._c = !1), s;
  },
  normalizeObjectSlots = (r, e, n) => {
    const s = r._ctx;
    for (const o in r) {
      if (isInternalKey(o)) continue;
      const a = r[o];
      if (isFunction$1(a)) e[o] = normalizeSlot$1(o, a, s);
      else if (a != null) {
        const l = normalizeSlotValue(a);
        e[o] = () => l;
      }
    }
  },
  normalizeVNodeSlots = (r, e) => {
    const n = normalizeSlotValue(e);
    r.slots.default = () => n;
  },
  initSlots = (r, e) => {
    if (r.vnode.shapeFlag & 32) {
      const n = e._;
      n ? ((r.slots = toRaw(e)), def(e, '_', n)) : normalizeObjectSlots(e, (r.slots = {}));
    } else (r.slots = {}), e && normalizeVNodeSlots(r, e);
    def(r.slots, InternalObjectKey, 1);
  },
  updateSlots = (r, e, n) => {
    const { vnode: s, slots: o } = r;
    let a = !0,
      l = EMPTY_OBJ;
    if (s.shapeFlag & 32) {
      const f = e._;
      f
        ? n && f === 1
          ? (a = !1)
          : (extend$1(o, e), !n && f === 1 && delete o._)
        : ((a = !e.$stable), normalizeObjectSlots(e, o)),
        (l = e);
    } else e && (normalizeVNodeSlots(r, e), (l = { default: 1 }));
    if (a) for (const f in o) !isInternalKey(f) && !(f in l) && delete o[f];
  };
function setRef(r, e, n, s, o = !1) {
  if (isArray$1(r)) {
    r.forEach((V, se) => setRef(V, e && (isArray$1(e) ? e[se] : e), n, s, o));
    return;
  }
  if (isAsyncWrapper(s) && !o) return;
  const a = s.shapeFlag & 4 ? getExposeProxy(s.component) || s.component.proxy : s.el,
    l = o ? null : a,
    { i: f, r: m } = r,
    v = e && e.r,
    I = f.refs === EMPTY_OBJ ? (f.refs = {}) : f.refs,
    L = f.setupState;
  if (
    (v != null &&
      v !== m &&
      (isString(v) ? ((I[v] = null), hasOwn(L, v) && (L[v] = null)) : isRef(v) && (v.value = null)),
    isFunction$1(m))
  )
    callWithErrorHandling(m, f, 12, [l, I]);
  else {
    const V = isString(m),
      se = isRef(m);
    if (V || se) {
      const Ee = () => {
        if (r.f) {
          const ht = V ? (hasOwn(L, m) ? L[m] : I[m]) : m.value;
          o
            ? isArray$1(ht) && remove$1(ht, a)
            : isArray$1(ht)
            ? ht.includes(a) || ht.push(a)
            : V
            ? ((I[m] = [a]), hasOwn(L, m) && (L[m] = I[m]))
            : ((m.value = [a]), r.k && (I[r.k] = m.value));
        } else V ? ((I[m] = l), hasOwn(L, m) && (L[m] = l)) : se && ((m.value = l), r.k && (I[r.k] = l));
      };
      l ? ((Ee.id = -1), queuePostRenderEffect(Ee, n)) : Ee();
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(r) {
  return baseCreateRenderer(r);
}
function baseCreateRenderer(r, e) {
  const n = getGlobalThis();
  n.__VUE__ = !0;
  const {
      insert: s,
      remove: o,
      patchProp: a,
      createElement: l,
      createText: f,
      createComment: m,
      setText: v,
      setElementText: I,
      parentNode: L,
      nextSibling: V,
      setScopeId: se = NOOP,
      insertStaticContent: Ee,
    } = r,
    ht = (gl, bl, Pl, Rl = null, Wl = null, Kl = null, th = !1, Hc = null, Qc = !!bl.dynamicChildren) => {
      if (gl === bl) return;
      gl && !isSameVNodeType(gl, bl) && ((Rl = wl(gl)), ph(gl, Wl, Kl, !0), (gl = null)),
        bl.patchFlag === -2 && ((Qc = !1), (bl.dynamicChildren = null));
      const { type: Gl, ref: ch, shapeFlag: lh } = bl;
      switch (Gl) {
        case Text$1:
          ar(gl, bl, Pl, Rl);
          break;
        case Comment:
          $i(gl, bl, Pl, Rl);
          break;
        case Static:
          gl == null && tl(bl, Pl, Rl, th);
          break;
        case Fragment:
          Jl(gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc);
          break;
        default:
          lh & 1
            ? fl(gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc)
            : lh & 6
            ? Kc(gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc)
            : (lh & 64 || lh & 128) && Gl.process(gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc, zc);
      }
      ch != null && Wl && setRef(ch, gl && gl.ref, Kl, bl || gl, !bl);
    },
    ar = (gl, bl, Pl, Rl) => {
      if (gl == null) s((bl.el = f(bl.children)), Pl, Rl);
      else {
        const Wl = (bl.el = gl.el);
        bl.children !== gl.children && v(Wl, bl.children);
      }
    },
    $i = (gl, bl, Pl, Rl) => {
      gl == null ? s((bl.el = m(bl.children || '')), Pl, Rl) : (bl.el = gl.el);
    },
    tl = (gl, bl, Pl, Rl) => {
      [gl.el, gl.anchor] = Ee(gl.children, bl, Pl, Rl, gl.el, gl.anchor);
    },
    Wi = ({ el: gl, anchor: bl }, Pl, Rl) => {
      let Wl;
      for (; gl && gl !== bl; ) (Wl = V(gl)), s(gl, Pl, Rl), (gl = Wl);
      s(bl, Pl, Rl);
    },
    hl = ({ el: gl, anchor: bl }) => {
      let Pl;
      for (; gl && gl !== bl; ) (Pl = V(gl)), o(gl), (gl = Pl);
      o(bl);
    },
    fl = (gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc) => {
      (th = th || bl.type === 'svg'), gl == null ? dl(bl, Pl, Rl, Wl, Kl, th, Hc, Qc) : vl(gl, bl, Wl, Kl, th, Hc, Qc);
    },
    dl = (gl, bl, Pl, Rl, Wl, Kl, th, Hc) => {
      let Qc, Gl;
      const { type: ch, props: lh, shapeFlag: dh, transition: mh, dirs: yh } = gl;
      if (
        ((Qc = gl.el = l(gl.type, Kl, lh && lh.is, lh)),
        dh & 8
          ? I(Qc, gl.children)
          : dh & 16 && Fl(gl.children, Qc, null, Rl, Wl, Kl && ch !== 'foreignObject', th, Hc),
        yh && invokeDirectiveHook(gl, null, Rl, 'created'),
        Al(Qc, gl, gl.scopeId, th, Rl),
        lh)
      ) {
        for (const Sh in lh)
          Sh !== 'value' && !isReservedProp(Sh) && a(Qc, Sh, null, lh[Sh], Kl, gl.children, Rl, Wl, Ah);
        'value' in lh && a(Qc, 'value', null, lh.value), (Gl = lh.onVnodeBeforeMount) && invokeVNodeHook(Gl, Rl, gl);
      }
      yh && invokeDirectiveHook(gl, null, Rl, 'beforeMount');
      const kh = (!Wl || (Wl && !Wl.pendingBranch)) && mh && !mh.persisted;
      kh && mh.beforeEnter(Qc),
        s(Qc, bl, Pl),
        ((Gl = lh && lh.onVnodeMounted) || kh || yh) &&
          queuePostRenderEffect(() => {
            Gl && invokeVNodeHook(Gl, Rl, gl), kh && mh.enter(Qc), yh && invokeDirectiveHook(gl, null, Rl, 'mounted');
          }, Wl);
    },
    Al = (gl, bl, Pl, Rl, Wl) => {
      if ((Pl && se(gl, Pl), Rl)) for (let Kl = 0; Kl < Rl.length; Kl++) se(gl, Rl[Kl]);
      if (Wl) {
        let Kl = Wl.subTree;
        if (bl === Kl) {
          const th = Wl.vnode;
          Al(gl, th, th.scopeId, th.slotScopeIds, Wl.parent);
        }
      }
    },
    Fl = (gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc = 0) => {
      for (let Gl = Qc; Gl < gl.length; Gl++) {
        const ch = (gl[Gl] = Hc ? cloneIfMounted(gl[Gl]) : normalizeVNode(gl[Gl]));
        ht(null, ch, bl, Pl, Rl, Wl, Kl, th, Hc);
      }
    },
    vl = (gl, bl, Pl, Rl, Wl, Kl, th) => {
      const Hc = (bl.el = gl.el);
      let { patchFlag: Qc, dynamicChildren: Gl, dirs: ch } = bl;
      Qc |= gl.patchFlag & 16;
      const lh = gl.props || EMPTY_OBJ,
        dh = bl.props || EMPTY_OBJ;
      let mh;
      Pl && toggleRecurse(Pl, !1),
        (mh = dh.onVnodeBeforeUpdate) && invokeVNodeHook(mh, Pl, bl, gl),
        ch && invokeDirectiveHook(bl, gl, Pl, 'beforeUpdate'),
        Pl && toggleRecurse(Pl, !0);
      const yh = Wl && bl.type !== 'foreignObject';
      if (
        (Gl ? kl(gl.dynamicChildren, Gl, Hc, Pl, Rl, yh, Kl) : th || Bl(gl, bl, Hc, null, Pl, Rl, yh, Kl, !1), Qc > 0)
      ) {
        if (Qc & 16) El(Hc, bl, lh, dh, Pl, Rl, Wl);
        else if (
          (Qc & 2 && lh.class !== dh.class && a(Hc, 'class', null, dh.class, Wl),
          Qc & 4 && a(Hc, 'style', lh.style, dh.style, Wl),
          Qc & 8)
        ) {
          const kh = bl.dynamicProps;
          for (let Sh = 0; Sh < kh.length; Sh++) {
            const Fh = kh[Sh],
              Lh = lh[Fh],
              Yh = dh[Fh];
            (Yh !== Lh || Fh === 'value') && a(Hc, Fh, Lh, Yh, Wl, gl.children, Pl, Rl, Ah);
          }
        }
        Qc & 1 && gl.children !== bl.children && I(Hc, bl.children);
      } else !th && Gl == null && El(Hc, bl, lh, dh, Pl, Rl, Wl);
      ((mh = dh.onVnodeUpdated) || ch) &&
        queuePostRenderEffect(() => {
          mh && invokeVNodeHook(mh, Pl, bl, gl), ch && invokeDirectiveHook(bl, gl, Pl, 'updated');
        }, Rl);
    },
    kl = (gl, bl, Pl, Rl, Wl, Kl, th) => {
      for (let Hc = 0; Hc < bl.length; Hc++) {
        const Qc = gl[Hc],
          Gl = bl[Hc],
          ch = Qc.el && (Qc.type === Fragment || !isSameVNodeType(Qc, Gl) || Qc.shapeFlag & 70) ? L(Qc.el) : Pl;
        ht(Qc, Gl, ch, null, Rl, Wl, Kl, th, !0);
      }
    },
    El = (gl, bl, Pl, Rl, Wl, Kl, th) => {
      if (Pl !== Rl) {
        if (Pl !== EMPTY_OBJ)
          for (const Hc in Pl)
            !isReservedProp(Hc) && !(Hc in Rl) && a(gl, Hc, Pl[Hc], null, th, bl.children, Wl, Kl, Ah);
        for (const Hc in Rl) {
          if (isReservedProp(Hc)) continue;
          const Qc = Rl[Hc],
            Gl = Pl[Hc];
          Qc !== Gl && Hc !== 'value' && a(gl, Hc, Gl, Qc, th, bl.children, Wl, Kl, Ah);
        }
        'value' in Rl && a(gl, 'value', Pl.value, Rl.value);
      }
    },
    Jl = (gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc) => {
      const Gl = (bl.el = gl ? gl.el : f('')),
        ch = (bl.anchor = gl ? gl.anchor : f(''));
      let { patchFlag: lh, dynamicChildren: dh, slotScopeIds: mh } = bl;
      mh && (Hc = Hc ? Hc.concat(mh) : mh),
        gl == null
          ? (s(Gl, Pl, Rl), s(ch, Pl, Rl), Fl(bl.children, Pl, ch, Wl, Kl, th, Hc, Qc))
          : lh > 0 && lh & 64 && dh && gl.dynamicChildren
          ? (kl(gl.dynamicChildren, dh, Pl, Wl, Kl, th, Hc),
            (bl.key != null || (Wl && bl === Wl.subTree)) && traverseStaticChildren(gl, bl, !0))
          : Bl(gl, bl, Pl, ch, Wl, Kl, th, Hc, Qc);
    },
    Kc = (gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc) => {
      (bl.slotScopeIds = Hc),
        gl == null
          ? bl.shapeFlag & 512
            ? Wl.ctx.activate(bl, Pl, Rl, th, Qc)
            : Il(bl, Pl, Rl, Wl, Kl, th, Qc)
          : Ll(gl, bl, Qc);
    },
    Il = (gl, bl, Pl, Rl, Wl, Kl, th) => {
      const Hc = (gl.component = createComponentInstance(gl, Rl, Wl));
      if ((isKeepAlive(gl) && (Hc.ctx.renderer = zc), setupComponent(Hc), Hc.asyncDep)) {
        if ((Wl && Wl.registerDep(Hc, Nl), !gl.el)) {
          const Qc = (Hc.subTree = createVNode(Comment));
          $i(null, Qc, bl, Pl);
        }
        return;
      }
      Nl(Hc, gl, bl, Pl, Wl, Kl, th);
    },
    Ll = (gl, bl, Pl) => {
      const Rl = (bl.component = gl.component);
      if (shouldUpdateComponent(gl, bl, Pl))
        if (Rl.asyncDep && !Rl.asyncResolved) {
          Hl(Rl, bl, Pl);
          return;
        } else (Rl.next = bl), invalidateJob(Rl.update), Rl.update();
      else (bl.el = gl.el), (Rl.vnode = bl);
    },
    Nl = (gl, bl, Pl, Rl, Wl, Kl, th) => {
      const Hc = () => {
          if (gl.isMounted) {
            let { next: ch, bu: lh, u: dh, parent: mh, vnode: yh } = gl,
              kh = ch,
              Sh;
            toggleRecurse(gl, !1),
              ch ? ((ch.el = yh.el), Hl(gl, ch, th)) : (ch = yh),
              lh && invokeArrayFns(lh),
              (Sh = ch.props && ch.props.onVnodeBeforeUpdate) && invokeVNodeHook(Sh, mh, ch, yh),
              toggleRecurse(gl, !0);
            const Fh = renderComponentRoot(gl),
              Lh = gl.subTree;
            (gl.subTree = Fh),
              ht(Lh, Fh, L(Lh.el), wl(Lh), gl, Wl, Kl),
              (ch.el = Fh.el),
              kh === null && updateHOCHostEl(gl, Fh.el),
              dh && queuePostRenderEffect(dh, Wl),
              (Sh = ch.props && ch.props.onVnodeUpdated) &&
                queuePostRenderEffect(() => invokeVNodeHook(Sh, mh, ch, yh), Wl);
          } else {
            let ch;
            const { el: lh, props: dh } = bl,
              { bm: mh, m: yh, parent: kh } = gl,
              Sh = isAsyncWrapper(bl);
            if (
              (toggleRecurse(gl, !1),
              mh && invokeArrayFns(mh),
              !Sh && (ch = dh && dh.onVnodeBeforeMount) && invokeVNodeHook(ch, kh, bl),
              toggleRecurse(gl, !0),
              lh && Dh)
            ) {
              const Fh = () => {
                (gl.subTree = renderComponentRoot(gl)), Dh(lh, gl.subTree, gl, Wl, null);
              };
              Sh ? bl.type.__asyncLoader().then(() => !gl.isUnmounted && Fh()) : Fh();
            } else {
              const Fh = (gl.subTree = renderComponentRoot(gl));
              ht(null, Fh, Pl, Rl, gl, Wl, Kl), (bl.el = Fh.el);
            }
            if ((yh && queuePostRenderEffect(yh, Wl), !Sh && (ch = dh && dh.onVnodeMounted))) {
              const Fh = bl;
              queuePostRenderEffect(() => invokeVNodeHook(ch, kh, Fh), Wl);
            }
            (bl.shapeFlag & 256 || (kh && isAsyncWrapper(kh.vnode) && kh.vnode.shapeFlag & 256)) &&
              gl.a &&
              queuePostRenderEffect(gl.a, Wl),
              (gl.isMounted = !0),
              (bl = Pl = Rl = null);
          }
        },
        Qc = (gl.effect = new ReactiveEffect(Hc, () => queueJob(Gl), gl.scope)),
        Gl = (gl.update = () => Qc.run());
      (Gl.id = gl.uid), toggleRecurse(gl, !0), Gl();
    },
    Hl = (gl, bl, Pl) => {
      bl.component = gl;
      const Rl = gl.vnode.props;
      (gl.vnode = bl),
        (gl.next = null),
        updateProps(gl, bl.props, Rl, Pl),
        updateSlots(gl, bl.children, Pl),
        pauseTracking(),
        flushPreFlushCbs(),
        resetTracking();
    },
    Bl = (gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc = !1) => {
      const Gl = gl && gl.children,
        ch = gl ? gl.shapeFlag : 0,
        lh = bl.children,
        { patchFlag: dh, shapeFlag: mh } = bl;
      if (dh > 0) {
        if (dh & 128) {
          Yl(Gl, lh, Pl, Rl, Wl, Kl, th, Hc, Qc);
          return;
        } else if (dh & 256) {
          ql(Gl, lh, Pl, Rl, Wl, Kl, th, Hc, Qc);
          return;
        }
      }
      mh & 8
        ? (ch & 16 && Ah(Gl, Wl, Kl), lh !== Gl && I(Pl, lh))
        : ch & 16
        ? mh & 16
          ? Yl(Gl, lh, Pl, Rl, Wl, Kl, th, Hc, Qc)
          : Ah(Gl, Wl, Kl, !0)
        : (ch & 8 && I(Pl, ''), mh & 16 && Fl(lh, Pl, Rl, Wl, Kl, th, Hc, Qc));
    },
    ql = (gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc) => {
      (gl = gl || EMPTY_ARR), (bl = bl || EMPTY_ARR);
      const Gl = gl.length,
        ch = bl.length,
        lh = Math.min(Gl, ch);
      let dh;
      for (dh = 0; dh < lh; dh++) {
        const mh = (bl[dh] = Qc ? cloneIfMounted(bl[dh]) : normalizeVNode(bl[dh]));
        ht(gl[dh], mh, Pl, null, Wl, Kl, th, Hc, Qc);
      }
      Gl > ch ? Ah(gl, Wl, Kl, !0, !1, lh) : Fl(bl, Pl, Rl, Wl, Kl, th, Hc, Qc, lh);
    },
    Yl = (gl, bl, Pl, Rl, Wl, Kl, th, Hc, Qc) => {
      let Gl = 0;
      const ch = bl.length;
      let lh = gl.length - 1,
        dh = ch - 1;
      for (; Gl <= lh && Gl <= dh; ) {
        const mh = gl[Gl],
          yh = (bl[Gl] = Qc ? cloneIfMounted(bl[Gl]) : normalizeVNode(bl[Gl]));
        if (isSameVNodeType(mh, yh)) ht(mh, yh, Pl, null, Wl, Kl, th, Hc, Qc);
        else break;
        Gl++;
      }
      for (; Gl <= lh && Gl <= dh; ) {
        const mh = gl[lh],
          yh = (bl[dh] = Qc ? cloneIfMounted(bl[dh]) : normalizeVNode(bl[dh]));
        if (isSameVNodeType(mh, yh)) ht(mh, yh, Pl, null, Wl, Kl, th, Hc, Qc);
        else break;
        lh--, dh--;
      }
      if (Gl > lh) {
        if (Gl <= dh) {
          const mh = dh + 1,
            yh = mh < ch ? bl[mh].el : Rl;
          for (; Gl <= dh; )
            ht(null, (bl[Gl] = Qc ? cloneIfMounted(bl[Gl]) : normalizeVNode(bl[Gl])), Pl, yh, Wl, Kl, th, Hc, Qc), Gl++;
        }
      } else if (Gl > dh) for (; Gl <= lh; ) ph(gl[Gl], Wl, Kl, !0), Gl++;
      else {
        const mh = Gl,
          yh = Gl,
          kh = new Map();
        for (Gl = yh; Gl <= dh; Gl++) {
          const $h = (bl[Gl] = Qc ? cloneIfMounted(bl[Gl]) : normalizeVNode(bl[Gl]));
          $h.key != null && kh.set($h.key, Gl);
        }
        let Sh,
          Fh = 0;
        const Lh = dh - yh + 1;
        let Yh = !1,
          td = 0;
        const rd = new Array(Lh);
        for (Gl = 0; Gl < Lh; Gl++) rd[Gl] = 0;
        for (Gl = mh; Gl <= lh; Gl++) {
          const $h = gl[Gl];
          if (Fh >= Lh) {
            ph($h, Wl, Kl, !0);
            continue;
          }
          let Rh;
          if ($h.key != null) Rh = kh.get($h.key);
          else
            for (Sh = yh; Sh <= dh; Sh++)
              if (rd[Sh - yh] === 0 && isSameVNodeType($h, bl[Sh])) {
                Rh = Sh;
                break;
              }
          Rh === void 0
            ? ph($h, Wl, Kl, !0)
            : ((rd[Rh - yh] = Gl + 1),
              Rh >= td ? (td = Rh) : (Yh = !0),
              ht($h, bl[Rh], Pl, null, Wl, Kl, th, Hc, Qc),
              Fh++);
        }
        const nd = Yh ? getSequence(rd) : EMPTY_ARR;
        for (Sh = nd.length - 1, Gl = Lh - 1; Gl >= 0; Gl--) {
          const $h = yh + Gl,
            Rh = bl[$h],
            Hh = $h + 1 < ch ? bl[$h + 1].el : Rl;
          rd[Gl] === 0
            ? ht(null, Rh, Pl, Hh, Wl, Kl, th, Hc, Qc)
            : Yh && (Sh < 0 || Gl !== nd[Sh] ? ih(Rh, Pl, Hh, 2) : Sh--);
        }
      }
    },
    ih = (gl, bl, Pl, Rl, Wl = null) => {
      const { el: Kl, type: th, transition: Hc, children: Qc, shapeFlag: Gl } = gl;
      if (Gl & 6) {
        ih(gl.component.subTree, bl, Pl, Rl);
        return;
      }
      if (Gl & 128) {
        gl.suspense.move(bl, Pl, Rl);
        return;
      }
      if (Gl & 64) {
        th.move(gl, bl, Pl, zc);
        return;
      }
      if (th === Fragment) {
        s(Kl, bl, Pl);
        for (let lh = 0; lh < Qc.length; lh++) ih(Qc[lh], bl, Pl, Rl);
        s(gl.anchor, bl, Pl);
        return;
      }
      if (th === Static) {
        Wi(gl, bl, Pl);
        return;
      }
      if (Rl !== 2 && Gl & 1 && Hc)
        if (Rl === 0) Hc.beforeEnter(Kl), s(Kl, bl, Pl), queuePostRenderEffect(() => Hc.enter(Kl), Wl);
        else {
          const { leave: lh, delayLeave: dh, afterLeave: mh } = Hc,
            yh = () => s(Kl, bl, Pl),
            kh = () => {
              lh(Kl, () => {
                yh(), mh && mh();
              });
            };
          dh ? dh(Kl, yh, kh) : kh();
        }
      else s(Kl, bl, Pl);
    },
    ph = (gl, bl, Pl, Rl = !1, Wl = !1) => {
      const {
        type: Kl,
        props: th,
        ref: Hc,
        children: Qc,
        dynamicChildren: Gl,
        shapeFlag: ch,
        patchFlag: lh,
        dirs: dh,
      } = gl;
      if ((Hc != null && setRef(Hc, null, Pl, gl, !0), ch & 256)) {
        bl.ctx.deactivate(gl);
        return;
      }
      const mh = ch & 1 && dh,
        yh = !isAsyncWrapper(gl);
      let kh;
      if ((yh && (kh = th && th.onVnodeBeforeUnmount) && invokeVNodeHook(kh, bl, gl), ch & 6)) bh(gl.component, Pl, Rl);
      else {
        if (ch & 128) {
          gl.suspense.unmount(Pl, Rl);
          return;
        }
        mh && invokeDirectiveHook(gl, null, bl, 'beforeUnmount'),
          ch & 64
            ? gl.type.remove(gl, bl, Pl, Wl, zc, Rl)
            : Gl && (Kl !== Fragment || (lh > 0 && lh & 64))
            ? Ah(Gl, bl, Pl, !1, !0)
            : ((Kl === Fragment && lh & 384) || (!Wl && ch & 16)) && Ah(Qc, bl, Pl),
          Rl && gh(gl);
      }
      ((yh && (kh = th && th.onVnodeUnmounted)) || mh) &&
        queuePostRenderEffect(() => {
          kh && invokeVNodeHook(kh, bl, gl), mh && invokeDirectiveHook(gl, null, bl, 'unmounted');
        }, Pl);
    },
    gh = (gl) => {
      const { type: bl, el: Pl, anchor: Rl, transition: Wl } = gl;
      if (bl === Fragment) {
        xh(Pl, Rl);
        return;
      }
      if (bl === Static) {
        hl(gl);
        return;
      }
      const Kl = () => {
        o(Pl), Wl && !Wl.persisted && Wl.afterLeave && Wl.afterLeave();
      };
      if (gl.shapeFlag & 1 && Wl && !Wl.persisted) {
        const { leave: th, delayLeave: Hc } = Wl,
          Qc = () => th(Pl, Kl);
        Hc ? Hc(gl.el, Kl, Qc) : Qc();
      } else Kl();
    },
    xh = (gl, bl) => {
      let Pl;
      for (; gl !== bl; ) (Pl = V(gl)), o(gl), (gl = Pl);
      o(bl);
    },
    bh = (gl, bl, Pl) => {
      const { bum: Rl, scope: Wl, update: Kl, subTree: th, um: Hc } = gl;
      Rl && invokeArrayFns(Rl),
        Wl.stop(),
        Kl && ((Kl.active = !1), ph(th, gl, bl, Pl)),
        Hc && queuePostRenderEffect(Hc, bl),
        queuePostRenderEffect(() => {
          gl.isUnmounted = !0;
        }, bl),
        bl &&
          bl.pendingBranch &&
          !bl.isUnmounted &&
          gl.asyncDep &&
          !gl.asyncResolved &&
          gl.suspenseId === bl.pendingId &&
          (bl.deps--, bl.deps === 0 && bl.resolve());
    },
    Ah = (gl, bl, Pl, Rl = !1, Wl = !1, Kl = 0) => {
      for (let th = Kl; th < gl.length; th++) ph(gl[th], bl, Pl, Rl, Wl);
    },
    wl = (gl) =>
      gl.shapeFlag & 6 ? wl(gl.component.subTree) : gl.shapeFlag & 128 ? gl.suspense.next() : V(gl.anchor || gl.el),
    zl = (gl, bl, Pl) => {
      gl == null ? bl._vnode && ph(bl._vnode, null, null, !0) : ht(bl._vnode || null, gl, bl, null, null, null, Pl),
        flushPreFlushCbs(),
        flushPostFlushCbs(),
        (bl._vnode = gl);
    },
    zc = { p: ht, um: ph, m: ih, r: gh, mt: Il, mc: Fl, pc: Bl, pbc: kl, n: wl, o: r };
  let Ul, Dh;
  return e && ([Ul, Dh] = e(zc)), { render: zl, hydrate: Ul, createApp: createAppAPI(zl, Ul) };
}
function toggleRecurse({ effect: r, update: e }, n) {
  r.allowRecurse = e.allowRecurse = n;
}
function traverseStaticChildren(r, e, n = !1) {
  const s = r.children,
    o = e.children;
  if (isArray$1(s) && isArray$1(o))
    for (let a = 0; a < s.length; a++) {
      const l = s[a];
      let f = o[a];
      f.shapeFlag & 1 &&
        !f.dynamicChildren &&
        ((f.patchFlag <= 0 || f.patchFlag === 32) && ((f = o[a] = cloneIfMounted(o[a])), (f.el = l.el)),
        n || traverseStaticChildren(l, f)),
        f.type === Text$1 && (f.el = l.el);
    }
}
function getSequence(r) {
  const e = r.slice(),
    n = [0];
  let s, o, a, l, f;
  const m = r.length;
  for (s = 0; s < m; s++) {
    const v = r[s];
    if (v !== 0) {
      if (((o = n[n.length - 1]), r[o] < v)) {
        (e[s] = o), n.push(s);
        continue;
      }
      for (a = 0, l = n.length - 1; a < l; ) (f = (a + l) >> 1), r[n[f]] < v ? (a = f + 1) : (l = f);
      v < r[n[a]] && (a > 0 && (e[s] = n[a - 1]), (n[a] = s));
    }
  }
  for (a = n.length, l = n[a - 1]; a-- > 0; ) (n[a] = l), (l = e[l]);
  return n;
}
const isTeleport = (r) => r.__isTeleport,
  Fragment = Symbol.for('v-fgt'),
  Text$1 = Symbol.for('v-txt'),
  Comment = Symbol.for('v-cmt'),
  Static = Symbol.for('v-stc'),
  blockStack = [];
let currentBlock = null;
function openBlock(r = !1) {
  blockStack.push((currentBlock = r ? null : []));
}
function closeBlock() {
  blockStack.pop(), (currentBlock = blockStack[blockStack.length - 1] || null);
}
let isBlockTreeEnabled = 1;
function setBlockTracking(r) {
  isBlockTreeEnabled += r;
}
function setupBlock(r) {
  return (
    (r.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null),
    closeBlock(),
    isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(r),
    r
  );
}
function createElementBlock(r, e, n, s, o, a) {
  return setupBlock(createBaseVNode(r, e, n, s, o, a, !0));
}
function createBlock(r, e, n, s, o) {
  return setupBlock(createVNode(r, e, n, s, o, !0));
}
function isVNode(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function isSameVNodeType(r, e) {
  return r.type === e.type && r.key === e.key;
}
const InternalObjectKey = '__vInternal',
  normalizeKey = ({ key: r }) => r ?? null,
  normalizeRef = ({ ref: r, ref_key: e, ref_for: n }) => (
    typeof r == 'number' && (r = '' + r),
    r != null
      ? isString(r) || isRef(r) || isFunction$1(r)
        ? { i: currentRenderingInstance, r, k: e, f: !!n }
        : r
      : null
  );
function createBaseVNode(r, e = null, n = null, s = 0, o = null, a = r === Fragment ? 0 : 1, l = !1, f = !1) {
  const m = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && normalizeKey(e),
    ref: e && normalizeRef(e),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a,
    patchFlag: s,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance,
  };
  return (
    f ? (normalizeChildren(m, n), a & 128 && r.normalize(m)) : n && (m.shapeFlag |= isString(n) ? 8 : 16),
    isBlockTreeEnabled > 0 &&
      !l &&
      currentBlock &&
      (m.patchFlag > 0 || a & 6) &&
      m.patchFlag !== 32 &&
      currentBlock.push(m),
    m
  );
}
const createVNode = _createVNode;
function _createVNode(r, e = null, n = null, s = 0, o = null, a = !1) {
  if (((!r || r === NULL_DYNAMIC_COMPONENT) && (r = Comment), isVNode(r))) {
    const f = cloneVNode(r, e, !0);
    return (
      n && normalizeChildren(f, n),
      isBlockTreeEnabled > 0 &&
        !a &&
        currentBlock &&
        (f.shapeFlag & 6 ? (currentBlock[currentBlock.indexOf(r)] = f) : currentBlock.push(f)),
      (f.patchFlag |= -2),
      f
    );
  }
  if ((isClassComponent(r) && (r = r.__vccOpts), e)) {
    e = guardReactiveProps(e);
    let { class: f, style: m } = e;
    f && !isString(f) && (e.class = normalizeClass(f)),
      isObject$2(m) && (isProxy(m) && !isArray$1(m) && (m = extend$1({}, m)), (e.style = normalizeStyle(m)));
  }
  const l = isString(r) ? 1 : isSuspense(r) ? 128 : isTeleport(r) ? 64 : isObject$2(r) ? 4 : isFunction$1(r) ? 2 : 0;
  return createBaseVNode(r, e, n, s, o, l, a, !0);
}
function guardReactiveProps(r) {
  return r ? (isProxy(r) || InternalObjectKey in r ? extend$1({}, r) : r) : null;
}
function cloneVNode(r, e, n = !1) {
  const { props: s, ref: o, patchFlag: a, children: l } = r,
    f = e ? mergeProps(s || {}, e) : s;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: f,
    key: f && normalizeKey(f),
    ref:
      e && e.ref ? (n && o ? (isArray$1(o) ? o.concat(normalizeRef(e)) : [o, normalizeRef(e)]) : normalizeRef(e)) : o,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: l,
    target: r.target,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    patchFlag: e && r.type !== Fragment ? (a === -1 ? 16 : a | 16) : a,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: r.transition,
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && cloneVNode(r.ssContent),
    ssFallback: r.ssFallback && cloneVNode(r.ssFallback),
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce,
  };
}
function createTextVNode(r = ' ', e = 0) {
  return createVNode(Text$1, null, r, e);
}
function createCommentVNode(r = '', e = !1) {
  return e ? (openBlock(), createBlock(Comment, null, r)) : createVNode(Comment, null, r);
}
function normalizeVNode(r) {
  return r == null || typeof r == 'boolean'
    ? createVNode(Comment)
    : isArray$1(r)
    ? createVNode(Fragment, null, r.slice())
    : typeof r == 'object'
    ? cloneIfMounted(r)
    : createVNode(Text$1, null, String(r));
}
function cloneIfMounted(r) {
  return (r.el === null && r.patchFlag !== -1) || r.memo ? r : cloneVNode(r);
}
function normalizeChildren(r, e) {
  let n = 0;
  const { shapeFlag: s } = r;
  if (e == null) e = null;
  else if (isArray$1(e)) n = 16;
  else if (typeof e == 'object')
    if (s & 65) {
      const o = e.default;
      o && (o._c && (o._d = !1), normalizeChildren(r, o()), o._c && (o._d = !0));
      return;
    } else {
      n = 32;
      const o = e._;
      !o && !(InternalObjectKey in e)
        ? (e._ctx = currentRenderingInstance)
        : o === 3 &&
          currentRenderingInstance &&
          (currentRenderingInstance.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (r.patchFlag |= 1024)));
    }
  else
    isFunction$1(e)
      ? ((e = { default: e, _ctx: currentRenderingInstance }), (n = 32))
      : ((e = String(e)), s & 64 ? ((n = 16), (e = [createTextVNode(e)])) : (n = 8));
  (r.children = e), (r.shapeFlag |= n);
}
function mergeProps(...r) {
  const e = {};
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    for (const o in s)
      if (o === 'class') e.class !== s.class && (e.class = normalizeClass([e.class, s.class]));
      else if (o === 'style') e.style = normalizeStyle([e.style, s.style]);
      else if (isOn(o)) {
        const a = e[o],
          l = s[o];
        l && a !== l && !(isArray$1(a) && a.includes(l)) && (e[o] = a ? [].concat(a, l) : l);
      } else o !== '' && (e[o] = s[o]);
  }
  return e;
}
function invokeVNodeHook(r, e, n, s = null) {
  callWithAsyncErrorHandling(r, e, 7, [n, s]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(r, e, n) {
  const s = r.type,
    o = (e ? e.appContext : r.appContext) || emptyAppContext,
    a = {
      uid: uid++,
      vnode: r,
      type: s,
      parent: e,
      appContext: o,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new EffectScope(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: e ? e.provides : Object.create(o.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(s, o),
      emitsOptions: normalizeEmitsOptions(s, o),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: s.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null,
    };
  return (a.ctx = { _: a }), (a.root = e ? e.root : a), (a.emit = emit.bind(null, a)), r.ce && r.ce(a), a;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance,
  globalCurrentInstanceSetters,
  settersKey = '__VUE_INSTANCE_SETTERS__';
(globalCurrentInstanceSetters = getGlobalThis()[settersKey]) ||
  (globalCurrentInstanceSetters = getGlobalThis()[settersKey] = []),
  globalCurrentInstanceSetters.push((r) => (currentInstance = r)),
  (internalSetCurrentInstance = (r) => {
    globalCurrentInstanceSetters.length > 1
      ? globalCurrentInstanceSetters.forEach((e) => e(r))
      : globalCurrentInstanceSetters[0](r);
  });
const setCurrentInstance = (r) => {
    internalSetCurrentInstance(r), r.scope.on();
  },
  unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off(), internalSetCurrentInstance(null);
  };
function isStatefulComponent(r) {
  return r.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = !1;
function setupComponent(r, e = !1) {
  isInSSRComponentSetup = e;
  const { props: n, children: s } = r.vnode,
    o = isStatefulComponent(r);
  initProps(r, n, o, e), initSlots(r, s);
  const a = o ? setupStatefulComponent(r, e) : void 0;
  return (isInSSRComponentSetup = !1), a;
}
function setupStatefulComponent(r, e) {
  const n = r.type;
  (r.accessCache = Object.create(null)), (r.proxy = markRaw(new Proxy(r.ctx, PublicInstanceProxyHandlers)));
  const { setup: s } = n;
  if (s) {
    const o = (r.setupContext = s.length > 1 ? createSetupContext(r) : null);
    setCurrentInstance(r), pauseTracking();
    const a = callWithErrorHandling(s, r, 0, [r.props, o]);
    if ((resetTracking(), unsetCurrentInstance(), isPromise(a))) {
      if ((a.then(unsetCurrentInstance, unsetCurrentInstance), e))
        return a
          .then((l) => {
            handleSetupResult(r, l, e);
          })
          .catch((l) => {
            handleError$1(l, r, 0);
          });
      r.asyncDep = a;
    } else handleSetupResult(r, a, e);
  } else finishComponentSetup(r, e);
}
function handleSetupResult(r, e, n) {
  isFunction$1(e)
    ? r.type.__ssrInlineRender
      ? (r.ssrRender = e)
      : (r.render = e)
    : isObject$2(e) && (r.setupState = proxyRefs(e)),
    finishComponentSetup(r, n);
}
let compile;
function finishComponentSetup(r, e, n) {
  const s = r.type;
  if (!r.render) {
    if (!e && compile && !s.render) {
      const o = s.template || resolveMergedOptions(r).template;
      if (o) {
        const { isCustomElement: a, compilerOptions: l } = r.appContext.config,
          { delimiters: f, compilerOptions: m } = s,
          v = extend$1(extend$1({ isCustomElement: a, delimiters: f }, l), m);
        s.render = compile(o, v);
      }
    }
    r.render = s.render || NOOP;
  }
  setCurrentInstance(r), pauseTracking(), applyOptions(r), resetTracking(), unsetCurrentInstance();
}
function getAttrsProxy(r) {
  return (
    r.attrsProxy ||
    (r.attrsProxy = new Proxy(r.attrs, {
      get(e, n) {
        return track(r, 'get', '$attrs'), e[n];
      },
    }))
  );
}
function createSetupContext(r) {
  const e = (n) => {
    r.exposed = n || {};
  };
  return {
    get attrs() {
      return getAttrsProxy(r);
    },
    slots: r.slots,
    emit: r.emit,
    expose: e,
  };
}
function getExposeProxy(r) {
  if (r.exposed)
    return (
      r.exposeProxy ||
      (r.exposeProxy = new Proxy(proxyRefs(markRaw(r.exposed)), {
        get(e, n) {
          if (n in e) return e[n];
          if (n in publicPropertiesMap) return publicPropertiesMap[n](r);
        },
        has(e, n) {
          return n in e || n in publicPropertiesMap;
        },
      }))
    );
}
function getComponentName(r, e = !0) {
  return isFunction$1(r) ? r.displayName || r.name : r.name || (e && r.__name);
}
function isClassComponent(r) {
  return isFunction$1(r) && '__vccOpts' in r;
}
const computed = (r, e) => computed$1(r, e, isInSSRComponentSetup);
function h$1(r, e, n) {
  const s = arguments.length;
  return s === 2
    ? isObject$2(e) && !isArray$1(e)
      ? isVNode(e)
        ? createVNode(r, null, [e])
        : createVNode(r, e)
      : createVNode(r, null, e)
    : (s > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : s === 3 && isVNode(n) && (n = [n]),
      createVNode(r, e, n));
}
const ssrContextKey = Symbol.for('v-scx'),
  useSSRContext = () => inject(ssrContextKey),
  version = '3.3.4',
  svgNS = 'http://www.w3.org/2000/svg',
  doc$1 = typeof document < 'u' ? document : null,
  templateContainer = doc$1 && doc$1.createElement('template'),
  nodeOps = {
    insert: (r, e, n) => {
      e.insertBefore(r, n || null);
    },
    remove: (r) => {
      const e = r.parentNode;
      e && e.removeChild(r);
    },
    createElement: (r, e, n, s) => {
      const o = e ? doc$1.createElementNS(svgNS, r) : doc$1.createElement(r, n ? { is: n } : void 0);
      return r === 'select' && s && s.multiple != null && o.setAttribute('multiple', s.multiple), o;
    },
    createText: (r) => doc$1.createTextNode(r),
    createComment: (r) => doc$1.createComment(r),
    setText: (r, e) => {
      r.nodeValue = e;
    },
    setElementText: (r, e) => {
      r.textContent = e;
    },
    parentNode: (r) => r.parentNode,
    nextSibling: (r) => r.nextSibling,
    querySelector: (r) => doc$1.querySelector(r),
    setScopeId(r, e) {
      r.setAttribute(e, '');
    },
    insertStaticContent(r, e, n, s, o, a) {
      const l = n ? n.previousSibling : e.lastChild;
      if (o && (o === a || o.nextSibling))
        for (; e.insertBefore(o.cloneNode(!0), n), !(o === a || !(o = o.nextSibling)); );
      else {
        templateContainer.innerHTML = s ? `<svg>${r}</svg>` : r;
        const f = templateContainer.content;
        if (s) {
          const m = f.firstChild;
          for (; m.firstChild; ) f.appendChild(m.firstChild);
          f.removeChild(m);
        }
        e.insertBefore(f, n);
      }
      return [l ? l.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild];
    },
  };
function patchClass(r, e, n) {
  const s = r._vtc;
  s && (e = (e ? [e, ...s] : [...s]).join(' ')),
    e == null ? r.removeAttribute('class') : n ? r.setAttribute('class', e) : (r.className = e);
}
function patchStyle(r, e, n) {
  const s = r.style,
    o = isString(n);
  if (n && !o) {
    if (e && !isString(e)) for (const a in e) n[a] == null && setStyle(s, a, '');
    for (const a in n) setStyle(s, a, n[a]);
  } else {
    const a = s.display;
    o ? e !== n && (s.cssText = n) : e && r.removeAttribute('style'), '_vod' in r && (s.display = a);
  }
}
const importantRE = /\s*!important$/;
function setStyle(r, e, n) {
  if (isArray$1(n)) n.forEach((s) => setStyle(r, e, s));
  else if ((n == null && (n = ''), e.startsWith('--'))) r.setProperty(e, n);
  else {
    const s = autoPrefix(r, e);
    importantRE.test(n) ? r.setProperty(hyphenate(s), n.replace(importantRE, ''), 'important') : (r[s] = n);
  }
}
const prefixes = ['Webkit', 'Moz', 'ms'],
  prefixCache = {};
function autoPrefix(r, e) {
  const n = prefixCache[e];
  if (n) return n;
  let s = camelize(e);
  if (s !== 'filter' && s in r) return (prefixCache[e] = s);
  s = capitalize(s);
  for (let o = 0; o < prefixes.length; o++) {
    const a = prefixes[o] + s;
    if (a in r) return (prefixCache[e] = a);
  }
  return e;
}
const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(r, e, n, s, o) {
  if (s && e.startsWith('xlink:'))
    n == null ? r.removeAttributeNS(xlinkNS, e.slice(6, e.length)) : r.setAttributeNS(xlinkNS, e, n);
  else {
    const a = isSpecialBooleanAttr(e);
    n == null || (a && !includeBooleanAttr(n)) ? r.removeAttribute(e) : r.setAttribute(e, a ? '' : n);
  }
}
function patchDOMProp(r, e, n, s, o, a, l) {
  if (e === 'innerHTML' || e === 'textContent') {
    s && l(s, o, a), (r[e] = n ?? '');
    return;
  }
  const f = r.tagName;
  if (e === 'value' && f !== 'PROGRESS' && !f.includes('-')) {
    r._value = n;
    const v = f === 'OPTION' ? r.getAttribute('value') : r.value,
      I = n ?? '';
    v !== I && (r.value = I), n == null && r.removeAttribute(e);
    return;
  }
  let m = !1;
  if (n === '' || n == null) {
    const v = typeof r[e];
    v === 'boolean'
      ? (n = includeBooleanAttr(n))
      : n == null && v === 'string'
      ? ((n = ''), (m = !0))
      : v === 'number' && ((n = 0), (m = !0));
  }
  try {
    r[e] = n;
  } catch {}
  m && r.removeAttribute(e);
}
function addEventListener(r, e, n, s) {
  r.addEventListener(e, n, s);
}
function removeEventListener(r, e, n, s) {
  r.removeEventListener(e, n, s);
}
function patchEvent(r, e, n, s, o = null) {
  const a = r._vei || (r._vei = {}),
    l = a[e];
  if (s && l) l.value = s;
  else {
    const [f, m] = parseName(e);
    if (s) {
      const v = (a[e] = createInvoker(s, o));
      addEventListener(r, f, v, m);
    } else l && (removeEventListener(r, f, l, m), (a[e] = void 0));
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(r) {
  let e;
  if (optionsModifierRE.test(r)) {
    e = {};
    let s;
    for (; (s = r.match(optionsModifierRE)); ) (r = r.slice(0, r.length - s[0].length)), (e[s[0].toLowerCase()] = !0);
  }
  return [r[2] === ':' ? r.slice(3) : hyphenate(r.slice(2)), e];
}
let cachedNow = 0;
const p = Promise.resolve(),
  getNow = () => cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now()));
function createInvoker(r, e) {
  const n = (s) => {
    if (!s._vts) s._vts = Date.now();
    else if (s._vts <= n.attached) return;
    callWithAsyncErrorHandling(patchStopImmediatePropagation(s, n.value), e, 5, [s]);
  };
  return (n.value = r), (n.attached = getNow()), n;
}
function patchStopImmediatePropagation(r, e) {
  if (isArray$1(e)) {
    const n = r.stopImmediatePropagation;
    return (
      (r.stopImmediatePropagation = () => {
        n.call(r), (r._stopped = !0);
      }),
      e.map((s) => (o) => !o._stopped && s && s(o))
    );
  } else return e;
}
const nativeOnRE = /^on[a-z]/,
  patchProp = (r, e, n, s, o = !1, a, l, f, m) => {
    e === 'class'
      ? patchClass(r, s, o)
      : e === 'style'
      ? patchStyle(r, n, s)
      : isOn(e)
      ? isModelListener(e) || patchEvent(r, e, n, s, l)
      : (e[0] === '.' ? ((e = e.slice(1)), !0) : e[0] === '^' ? ((e = e.slice(1)), !1) : shouldSetAsProp(r, e, s, o))
      ? patchDOMProp(r, e, s, a, l, f, m)
      : (e === 'true-value' ? (r._trueValue = s) : e === 'false-value' && (r._falseValue = s), patchAttr(r, e, s, o));
  };
function shouldSetAsProp(r, e, n, s) {
  return s
    ? !!(e === 'innerHTML' || e === 'textContent' || (e in r && nativeOnRE.test(e) && isFunction$1(n)))
    : e === 'spellcheck' ||
      e === 'draggable' ||
      e === 'translate' ||
      e === 'form' ||
      (e === 'list' && r.tagName === 'INPUT') ||
      (e === 'type' && r.tagName === 'TEXTAREA') ||
      (nativeOnRE.test(e) && isString(n))
    ? !1
    : e in r;
}
const TRANSITION = 'transition',
  ANIMATION = 'animation',
  Transition = (r, { slots: e }) => h$1(BaseTransition, resolveTransitionProps(r), e);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: { type: Boolean, default: !0 },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String,
};
Transition.props = extend$1({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
const callHook = (r, e = []) => {
    isArray$1(r) ? r.forEach((n) => n(...e)) : r && r(...e);
  },
  hasExplicitCallback = (r) => (r ? (isArray$1(r) ? r.some((e) => e.length > 1) : r.length > 1) : !1);
function resolveTransitionProps(r) {
  const e = {};
  for (const Jl in r) Jl in DOMTransitionPropsValidators || (e[Jl] = r[Jl]);
  if (r.css === !1) return e;
  const {
      name: n = 'v',
      type: s,
      duration: o,
      enterFromClass: a = `${n}-enter-from`,
      enterActiveClass: l = `${n}-enter-active`,
      enterToClass: f = `${n}-enter-to`,
      appearFromClass: m = a,
      appearActiveClass: v = l,
      appearToClass: I = f,
      leaveFromClass: L = `${n}-leave-from`,
      leaveActiveClass: V = `${n}-leave-active`,
      leaveToClass: se = `${n}-leave-to`,
    } = r,
    Ee = normalizeDuration(o),
    ht = Ee && Ee[0],
    ar = Ee && Ee[1],
    {
      onBeforeEnter: $i,
      onEnter: tl,
      onEnterCancelled: Wi,
      onLeave: hl,
      onLeaveCancelled: fl,
      onBeforeAppear: dl = $i,
      onAppear: Al = tl,
      onAppearCancelled: Fl = Wi,
    } = e,
    vl = (Jl, Kc, Il) => {
      removeTransitionClass(Jl, Kc ? I : f), removeTransitionClass(Jl, Kc ? v : l), Il && Il();
    },
    kl = (Jl, Kc) => {
      (Jl._isLeaving = !1),
        removeTransitionClass(Jl, L),
        removeTransitionClass(Jl, se),
        removeTransitionClass(Jl, V),
        Kc && Kc();
    },
    El = (Jl) => (Kc, Il) => {
      const Ll = Jl ? Al : tl,
        Nl = () => vl(Kc, Jl, Il);
      callHook(Ll, [Kc, Nl]),
        nextFrame(() => {
          removeTransitionClass(Kc, Jl ? m : a),
            addTransitionClass(Kc, Jl ? I : f),
            hasExplicitCallback(Ll) || whenTransitionEnds(Kc, s, ht, Nl);
        });
    };
  return extend$1(e, {
    onBeforeEnter(Jl) {
      callHook($i, [Jl]), addTransitionClass(Jl, a), addTransitionClass(Jl, l);
    },
    onBeforeAppear(Jl) {
      callHook(dl, [Jl]), addTransitionClass(Jl, m), addTransitionClass(Jl, v);
    },
    onEnter: El(!1),
    onAppear: El(!0),
    onLeave(Jl, Kc) {
      Jl._isLeaving = !0;
      const Il = () => kl(Jl, Kc);
      addTransitionClass(Jl, L),
        forceReflow(),
        addTransitionClass(Jl, V),
        nextFrame(() => {
          Jl._isLeaving &&
            (removeTransitionClass(Jl, L),
            addTransitionClass(Jl, se),
            hasExplicitCallback(hl) || whenTransitionEnds(Jl, s, ar, Il));
        }),
        callHook(hl, [Jl, Il]);
    },
    onEnterCancelled(Jl) {
      vl(Jl, !1), callHook(Wi, [Jl]);
    },
    onAppearCancelled(Jl) {
      vl(Jl, !0), callHook(Fl, [Jl]);
    },
    onLeaveCancelled(Jl) {
      kl(Jl), callHook(fl, [Jl]);
    },
  });
}
function normalizeDuration(r) {
  if (r == null) return null;
  if (isObject$2(r)) return [NumberOf(r.enter), NumberOf(r.leave)];
  {
    const e = NumberOf(r);
    return [e, e];
  }
}
function NumberOf(r) {
  return toNumber(r);
}
function addTransitionClass(r, e) {
  e.split(/\s+/).forEach((n) => n && r.classList.add(n)), (r._vtc || (r._vtc = new Set())).add(e);
}
function removeTransitionClass(r, e) {
  e.split(/\s+/).forEach((s) => s && r.classList.remove(s));
  const { _vtc: n } = r;
  n && (n.delete(e), n.size || (r._vtc = void 0));
}
function nextFrame(r) {
  requestAnimationFrame(() => {
    requestAnimationFrame(r);
  });
}
let endId = 0;
function whenTransitionEnds(r, e, n, s) {
  const o = (r._endId = ++endId),
    a = () => {
      o === r._endId && s();
    };
  if (n) return setTimeout(a, n);
  const { type: l, timeout: f, propCount: m } = getTransitionInfo(r, e);
  if (!l) return s();
  const v = l + 'end';
  let I = 0;
  const L = () => {
      r.removeEventListener(v, V), a();
    },
    V = (se) => {
      se.target === r && ++I >= m && L();
    };
  setTimeout(() => {
    I < m && L();
  }, f + 1),
    r.addEventListener(v, V);
}
function getTransitionInfo(r, e) {
  const n = window.getComputedStyle(r),
    s = (Ee) => (n[Ee] || '').split(', '),
    o = s(`${TRANSITION}Delay`),
    a = s(`${TRANSITION}Duration`),
    l = getTimeout(o, a),
    f = s(`${ANIMATION}Delay`),
    m = s(`${ANIMATION}Duration`),
    v = getTimeout(f, m);
  let I = null,
    L = 0,
    V = 0;
  e === TRANSITION
    ? l > 0 && ((I = TRANSITION), (L = l), (V = a.length))
    : e === ANIMATION
    ? v > 0 && ((I = ANIMATION), (L = v), (V = m.length))
    : ((L = Math.max(l, v)),
      (I = L > 0 ? (l > v ? TRANSITION : ANIMATION) : null),
      (V = I ? (I === TRANSITION ? a.length : m.length) : 0));
  const se = I === TRANSITION && /\b(transform|all)(,|$)/.test(s(`${TRANSITION}Property`).toString());
  return { type: I, timeout: L, propCount: V, hasTransform: se };
}
function getTimeout(r, e) {
  for (; r.length < e.length; ) r = r.concat(r);
  return Math.max(...e.map((n, s) => toMs(n) + toMs(r[s])));
}
function toMs(r) {
  return Number(r.slice(0, -1).replace(',', '.')) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'],
  modifierGuards = {
    stop: (r) => r.stopPropagation(),
    prevent: (r) => r.preventDefault(),
    self: (r) => r.target !== r.currentTarget,
    ctrl: (r) => !r.ctrlKey,
    shift: (r) => !r.shiftKey,
    alt: (r) => !r.altKey,
    meta: (r) => !r.metaKey,
    left: (r) => 'button' in r && r.button !== 0,
    middle: (r) => 'button' in r && r.button !== 1,
    right: (r) => 'button' in r && r.button !== 2,
    exact: (r, e) => systemModifiers.some((n) => r[`${n}Key`] && !e.includes(n)),
  },
  withModifiers =
    (r, e) =>
    (n, ...s) => {
      for (let o = 0; o < e.length; o++) {
        const a = modifierGuards[e[o]];
        if (a && a(n, e)) return;
      }
      return r(n, ...s);
    },
  keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace',
  },
  withKeys = (r, e) => (n) => {
    if (!('key' in n)) return;
    const s = hyphenate(n.key);
    if (e.some((o) => o === s || keyNames[o] === s)) return r(n);
  },
  vShow = {
    beforeMount(r, { value: e }, { transition: n }) {
      (r._vod = r.style.display === 'none' ? '' : r.style.display), n && e ? n.beforeEnter(r) : setDisplay(r, e);
    },
    mounted(r, { value: e }, { transition: n }) {
      n && e && n.enter(r);
    },
    updated(r, { value: e, oldValue: n }, { transition: s }) {
      !e != !n &&
        (s
          ? e
            ? (s.beforeEnter(r), setDisplay(r, !0), s.enter(r))
            : s.leave(r, () => {
                setDisplay(r, !1);
              })
          : setDisplay(r, e));
    },
    beforeUnmount(r, { value: e }) {
      setDisplay(r, e);
    },
  };
function setDisplay(r, e) {
  r.style.display = e ? r._vod : 'none';
}
const rendererOptions = extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const render = (...r) => {
    ensureRenderer().render(...r);
  },
  createApp = (...r) => {
    const e = ensureRenderer().createApp(...r),
      { mount: n } = e;
    return (
      (e.mount = (s) => {
        const o = normalizeContainer(s);
        if (!o) return;
        const a = e._component;
        !isFunction$1(a) && !a.render && !a.template && (a.template = o.innerHTML), (o.innerHTML = '');
        const l = n(o, !1, o instanceof SVGElement);
        return o instanceof Element && (o.removeAttribute('v-cloak'), o.setAttribute('data-v-app', '')), l;
      }),
      e
    );
  };
function normalizeContainer(r) {
  return isString(r) ? document.querySelector(r) : r;
}
var isVue2 = !1;
/*!
 * pinia v2.1.6
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ let activePinia;
const setActivePinia = (r) => (activePinia = r),
  piniaSymbol = Symbol();
function isPlainObject(r) {
  return (
    r &&
    typeof r == 'object' &&
    Object.prototype.toString.call(r) === '[object Object]' &&
    typeof r.toJSON != 'function'
  );
}
var MutationType;
(function (r) {
  (r.direct = 'direct'), (r.patchObject = 'patch object'), (r.patchFunction = 'patch function');
})(MutationType || (MutationType = {}));
function createPinia() {
  const r = effectScope(!0),
    e = r.run(() => ref({}));
  let n = [],
    s = [];
  const o = markRaw({
    install(a) {
      setActivePinia(o),
        (o._a = a),
        a.provide(piniaSymbol, o),
        (a.config.globalProperties.$pinia = o),
        s.forEach((l) => n.push(l)),
        (s = []);
    },
    use(a) {
      return !this._a && !isVue2 ? s.push(a) : n.push(a), this;
    },
    _p: n,
    _a: null,
    _e: r,
    _s: new Map(),
    state: e,
  });
  return o;
}
const noop$3 = () => {};
function addSubscription(r, e, n, s = noop$3) {
  r.push(e);
  const o = () => {
    const a = r.indexOf(e);
    a > -1 && (r.splice(a, 1), s());
  };
  return !n && getCurrentScope() && onScopeDispose(o), o;
}
function triggerSubscriptions(r, ...e) {
  r.slice().forEach((n) => {
    n(...e);
  });
}
const fallbackRunWithContext = (r) => r();
function mergeReactiveObjects(r, e) {
  r instanceof Map && e instanceof Map && e.forEach((n, s) => r.set(s, n)),
    r instanceof Set && e instanceof Set && e.forEach(r.add, r);
  for (const n in e) {
    if (!e.hasOwnProperty(n)) continue;
    const s = e[n],
      o = r[n];
    isPlainObject(o) && isPlainObject(s) && r.hasOwnProperty(n) && !isRef(s) && !isReactive(s)
      ? (r[n] = mergeReactiveObjects(o, s))
      : (r[n] = s);
  }
  return r;
}
const skipHydrateSymbol = Symbol();
function shouldHydrate(r) {
  return !isPlainObject(r) || !r.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$1 } = Object;
function isComputed(r) {
  return !!(isRef(r) && r.effect);
}
function createOptionsStore(r, e, n, s) {
  const { state: o, actions: a, getters: l } = e,
    f = n.state.value[r];
  let m;
  function v() {
    f || (n.state.value[r] = o ? o() : {});
    const I = toRefs(n.state.value[r]);
    return assign$1(
      I,
      a,
      Object.keys(l || {}).reduce(
        (L, V) => (
          (L[V] = markRaw(
            computed(() => {
              setActivePinia(n);
              const se = n._s.get(r);
              return l[V].call(se, se);
            }),
          )),
          L
        ),
        {},
      ),
    );
  }
  return (m = createSetupStore(r, v, e, n, s, !0)), m;
}
function createSetupStore(r, e, n = {}, s, o, a) {
  let l;
  const f = assign$1({ actions: {} }, n),
    m = { deep: !0 };
  let v,
    I,
    L = [],
    V = [],
    se;
  const Ee = s.state.value[r];
  !a && !Ee && (s.state.value[r] = {}), ref({});
  let ht;
  function ar(Fl) {
    let vl;
    (v = I = !1),
      typeof Fl == 'function'
        ? (Fl(s.state.value[r]), (vl = { type: MutationType.patchFunction, storeId: r, events: se }))
        : (mergeReactiveObjects(s.state.value[r], Fl),
          (vl = { type: MutationType.patchObject, payload: Fl, storeId: r, events: se }));
    const kl = (ht = Symbol());
    nextTick().then(() => {
      ht === kl && (v = !0);
    }),
      (I = !0),
      triggerSubscriptions(L, vl, s.state.value[r]);
  }
  const $i = a
    ? function () {
        const { state: vl } = n,
          kl = vl ? vl() : {};
        this.$patch((El) => {
          assign$1(El, kl);
        });
      }
    : noop$3;
  function tl() {
    l.stop(), (L = []), (V = []), s._s.delete(r);
  }
  function Wi(Fl, vl) {
    return function () {
      setActivePinia(s);
      const kl = Array.from(arguments),
        El = [],
        Jl = [];
      function Kc(Nl) {
        El.push(Nl);
      }
      function Il(Nl) {
        Jl.push(Nl);
      }
      triggerSubscriptions(V, { args: kl, name: Fl, store: fl, after: Kc, onError: Il });
      let Ll;
      try {
        Ll = vl.apply(this && this.$id === r ? this : fl, kl);
      } catch (Nl) {
        throw (triggerSubscriptions(Jl, Nl), Nl);
      }
      return Ll instanceof Promise
        ? Ll.then((Nl) => (triggerSubscriptions(El, Nl), Nl)).catch(
            (Nl) => (triggerSubscriptions(Jl, Nl), Promise.reject(Nl)),
          )
        : (triggerSubscriptions(El, Ll), Ll);
    };
  }
  const hl = {
      _p: s,
      $id: r,
      $onAction: addSubscription.bind(null, V),
      $patch: ar,
      $reset: $i,
      $subscribe(Fl, vl = {}) {
        const kl = addSubscription(L, Fl, vl.detached, () => El()),
          El = l.run(() =>
            watch(
              () => s.state.value[r],
              (Jl) => {
                (vl.flush === 'sync' ? I : v) && Fl({ storeId: r, type: MutationType.direct, events: se }, Jl);
              },
              assign$1({}, m, vl),
            ),
          );
        return kl;
      },
      $dispose: tl,
    },
    fl = reactive(hl);
  s._s.set(r, fl);
  const dl = (s._a && s._a.runWithContext) || fallbackRunWithContext,
    Al = s._e.run(() => ((l = effectScope()), dl(() => l.run(e))));
  for (const Fl in Al) {
    const vl = Al[Fl];
    if ((isRef(vl) && !isComputed(vl)) || isReactive(vl))
      a ||
        (Ee && shouldHydrate(vl) && (isRef(vl) ? (vl.value = Ee[Fl]) : mergeReactiveObjects(vl, Ee[Fl])),
        (s.state.value[r][Fl] = vl));
    else if (typeof vl == 'function') {
      const kl = Wi(Fl, vl);
      (Al[Fl] = kl), (f.actions[Fl] = vl);
    }
  }
  return (
    assign$1(fl, Al),
    assign$1(toRaw(fl), Al),
    Object.defineProperty(fl, '$state', {
      get: () => s.state.value[r],
      set: (Fl) => {
        ar((vl) => {
          assign$1(vl, Fl);
        });
      },
    }),
    s._p.forEach((Fl) => {
      assign$1(
        fl,
        l.run(() => Fl({ store: fl, app: s._a, pinia: s, options: f })),
      );
    }),
    Ee && a && n.hydrate && n.hydrate(fl.$state, Ee),
    (v = !0),
    (I = !0),
    fl
  );
}
function defineStore(r, e, n) {
  let s, o;
  const a = typeof e == 'function';
  typeof r == 'string' ? ((s = r), (o = a ? n : e)) : ((o = r), (s = r.id));
  function l(f, m) {
    const v = hasInjectionContext();
    return (
      (f = f || (v ? inject(piniaSymbol, null) : null)),
      f && setActivePinia(f),
      (f = activePinia),
      f._s.has(s) || (a ? createSetupStore(s, e, o, f) : createOptionsStore(s, o, f)),
      f._s.get(s)
    );
  }
  return (l.$id = s), l;
}
function storeToRefs(r) {
  {
    r = toRaw(r);
    const e = {};
    for (const n in r) {
      const s = r[n];
      (isRef(s) || isReactive(s)) && (e[n] = toRef(r, n));
    }
    return e;
  }
}
/*!
 * vue-router v4.2.5
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ const isBrowser = typeof window < 'u';
function isESModule(r) {
  return r.__esModule || r[Symbol.toStringTag] === 'Module';
}
const assign = Object.assign;
function applyToParams(r, e) {
  const n = {};
  for (const s in e) {
    const o = e[s];
    n[s] = isArray(o) ? o.map(r) : r(o);
  }
  return n;
}
const noop$2 = () => {},
  isArray = Array.isArray,
  TRAILING_SLASH_RE = /\/$/,
  removeTrailingSlash = (r) => r.replace(TRAILING_SLASH_RE, '');
function parseURL(r, e, n = '/') {
  let s,
    o = {},
    a = '',
    l = '';
  const f = e.indexOf('#');
  let m = e.indexOf('?');
  return (
    f < m && f >= 0 && (m = -1),
    m > -1 && ((s = e.slice(0, m)), (a = e.slice(m + 1, f > -1 ? f : e.length)), (o = r(a))),
    f > -1 && ((s = s || e.slice(0, f)), (l = e.slice(f, e.length))),
    (s = resolveRelativePath(s ?? e, n)),
    { fullPath: s + (a && '?') + a + l, path: s, query: o, hash: l }
  );
}
function stringifyURL(r, e) {
  const n = e.query ? r(e.query) : '';
  return e.path + (n && '?') + n + (e.hash || '');
}
function stripBase(r, e) {
  return !e || !r.toLowerCase().startsWith(e.toLowerCase()) ? r : r.slice(e.length) || '/';
}
function isSameRouteLocation(r, e, n) {
  const s = e.matched.length - 1,
    o = n.matched.length - 1;
  return (
    s > -1 &&
    s === o &&
    isSameRouteRecord(e.matched[s], n.matched[o]) &&
    isSameRouteLocationParams(e.params, n.params) &&
    r(e.query) === r(n.query) &&
    e.hash === n.hash
  );
}
function isSameRouteRecord(r, e) {
  return (r.aliasOf || r) === (e.aliasOf || e);
}
function isSameRouteLocationParams(r, e) {
  if (Object.keys(r).length !== Object.keys(e).length) return !1;
  for (const n in r) if (!isSameRouteLocationParamsValue(r[n], e[n])) return !1;
  return !0;
}
function isSameRouteLocationParamsValue(r, e) {
  return isArray(r) ? isEquivalentArray(r, e) : isArray(e) ? isEquivalentArray(e, r) : r === e;
}
function isEquivalentArray(r, e) {
  return isArray(e) ? r.length === e.length && r.every((n, s) => n === e[s]) : r.length === 1 && r[0] === e;
}
function resolveRelativePath(r, e) {
  if (r.startsWith('/')) return r;
  if (!r) return e;
  const n = e.split('/'),
    s = r.split('/'),
    o = s[s.length - 1];
  (o === '..' || o === '.') && s.push('');
  let a = n.length - 1,
    l,
    f;
  for (l = 0; l < s.length; l++)
    if (((f = s[l]), f !== '.'))
      if (f === '..') a > 1 && a--;
      else break;
  return n.slice(0, a).join('/') + '/' + s.slice(l - (l === s.length ? 1 : 0)).join('/');
}
var NavigationType;
(function (r) {
  (r.pop = 'pop'), (r.push = 'push');
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function (r) {
  (r.back = 'back'), (r.forward = 'forward'), (r.unknown = '');
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(r) {
  if (!r)
    if (isBrowser) {
      const e = document.querySelector('base');
      (r = (e && e.getAttribute('href')) || '/'), (r = r.replace(/^\w+:\/\/[^\/]+/, ''));
    } else r = '/';
  return r[0] !== '/' && r[0] !== '#' && (r = '/' + r), removeTrailingSlash(r);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(r, e) {
  return r.replace(BEFORE_HASH_RE, '#') + e;
}
function getElementPosition(r, e) {
  const n = document.documentElement.getBoundingClientRect(),
    s = r.getBoundingClientRect();
  return { behavior: e.behavior, left: s.left - n.left - (e.left || 0), top: s.top - n.top - (e.top || 0) };
}
const computeScrollPosition = () => ({ left: window.pageXOffset, top: window.pageYOffset });
function scrollToPosition(r) {
  let e;
  if ('el' in r) {
    const n = r.el,
      s = typeof n == 'string' && n.startsWith('#'),
      o = typeof n == 'string' ? (s ? document.getElementById(n.slice(1)) : document.querySelector(n)) : n;
    if (!o) return;
    e = getElementPosition(o, r);
  } else e = r;
  'scrollBehavior' in document.documentElement.style
    ? window.scrollTo(e)
    : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset);
}
function getScrollKey(r, e) {
  return (history.state ? history.state.position - e : -1) + r;
}
const scrollPositions = new Map();
function saveScrollPosition(r, e) {
  scrollPositions.set(r, e);
}
function getSavedScrollPosition(r) {
  const e = scrollPositions.get(r);
  return scrollPositions.delete(r), e;
}
let createBaseLocation = () => location.protocol + '//' + location.host;
function createCurrentLocation(r, e) {
  const { pathname: n, search: s, hash: o } = e,
    a = r.indexOf('#');
  if (a > -1) {
    let f = o.includes(r.slice(a)) ? r.slice(a).length : 1,
      m = o.slice(f);
    return m[0] !== '/' && (m = '/' + m), stripBase(m, '');
  }
  return stripBase(n, r) + s + o;
}
function useHistoryListeners(r, e, n, s) {
  let o = [],
    a = [],
    l = null;
  const f = ({ state: V }) => {
    const se = createCurrentLocation(r, location),
      Ee = n.value,
      ht = e.value;
    let ar = 0;
    if (V) {
      if (((n.value = se), (e.value = V), l && l === Ee)) {
        l = null;
        return;
      }
      ar = ht ? V.position - ht.position : 0;
    } else s(se);
    o.forEach(($i) => {
      $i(n.value, Ee, {
        delta: ar,
        type: NavigationType.pop,
        direction: ar ? (ar > 0 ? NavigationDirection.forward : NavigationDirection.back) : NavigationDirection.unknown,
      });
    });
  };
  function m() {
    l = n.value;
  }
  function v(V) {
    o.push(V);
    const se = () => {
      const Ee = o.indexOf(V);
      Ee > -1 && o.splice(Ee, 1);
    };
    return a.push(se), se;
  }
  function I() {
    const { history: V } = window;
    V.state && V.replaceState(assign({}, V.state, { scroll: computeScrollPosition() }), '');
  }
  function L() {
    for (const V of a) V();
    (a = []), window.removeEventListener('popstate', f), window.removeEventListener('beforeunload', I);
  }
  return (
    window.addEventListener('popstate', f),
    window.addEventListener('beforeunload', I, { passive: !0 }),
    { pauseListeners: m, listen: v, destroy: L }
  );
}
function buildState(r, e, n, s = !1, o = !1) {
  return {
    back: r,
    current: e,
    forward: n,
    replaced: s,
    position: window.history.length,
    scroll: o ? computeScrollPosition() : null,
  };
}
function useHistoryStateNavigation(r) {
  const { history: e, location: n } = window,
    s = { value: createCurrentLocation(r, n) },
    o = { value: e.state };
  o.value ||
    a(s.value, { back: null, current: s.value, forward: null, position: e.length - 1, replaced: !0, scroll: null }, !0);
  function a(m, v, I) {
    const L = r.indexOf('#'),
      V = L > -1 ? (n.host && document.querySelector('base') ? r : r.slice(L)) + m : createBaseLocation() + r + m;
    try {
      e[I ? 'replaceState' : 'pushState'](v, '', V), (o.value = v);
    } catch (se) {
      console.error(se), n[I ? 'replace' : 'assign'](V);
    }
  }
  function l(m, v) {
    const I = assign({}, e.state, buildState(o.value.back, m, o.value.forward, !0), v, { position: o.value.position });
    a(m, I, !0), (s.value = m);
  }
  function f(m, v) {
    const I = assign({}, o.value, e.state, { forward: m, scroll: computeScrollPosition() });
    a(I.current, I, !0);
    const L = assign({}, buildState(s.value, m, null), { position: I.position + 1 }, v);
    a(m, L, !1), (s.value = m);
  }
  return { location: s, state: o, push: f, replace: l };
}
function createWebHistory(r) {
  r = normalizeBase(r);
  const e = useHistoryStateNavigation(r),
    n = useHistoryListeners(r, e.state, e.location, e.replace);
  function s(a, l = !0) {
    l || n.pauseListeners(), history.go(a);
  }
  const o = assign({ location: '', base: r, go: s, createHref: createHref.bind(null, r) }, e, n);
  return (
    Object.defineProperty(o, 'location', { enumerable: !0, get: () => e.location.value }),
    Object.defineProperty(o, 'state', { enumerable: !0, get: () => e.state.value }),
    o
  );
}
function createWebHashHistory(r) {
  return (
    (r = location.host ? r || location.pathname + location.search : ''),
    r.includes('#') || (r += '#'),
    createWebHistory(r)
  );
}
function isRouteLocation(r) {
  return typeof r == 'string' || (r && typeof r == 'object');
}
function isRouteName(r) {
  return typeof r == 'string' || typeof r == 'symbol';
}
const START_LOCATION_NORMALIZED = {
    path: '/',
    name: void 0,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: void 0,
  },
  NavigationFailureSymbol = Symbol('');
var NavigationFailureType;
(function (r) {
  (r[(r.aborted = 4)] = 'aborted'), (r[(r.cancelled = 8)] = 'cancelled'), (r[(r.duplicated = 16)] = 'duplicated');
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(r, e) {
  return assign(new Error(), { type: r, [NavigationFailureSymbol]: !0 }, e);
}
function isNavigationFailure(r, e) {
  return r instanceof Error && NavigationFailureSymbol in r && (e == null || !!(r.type & e));
}
const BASE_PARAM_PATTERN = '[^/]+?',
  BASE_PATH_PARSER_OPTIONS = { sensitive: !1, strict: !1, start: !0, end: !0 },
  REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(r, e) {
  const n = assign({}, BASE_PATH_PARSER_OPTIONS, e),
    s = [];
  let o = n.start ? '^' : '';
  const a = [];
  for (const v of r) {
    const I = v.length ? [] : [90];
    n.strict && !v.length && (o += '/');
    for (let L = 0; L < v.length; L++) {
      const V = v[L];
      let se = 40 + (n.sensitive ? 0.25 : 0);
      if (V.type === 0) L || (o += '/'), (o += V.value.replace(REGEX_CHARS_RE, '\\$&')), (se += 40);
      else if (V.type === 1) {
        const { value: Ee, repeatable: ht, optional: ar, regexp: $i } = V;
        a.push({ name: Ee, repeatable: ht, optional: ar });
        const tl = $i || BASE_PARAM_PATTERN;
        if (tl !== BASE_PARAM_PATTERN) {
          se += 10;
          try {
            new RegExp(`(${tl})`);
          } catch (hl) {
            throw new Error(`Invalid custom RegExp for param "${Ee}" (${tl}): ` + hl.message);
          }
        }
        let Wi = ht ? `((?:${tl})(?:/(?:${tl}))*)` : `(${tl})`;
        L || (Wi = ar && v.length < 2 ? `(?:/${Wi})` : '/' + Wi),
          ar && (Wi += '?'),
          (o += Wi),
          (se += 20),
          ar && (se += -8),
          ht && (se += -20),
          tl === '.*' && (se += -50);
      }
      I.push(se);
    }
    s.push(I);
  }
  if (n.strict && n.end) {
    const v = s.length - 1;
    s[v][s[v].length - 1] += 0.7000000000000001;
  }
  n.strict || (o += '/?'), n.end ? (o += '$') : n.strict && (o += '(?:/|$)');
  const l = new RegExp(o, n.sensitive ? '' : 'i');
  function f(v) {
    const I = v.match(l),
      L = {};
    if (!I) return null;
    for (let V = 1; V < I.length; V++) {
      const se = I[V] || '',
        Ee = a[V - 1];
      L[Ee.name] = se && Ee.repeatable ? se.split('/') : se;
    }
    return L;
  }
  function m(v) {
    let I = '',
      L = !1;
    for (const V of r) {
      (!L || !I.endsWith('/')) && (I += '/'), (L = !1);
      for (const se of V)
        if (se.type === 0) I += se.value;
        else if (se.type === 1) {
          const { value: Ee, repeatable: ht, optional: ar } = se,
            $i = Ee in v ? v[Ee] : '';
          if (isArray($i) && !ht)
            throw new Error(`Provided param "${Ee}" is an array but it is not repeatable (* or + modifiers)`);
          const tl = isArray($i) ? $i.join('/') : $i;
          if (!tl)
            if (ar) V.length < 2 && (I.endsWith('/') ? (I = I.slice(0, -1)) : (L = !0));
            else throw new Error(`Missing required param "${Ee}"`);
          I += tl;
        }
    }
    return I || '/';
  }
  return { re: l, score: s, keys: a, parse: f, stringify: m };
}
function compareScoreArray(r, e) {
  let n = 0;
  for (; n < r.length && n < e.length; ) {
    const s = e[n] - r[n];
    if (s) return s;
    n++;
  }
  return r.length < e.length
    ? r.length === 1 && r[0] === 40 + 40
      ? -1
      : 1
    : r.length > e.length
    ? e.length === 1 && e[0] === 40 + 40
      ? 1
      : -1
    : 0;
}
function comparePathParserScore(r, e) {
  let n = 0;
  const s = r.score,
    o = e.score;
  for (; n < s.length && n < o.length; ) {
    const a = compareScoreArray(s[n], o[n]);
    if (a) return a;
    n++;
  }
  if (Math.abs(o.length - s.length) === 1) {
    if (isLastScoreNegative(s)) return 1;
    if (isLastScoreNegative(o)) return -1;
  }
  return o.length - s.length;
}
function isLastScoreNegative(r) {
  const e = r[r.length - 1];
  return r.length > 0 && e[e.length - 1] < 0;
}
const ROOT_TOKEN = { type: 0, value: '' },
  VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(r) {
  if (!r) return [[]];
  if (r === '/') return [[ROOT_TOKEN]];
  if (!r.startsWith('/')) throw new Error(`Invalid path "${r}"`);
  function e(se) {
    throw new Error(`ERR (${n})/"${v}": ${se}`);
  }
  let n = 0,
    s = n;
  const o = [];
  let a;
  function l() {
    a && o.push(a), (a = []);
  }
  let f = 0,
    m,
    v = '',
    I = '';
  function L() {
    v &&
      (n === 0
        ? a.push({ type: 0, value: v })
        : n === 1 || n === 2 || n === 3
        ? (a.length > 1 &&
            (m === '*' || m === '+') &&
            e(`A repeatable param (${v}) must be alone in its segment. eg: '/:ids+.`),
          a.push({
            type: 1,
            value: v,
            regexp: I,
            repeatable: m === '*' || m === '+',
            optional: m === '*' || m === '?',
          }))
        : e('Invalid state to consume buffer'),
      (v = ''));
  }
  function V() {
    v += m;
  }
  for (; f < r.length; ) {
    if (((m = r[f++]), m === '\\' && n !== 2)) {
      (s = n), (n = 4);
      continue;
    }
    switch (n) {
      case 0:
        m === '/' ? (v && L(), l()) : m === ':' ? (L(), (n = 1)) : V();
        break;
      case 4:
        V(), (n = s);
        break;
      case 1:
        m === '(' ? (n = 2) : VALID_PARAM_RE.test(m) ? V() : (L(), (n = 0), m !== '*' && m !== '?' && m !== '+' && f--);
        break;
      case 2:
        m === ')' ? (I[I.length - 1] == '\\' ? (I = I.slice(0, -1) + m) : (n = 3)) : (I += m);
        break;
      case 3:
        L(), (n = 0), m !== '*' && m !== '?' && m !== '+' && f--, (I = '');
        break;
      default:
        e('Unknown state');
        break;
    }
  }
  return n === 2 && e(`Unfinished custom RegExp for param "${v}"`), L(), l(), o;
}
function createRouteRecordMatcher(r, e, n) {
  const s = tokensToParser(tokenizePath(r.path), n),
    o = assign(s, { record: r, parent: e, children: [], alias: [] });
  return e && !o.record.aliasOf == !e.record.aliasOf && e.children.push(o), o;
}
function createRouterMatcher(r, e) {
  const n = [],
    s = new Map();
  e = mergeOptions({ strict: !1, end: !0, sensitive: !1 }, e);
  function o(I) {
    return s.get(I);
  }
  function a(I, L, V) {
    const se = !V,
      Ee = normalizeRouteRecord(I);
    Ee.aliasOf = V && V.record;
    const ht = mergeOptions(e, I),
      ar = [Ee];
    if ('alias' in I) {
      const Wi = typeof I.alias == 'string' ? [I.alias] : I.alias;
      for (const hl of Wi)
        ar.push(
          assign({}, Ee, { components: V ? V.record.components : Ee.components, path: hl, aliasOf: V ? V.record : Ee }),
        );
    }
    let $i, tl;
    for (const Wi of ar) {
      const { path: hl } = Wi;
      if (L && hl[0] !== '/') {
        const fl = L.record.path,
          dl = fl[fl.length - 1] === '/' ? '' : '/';
        Wi.path = L.record.path + (hl && dl + hl);
      }
      if (
        (($i = createRouteRecordMatcher(Wi, L, ht)),
        V
          ? V.alias.push($i)
          : ((tl = tl || $i), tl !== $i && tl.alias.push($i), se && I.name && !isAliasRecord($i) && l(I.name)),
        Ee.children)
      ) {
        const fl = Ee.children;
        for (let dl = 0; dl < fl.length; dl++) a(fl[dl], $i, V && V.children[dl]);
      }
      (V = V || $i),
        (($i.record.components && Object.keys($i.record.components).length) || $i.record.name || $i.record.redirect) &&
          m($i);
    }
    return tl
      ? () => {
          l(tl);
        }
      : noop$2;
  }
  function l(I) {
    if (isRouteName(I)) {
      const L = s.get(I);
      L && (s.delete(I), n.splice(n.indexOf(L), 1), L.children.forEach(l), L.alias.forEach(l));
    } else {
      const L = n.indexOf(I);
      L > -1 && (n.splice(L, 1), I.record.name && s.delete(I.record.name), I.children.forEach(l), I.alias.forEach(l));
    }
  }
  function f() {
    return n;
  }
  function m(I) {
    let L = 0;
    for (
      ;
      L < n.length &&
      comparePathParserScore(I, n[L]) >= 0 &&
      (I.record.path !== n[L].record.path || !isRecordChildOf(I, n[L]));

    )
      L++;
    n.splice(L, 0, I), I.record.name && !isAliasRecord(I) && s.set(I.record.name, I);
  }
  function v(I, L) {
    let V,
      se = {},
      Ee,
      ht;
    if ('name' in I && I.name) {
      if (((V = s.get(I.name)), !V)) throw createRouterError(1, { location: I });
      (ht = V.record.name),
        (se = assign(
          paramsFromLocation(
            L.params,
            V.keys.filter((tl) => !tl.optional).map((tl) => tl.name),
          ),
          I.params &&
            paramsFromLocation(
              I.params,
              V.keys.map((tl) => tl.name),
            ),
        )),
        (Ee = V.stringify(se));
    } else if ('path' in I)
      (Ee = I.path), (V = n.find((tl) => tl.re.test(Ee))), V && ((se = V.parse(Ee)), (ht = V.record.name));
    else {
      if (((V = L.name ? s.get(L.name) : n.find((tl) => tl.re.test(L.path))), !V))
        throw createRouterError(1, { location: I, currentLocation: L });
      (ht = V.record.name), (se = assign({}, L.params, I.params)), (Ee = V.stringify(se));
    }
    const ar = [];
    let $i = V;
    for (; $i; ) ar.unshift($i.record), ($i = $i.parent);
    return { name: ht, path: Ee, params: se, matched: ar, meta: mergeMetaFields(ar) };
  }
  return r.forEach((I) => a(I)), { addRoute: a, resolve: v, removeRoute: l, getRoutes: f, getRecordMatcher: o };
}
function paramsFromLocation(r, e) {
  const n = {};
  for (const s of e) s in r && (n[s] = r[s]);
  return n;
}
function normalizeRouteRecord(r) {
  return {
    path: r.path,
    redirect: r.redirect,
    name: r.name,
    meta: r.meta || {},
    aliasOf: void 0,
    beforeEnter: r.beforeEnter,
    props: normalizeRecordProps(r),
    children: r.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: 'components' in r ? r.components || null : r.component && { default: r.component },
  };
}
function normalizeRecordProps(r) {
  const e = {},
    n = r.props || !1;
  if ('component' in r) e.default = n;
  else for (const s in r.components) e[s] = typeof n == 'object' ? n[s] : n;
  return e;
}
function isAliasRecord(r) {
  for (; r; ) {
    if (r.record.aliasOf) return !0;
    r = r.parent;
  }
  return !1;
}
function mergeMetaFields(r) {
  return r.reduce((e, n) => assign(e, n.meta), {});
}
function mergeOptions(r, e) {
  const n = {};
  for (const s in r) n[s] = s in e ? e[s] : r[s];
  return n;
}
function isRecordChildOf(r, e) {
  return e.children.some((n) => n === r || isRecordChildOf(r, n));
}
const HASH_RE = /#/g,
  AMPERSAND_RE = /&/g,
  SLASH_RE = /\//g,
  EQUAL_RE = /=/g,
  IM_RE = /\?/g,
  PLUS_RE = /\+/g,
  ENC_BRACKET_OPEN_RE = /%5B/g,
  ENC_BRACKET_CLOSE_RE = /%5D/g,
  ENC_CARET_RE = /%5E/g,
  ENC_BACKTICK_RE = /%60/g,
  ENC_CURLY_OPEN_RE = /%7B/g,
  ENC_PIPE_RE = /%7C/g,
  ENC_CURLY_CLOSE_RE = /%7D/g,
  ENC_SPACE_RE = /%20/g;
function commonEncode(r) {
  return encodeURI('' + r)
    .replace(ENC_PIPE_RE, '|')
    .replace(ENC_BRACKET_OPEN_RE, '[')
    .replace(ENC_BRACKET_CLOSE_RE, ']');
}
function encodeHash(r) {
  return commonEncode(r).replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');
}
function encodeQueryValue(r) {
  return commonEncode(r)
    .replace(PLUS_RE, '%2B')
    .replace(ENC_SPACE_RE, '+')
    .replace(HASH_RE, '%23')
    .replace(AMPERSAND_RE, '%26')
    .replace(ENC_BACKTICK_RE, '`')
    .replace(ENC_CURLY_OPEN_RE, '{')
    .replace(ENC_CURLY_CLOSE_RE, '}')
    .replace(ENC_CARET_RE, '^');
}
function encodeQueryKey(r) {
  return encodeQueryValue(r).replace(EQUAL_RE, '%3D');
}
function encodePath(r) {
  return commonEncode(r).replace(HASH_RE, '%23').replace(IM_RE, '%3F');
}
function encodeParam(r) {
  return r == null ? '' : encodePath(r).replace(SLASH_RE, '%2F');
}
function decode(r) {
  try {
    return decodeURIComponent('' + r);
  } catch {}
  return '' + r;
}
function parseQuery(r) {
  const e = {};
  if (r === '' || r === '?') return e;
  const s = (r[0] === '?' ? r.slice(1) : r).split('&');
  for (let o = 0; o < s.length; ++o) {
    const a = s[o].replace(PLUS_RE, ' '),
      l = a.indexOf('='),
      f = decode(l < 0 ? a : a.slice(0, l)),
      m = l < 0 ? null : decode(a.slice(l + 1));
    if (f in e) {
      let v = e[f];
      isArray(v) || (v = e[f] = [v]), v.push(m);
    } else e[f] = m;
  }
  return e;
}
function stringifyQuery(r) {
  let e = '';
  for (let n in r) {
    const s = r[n];
    if (((n = encodeQueryKey(n)), s == null)) {
      s !== void 0 && (e += (e.length ? '&' : '') + n);
      continue;
    }
    (isArray(s) ? s.map((a) => a && encodeQueryValue(a)) : [s && encodeQueryValue(s)]).forEach((a) => {
      a !== void 0 && ((e += (e.length ? '&' : '') + n), a != null && (e += '=' + a));
    });
  }
  return e;
}
function normalizeQuery(r) {
  const e = {};
  for (const n in r) {
    const s = r[n];
    s !== void 0 && (e[n] = isArray(s) ? s.map((o) => (o == null ? null : '' + o)) : s == null ? s : '' + s);
  }
  return e;
}
const matchedRouteKey = Symbol(''),
  viewDepthKey = Symbol(''),
  routerKey = Symbol(''),
  routeLocationKey = Symbol(''),
  routerViewLocationKey = Symbol('');
function useCallbacks() {
  let r = [];
  function e(s) {
    return (
      r.push(s),
      () => {
        const o = r.indexOf(s);
        o > -1 && r.splice(o, 1);
      }
    );
  }
  function n() {
    r = [];
  }
  return { add: e, list: () => r.slice(), reset: n };
}
function guardToPromiseFn(r, e, n, s, o) {
  const a = s && (s.enterCallbacks[o] = s.enterCallbacks[o] || []);
  return () =>
    new Promise((l, f) => {
      const m = (L) => {
          L === !1
            ? f(createRouterError(4, { from: n, to: e }))
            : L instanceof Error
            ? f(L)
            : isRouteLocation(L)
            ? f(createRouterError(2, { from: e, to: L }))
            : (a && s.enterCallbacks[o] === a && typeof L == 'function' && a.push(L), l());
        },
        v = r.call(s && s.instances[o], e, n, m);
      let I = Promise.resolve(v);
      r.length < 3 && (I = I.then(m)), I.catch((L) => f(L));
    });
}
function extractComponentsGuards(r, e, n, s) {
  const o = [];
  for (const a of r)
    for (const l in a.components) {
      let f = a.components[l];
      if (!(e !== 'beforeRouteEnter' && !a.instances[l]))
        if (isRouteComponent(f)) {
          const v = (f.__vccOpts || f)[e];
          v && o.push(guardToPromiseFn(v, n, s, a, l));
        } else {
          let m = f();
          o.push(() =>
            m.then((v) => {
              if (!v) return Promise.reject(new Error(`Couldn't resolve component "${l}" at "${a.path}"`));
              const I = isESModule(v) ? v.default : v;
              a.components[l] = I;
              const V = (I.__vccOpts || I)[e];
              return V && guardToPromiseFn(V, n, s, a, l)();
            }),
          );
        }
    }
  return o;
}
function isRouteComponent(r) {
  return typeof r == 'object' || 'displayName' in r || 'props' in r || '__vccOpts' in r;
}
function useLink(r) {
  const e = inject(routerKey),
    n = inject(routeLocationKey),
    s = computed(() => e.resolve(unref(r.to))),
    o = computed(() => {
      const { matched: m } = s.value,
        { length: v } = m,
        I = m[v - 1],
        L = n.matched;
      if (!I || !L.length) return -1;
      const V = L.findIndex(isSameRouteRecord.bind(null, I));
      if (V > -1) return V;
      const se = getOriginalPath(m[v - 2]);
      return v > 1 && getOriginalPath(I) === se && L[L.length - 1].path !== se
        ? L.findIndex(isSameRouteRecord.bind(null, m[v - 2]))
        : V;
    }),
    a = computed(() => o.value > -1 && includesParams(n.params, s.value.params)),
    l = computed(
      () => o.value > -1 && o.value === n.matched.length - 1 && isSameRouteLocationParams(n.params, s.value.params),
    );
  function f(m = {}) {
    return guardEvent(m) ? e[unref(r.replace) ? 'replace' : 'push'](unref(r.to)).catch(noop$2) : Promise.resolve();
  }
  return { route: s, href: computed(() => s.value.href), isActive: a, isExactActive: l, navigate: f };
}
const RouterLinkImpl = defineComponent({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
      to: { type: [String, Object], required: !0 },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: { type: String, default: 'page' },
    },
    useLink,
    setup(r, { slots: e }) {
      const n = reactive(useLink(r)),
        { options: s } = inject(routerKey),
        o = computed(() => ({
          [getLinkClass(r.activeClass, s.linkActiveClass, 'router-link-active')]: n.isActive,
          [getLinkClass(r.exactActiveClass, s.linkExactActiveClass, 'router-link-exact-active')]: n.isExactActive,
        }));
      return () => {
        const a = e.default && e.default(n);
        return r.custom
          ? a
          : h$1(
              'a',
              {
                'aria-current': n.isExactActive ? r.ariaCurrentValue : null,
                'href': n.href,
                'onClick': n.navigate,
                'class': o.value,
              },
              a,
            );
      };
    },
  }),
  RouterLink = RouterLinkImpl;
function guardEvent(r) {
  if (
    !(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey) &&
    !r.defaultPrevented &&
    !(r.button !== void 0 && r.button !== 0)
  ) {
    if (r.currentTarget && r.currentTarget.getAttribute) {
      const e = r.currentTarget.getAttribute('target');
      if (/\b_blank\b/i.test(e)) return;
    }
    return r.preventDefault && r.preventDefault(), !0;
  }
}
function includesParams(r, e) {
  for (const n in e) {
    const s = e[n],
      o = r[n];
    if (typeof s == 'string') {
      if (s !== o) return !1;
    } else if (!isArray(o) || o.length !== s.length || s.some((a, l) => a !== o[l])) return !1;
  }
  return !0;
}
function getOriginalPath(r) {
  return r ? (r.aliasOf ? r.aliasOf.path : r.path) : '';
}
const getLinkClass = (r, e, n) => r ?? e ?? n,
  RouterViewImpl = defineComponent({
    name: 'RouterView',
    inheritAttrs: !1,
    props: { name: { type: String, default: 'default' }, route: Object },
    compatConfig: { MODE: 3 },
    setup(r, { attrs: e, slots: n }) {
      const s = inject(routerViewLocationKey),
        o = computed(() => r.route || s.value),
        a = inject(viewDepthKey, 0),
        l = computed(() => {
          let v = unref(a);
          const { matched: I } = o.value;
          let L;
          for (; (L = I[v]) && !L.components; ) v++;
          return v;
        }),
        f = computed(() => o.value.matched[l.value]);
      provide(
        viewDepthKey,
        computed(() => l.value + 1),
      ),
        provide(matchedRouteKey, f),
        provide(routerViewLocationKey, o);
      const m = ref();
      return (
        watch(
          () => [m.value, f.value, r.name],
          ([v, I, L], [V, se, Ee]) => {
            I &&
              ((I.instances[L] = v),
              se &&
                se !== I &&
                v &&
                v === V &&
                (I.leaveGuards.size || (I.leaveGuards = se.leaveGuards),
                I.updateGuards.size || (I.updateGuards = se.updateGuards))),
              v && I && (!se || !isSameRouteRecord(I, se) || !V) && (I.enterCallbacks[L] || []).forEach((ht) => ht(v));
          },
          { flush: 'post' },
        ),
        () => {
          const v = o.value,
            I = r.name,
            L = f.value,
            V = L && L.components[I];
          if (!V) return normalizeSlot(n.default, { Component: V, route: v });
          const se = L.props[I],
            Ee = se ? (se === !0 ? v.params : typeof se == 'function' ? se(v) : se) : null,
            ar = h$1(
              V,
              assign({}, Ee, e, {
                onVnodeUnmounted: ($i) => {
                  $i.component.isUnmounted && (L.instances[I] = null);
                },
                ref: m,
              }),
            );
          return normalizeSlot(n.default, { Component: ar, route: v }) || ar;
        }
      );
    },
  });
function normalizeSlot(r, e) {
  if (!r) return null;
  const n = r(e);
  return n.length === 1 ? n[0] : n;
}
const RouterView = RouterViewImpl;
function createRouter(r) {
  const e = createRouterMatcher(r.routes, r),
    n = r.parseQuery || parseQuery,
    s = r.stringifyQuery || stringifyQuery,
    o = r.history,
    a = useCallbacks(),
    l = useCallbacks(),
    f = useCallbacks(),
    m = shallowRef(START_LOCATION_NORMALIZED);
  let v = START_LOCATION_NORMALIZED;
  isBrowser && r.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual');
  const I = applyToParams.bind(null, (wl) => '' + wl),
    L = applyToParams.bind(null, encodeParam),
    V = applyToParams.bind(null, decode);
  function se(wl, zl) {
    let zc, Ul;
    return isRouteName(wl) ? ((zc = e.getRecordMatcher(wl)), (Ul = zl)) : (Ul = wl), e.addRoute(Ul, zc);
  }
  function Ee(wl) {
    const zl = e.getRecordMatcher(wl);
    zl && e.removeRoute(zl);
  }
  function ht() {
    return e.getRoutes().map((wl) => wl.record);
  }
  function ar(wl) {
    return !!e.getRecordMatcher(wl);
  }
  function $i(wl, zl) {
    if (((zl = assign({}, zl || m.value)), typeof wl == 'string')) {
      const Pl = parseURL(n, wl, zl.path),
        Rl = e.resolve({ path: Pl.path }, zl),
        Wl = o.createHref(Pl.fullPath);
      return assign(Pl, Rl, { params: V(Rl.params), hash: decode(Pl.hash), redirectedFrom: void 0, href: Wl });
    }
    let zc;
    if ('path' in wl) zc = assign({}, wl, { path: parseURL(n, wl.path, zl.path).path });
    else {
      const Pl = assign({}, wl.params);
      for (const Rl in Pl) Pl[Rl] == null && delete Pl[Rl];
      (zc = assign({}, wl, { params: L(Pl) })), (zl.params = L(zl.params));
    }
    const Ul = e.resolve(zc, zl),
      Dh = wl.hash || '';
    Ul.params = I(V(Ul.params));
    const gl = stringifyURL(s, assign({}, wl, { hash: encodeHash(Dh), path: Ul.path })),
      bl = o.createHref(gl);
    return assign(
      { fullPath: gl, hash: Dh, query: s === stringifyQuery ? normalizeQuery(wl.query) : wl.query || {} },
      Ul,
      { redirectedFrom: void 0, href: bl },
    );
  }
  function tl(wl) {
    return typeof wl == 'string' ? parseURL(n, wl, m.value.path) : assign({}, wl);
  }
  function Wi(wl, zl) {
    if (v !== wl) return createRouterError(8, { from: zl, to: wl });
  }
  function hl(wl) {
    return Al(wl);
  }
  function fl(wl) {
    return hl(assign(tl(wl), { replace: !0 }));
  }
  function dl(wl) {
    const zl = wl.matched[wl.matched.length - 1];
    if (zl && zl.redirect) {
      const { redirect: zc } = zl;
      let Ul = typeof zc == 'function' ? zc(wl) : zc;
      return (
        typeof Ul == 'string' &&
          ((Ul = Ul.includes('?') || Ul.includes('#') ? (Ul = tl(Ul)) : { path: Ul }), (Ul.params = {})),
        assign({ query: wl.query, hash: wl.hash, params: 'path' in Ul ? {} : wl.params }, Ul)
      );
    }
  }
  function Al(wl, zl) {
    const zc = (v = $i(wl)),
      Ul = m.value,
      Dh = wl.state,
      gl = wl.force,
      bl = wl.replace === !0,
      Pl = dl(zc);
    if (Pl)
      return Al(
        assign(tl(Pl), { state: typeof Pl == 'object' ? assign({}, Dh, Pl.state) : Dh, force: gl, replace: bl }),
        zl || zc,
      );
    const Rl = zc;
    Rl.redirectedFrom = zl;
    let Wl;
    return (
      !gl && isSameRouteLocation(s, Ul, zc) && ((Wl = createRouterError(16, { to: Rl, from: Ul })), ih(Ul, Ul, !0, !1)),
      (Wl ? Promise.resolve(Wl) : kl(Rl, Ul))
        .catch((Kl) => (isNavigationFailure(Kl) ? (isNavigationFailure(Kl, 2) ? Kl : Yl(Kl)) : Bl(Kl, Rl, Ul)))
        .then((Kl) => {
          if (Kl) {
            if (isNavigationFailure(Kl, 2))
              return Al(
                assign({ replace: bl }, tl(Kl.to), {
                  state: typeof Kl.to == 'object' ? assign({}, Dh, Kl.to.state) : Dh,
                  force: gl,
                }),
                zl || Rl,
              );
          } else Kl = Jl(Rl, Ul, !0, bl, Dh);
          return El(Rl, Ul, Kl), Kl;
        })
    );
  }
  function Fl(wl, zl) {
    const zc = Wi(wl, zl);
    return zc ? Promise.reject(zc) : Promise.resolve();
  }
  function vl(wl) {
    const zl = xh.values().next().value;
    return zl && typeof zl.runWithContext == 'function' ? zl.runWithContext(wl) : wl();
  }
  function kl(wl, zl) {
    let zc;
    const [Ul, Dh, gl] = extractChangingRecords(wl, zl);
    zc = extractComponentsGuards(Ul.reverse(), 'beforeRouteLeave', wl, zl);
    for (const Pl of Ul)
      Pl.leaveGuards.forEach((Rl) => {
        zc.push(guardToPromiseFn(Rl, wl, zl));
      });
    const bl = Fl.bind(null, wl, zl);
    return (
      zc.push(bl),
      Ah(zc)
        .then(() => {
          zc = [];
          for (const Pl of a.list()) zc.push(guardToPromiseFn(Pl, wl, zl));
          return zc.push(bl), Ah(zc);
        })
        .then(() => {
          zc = extractComponentsGuards(Dh, 'beforeRouteUpdate', wl, zl);
          for (const Pl of Dh)
            Pl.updateGuards.forEach((Rl) => {
              zc.push(guardToPromiseFn(Rl, wl, zl));
            });
          return zc.push(bl), Ah(zc);
        })
        .then(() => {
          zc = [];
          for (const Pl of gl)
            if (Pl.beforeEnter)
              if (isArray(Pl.beforeEnter)) for (const Rl of Pl.beforeEnter) zc.push(guardToPromiseFn(Rl, wl, zl));
              else zc.push(guardToPromiseFn(Pl.beforeEnter, wl, zl));
          return zc.push(bl), Ah(zc);
        })
        .then(
          () => (
            wl.matched.forEach((Pl) => (Pl.enterCallbacks = {})),
            (zc = extractComponentsGuards(gl, 'beforeRouteEnter', wl, zl)),
            zc.push(bl),
            Ah(zc)
          ),
        )
        .then(() => {
          zc = [];
          for (const Pl of l.list()) zc.push(guardToPromiseFn(Pl, wl, zl));
          return zc.push(bl), Ah(zc);
        })
        .catch((Pl) => (isNavigationFailure(Pl, 8) ? Pl : Promise.reject(Pl)))
    );
  }
  function El(wl, zl, zc) {
    f.list().forEach((Ul) => vl(() => Ul(wl, zl, zc)));
  }
  function Jl(wl, zl, zc, Ul, Dh) {
    const gl = Wi(wl, zl);
    if (gl) return gl;
    const bl = zl === START_LOCATION_NORMALIZED,
      Pl = isBrowser ? history.state : {};
    zc && (Ul || bl ? o.replace(wl.fullPath, assign({ scroll: bl && Pl && Pl.scroll }, Dh)) : o.push(wl.fullPath, Dh)),
      (m.value = wl),
      ih(wl, zl, zc, bl),
      Yl();
  }
  let Kc;
  function Il() {
    Kc ||
      (Kc = o.listen((wl, zl, zc) => {
        if (!bh.listening) return;
        const Ul = $i(wl),
          Dh = dl(Ul);
        if (Dh) {
          Al(assign(Dh, { replace: !0 }), Ul).catch(noop$2);
          return;
        }
        v = Ul;
        const gl = m.value;
        isBrowser && saveScrollPosition(getScrollKey(gl.fullPath, zc.delta), computeScrollPosition()),
          kl(Ul, gl)
            .catch((bl) =>
              isNavigationFailure(bl, 12)
                ? bl
                : isNavigationFailure(bl, 2)
                ? (Al(bl.to, Ul)
                    .then((Pl) => {
                      isNavigationFailure(Pl, 20) && !zc.delta && zc.type === NavigationType.pop && o.go(-1, !1);
                    })
                    .catch(noop$2),
                  Promise.reject())
                : (zc.delta && o.go(-zc.delta, !1), Bl(bl, Ul, gl)),
            )
            .then((bl) => {
              (bl = bl || Jl(Ul, gl, !1)),
                bl &&
                  (zc.delta && !isNavigationFailure(bl, 8)
                    ? o.go(-zc.delta, !1)
                    : zc.type === NavigationType.pop && isNavigationFailure(bl, 20) && o.go(-1, !1)),
                El(Ul, gl, bl);
            })
            .catch(noop$2);
      }));
  }
  let Ll = useCallbacks(),
    Nl = useCallbacks(),
    Hl;
  function Bl(wl, zl, zc) {
    Yl(wl);
    const Ul = Nl.list();
    return Ul.length ? Ul.forEach((Dh) => Dh(wl, zl, zc)) : console.error(wl), Promise.reject(wl);
  }
  function ql() {
    return Hl && m.value !== START_LOCATION_NORMALIZED
      ? Promise.resolve()
      : new Promise((wl, zl) => {
          Ll.add([wl, zl]);
        });
  }
  function Yl(wl) {
    return Hl || ((Hl = !wl), Il(), Ll.list().forEach(([zl, zc]) => (wl ? zc(wl) : zl())), Ll.reset()), wl;
  }
  function ih(wl, zl, zc, Ul) {
    const { scrollBehavior: Dh } = r;
    if (!isBrowser || !Dh) return Promise.resolve();
    const gl =
      (!zc && getSavedScrollPosition(getScrollKey(wl.fullPath, 0))) ||
      ((Ul || !zc) && history.state && history.state.scroll) ||
      null;
    return nextTick()
      .then(() => Dh(wl, zl, gl))
      .then((bl) => bl && scrollToPosition(bl))
      .catch((bl) => Bl(bl, wl, zl));
  }
  const ph = (wl) => o.go(wl);
  let gh;
  const xh = new Set(),
    bh = {
      currentRoute: m,
      listening: !0,
      addRoute: se,
      removeRoute: Ee,
      hasRoute: ar,
      getRoutes: ht,
      resolve: $i,
      options: r,
      push: hl,
      replace: fl,
      go: ph,
      back: () => ph(-1),
      forward: () => ph(1),
      beforeEach: a.add,
      beforeResolve: l.add,
      afterEach: f.add,
      onError: Nl.add,
      isReady: ql,
      install(wl) {
        const zl = this;
        wl.component('RouterLink', RouterLink),
          wl.component('RouterView', RouterView),
          (wl.config.globalProperties.$router = zl),
          Object.defineProperty(wl.config.globalProperties, '$route', { enumerable: !0, get: () => unref(m) }),
          isBrowser && !gh && m.value === START_LOCATION_NORMALIZED && ((gh = !0), hl(o.location).catch((Dh) => {}));
        const zc = {};
        for (const Dh in START_LOCATION_NORMALIZED)
          Object.defineProperty(zc, Dh, { get: () => m.value[Dh], enumerable: !0 });
        wl.provide(routerKey, zl),
          wl.provide(routeLocationKey, shallowReactive(zc)),
          wl.provide(routerViewLocationKey, m);
        const Ul = wl.unmount;
        xh.add(wl),
          (wl.unmount = function () {
            xh.delete(wl),
              xh.size < 1 &&
                ((v = START_LOCATION_NORMALIZED),
                Kc && Kc(),
                (Kc = null),
                (m.value = START_LOCATION_NORMALIZED),
                (gh = !1),
                (Hl = !1)),
              Ul();
          });
      },
    };
  function Ah(wl) {
    return wl.reduce((zl, zc) => zl.then(() => vl(zc)), Promise.resolve());
  }
  return bh;
}
function extractChangingRecords(r, e) {
  const n = [],
    s = [],
    o = [],
    a = Math.max(e.matched.length, r.matched.length);
  for (let l = 0; l < a; l++) {
    const f = e.matched[l];
    f && (r.matched.find((v) => isSameRouteRecord(v, f)) ? s.push(f) : n.push(f));
    const m = r.matched[l];
    m && (e.matched.find((v) => isSameRouteRecord(v, m)) || o.push(m));
  }
  return [n, s, o];
}
function useRouter() {
  return inject(routerKey);
}
const _hoisted_1$p = { key: 0, class: 'h-full w-full bg-base-100 shadow-md rounded' },
  _hoisted_2$f = { key: 1, class: 'h-full w-full bg-base-100 shadow-md rounded flex flex-col' },
  _hoisted_3$b = { class: 'border-b border-base-300 text-xs font-semibold leading-6' },
  _hoisted_4$a = { class: 'flex-1 min-h-0' },
  _sfc_main$v = defineComponent({
    __name: 'ContentCard',
    setup(r) {
      const e = useSlots();
      return (n, s) =>
        unref(e).header
          ? (openBlock(),
            createElementBlock('div', _hoisted_2$f, [
              createBaseVNode('div', _hoisted_3$b, [renderSlot(n.$slots, 'header')]),
              createBaseVNode('div', _hoisted_4$a, [renderSlot(n.$slots, 'default')]),
            ]))
          : (openBlock(), createElementBlock('div', _hoisted_1$p, [renderSlot(n.$slots, 'default')]));
    },
  }),
  _sfc_main$u = defineComponent({
    __name: 'Button',
    props: {
      type: {},
      size: { default: 'sm' },
      outline: { type: Boolean },
      active: { type: Boolean },
      disabled: { type: Boolean },
      glass: { type: Boolean },
      noAnimation: { type: Boolean },
      wide: { type: Boolean },
      block: { type: Boolean },
      shape: {},
    },
    setup(r) {
      const e = r,
        n = computed(() => ({
          'btn': !0,
          'btn-neutral': e.type === 'neutral',
          'btn-primary': e.type === 'primary',
          'btn-secondary': e.type === 'secondary',
          'btn-accent': e.type === 'accent',
          'btn-info': e.type === 'info',
          'btn-success': e.type === 'success',
          'btn-warning': e.type === 'warning',
          'btn-error': e.type === 'error',
          'btn-ghost': e.type === 'ghost',
          'btn-link': e.type === 'link',
          'btn-outline': !!e.outline,
          'btn-active': !!e.active,
          'btn-disabled': !!e.disabled,
          'glass': !!e.glass,
          'no-animation': !!e.noAnimation,
          'btn-xs': e.size === 'xs',
          'btn-sm': e.size === 'sm',
          'btn-md': e.size === 'md',
          'btn-lg': e.size === 'lg',
          'btn-wide': !!e.wide,
          'btn-block': !!e.block,
          'btn-circle': e.shape === 'circle',
          'btn-square': e.shape === 'square',
        }));
      return (s, o) => (
        openBlock(),
        createElementBlock(
          'button',
          { class: normalizeClass([n.value, 'rounded']) },
          [renderSlot(s.$slots, 'default', {}, void 0, !0)],
          2,
        )
      );
    },
  }),
  Button_vue_vue_type_style_index_0_scoped_14336724_lang = '',
  _export_sfc = (r, e) => {
    const n = r.__vccOpts || r;
    for (const [s, o] of e) n[s] = o;
    return n;
  },
  Button = _export_sfc(_sfc_main$u, [['__scopeId', 'data-v-14336724']]),
  _sfc_main$t = {},
  _hoisted_1$o = { class: 'hero w-full h-full' },
  _hoisted_2$e = { class: 'hero-content text-center' };
function _sfc_render(r, e) {
  return (
    openBlock(),
    createElementBlock('div', _hoisted_1$o, [createBaseVNode('div', _hoisted_2$e, [renderSlot(r.$slots, 'default')])])
  );
}
const Hero = _export_sfc(_sfc_main$t, [['render', _sfc_render]]),
  _hoisted_1$n = ['value', 'placeholder', 'onKeydown'],
  _sfc_main$s = defineComponent({
    __name: 'Input',
    props: { modelValue: {}, placeholder: { default: '' }, size: {}, type: {}, bordered: { type: Boolean } },
    emits: ['update:modelValue', 'change', 'input'],
    setup(r, { expose: e, emit: n }) {
      const s = r;
      e({ focus: l, blur: f, select: m });
      const o = computed(() => ({
          'input': !0,
          'input-primary': s.type === 'primary',
          'input-secondary': s.type === 'secondary',
          'input-accent': s.type === 'accent',
          'input-info': s.type === 'info',
          'input-success': s.type === 'success',
          'input-warning': s.type === 'warning',
          'input-error': s.type === 'error',
          'input-ghost': s.type === 'ghost',
          'input-bordered': !!s.bordered,
          'input-xs': s.size === 'xs',
          'input-sm': s.size === 'sm',
          'input-md': s.size === 'md',
          'input-lg': s.size === 'lg',
        })),
        a = ref(null);
      function l() {
        var V;
        (V = a.value) == null || V.focus();
      }
      function f() {
        var V;
        (V = a.value) == null || V.blur();
      }
      function m() {
        var V;
        return (V = a.value) == null ? void 0 : V.select();
      }
      function v(V) {
        const se = V.target.value;
        n('change', se);
      }
      function I(V) {
        const se = V.target.value;
        n('input', se), n('update:modelValue', se);
      }
      function L() {
        f();
      }
      return (V, se) => (
        openBlock(),
        createElementBlock(
          'input',
          {
            ref_key: 'input',
            ref: a,
            value: V.modelValue,
            class: normalizeClass(['w-full rounded', o.value]),
            placeholder: V.placeholder,
            type: 'text',
            onChange: v,
            onInput: I,
            onKeydown: withKeys(L, ['enter']),
          },
          null,
          42,
          _hoisted_1$n,
        )
      );
    },
  }),
  _sfc_main$r = defineComponent({
    __name: 'Loading',
    props: { shape: { default: 'spinner' }, type: {}, size: { default: 'md' } },
    setup(r) {
      const e = r,
        n = computed(() => ({
          'loading': !0,
          'loading-spinner': e.shape === 'spinner',
          'loading-dots': e.shape === 'dots',
          'loading-ring': e.shape === 'ring',
          'loading-ball': e.shape === 'ball',
          'loading-bars': e.shape === 'bars',
          'loading-infinity': e.shape === 'infinity',
          'loading-xs': e.size === 'xs',
          'loading-sm': e.size === 'sm',
          'loading-md': e.size === 'md',
          'loading-lg': e.size === 'lg',
          'text-neutral': e.type === 'neutral',
          'text-primary': e.type === 'primary',
          'text-secondary': e.type === 'secondary',
          'text-accent': e.type === 'accent',
          'text-info': e.type === 'info',
          'text-success': e.type === 'success',
          'text-warning': e.type === 'warning',
          'text-error': e.type === 'error',
        }));
      return (s, o) => (openBlock(), createElementBlock('div', { class: normalizeClass(n.value) }, null, 2));
    },
  }),
  _hoisted_1$m = { method: 'dialog', class: 'modal-box' },
  _hoisted_2$d = { key: 1, class: 'font-bold text-lg' },
  _hoisted_3$a = { class: 'content py-4' },
  _hoisted_4$9 = { key: 2, class: 'modal-action' },
  _hoisted_5$5 = { key: 0, method: 'dialog', class: 'modal-backdrop' },
  _sfc_main$q = defineComponent({
    __name: 'Modal',
    props: {
      modelValue: { type: Boolean },
      useTopLayer: { type: Boolean, default: !1 },
      title: {},
      showClose: { type: Boolean, default: !0 },
      position: { default: 'middle' },
      closeOnBackdrop: { type: Boolean, default: !0 },
    },
    emits: ['update:modelValue'],
    setup(r, { emit: e }) {
      const n = r,
        s = useSlots(),
        o = ref(null),
        a = computed(() => ({ top: 'modal-top', bottom: 'modal-bottom', middle: 'modal-middle' })[n.position]);
      function l() {
        e('update:modelValue', !1);
      }
      function f() {
        n.useTopLayer || l();
      }
      return (
        watchEffect(() => {
          !o.value ||
            !n.useTopLayer ||
            (n.modelValue && !o.value.open ? o.value.showModal() : !n.modelValue && o.value.open && o.value.close());
        }),
        (m, v) => (
          openBlock(),
          createElementBlock(
            'dialog',
            {
              ref_key: 'dialogRef',
              ref: o,
              class: normalizeClass(['modal', a.value, !m.useTopLayer && m.modelValue && 'modal-open']),
              onClose: l,
            },
            [
              createBaseVNode('form', _hoisted_1$m, [
                m.showClose
                  ? (openBlock(),
                    createBlock(
                      unref(Button),
                      { key: 0, class: 'absolute right-2 top-2', shape: 'circle', type: 'ghost', onClick: f },
                      { default: withCtx(() => [createTextVNode(' ✕ ')]), _: 1 },
                    ))
                  : createCommentVNode('', !0),
                m.title
                  ? (openBlock(), createElementBlock('h3', _hoisted_2$d, toDisplayString(m.title), 1))
                  : createCommentVNode('', !0),
                createBaseVNode('div', _hoisted_3$a, [renderSlot(m.$slots, 'default')]),
                unref(s).action
                  ? (openBlock(), createElementBlock('div', _hoisted_4$9, [renderSlot(m.$slots, 'action')]))
                  : createCommentVNode('', !0),
              ]),
              m.closeOnBackdrop
                ? (openBlock(),
                  createElementBlock('form', _hoisted_5$5, [createBaseVNode('button', { onClick: f }, 'close')]))
                : createCommentVNode('', !0),
            ],
            34,
          )
        )
      );
    },
  }),
  TOAST_TYPES = ['info', 'success', 'warning', 'error'],
  DEFAULT_OFFSET = 8;
var DEFAULT_ICON_CONFIGS = {
  size: '1em',
  strokeWidth: 4,
  strokeLinecap: 'round',
  strokeLinejoin: 'round',
  rtl: !1,
  theme: 'outline',
  colors: {
    outline: { fill: '#333', background: 'transparent' },
    filled: { fill: '#333', background: '#FFF' },
    twoTone: { fill: '#333', twoTone: '#2F88FF' },
    multiColor: {
      outStrokeColor: '#333',
      outFillColor: '#2F88FF',
      innerStrokeColor: '#FFF',
      innerFillColor: '#43CCF8',
    },
  },
  prefix: 'i',
};
function guid() {
  return 'icon-' + (((1 + Math.random()) * 4294967296) | 0).toString(16).substring(1);
}
function IconConverter(r, e, n) {
  var s = typeof e.fill == 'string' ? [e.fill] : e.fill || [],
    o = [],
    a = e.theme || n.theme;
  switch (a) {
    case 'outline':
      o.push(typeof s[0] == 'string' ? s[0] : 'currentColor'),
        o.push('none'),
        o.push(typeof s[0] == 'string' ? s[0] : 'currentColor'),
        o.push('none');
      break;
    case 'filled':
      o.push(typeof s[0] == 'string' ? s[0] : 'currentColor'),
        o.push(typeof s[0] == 'string' ? s[0] : 'currentColor'),
        o.push('#FFF'),
        o.push('#FFF');
      break;
    case 'two-tone':
      o.push(typeof s[0] == 'string' ? s[0] : 'currentColor'),
        o.push(typeof s[1] == 'string' ? s[1] : n.colors.twoTone.twoTone),
        o.push(typeof s[0] == 'string' ? s[0] : 'currentColor'),
        o.push(typeof s[1] == 'string' ? s[1] : n.colors.twoTone.twoTone);
      break;
    case 'multi-color':
      o.push(typeof s[0] == 'string' ? s[0] : 'currentColor'),
        o.push(typeof s[1] == 'string' ? s[1] : n.colors.multiColor.outFillColor),
        o.push(typeof s[2] == 'string' ? s[2] : n.colors.multiColor.innerStrokeColor),
        o.push(typeof s[3] == 'string' ? s[3] : n.colors.multiColor.innerFillColor);
      break;
  }
  return {
    size: e.size || n.size,
    strokeWidth: e.strokeWidth || n.strokeWidth,
    strokeLinecap: e.strokeLinecap || n.strokeLinecap,
    strokeLinejoin: e.strokeLinejoin || n.strokeLinejoin,
    colors: o,
    id: r,
  };
}
var IconContext = Symbol('icon-context');
function IconWrapper(r, e, n) {
  var s = {
    name: 'icon-' + r,
    props: ['size', 'strokeWidth', 'strokeLinecap', 'strokeLinejoin', 'theme', 'fill', 'spin'],
    setup: function (a) {
      var l = guid(),
        f = inject(IconContext, DEFAULT_ICON_CONFIGS);
      return function () {
        var m = a.size,
          v = a.strokeWidth,
          I = a.strokeLinecap,
          L = a.strokeLinejoin,
          V = a.theme,
          se = a.fill,
          Ee = a.spin,
          ht = IconConverter(
            l,
            { size: m, strokeWidth: v, strokeLinecap: I, strokeLinejoin: L, theme: V, fill: se },
            f,
          ),
          ar = [f.prefix + '-icon'];
        return (
          ar.push(f.prefix + '-icon-' + r),
          e && f.rtl && ar.push(f.prefix + '-icon-rtl'),
          Ee && ar.push(f.prefix + '-icon-spin'),
          createVNode('span', { class: ar.join(' ') }, [n(ht)])
        );
      };
    },
  };
  return s;
}
const AlignTextLeft = IconWrapper('align-text-left', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M42 9H6',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M34 19H6',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M42 29H6',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M34 39H6',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Analysis = IconWrapper('analysis', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M44 5H3.99998V17H44V5Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M3.99998 41.0301L16.1756 28.7293L22.7549 35.0301L30.7982 27L35.2786 31.368',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M44 16.1719V42.1719',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M3.99998 16.1719V30.1719',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M13.0155 43H44',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
        },
        null,
      ),
      createVNode(
        'path',
        { 'd': 'M17 11H38', 'stroke': r.colors[2], 'stroke-width': r.strokeWidth, 'stroke-linecap': r.strokeLinecap },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M9.99998 10.9966H11',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
        },
        null,
      ),
    ]);
  }),
  Attention = IconWrapper('attention', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M24 37C25.3807 37 26.5 35.8807 26.5 34.5C26.5 33.1193 25.3807 32 24 32C22.6193 32 21.5 33.1193 21.5 34.5C21.5 35.8807 22.6193 37 24 37Z',
          'fill': r.colors[2],
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M24 12V28',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Check = IconWrapper('check', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M43 11L16.875 37L5 25.1818',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  CheckOne = IconWrapper('check-one', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M16 24L22 30L34 18',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Close = IconWrapper('close', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M8 8L40 40',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M8 40L40 8',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  CloseOne = IconWrapper('close-one', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M29.6567 18.3432L18.343 29.6569',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M18.3433 18.3432L29.657 29.6569',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Delete = IconWrapper('delete', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M9 10V44H39V10H9Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M20 20V33',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M28 20V33',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M4 10H44',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M16 10L19.289 4H28.7771L32 10H16Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Dot = IconWrapper('dot', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 33C28.9706 33 33 28.9706 33 24C33 19.0294 28.9706 15 24 15C19.0294 15 15 19.0294 15 24C15 28.9706 19.0294 33 24 33Z',
          'fill': r.colors[0],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
        },
        null,
      ),
    ]);
  }),
  Down = IconWrapper('down', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M36 18L24 30L12 18',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Edit = IconWrapper('edit', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M7 42H43',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M11 26.7199V34H18.3172L39 13.3081L31.6951 6L11 26.7199Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  FileAddition = IconWrapper('file-addition', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M10 44H38C39.1046 44 40 43.1046 40 42V14H30V4H10C8.89543 4 8 4.89543 8 6V42C8 43.1046 8.89543 44 10 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M30 4L40 14',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M24 21V35',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M17 28H24L31 28',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  FileCode = IconWrapper('file-code', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M10 44H38C39.1046 44 40 43.1046 40 42V14H30V4H10C8.89543 4 8 4.89543 8 6V42C8 43.1046 8.89543 44 10 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M30 4L40 14',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M27 24L32 29L27 34',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M21 24L16 29L21 34',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  HandLeft = IconWrapper('hand-left', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M44 41V19H38V41H44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M38 19.0002C30.8948 12.4304 26.7757 8.66359 25.6428 7.69983C23.9433 6.25419 22.0226 6.86123 22.0226 10.479C22.0226 14.0968 27.2864 16.2443 27.2864 19.0002C27.2898 19.0166 20.529 19.0177 7.00404 19.0035C5.3467 19.0017 4.00175 20.3438 4 22.0012C4 22.0022 4 22.0033 4 22.0043C4 23.6635 5.34501 25.0085 7.00417 25.0085H14.0165C15.2234 32.9771 15.8893 37.3101 16.0144 38.0075C16.2019 39.0536 17.199 41.0002 20.068 41.0002C21.9807 41.0002 27.9581 41.0002 38 41.0002V19.0002Z',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Help = IconWrapper('help', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M24 28.6248V24.6248C27.3137 24.6248 30 21.9385 30 18.6248C30 15.3111 27.3137 12.6248 24 12.6248C20.6863 12.6248 18 15.3111 18 18.6248',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M24 37.6248C25.3807 37.6248 26.5 36.5055 26.5 35.1248C26.5 33.7441 25.3807 32.6248 24 32.6248C22.6193 32.6248 21.5 33.7441 21.5 35.1248C21.5 36.5055 22.6193 37.6248 24 37.6248Z',
          'fill': r.colors[2],
        },
        null,
      ),
    ]);
  }),
  Home = IconWrapper('home', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M9 18V42H39V18L24 6L9 18Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M19 29V42H29V29H19Z',
          'fill': r.colors[3],
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        { 'd': 'M9 42H39', 'stroke': r.colors[0], 'stroke-width': r.strokeWidth, 'stroke-linecap': r.strokeLinecap },
        null,
      ),
    ]);
  }),
  Info = IconWrapper('info', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'fill-rule': 'evenodd',
          'clip-rule': 'evenodd',
          'd': 'M24 11C25.3807 11 26.5 12.1193 26.5 13.5C26.5 14.8807 25.3807 16 24 16C22.6193 16 21.5 14.8807 21.5 13.5C21.5 12.1193 22.6193 11 24 11Z',
          'fill': r.colors[2],
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M24.5 34V20H23.5H22.5',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M21 34H28',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Key = IconWrapper('key', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M22.8682 24.2982C25.4105 26.7935 26.4138 30.4526 25.4971 33.8863C24.5805 37.32 21.8844 40.0019 18.4325 40.9137C14.9806 41.8256 11.3022 40.8276 8.79375 38.2986C5.02208 34.4141 5.07602 28.2394 8.91499 24.4206C12.754 20.6019 18.9613 20.5482 22.8664 24.3L22.8682 24.2982Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M23 24L40 7',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M30.3052 16.9001L35.7337 22.3001L42.0671 16.0001L36.6385 10.6001L30.3052 16.9001Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  MonitorOne = IconWrapper('monitor-one', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M5 8C5 6.89543 5.89543 6 7 6H41C42.1046 6 43 6.89543 43 8V32C43 33.1046 42.1046 34 41 34H7C5.89543 34 5 33.1046 5 32V8Z',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M5 26C5 24.8954 5.89543 24 7 24H41C42.1046 24 43 24.8954 43 26V32C43 33.1046 42.1046 34 41 34H7C5.89543 34 5 33.1046 5 32V26Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M22 12L18 17',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M28 14L25 18',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode('circle', { cx: '24', cy: '29', r: '2', fill: r.colors[2] }, null),
      createVNode(
        'path',
        {
          'd': 'M17 34L14 42H34L31 34',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  ParagraphBreak = IconWrapper('paragraph-break', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M6 4V44',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M42 4V44',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M18 26L14 30L18 34',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M15 30C15 30 25.7909 30 28 30C31.3137 30 34 27.3137 34 24C34 20.6863 31.3137 18 28 18C26.6852 18 14 18 14 18',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Plus = IconWrapper('plus', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24.0605 10L24.0239 38',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M10 24L38 24',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  ReduceOne = IconWrapper('reduce-one', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M16 24L32 24',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Search = IconWrapper('search', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M21 38C30.3888 38 38 30.3888 38 21C38 11.6112 30.3888 4 21 4C11.6112 4 4 11.6112 4 21C4 30.3888 11.6112 38 21 38Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M26.657 14.3431C25.2093 12.8954 23.2093 12 21.0001 12C18.791 12 16.791 12.8954 15.3433 14.3431',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M33.2216 33.2217L41.7069 41.707',
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Setting = IconWrapper('setting', !1, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M36.686 15.171C37.9364 16.9643 38.8163 19.0352 39.2147 21.2727H44V26.7273H39.2147C38.8163 28.9648 37.9364 31.0357 36.686 32.829L40.0706 36.2137L36.2137 40.0706L32.829 36.686C31.0357 37.9364 28.9648 38.8163 26.7273 39.2147V44H21.2727V39.2147C19.0352 38.8163 16.9643 37.9364 15.171 36.686L11.7863 40.0706L7.92939 36.2137L11.314 32.829C10.0636 31.0357 9.18372 28.9648 8.78533 26.7273H4V21.2727H8.78533C9.18372 19.0352 10.0636 16.9643 11.314 15.171L7.92939 11.7863L11.7863 7.92939L15.171 11.314C16.9643 10.0636 19.0352 9.18372 21.2727 8.78533V4H26.7273V8.78533C28.9648 9.18372 31.0357 10.0636 32.829 11.314L36.2137 7.92939L40.0706 11.7863L36.686 15.171Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M24 29C26.7614 29 29 26.7614 29 24C29 21.2386 26.7614 19 24 19C21.2386 19 19 21.2386 19 24C19 26.7614 21.2386 29 24 29Z',
          'fill': r.colors[3],
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  Time = IconWrapper('time', !0, function (r) {
    return createVNode('svg', { width: r.size, height: r.size, viewBox: '0 0 48 48', fill: 'none' }, [
      createVNode(
        'path',
        {
          'd': 'M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z',
          'fill': r.colors[1],
          'stroke': r.colors[0],
          'stroke-width': r.strokeWidth,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
      createVNode(
        'path',
        {
          'd': 'M24.0084 12.0001L24.0072 24.0089L32.4866 32.4883',
          'stroke': r.colors[2],
          'stroke-width': r.strokeWidth,
          'stroke-linecap': r.strokeLinecap,
          'stroke-linejoin': r.strokeLinejoin,
        },
        null,
      ),
    ]);
  }),
  _hoisted_1$l = { class: 'flex items-start max-w-[75vw] w-max' },
  _hoisted_2$c = { class: 'h-5 flex-center flex-none' },
  _hoisted_3$9 = { class: 'ml-1 text-sm whitespace-normal break-all' },
  _sfc_main$p = defineComponent({
    __name: 'Toast',
    props: {
      id: {},
      offset: { default: 0 },
      onClose: {},
      onDestroy: {},
      type: {},
      content: {},
      duration: { default: 1500 },
      position: { default: 'top-center' },
      html: { type: Boolean },
    },
    setup(r) {
      const e = r,
        n = ref(!1),
        s = computed(() => e.position.split('-')),
        o = computed(() => s.value[0]),
        a = computed(() => s.value[1]),
        l = computed(() => ({ success: CheckOne, error: CloseOne, info: Info, warning: Attention })[e.type]),
        f = computed(() => ({
          'toast': !0,
          'toast-top': o.value === 'top',
          'toast-bottom': o.value === 'bottom',
          'toast-start': a.value === 'start',
          'toast-center': a.value === 'center',
          'toast-end': a.value === 'end',
          'p-1': !0,
          'z-[9999]': !0,
        })),
        m = computed(() => ({
          'alert': !0,
          'alert-info': e.type === 'info',
          'alert-error': e.type === 'error',
          'alert-warning': e.type === 'warning',
          'alert-success': e.type === 'success',
          'py-2': !0,
        })),
        v = computed(() => ({ [o.value]: `${e.offset}px` })),
        I = computed(() => (a.value === 'center' ? `toast-${e.position}` : `toast-${a.value}`));
      onMounted(() => {
        (n.value = !0), L();
      });
      function L() {
        setTimeout(() => {
          V();
        }, e.duration);
      }
      function V() {
        n.value = !1;
      }
      return (se, Ee) => (
        openBlock(),
        createBlock(
          Transition,
          { name: I.value, onBeforeLeave: se.onClose, onAfterLeave: se.onDestroy },
          {
            default: withCtx(() => [
              withDirectives(
                createBaseVNode(
                  'div',
                  { class: normalizeClass(f.value), style: normalizeStyle(v.value) },
                  [
                    createBaseVNode(
                      'div',
                      { class: normalizeClass([m.value, 'grid-cols-[unset] text-left']) },
                      [
                        createBaseVNode('div', _hoisted_1$l, [
                          createBaseVNode('div', _hoisted_2$c, [
                            (openBlock(), createBlock(resolveDynamicComponent(l.value))),
                          ]),
                          createBaseVNode('div', _hoisted_3$9, toDisplayString(se.content), 1),
                        ]),
                      ],
                      2,
                    ),
                  ],
                  6,
                ),
                [[vShow, n.value]],
              ),
            ]),
            _: 1,
          },
          8,
          ['name', 'onBeforeLeave', 'onAfterLeave'],
        )
      );
    },
  }),
  Toast_vue_vue_type_style_index_0_scoped_737de82e_lang = '',
  ToastComponent = _export_sfc(_sfc_main$p, [['__scopeId', 'data-v-737de82e']]);
let nextId = 0;
const instancesMap = new Map(),
  getInstances = (r) => (instancesMap.has(r) || instancesMap.set(r, []), instancesMap.get(r)),
  close = (r, e) => {
    var l;
    const n = e.split('-')[0] === 'top',
      s = getInstances(e),
      o = s.findIndex((f) => {
        var m, v;
        return ((v = (m = f.component) == null ? void 0 : m.props) == null ? void 0 : v.id) === r;
      });
    if (o === -1) return;
    const a = s.splice(o, 1)[0];
    if (n) {
      const f = s.length;
      if (!f || o >= f) return;
      const m = ((l = a.el) == null ? void 0 : l.offsetHeight) ?? 0;
      for (let v = o; v < f; v++) {
        const I = s[v];
        if (I.el && I.component) {
          const L = parseInt(I.el.style.top, 10) - m;
          I.component.props.offset = L;
        }
      }
    }
  },
  baseToast = (r) => {
    const { position: e = 'top-center' } = r,
      n = e.split('-')[0] === 'bottom',
      s = document.createElement('div');
    s.classList.add('toast-container');
    const o = getInstances(e);
    let a = DEFAULT_OFFSET;
    n ||
      o.forEach((v) => {
        var I;
        a += ((I = v.el) == null ? void 0 : I.offsetHeight) ?? 0;
      });
    const l = nextId++,
      f = {
        ...r,
        id: l,
        offset: a,
        onClose: () => {
          close(l, e);
        },
        onDestroy: () => {
          render(null, s), s.remove();
        },
      },
      m = createVNode(ToastComponent, f);
    return (
      o.push(m),
      render(m, s),
      document.body.appendChild(s),
      n &&
        setTimeout(() => {
          var I;
          const v = ((I = m.el) == null ? void 0 : I.offsetHeight) ?? 0;
          for (let L = 0; L < o.length - 1; L++) {
            const V = o[L];
            if (V.el && V.component) {
              const se = parseInt(V.el.style.bottom, 10) + v;
              V.component.props.offset = se;
            }
          }
        }),
      () => {
        close(l, e);
      }
    );
  },
  typedToastObj = TOAST_TYPES.reduce((r, e) => ((r[e] = (n, s) => baseToast({ ...s, content: n, type: e })), r), {}),
  toast = Object.assign(baseToast, typedToastObj),
  _hoisted_1$k = ['checked', 'disabled'],
  _sfc_main$o = defineComponent({
    __name: 'Toggle',
    props: {
      modelValue: { type: Boolean },
      type: {},
      size: { default: 'sm' },
      disabled: { type: Boolean, default: !1 },
    },
    emits: ['update:modelValue', 'change'],
    setup(r, { emit: e }) {
      const n = r,
        s = computed(() => ({
          'toggle': !0,
          'toggle-primary': n.type === 'primary',
          'toggle-secondary': n.type === 'secondary',
          'toggle-accent': n.type === 'accent',
          'toggle-info': n.type === 'info',
          'toggle-success': n.type === 'success',
          'toggle-warning': n.type === 'warning',
          'toggle-error': n.type === 'error',
          'toggle-xs': n.size === 'xs',
          'toggle-sm': n.size === 'sm',
          'toggle-md': n.size === 'md',
          'toggle-lg': n.size === 'lg',
        }));
      function o(a) {
        const l = a.target.checked;
        e('update:modelValue', l), e('change', l);
      }
      return (a, l) => (
        openBlock(),
        createElementBlock(
          'input',
          { class: normalizeClass(s.value), checked: a.modelValue, type: 'checkbox', disabled: a.disabled, onInput: o },
          null,
          42,
          _hoisted_1$k,
        )
      );
    },
  }),
  _hoisted_1$j = ['data-tip'],
  _sfc_main$n = defineComponent({
    __name: 'Tooltip',
    props: {
      type: {},
      content: { default: '' },
      open: { type: Boolean },
      position: { default: 'top' },
      disabled: { type: Boolean, default: !1 },
    },
    setup(r) {
      const e = r,
        n = computed(() => !e.content || e.disabled),
        s = computed(() =>
          n.value
            ? {}
            : {
                'tooltip': !0,
                'tooltip-open': e.open,
                'tooltip-top': e.position === 'top',
                'tooltip-bottom': e.position === 'bottom',
                'tooltip-left': e.position === 'left',
                'tooltip-right': e.position === 'right',
                'tooltip-primary': e.type === 'primary',
                'tooltip-secondary': e.type === 'secondary',
                'tooltip-accent': e.type === 'accent',
                'tooltip-info': e.type === 'info',
                'tooltip-success': e.type === 'success',
                'tooltip-warning': e.type === 'warning',
                'tooltip-error': e.type === 'error',
              },
        );
      return (o, a) => (
        openBlock(),
        createElementBlock(
          'div',
          { 'class': normalizeClass(s.value), 'data-tip': o.content },
          [renderSlot(o.$slots, 'default', {}, void 0, !0)],
          10,
          _hoisted_1$j,
        )
      );
    },
  }),
  Tooltip_vue_vue_type_style_index_0_scoped_2a81d5de_lang = '',
  Tooltip = _export_sfc(_sfc_main$n, [['__scopeId', 'data-v-2a81d5de']]),
  _hoisted_1$i = { class: 'form-control w-full' },
  _hoisted_2$b = { class: 'label' },
  _hoisted_3$8 = { class: 'inline-flex items-center' },
  _hoisted_4$8 = { class: 'label-text font-semibold text-base' },
  _hoisted_5$4 = { class: 'label font-semibold pb-0' },
  _sfc_main$m = defineComponent({
    __name: 'FormInput',
    props: { modelValue: {}, title: {}, placeholder: { default: '' }, tip: { default: '' }, validateFn: {} },
    emits: ['update:modelValue', 'change', 'input'],
    setup(r, { expose: e, emit: n }) {
      const s = r;
      e({ validate: m, clearValidation: v, focus: f });
      const o = computed({
          get() {
            return s.modelValue;
          },
          set(V) {
            n('update:modelValue', V);
          },
        }),
        a = ref(''),
        l = ref(null);
      function f() {
        var V;
        (V = l.value) == null || V.focus();
      }
      function m() {
        var V;
        return (a.value = ((V = s.validateFn) == null ? void 0 : V.call(s, s.modelValue)) ?? ''), !a.value;
      }
      function v() {
        a.value = '';
      }
      function I(V) {
        n('change', V);
      }
      function L(V) {
        var se;
        (a.value = ((se = s.validateFn) == null ? void 0 : se.call(s, V)) ?? ''), n('input', V);
      }
      return (V, se) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$i, [
          createBaseVNode('label', _hoisted_2$b, [
            createBaseVNode('div', _hoisted_3$8, [
              createBaseVNode('span', _hoisted_4$8, toDisplayString(V.title), 1),
              V.tip
                ? (openBlock(),
                  createBlock(
                    unref(Tooltip),
                    { key: 0, class: 'ml-1', content: V.tip, position: 'right' },
                    { default: withCtx(() => [createVNode(unref(Help), { size: 14 })]), _: 1 },
                    8,
                    ['content'],
                  ))
                : createCommentVNode('', !0),
            ]),
          ]),
          createVNode(
            unref(_sfc_main$s),
            {
              'ref_key': 'input',
              'ref': l,
              'modelValue': o.value,
              'onUpdate:modelValue': se[0] || (se[0] = (Ee) => (o.value = Ee)),
              'class': normalizeClass({ 'text-error': !!a.value }),
              'placeholder': V.placeholder,
              'size': 'sm',
              'bordered': '',
              'type': a.value ? 'error' : void 0,
              'onChange': I,
              'onInput': L,
            },
            null,
            8,
            ['modelValue', 'class', 'placeholder', 'type'],
          ),
          createBaseVNode('label', _hoisted_5$4, [
            createBaseVNode(
              'span',
              { class: normalizeClass(['label-text-alt', { 'text-error': !!a.value }]) },
              toDisplayString(a.value || ' '),
              3,
            ),
          ]),
        ])
      );
    },
  }),
  _sfc_main$l = defineComponent({
    __name: 'IconButton',
    props: { size: { default: 24 }, transparent: { type: Boolean, default: !1 }, danger: { type: Boolean } },
    setup(r) {
      const e = r,
        n = computed(() => ({ width: `${e.size}px`, height: `${e.size}px` }));
      return (s, o) => (
        openBlock(),
        createBlock(
          unref(Button),
          {
            class: normalizeClass([
              'min-h-0 rounded',
              { 'hover:!bg-transparent': s.transparent && !s.danger, 'text-base-100': s.danger },
            ]),
            style: normalizeStyle(n.value),
            shape: 'square',
            type: s.danger ? 'error' : 'ghost',
          },
          { default: withCtx(() => [renderSlot(s.$slots, 'default')]), _: 3 },
          8,
          ['class', 'style', 'type'],
        )
      );
    },
  });
function tryOnScopeDispose(r) {
  return getCurrentScope() ? (onScopeDispose(r), !0) : !1;
}
function toValue(r) {
  return typeof r == 'function' ? r() : unref(r);
}
const isClient = typeof window < 'u' && typeof document < 'u',
  toString = Object.prototype.toString,
  isObject$1 = (r) => toString.call(r) === '[object Object]',
  noop$1 = () => {},
  isIOS = getIsIOS();
function getIsIOS() {
  var r;
  return (
    isClient &&
    ((r = window == null ? void 0 : window.navigator) == null ? void 0 : r.userAgent) &&
    /iP(ad|hone|od)/.test(window.navigator.userAgent)
  );
}
function createFilterWrapper(r, e) {
  function n(...s) {
    return new Promise((o, a) => {
      Promise.resolve(r(() => e.apply(this, s), { fn: e, thisArg: this, args: s }))
        .then(o)
        .catch(a);
    });
  }
  return n;
}
const bypassFilter = (r) => r();
function debounceFilter(r, e = {}) {
  let n,
    s,
    o = noop$1;
  const a = (f) => {
    clearTimeout(f), o(), (o = noop$1);
  };
  return (f) => {
    const m = toValue(r),
      v = toValue(e.maxWait);
    return (
      n && a(n),
      m <= 0 || (v !== void 0 && v <= 0)
        ? (s && (a(s), (s = null)), Promise.resolve(f()))
        : new Promise((I, L) => {
            (o = e.rejectOnCancel ? L : I),
              v &&
                !s &&
                (s = setTimeout(() => {
                  n && a(n), (s = null), I(f());
                }, v)),
              (n = setTimeout(() => {
                s && a(s), (s = null), I(f());
              }, m));
          })
    );
  };
}
function pausableFilter(r = bypassFilter) {
  const e = ref(!0);
  function n() {
    e.value = !1;
  }
  function s() {
    e.value = !0;
  }
  const o = (...a) => {
    e.value && r(...a);
  };
  return { isActive: readonly(e), pause: n, resume: s, eventFilter: o };
}
function useDebounceFn(r, e = 200, n = {}) {
  return createFilterWrapper(debounceFilter(e, n), r);
}
function watchWithFilter(r, e, n = {}) {
  const { eventFilter: s = bypassFilter, ...o } = n;
  return watch(r, createFilterWrapper(s, e), o);
}
function watchPausable(r, e, n = {}) {
  const { eventFilter: s, ...o } = n,
    { eventFilter: a, pause: l, resume: f, isActive: m } = pausableFilter(s);
  return { stop: watchWithFilter(r, e, { ...o, eventFilter: a }), pause: l, resume: f, isActive: m };
}
function tryOnMounted(r, e = !0) {
  getCurrentInstance() ? onMounted(r) : e ? r() : nextTick(r);
}
function useTimeoutFn(r, e, n = {}) {
  const { immediate: s = !0 } = n,
    o = ref(!1);
  let a = null;
  function l() {
    a && (clearTimeout(a), (a = null));
  }
  function f() {
    (o.value = !1), l();
  }
  function m(...v) {
    l(),
      (o.value = !0),
      (a = setTimeout(() => {
        (o.value = !1), (a = null), r(...v);
      }, toValue(e)));
  }
  return s && ((o.value = !0), isClient && m()), tryOnScopeDispose(f), { isPending: readonly(o), start: m, stop: f };
}
function whenever(r, e, n) {
  return watch(
    r,
    (s, o, a) => {
      s && e(s, o, a);
    },
    n,
  );
}
function unrefElement(r) {
  var e;
  const n = toValue(r);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const defaultWindow = isClient ? window : void 0,
  defaultDocument = isClient ? window.document : void 0;
function useEventListener(...r) {
  let e, n, s, o;
  if (
    (typeof r[0] == 'string' || Array.isArray(r[0]) ? (([n, s, o] = r), (e = defaultWindow)) : ([e, n, s, o] = r), !e)
  )
    return noop$1;
  Array.isArray(n) || (n = [n]), Array.isArray(s) || (s = [s]);
  const a = [],
    l = () => {
      a.forEach((I) => I()), (a.length = 0);
    },
    f = (I, L, V, se) => (I.addEventListener(L, V, se), () => I.removeEventListener(L, V, se)),
    m = watch(
      () => [unrefElement(e), toValue(o)],
      ([I, L]) => {
        if ((l(), !I)) return;
        const V = isObject$1(L) ? { ...L } : L;
        a.push(...n.flatMap((se) => s.map((Ee) => f(I, se, Ee, V))));
      },
      { immediate: !0, flush: 'post' },
    ),
    v = () => {
      m(), l();
    };
  return tryOnScopeDispose(v), v;
}
let _iOSWorkaround = !1;
function onClickOutside(r, e, n = {}) {
  const { window: s = defaultWindow, ignore: o = [], capture: a = !0, detectIframe: l = !1 } = n;
  if (!s) return;
  isIOS &&
    !_iOSWorkaround &&
    ((_iOSWorkaround = !0),
    Array.from(s.document.body.children).forEach((V) => V.addEventListener('click', noop$1)),
    s.document.documentElement.addEventListener('click', noop$1));
  let f = !0;
  const m = (V) =>
      o.some((se) => {
        if (typeof se == 'string')
          return Array.from(s.document.querySelectorAll(se)).some(
            (Ee) => Ee === V.target || V.composedPath().includes(Ee),
          );
        {
          const Ee = unrefElement(se);
          return Ee && (V.target === Ee || V.composedPath().includes(Ee));
        }
      }),
    I = [
      useEventListener(
        s,
        'click',
        (V) => {
          const se = unrefElement(r);
          if (!(!se || se === V.target || V.composedPath().includes(se))) {
            if ((V.detail === 0 && (f = !m(V)), !f)) {
              f = !0;
              return;
            }
            e(V);
          }
        },
        { passive: !0, capture: a },
      ),
      useEventListener(
        s,
        'pointerdown',
        (V) => {
          const se = unrefElement(r);
          se && (f = !V.composedPath().includes(se) && !m(V));
        },
        { passive: !0 },
      ),
      l &&
        useEventListener(s, 'blur', (V) => {
          setTimeout(() => {
            var se;
            const Ee = unrefElement(r);
            ((se = s.document.activeElement) == null ? void 0 : se.tagName) === 'IFRAME' &&
              !(Ee != null && Ee.contains(s.document.activeElement)) &&
              e(V);
          }, 0);
        }),
    ].filter(Boolean);
  return () => I.forEach((V) => V());
}
function useMounted() {
  const r = ref(!1);
  return (
    getCurrentInstance() &&
      onMounted(() => {
        r.value = !0;
      }),
    r
  );
}
function useSupported(r) {
  const e = useMounted();
  return computed(() => (e.value, !!r()));
}
const _global =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : typeof self < 'u'
      ? self
      : {},
  globalKey = '__vueuse_ssr_handlers__',
  handlers$1 = getHandlers();
function getHandlers() {
  return globalKey in _global || (_global[globalKey] = _global[globalKey] || {}), _global[globalKey];
}
function getSSRHandler(r, e) {
  return handlers$1[r] || e;
}
function guessSerializerType(r) {
  return r == null
    ? 'any'
    : r instanceof Set
    ? 'set'
    : r instanceof Map
    ? 'map'
    : r instanceof Date
    ? 'date'
    : typeof r == 'boolean'
    ? 'boolean'
    : typeof r == 'string'
    ? 'string'
    : typeof r == 'object'
    ? 'object'
    : Number.isNaN(r)
    ? 'any'
    : 'number';
}
const StorageSerializers = {
    boolean: { read: (r) => r === 'true', write: (r) => String(r) },
    object: { read: (r) => JSON.parse(r), write: (r) => JSON.stringify(r) },
    number: { read: (r) => Number.parseFloat(r), write: (r) => String(r) },
    any: { read: (r) => r, write: (r) => String(r) },
    string: { read: (r) => r, write: (r) => String(r) },
    map: { read: (r) => new Map(JSON.parse(r)), write: (r) => JSON.stringify(Array.from(r.entries())) },
    set: { read: (r) => new Set(JSON.parse(r)), write: (r) => JSON.stringify(Array.from(r)) },
    date: { read: (r) => new Date(r), write: (r) => r.toISOString() },
  },
  customStorageEventName = 'vueuse-storage';
function useStorage(r, e, n, s = {}) {
  var o;
  const {
      flush: a = 'pre',
      deep: l = !0,
      listenToStorageChanges: f = !0,
      writeDefaults: m = !0,
      mergeDefaults: v = !1,
      shallow: I,
      window: L = defaultWindow,
      eventFilter: V,
      onError: se = (Fl) => {
        console.error(Fl);
      },
    } = s,
    Ee = (I ? shallowRef : ref)(e);
  if (!n)
    try {
      n = getSSRHandler('getDefaultStorage', () => {
        var Fl;
        return (Fl = defaultWindow) == null ? void 0 : Fl.localStorage;
      })();
    } catch (Fl) {
      se(Fl);
    }
  if (!n) return Ee;
  const ht = toValue(e),
    ar = guessSerializerType(ht),
    $i = (o = s.serializer) != null ? o : StorageSerializers[ar],
    { pause: tl, resume: Wi } = watchPausable(Ee, () => hl(Ee.value), { flush: a, deep: l, eventFilter: V });
  return L && f && (useEventListener(L, 'storage', Al), useEventListener(L, customStorageEventName, dl)), Al(), Ee;
  function hl(Fl) {
    try {
      if (Fl == null) n.removeItem(r);
      else {
        const vl = $i.write(Fl),
          kl = n.getItem(r);
        kl !== vl &&
          (n.setItem(r, vl),
          L &&
            L.dispatchEvent(
              new CustomEvent(customStorageEventName, {
                detail: { key: r, oldValue: kl, newValue: vl, storageArea: n },
              }),
            ));
      }
    } catch (vl) {
      se(vl);
    }
  }
  function fl(Fl) {
    const vl = Fl ? Fl.newValue : n.getItem(r);
    if (vl == null) return m && ht !== null && n.setItem(r, $i.write(ht)), ht;
    if (!Fl && v) {
      const kl = $i.read(vl);
      return typeof v == 'function' ? v(kl, ht) : ar === 'object' && !Array.isArray(kl) ? { ...ht, ...kl } : kl;
    } else return typeof vl != 'string' ? vl : $i.read(vl);
  }
  function dl(Fl) {
    Al(Fl.detail);
  }
  function Al(Fl) {
    if (!(Fl && Fl.storageArea !== n)) {
      if (Fl && Fl.key == null) {
        Ee.value = ht;
        return;
      }
      if (!(Fl && Fl.key !== r)) {
        tl();
        try {
          (Fl == null ? void 0 : Fl.newValue) !== $i.write(Ee.value) && (Ee.value = fl(Fl));
        } catch (vl) {
          se(vl);
        } finally {
          Fl ? nextTick(Wi) : Wi();
        }
      }
    }
  }
}
function useResizeObserver(r, e, n = {}) {
  const { window: s = defaultWindow, ...o } = n;
  let a;
  const l = useSupported(() => s && 'ResizeObserver' in s),
    f = () => {
      a && (a.disconnect(), (a = void 0));
    },
    m = computed(() => (Array.isArray(r) ? r.map((L) => unrefElement(L)) : [unrefElement(r)])),
    v = watch(
      m,
      (L) => {
        if ((f(), l.value && s)) {
          a = new ResizeObserver(e);
          for (const V of L) V && a.observe(V, o);
        }
      },
      { immediate: !0, flush: 'post', deep: !0 },
    ),
    I = () => {
      f(), v();
    };
  return tryOnScopeDispose(I), { isSupported: l, stop: I };
}
const events = new Map();
function useEventBus(r) {
  const e = getCurrentScope();
  function n(f) {
    var m;
    const v = events.get(r) || new Set();
    v.add(f), events.set(r, v);
    const I = () => o(f);
    return (m = e == null ? void 0 : e.cleanups) == null || m.push(I), I;
  }
  function s(f) {
    function m(...v) {
      o(m), f(...v);
    }
    return n(m);
  }
  function o(f) {
    const m = events.get(r);
    m && (m.delete(f), m.size || a());
  }
  function a() {
    events.delete(r);
  }
  function l(f, m) {
    var v;
    (v = events.get(r)) == null || v.forEach((I) => I(f, m));
  }
  return { on: n, once: s, off: o, emit: l, reset: a };
}
function useLocalStorage(r, e, n = {}) {
  const { window: s = defaultWindow } = n;
  return useStorage(r, e, s == null ? void 0 : s.localStorage, n);
}
let _id = 0;
function useStyleTag(r, e = {}) {
  const n = ref(!1),
    { document: s = defaultDocument, immediate: o = !0, manual: a = !1, id: l = `vueuse_styletag_${++_id}` } = e,
    f = ref(r);
  let m = () => {};
  const v = () => {
      if (!s) return;
      const L = s.getElementById(l) || s.createElement('style');
      L.isConnected || ((L.id = l), e.media && (L.media = e.media), s.head.appendChild(L)),
        !n.value &&
          ((m = watch(
            f,
            (V) => {
              L.textContent = V;
            },
            { immediate: !0 },
          )),
          (n.value = !0));
    },
    I = () => {
      !s || !n.value || (m(), s.head.removeChild(s.getElementById(l)), (n.value = !1));
    };
  return (
    o && !a && tryOnMounted(v), a || tryOnScopeDispose(I), { id: l, css: f, unload: I, load: v, isLoaded: readonly(n) }
  );
}
const _sfc_main$k = defineComponent({
    __name: 'ResizeLayout',
    props: {
      vertical: { type: Boolean, default: !1 },
      barSize: { default: 8 },
      barColor: { default: 'transparent' },
      barFocusedSize: { default: 2 },
      barFocusedColor: { default: 'hsl(var(--p))' },
      initStartSize: {},
      localKey: { default: '' },
      reverse: { type: Boolean, default: !1 },
      startMinSize: {},
      startMaxSize: {},
    },
    setup(r) {
      const e = r,
        n = ref(null),
        s = ref(null),
        o = ref(null),
        a = ref(null),
        l = ref(!1),
        f = ref(!1),
        m = useLocalStorage(e.localKey, ''),
        v = ref(m.value || e.initStartSize || '50%'),
        { css: I, load: L, unload: V } = useStyleTag(''),
        se = computed(() =>
          e.vertical
            ? {
                'height': v.value,
                'min-height': e.startMinSize && `${e.startMinSize}px`,
                'max-height': e.startMaxSize && `${e.startMaxSize}px`,
              }
            : {
                'width': v.value,
                'min-width': e.startMinSize && `${e.startMinSize}px`,
                'max-width': e.startMaxSize && `${e.startMaxSize}px`,
              },
        ),
        Ee = computed(() =>
          e.vertical
            ? { 'height': `${e.barSize}px`, 'width': '100%', 'cursor': 'row-resize', 'background-color': e.barColor }
            : { 'width': `${e.barSize}px`, 'height': '100%', 'cursor': 'col-resize', 'background-color': e.barColor },
        ),
        ht = computed(() =>
          e.vertical
            ? {
                'height': `${e.barFocusedSize}px`,
                'width': '100%',
                'background-color': l.value || f.value ? e.barFocusedColor : 'transparent',
              }
            : {
                'width': `${e.barFocusedSize}px`,
                'height': '100%',
                'background-color': l.value || f.value ? e.barFocusedColor : 'transparent',
              },
        );
      return (
        useEventListener(s, 'mousedown', () => {
          (f.value = !0),
            (I.value = `
    :root { 
      cursor: ${e.vertical ? 'row-resize' : 'col-resize'}; 
    }
    * {
      user-select: none;
      pointer-events: none;
    }
  `),
            L();
        }),
        useEventListener(document, 'mouseup', () => {
          (f.value = !1), V();
        }),
        useEventListener(document, 'mousemove', (ar) => {
          var Al, Fl;
          if (!f.value) return;
          const { width: $i = 0, height: tl = 0 } =
              ((Al = n.value) == null ? void 0 : Al.getBoundingClientRect()) ?? {},
            { width: Wi = 0, height: hl = 0 } = ((Fl = o.value) == null ? void 0 : Fl.getBoundingClientRect()) ?? {},
            fl = e.vertical ? tl - e.barSize : $i - e.barSize,
            dl = e.vertical
              ? e.reverse
                ? hl - ar.movementY
                : hl + ar.movementY
              : e.reverse
              ? Wi - ar.movementX
              : Wi + ar.movementX;
          (v.value = `${Math.min(dl, fl)}px`),
            e.localKey && (m.value = v.value),
            nextTick(() => {
              var El, Jl, Kc, Il, Ll, Nl;
              const vl =
                  (e.vertical
                    ? (El = n.value) == null
                      ? void 0
                      : El.scrollHeight
                    : (Jl = n.value) == null
                    ? void 0
                    : Jl.scrollWidth) ?? 0,
                kl =
                  (e.vertical
                    ? (Kc = n.value) == null
                      ? void 0
                      : Kc.offsetHeight
                    : (Il = n.value) == null
                    ? void 0
                    : Il.offsetWidth) ?? 0;
              if (vl > kl) {
                const Hl =
                  (e.vertical
                    ? (Ll = a.value) == null
                      ? void 0
                      : Ll.scrollHeight
                    : (Nl = a.value) == null
                    ? void 0
                    : Nl.scrollWidth) ?? 0;
                (v.value = `${kl - e.barSize - Hl}px`), e.localKey && (m.value = v.value);
              }
            });
        }),
        useResizeObserver(n, (ar) => {
          var dl;
          const $i = ar[0],
            { width: tl, height: Wi } = $i.contentRect,
            { width: hl = 0, height: fl = 0 } = ((dl = o.value) == null ? void 0 : dl.getBoundingClientRect()) ?? {};
          e.vertical
            ? (v.value = `${Math.min(fl, Wi - e.barSize)}px`)
            : (v.value = `${Math.min(hl, tl - e.barSize)}px`),
            e.localKey && (m.value = v.value);
        }),
        onUnmounted(() => {
          V();
        }),
        (ar, $i) => (
          openBlock(),
          createElementBlock(
            'div',
            {
              ref_key: 'layoutRef',
              ref: n,
              class: normalizeClass([
                'resize-layout flex',
                {
                  'flex-col': ar.vertical && !ar.reverse,
                  'flex-row-reverse': !ar.vertical && ar.reverse,
                  'flex-col-reverse': ar.vertical && ar.reverse,
                },
              ]),
            },
            [
              createBaseVNode(
                'div',
                {
                  ref_key: 'startRef',
                  ref: o,
                  class: normalizeClass([
                    'start-container flex-none',
                    [ar.vertical ? 'min-h-0 max-h-full h-1/2' : 'min-w-0 max-w-full w-1/2'],
                  ]),
                  style: normalizeStyle(se.value),
                },
                [renderSlot(ar.$slots, 'start', {}, void 0, !0)],
                6,
              ),
              createBaseVNode(
                'div',
                {
                  ref_key: 'barRef',
                  ref: s,
                  class: 'flex-none flex-center',
                  style: normalizeStyle(Ee.value),
                  onMouseenter: $i[0] || ($i[0] = (tl) => (l.value = !0)),
                  onMouseleave: $i[1] || ($i[1] = (tl) => (l.value = !1)),
                },
                [
                  createBaseVNode(
                    'div',
                    { class: 'transition rounded-full', style: normalizeStyle(ht.value) },
                    null,
                    4,
                  ),
                ],
                36,
              ),
              createBaseVNode(
                'div',
                {
                  ref_key: 'endRef',
                  ref: a,
                  class: normalizeClass([
                    'end-container flex-1',
                    [ar.vertical ? 'min-h-0 max-h-full' : 'min-w-0 max-w-full'],
                  ]),
                },
                [renderSlot(ar.$slots, 'end', {}, void 0, !0)],
                2,
              ),
            ],
            2,
          )
        )
      );
    },
  }),
  ResizeLayout_vue_vue_type_style_index_0_scoped_ab7dc4ae_lang = '',
  ResizeLayout = _export_sfc(_sfc_main$k, [['__scopeId', 'data-v-ab7dc4ae']]);
var LocalStorageKey = ((r) => (
  (r.DetailResizeLayout = 'mockya-detail-resize-layout'),
  (r.ConfigResizeLayout = 'mockya-config-resize-layout'),
  (r.EditorLineWrap = 'mockya-editor-line-wrap'),
  r
))(LocalStorageKey || {});
const GlobalEvents = { ChangeSelectMock: Symbol('change-select-mock') },
  updateSaveDelay = 250;
class Text {
  lineAt(e) {
    if (e < 0 || e > this.length) throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  line(e) {
    if (e < 1 || e > this.lines) throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  replace(e, n, s) {
    let o = [];
    return (
      this.decompose(0, e, o, 2),
      s.length && s.decompose(0, s.length, o, 3),
      this.decompose(n, this.length, o, 1),
      TextNode.from(o, this.length - (n - e) + s.length)
    );
  }
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  slice(e, n = this.length) {
    let s = [];
    return this.decompose(e, n, s, 0), TextNode.from(s, n - e);
  }
  eq(e) {
    if (e == this) return !0;
    if (e.length != this.length || e.lines != this.lines) return !1;
    let n = this.scanIdentical(e, 1),
      s = this.length - this.scanIdentical(e, -1),
      o = new RawTextCursor(this),
      a = new RawTextCursor(e);
    for (let l = n, f = n; ; ) {
      if ((o.next(l), a.next(l), (l = 0), o.lineBreak != a.lineBreak || o.done != a.done || o.value != a.value))
        return !1;
      if (((f += o.value.length), o.done || f >= s)) return !0;
    }
  }
  iter(e = 1) {
    return new RawTextCursor(this, e);
  }
  iterRange(e, n = this.length) {
    return new PartialTextCursor(this, e, n);
  }
  iterLines(e, n) {
    let s;
    if (e == null) s = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let o = this.line(e).from;
      s = this.iterRange(o, Math.max(o, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new LineCursor(s);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  constructor() {}
  static of(e) {
    if (e.length == 0) throw new RangeError('A document must have at least one line');
    return e.length == 1 && !e[0]
      ? Text.empty
      : e.length <= 32
      ? new TextLeaf(e)
      : TextNode.from(TextLeaf.split(e, []));
  }
}
class TextLeaf extends Text {
  constructor(e, n = textLength(e)) {
    super(), (this.text = e), (this.length = n);
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, s, o) {
    for (let a = 0; ; a++) {
      let l = this.text[a],
        f = o + l.length;
      if ((n ? s : f) >= e) return new Line(o, f, s, l);
      (o = f + 1), s++;
    }
  }
  decompose(e, n, s, o) {
    let a =
      e <= 0 && n >= this.length
        ? this
        : new TextLeaf(sliceText(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (o & 1) {
      let l = s.pop(),
        f = appendText(a.text, l.text.slice(), 0, a.length);
      if (f.length <= 32) s.push(new TextLeaf(f, l.length + a.length));
      else {
        let m = f.length >> 1;
        s.push(new TextLeaf(f.slice(0, m)), new TextLeaf(f.slice(m)));
      }
    } else s.push(a);
  }
  replace(e, n, s) {
    if (!(s instanceof TextLeaf)) return super.replace(e, n, s);
    let o = appendText(this.text, appendText(s.text, sliceText(this.text, 0, e)), n),
      a = this.length + s.length - (n - e);
    return o.length <= 32 ? new TextLeaf(o, a) : TextNode.from(TextLeaf.split(o, []), a);
  }
  sliceString(
    e,
    n = this.length,
    s = `
`,
  ) {
    let o = '';
    for (let a = 0, l = 0; a <= n && l < this.text.length; l++) {
      let f = this.text[l],
        m = a + f.length;
      a > e && l && (o += s), e < m && n > a && (o += f.slice(Math.max(0, e - a), n - a)), (a = m + 1);
    }
    return o;
  }
  flatten(e) {
    for (let n of this.text) e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let s = [],
      o = -1;
    for (let a of e) s.push(a), (o += a.length + 1), s.length == 32 && (n.push(new TextLeaf(s, o)), (s = []), (o = -1));
    return o > -1 && n.push(new TextLeaf(s, o)), n;
  }
}
class TextNode extends Text {
  constructor(e, n) {
    super(), (this.children = e), (this.length = n), (this.lines = 0);
    for (let s of e) this.lines += s.lines;
  }
  lineInner(e, n, s, o) {
    for (let a = 0; ; a++) {
      let l = this.children[a],
        f = o + l.length,
        m = s + l.lines - 1;
      if ((n ? m : f) >= e) return l.lineInner(e, n, s, o);
      (o = f + 1), (s = m + 1);
    }
  }
  decompose(e, n, s, o) {
    for (let a = 0, l = 0; l <= n && a < this.children.length; a++) {
      let f = this.children[a],
        m = l + f.length;
      if (e <= m && n >= l) {
        let v = o & ((l <= e ? 1 : 0) | (m >= n ? 2 : 0));
        l >= e && m <= n && !v ? s.push(f) : f.decompose(e - l, n - l, s, v);
      }
      l = m + 1;
    }
  }
  replace(e, n, s) {
    if (s.lines < this.lines)
      for (let o = 0, a = 0; o < this.children.length; o++) {
        let l = this.children[o],
          f = a + l.length;
        if (e >= a && n <= f) {
          let m = l.replace(e - a, n - a, s),
            v = this.lines - l.lines + m.lines;
          if (m.lines < v >> (5 - 1) && m.lines > v >> (5 + 1)) {
            let I = this.children.slice();
            return (I[o] = m), new TextNode(I, this.length - (n - e) + s.length);
          }
          return super.replace(a, f, m);
        }
        a = f + 1;
      }
    return super.replace(e, n, s);
  }
  sliceString(
    e,
    n = this.length,
    s = `
`,
  ) {
    let o = '';
    for (let a = 0, l = 0; a < this.children.length && l <= n; a++) {
      let f = this.children[a],
        m = l + f.length;
      l > e && a && (o += s), e < m && n > l && (o += f.sliceString(e - l, n - l, s)), (l = m + 1);
    }
    return o;
  }
  flatten(e) {
    for (let n of this.children) n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof TextNode)) return 0;
    let s = 0,
      [o, a, l, f] =
        n > 0
          ? [0, 0, this.children.length, e.children.length]
          : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; o += n, a += n) {
      if (o == l || a == f) return s;
      let m = this.children[o],
        v = e.children[a];
      if (m != v) return s + m.scanIdentical(v, n);
      s += m.length + 1;
    }
  }
  static from(e, n = e.reduce((s, o) => s + o.length + 1, -1)) {
    let s = 0;
    for (let se of e) s += se.lines;
    if (s < 32) {
      let se = [];
      for (let Ee of e) Ee.flatten(se);
      return new TextLeaf(se, n);
    }
    let o = Math.max(32, s >> 5),
      a = o << 1,
      l = o >> 1,
      f = [],
      m = 0,
      v = -1,
      I = [];
    function L(se) {
      let Ee;
      if (se.lines > a && se instanceof TextNode) for (let ht of se.children) L(ht);
      else
        se.lines > l && (m > l || !m)
          ? (V(), f.push(se))
          : se instanceof TextLeaf && m && (Ee = I[I.length - 1]) instanceof TextLeaf && se.lines + Ee.lines <= 32
          ? ((m += se.lines),
            (v += se.length + 1),
            (I[I.length - 1] = new TextLeaf(Ee.text.concat(se.text), Ee.length + 1 + se.length)))
          : (m + se.lines > o && V(), (m += se.lines), (v += se.length + 1), I.push(se));
    }
    function V() {
      m != 0 && (f.push(I.length == 1 ? I[0] : TextNode.from(I, v)), (v = -1), (m = I.length = 0));
    }
    for (let se of e) L(se);
    return V(), f.length == 1 ? f[0] : new TextNode(f, n);
  }
}
Text.empty = new TextLeaf([''], 0);
function textLength(r) {
  let e = -1;
  for (let n of r) e += n.length + 1;
  return e;
}
function appendText(r, e, n = 0, s = 1e9) {
  for (let o = 0, a = 0, l = !0; a < r.length && o <= s; a++) {
    let f = r[a],
      m = o + f.length;
    m >= n &&
      (m > s && (f = f.slice(0, s - o)),
      o < n && (f = f.slice(n - o)),
      l ? ((e[e.length - 1] += f), (l = !1)) : e.push(f)),
      (o = m + 1);
  }
  return e;
}
function sliceText(r, e, n) {
  return appendText(r, [''], e, n);
}
class RawTextCursor {
  constructor(e, n = 1) {
    (this.dir = n),
      (this.done = !1),
      (this.lineBreak = !1),
      (this.value = ''),
      (this.nodes = [e]),
      (this.offsets = [n > 0 ? 1 : (e instanceof TextLeaf ? e.text.length : e.children.length) << 1]);
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let s = this.nodes.length - 1,
        o = this.nodes[s],
        a = this.offsets[s],
        l = a >> 1,
        f = o instanceof TextLeaf ? o.text.length : o.children.length;
      if (l == (n > 0 ? f : 0)) {
        if (s == 0) return (this.done = !0), (this.value = ''), this;
        n > 0 && this.offsets[s - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((a & 1) == (n > 0 ? 0 : 1)) {
        if (((this.offsets[s] += n), e == 0))
          return (
            (this.lineBreak = !0),
            (this.value = `
`),
            this
          );
        e--;
      } else if (o instanceof TextLeaf) {
        let m = o.text[l + (n < 0 ? -1 : 0)];
        if (((this.offsets[s] += n), m.length > Math.max(0, e)))
          return (this.value = e == 0 ? m : n > 0 ? m.slice(e) : m.slice(0, m.length - e)), this;
        e -= m.length;
      } else {
        let m = o.children[l + (n < 0 ? -1 : 0)];
        e > m.length
          ? ((e -= m.length), (this.offsets[s] += n))
          : (n < 0 && this.offsets[s]--,
            this.nodes.push(m),
            this.offsets.push(n > 0 ? 1 : (m instanceof TextLeaf ? m.text.length : m.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), (e = this.value.length)), this.nextInner(e, this.dir);
  }
}
class PartialTextCursor {
  constructor(e, n, s) {
    (this.value = ''),
      (this.done = !1),
      (this.cursor = new RawTextCursor(e, n > s ? -1 : 1)),
      (this.pos = n > s ? e.length : 0),
      (this.from = Math.min(n, s)),
      (this.to = Math.max(n, s));
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to) return (this.value = ''), (this.done = !0), this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let s = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > s && (e = s), (s -= e);
    let { value: o } = this.cursor.next(e);
    return (
      (this.pos += (o.length + e) * n),
      (this.value = o.length <= s ? o : n < 0 ? o.slice(o.length - s) : o.slice(0, s)),
      (this.done = !this.value),
      this
    );
  }
  next(e = 0) {
    return (
      e < 0 ? (e = Math.max(e, this.from - this.pos)) : e > 0 && (e = Math.min(e, this.to - this.pos)),
      this.nextInner(e, this.cursor.dir)
    );
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != '';
  }
}
class LineCursor {
  constructor(e) {
    (this.inner = e), (this.afterBreak = !0), (this.value = ''), (this.done = !1);
  }
  next(e = 0) {
    let { done: n, lineBreak: s, value: o } = this.inner.next(e);
    return (
      n
        ? ((this.done = !0), (this.value = ''))
        : s
        ? this.afterBreak
          ? (this.value = '')
          : ((this.afterBreak = !0), this.next())
        : ((this.value = o), (this.afterBreak = !1)),
      this
    );
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < 'u' &&
  ((Text.prototype[Symbol.iterator] = function () {
    return this.iter();
  }),
  (RawTextCursor.prototype[Symbol.iterator] =
    PartialTextCursor.prototype[Symbol.iterator] =
    LineCursor.prototype[Symbol.iterator] =
      function () {
        return this;
      }));
class Line {
  constructor(e, n, s, o) {
    (this.from = e), (this.to = n), (this.number = s), (this.text = o);
  }
  get length() {
    return this.to - this.from;
  }
}
let extend =
  'lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o'
    .split(',')
    .map((r) => (r ? parseInt(r, 36) : 1));
for (let r = 1; r < extend.length; r++) extend[r] += extend[r - 1];
function isExtendingChar(r) {
  for (let e = 1; e < extend.length; e += 2) if (extend[e] > r) return extend[e - 1] <= r;
  return !1;
}
function isRegionalIndicator(r) {
  return r >= 127462 && r <= 127487;
}
const ZWJ = 8205;
function findClusterBreak(r, e, n = !0, s = !0) {
  return (n ? nextClusterBreak : prevClusterBreak)(r, e, s);
}
function nextClusterBreak(r, e, n) {
  if (e == r.length) return e;
  e && surrogateLow(r.charCodeAt(e)) && surrogateHigh(r.charCodeAt(e - 1)) && e--;
  let s = codePointAt(r, e);
  for (e += codePointSize(s); e < r.length; ) {
    let o = codePointAt(r, e);
    if (s == ZWJ || o == ZWJ || (n && isExtendingChar(o))) (e += codePointSize(o)), (s = o);
    else if (isRegionalIndicator(o)) {
      let a = 0,
        l = e - 2;
      for (; l >= 0 && isRegionalIndicator(codePointAt(r, l)); ) a++, (l -= 2);
      if (a % 2 == 0) break;
      e += 2;
    } else break;
  }
  return e;
}
function prevClusterBreak(r, e, n) {
  for (; e > 0; ) {
    let s = nextClusterBreak(r, e - 2, n);
    if (s < e) return s;
    e--;
  }
  return 0;
}
function surrogateLow(r) {
  return r >= 56320 && r < 57344;
}
function surrogateHigh(r) {
  return r >= 55296 && r < 56320;
}
function codePointAt(r, e) {
  let n = r.charCodeAt(e);
  if (!surrogateHigh(n) || e + 1 == r.length) return n;
  let s = r.charCodeAt(e + 1);
  return surrogateLow(s) ? ((n - 55296) << 10) + (s - 56320) + 65536 : n;
}
function fromCodePoint(r) {
  return r <= 65535
    ? String.fromCharCode(r)
    : ((r -= 65536), String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
}
function codePointSize(r) {
  return r < 65536 ? 1 : 2;
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = (function (r) {
  return (
    (r[(r.Simple = 0)] = 'Simple'),
    (r[(r.TrackDel = 1)] = 'TrackDel'),
    (r[(r.TrackBefore = 2)] = 'TrackBefore'),
    (r[(r.TrackAfter = 3)] = 'TrackAfter'),
    r
  );
})(MapMode || (MapMode = {}));
class ChangeDesc {
  constructor(e) {
    this.sections = e;
  }
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) e += this.sections[n];
    return e;
  }
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let s = this.sections[n + 1];
      e += s < 0 ? this.sections[n] : s;
    }
    return e;
  }
  get empty() {
    return this.sections.length == 0 || (this.sections.length == 2 && this.sections[1] < 0);
  }
  iterGaps(e) {
    for (let n = 0, s = 0, o = 0; n < this.sections.length; ) {
      let a = this.sections[n++],
        l = this.sections[n++];
      l < 0 ? (e(s, o, a), (o += a)) : (o += l), (s += a);
    }
  }
  iterChangedRanges(e, n = !1) {
    iterChanges(this, e, n);
  }
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let s = this.sections[n++],
        o = this.sections[n++];
      o < 0 ? e.push(s, o) : e.push(o, s);
    }
    return new ChangeDesc(e);
  }
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : composeSets(this, e);
  }
  mapDesc(e, n = !1) {
    return e.empty ? this : mapSet(this, e, n);
  }
  mapPos(e, n = -1, s = MapMode.Simple) {
    let o = 0,
      a = 0;
    for (let l = 0; l < this.sections.length; ) {
      let f = this.sections[l++],
        m = this.sections[l++],
        v = o + f;
      if (m < 0) {
        if (v > e) return a + (e - o);
        a += f;
      } else {
        if (
          s != MapMode.Simple &&
          v >= e &&
          ((s == MapMode.TrackDel && o < e && v > e) ||
            (s == MapMode.TrackBefore && o < e) ||
            (s == MapMode.TrackAfter && v > e))
        )
          return null;
        if (v > e || (v == e && n < 0 && !f)) return e == o || n < 0 ? a : a + m;
        a += m;
      }
      o = v;
    }
    if (e > o) throw new RangeError(`Position ${e} is out of range for changeset of length ${o}`);
    return a;
  }
  touchesRange(e, n = e) {
    for (let s = 0, o = 0; s < this.sections.length && o <= n; ) {
      let a = this.sections[s++],
        l = this.sections[s++],
        f = o + a;
      if (l >= 0 && o <= n && f >= e) return o < e && f > n ? 'cover' : !0;
      o = f;
    }
    return !1;
  }
  toString() {
    let e = '';
    for (let n = 0; n < this.sections.length; ) {
      let s = this.sections[n++],
        o = this.sections[n++];
      e += (e ? ' ' : '') + s + (o >= 0 ? ':' + o : '');
    }
    return e;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != 'number'))
      throw new RangeError('Invalid JSON representation of ChangeDesc');
    return new ChangeDesc(e);
  }
  static create(e) {
    return new ChangeDesc(e);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(e, n) {
    super(e), (this.inserted = n);
  }
  apply(e) {
    if (this.length != e.length) throw new RangeError('Applying change set to a document with the wrong length');
    return iterChanges(this, (n, s, o, a, l) => (e = e.replace(o, o + (s - n), l)), !1), e;
  }
  mapDesc(e, n = !1) {
    return mapSet(this, e, n, !0);
  }
  invert(e) {
    let n = this.sections.slice(),
      s = [];
    for (let o = 0, a = 0; o < n.length; o += 2) {
      let l = n[o],
        f = n[o + 1];
      if (f >= 0) {
        (n[o] = f), (n[o + 1] = l);
        let m = o >> 1;
        for (; s.length < m; ) s.push(Text.empty);
        s.push(l ? e.slice(a, a + l) : Text.empty);
      }
      a += l;
    }
    return new ChangeSet(n, s);
  }
  compose(e) {
    return this.empty ? e : e.empty ? this : composeSets(this, e, !0);
  }
  map(e, n = !1) {
    return e.empty ? this : mapSet(this, e, n, !0);
  }
  iterChanges(e, n = !1) {
    iterChanges(this, e, n);
  }
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  filter(e) {
    let n = [],
      s = [],
      o = [],
      a = new SectionIter(this);
    e: for (let l = 0, f = 0; ; ) {
      let m = l == e.length ? 1e9 : e[l++];
      for (; f < m || (f == m && a.len == 0); ) {
        if (a.done) break e;
        let I = Math.min(a.len, m - f);
        addSection(o, I, -1);
        let L = a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0;
        addSection(n, I, L), L > 0 && addInsert(s, n, a.text), a.forward(I), (f += I);
      }
      let v = e[l++];
      for (; f < v; ) {
        if (a.done) break e;
        let I = Math.min(a.len, v - f);
        addSection(n, I, -1), addSection(o, I, a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0), a.forward(I), (f += I);
      }
    }
    return { changes: new ChangeSet(n, s), filtered: ChangeDesc.create(o) };
  }
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let s = this.sections[n],
        o = this.sections[n + 1];
      o < 0 ? e.push(s) : o == 0 ? e.push([s]) : e.push([s].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  static of(e, n, s) {
    let o = [],
      a = [],
      l = 0,
      f = null;
    function m(I = !1) {
      if (!I && !o.length) return;
      l < n && addSection(o, n - l, -1);
      let L = new ChangeSet(o, a);
      (f = f ? f.compose(L.map(f)) : L), (o = []), (a = []), (l = 0);
    }
    function v(I) {
      if (Array.isArray(I)) for (let L of I) v(L);
      else if (I instanceof ChangeSet) {
        if (I.length != n) throw new RangeError(`Mismatched change set length (got ${I.length}, expected ${n})`);
        m(), (f = f ? f.compose(I.map(f)) : I);
      } else {
        let { from: L, to: V = L, insert: se } = I;
        if (L > V || L < 0 || V > n) throw new RangeError(`Invalid change range ${L} to ${V} (in doc of length ${n})`);
        let Ee = se ? (typeof se == 'string' ? Text.of(se.split(s || DefaultSplit)) : se) : Text.empty,
          ht = Ee.length;
        if (L == V && ht == 0) return;
        L < l && m(), L > l && addSection(o, L - l, -1), addSection(o, V - L, ht), addInsert(a, o, Ee), (l = V);
      }
    }
    return v(e), m(!f), f;
  }
  static empty(e) {
    return new ChangeSet(e ? [e, -1] : [], []);
  }
  static fromJSON(e) {
    if (!Array.isArray(e)) throw new RangeError('Invalid JSON representation of ChangeSet');
    let n = [],
      s = [];
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (typeof a == 'number') n.push(a, -1);
      else {
        if (!Array.isArray(a) || typeof a[0] != 'number' || a.some((l, f) => f && typeof l != 'string'))
          throw new RangeError('Invalid JSON representation of ChangeSet');
        if (a.length == 1) n.push(a[0], 0);
        else {
          for (; s.length < o; ) s.push(Text.empty);
          (s[o] = Text.of(a.slice(1))), n.push(a[0], s[o].length);
        }
      }
    }
    return new ChangeSet(n, s);
  }
  static createSet(e, n) {
    return new ChangeSet(e, n);
  }
}
function addSection(r, e, n, s = !1) {
  if (e == 0 && n <= 0) return;
  let o = r.length - 2;
  o >= 0 && n <= 0 && n == r[o + 1]
    ? (r[o] += e)
    : e == 0 && r[o] == 0
    ? (r[o + 1] += n)
    : s
    ? ((r[o] += e), (r[o + 1] += n))
    : r.push(e, n);
}
function addInsert(r, e, n) {
  if (n.length == 0) return;
  let s = (e.length - 2) >> 1;
  if (s < r.length) r[r.length - 1] = r[r.length - 1].append(n);
  else {
    for (; r.length < s; ) r.push(Text.empty);
    r.push(n);
  }
}
function iterChanges(r, e, n) {
  let s = r.inserted;
  for (let o = 0, a = 0, l = 0; l < r.sections.length; ) {
    let f = r.sections[l++],
      m = r.sections[l++];
    if (m < 0) (o += f), (a += f);
    else {
      let v = o,
        I = a,
        L = Text.empty;
      for (
        ;
        (v += f),
          (I += m),
          m && s && (L = L.append(s[(l - 2) >> 1])),
          !(n || l == r.sections.length || r.sections[l + 1] < 0);

      )
        (f = r.sections[l++]), (m = r.sections[l++]);
      e(o, v, a, I, L), (o = v), (a = I);
    }
  }
}
function mapSet(r, e, n, s = !1) {
  let o = [],
    a = s ? [] : null,
    l = new SectionIter(r),
    f = new SectionIter(e);
  for (let m = -1; ; )
    if (l.ins == -1 && f.ins == -1) {
      let v = Math.min(l.len, f.len);
      addSection(o, v, -1), l.forward(v), f.forward(v);
    } else if (f.ins >= 0 && (l.ins < 0 || m == l.i || (l.off == 0 && (f.len < l.len || (f.len == l.len && !n))))) {
      let v = f.len;
      for (addSection(o, f.ins, -1); v; ) {
        let I = Math.min(l.len, v);
        l.ins >= 0 && m < l.i && l.len <= I && (addSection(o, 0, l.ins), a && addInsert(a, o, l.text), (m = l.i)),
          l.forward(I),
          (v -= I);
      }
      f.next();
    } else if (l.ins >= 0) {
      let v = 0,
        I = l.len;
      for (; I; )
        if (f.ins == -1) {
          let L = Math.min(I, f.len);
          (v += L), (I -= L), f.forward(L);
        } else if (f.ins == 0 && f.len < I) (I -= f.len), f.next();
        else break;
      addSection(o, v, m < l.i ? l.ins : 0), a && m < l.i && addInsert(a, o, l.text), (m = l.i), l.forward(l.len - I);
    } else {
      if (l.done && f.done) return a ? ChangeSet.createSet(o, a) : ChangeDesc.create(o);
      throw new Error('Mismatched change set lengths');
    }
}
function composeSets(r, e, n = !1) {
  let s = [],
    o = n ? [] : null,
    a = new SectionIter(r),
    l = new SectionIter(e);
  for (let f = !1; ; ) {
    if (a.done && l.done) return o ? ChangeSet.createSet(s, o) : ChangeDesc.create(s);
    if (a.ins == 0) addSection(s, a.len, 0, f), a.next();
    else if (l.len == 0 && !l.done) addSection(s, 0, l.ins, f), o && addInsert(o, s, l.text), l.next();
    else {
      if (a.done || l.done) throw new Error('Mismatched change set lengths');
      {
        let m = Math.min(a.len2, l.len),
          v = s.length;
        if (a.ins == -1) {
          let I = l.ins == -1 ? -1 : l.off ? 0 : l.ins;
          addSection(s, m, I, f), o && I && addInsert(o, s, l.text);
        } else
          l.ins == -1
            ? (addSection(s, a.off ? 0 : a.len, m, f), o && addInsert(o, s, a.textBit(m)))
            : (addSection(s, a.off ? 0 : a.len, l.off ? 0 : l.ins, f), o && !l.off && addInsert(o, s, l.text));
        (f = (a.ins > m || (l.ins >= 0 && l.len > m)) && (f || s.length > v)), a.forward2(m), l.forward(m);
      }
    }
  }
}
class SectionIter {
  constructor(e) {
    (this.set = e), (this.i = 0), this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? ((this.len = e[this.i++]), (this.ins = e[this.i++])) : ((this.len = 0), (this.ins = -2)),
      (this.off = 0);
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set,
      n = (this.i - 2) >> 1;
    return n >= e.length ? Text.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set,
      s = (this.i - 2) >> 1;
    return s >= n.length && !e ? Text.empty : n[s].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : ((this.len -= e), (this.off += e));
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : ((this.ins -= e), (this.off += e));
  }
}
class SelectionRange {
  constructor(e, n, s) {
    (this.from = e), (this.to = n), (this.flags = s);
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  map(e, n = -1) {
    let s, o;
    return (
      this.empty ? (s = o = e.mapPos(this.from, n)) : ((s = e.mapPos(this.from, 1)), (o = e.mapPos(this.to, -1))),
      s == this.from && o == this.to ? this : new SelectionRange(s, o, this.flags)
    );
  }
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor) return EditorSelection.range(e, n);
    let s = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return EditorSelection.range(this.anchor, s);
  }
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(e) {
    if (!e || typeof e.anchor != 'number' || typeof e.head != 'number')
      throw new RangeError('Invalid JSON representation for SelectionRange');
    return EditorSelection.range(e.anchor, e.head);
  }
  static create(e, n, s) {
    return new SelectionRange(e, n, s);
  }
}
class EditorSelection {
  constructor(e, n) {
    (this.ranges = e), (this.mainIndex = n);
  }
  map(e, n = -1) {
    return e.empty
      ? this
      : EditorSelection.create(
          this.ranges.map((s) => s.map(e, n)),
          this.mainIndex,
        );
  }
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1;
    for (let n = 0; n < this.ranges.length; n++) if (!this.ranges[n].eq(e.ranges[n])) return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
  }
  addRange(e, n = !0) {
    return EditorSelection.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  replaceRange(e, n = this.mainIndex) {
    let s = this.ranges.slice();
    return (s[n] = e), EditorSelection.create(s, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != 'number' || e.main >= e.ranges.length)
      throw new RangeError('Invalid JSON representation for EditorSelection');
    return new EditorSelection(
      e.ranges.map((n) => SelectionRange.fromJSON(n)),
      e.main,
    );
  }
  static single(e, n = e) {
    return new EditorSelection([EditorSelection.range(e, n)], 0);
  }
  static create(e, n = 0) {
    if (e.length == 0) throw new RangeError('A selection needs at least one range');
    for (let s = 0, o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.empty ? a.from <= s : a.from < s) return EditorSelection.normalized(e.slice(), n);
      s = a.to;
    }
    return new EditorSelection(e, n);
  }
  static cursor(e, n = 0, s, o) {
    return SelectionRange.create(
      e,
      e,
      (n == 0 ? 0 : n < 0 ? 8 : 16) | (s == null ? 7 : Math.min(6, s)) | ((o ?? 16777215) << 6),
    );
  }
  static range(e, n, s, o) {
    let a = ((s ?? 16777215) << 6) | (o == null ? 7 : Math.min(6, o));
    return n < e ? SelectionRange.create(n, e, 48 | a) : SelectionRange.create(e, n, (n > e ? 8 : 0) | a);
  }
  static normalized(e, n = 0) {
    let s = e[n];
    e.sort((o, a) => o.from - a.from), (n = e.indexOf(s));
    for (let o = 1; o < e.length; o++) {
      let a = e[o],
        l = e[o - 1];
      if (a.empty ? a.from <= l.to : a.from < l.to) {
        let f = l.from,
          m = Math.max(a.to, l.to);
        o <= n && n--, e.splice(--o, 2, a.anchor > a.head ? EditorSelection.range(m, f) : EditorSelection.range(f, m));
      }
    }
    return new EditorSelection(e, n);
  }
}
function checkSelection(r, e) {
  for (let n of r.ranges) if (n.to > e) throw new RangeError('Selection points outside of document');
}
let nextID = 0;
class Facet {
  constructor(e, n, s, o, a) {
    (this.combine = e),
      (this.compareInput = n),
      (this.compare = s),
      (this.isStatic = o),
      (this.id = nextID++),
      (this.default = e([])),
      (this.extensions = typeof a == 'function' ? a(this) : a);
  }
  get reader() {
    return this;
  }
  static define(e = {}) {
    return new Facet(
      e.combine || ((n) => n),
      e.compareInput || ((n, s) => n === s),
      e.compare || (e.combine ? (n, s) => n === s : sameArray$1),
      !!e.static,
      e.enables,
    );
  }
  of(e) {
    return new FacetProvider([], this, 0, e);
  }
  compute(e, n) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(e, this, 1, n);
  }
  computeN(e, n) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (s) => s), this.compute([e], (s) => n(s.field(e)));
  }
}
function sameArray$1(r, e) {
  return r == e || (r.length == e.length && r.every((n, s) => n === e[s]));
}
class FacetProvider {
  constructor(e, n, s, o) {
    (this.dependencies = e), (this.facet = n), (this.type = s), (this.value = o), (this.id = nextID++);
  }
  dynamicSlot(e) {
    var n;
    let s = this.value,
      o = this.facet.compareInput,
      a = this.id,
      l = e[a] >> 1,
      f = this.type == 2,
      m = !1,
      v = !1,
      I = [];
    for (let L of this.dependencies)
      L == 'doc'
        ? (m = !0)
        : L == 'selection'
        ? (v = !0)
        : ((n = e[L.id]) !== null && n !== void 0 ? n : 1) & 1 || I.push(e[L.id]);
    return {
      create(L) {
        return (L.values[l] = s(L)), 1;
      },
      update(L, V) {
        if ((m && V.docChanged) || (v && (V.docChanged || V.selection)) || ensureAll(L, I)) {
          let se = s(L);
          if (f ? !compareArray(se, L.values[l], o) : !o(se, L.values[l])) return (L.values[l] = se), 1;
        }
        return 0;
      },
      reconfigure: (L, V) => {
        let se,
          Ee = V.config.address[a];
        if (Ee != null) {
          let ht = getAddr(V, Ee);
          if (
            this.dependencies.every((ar) =>
              ar instanceof Facet
                ? V.facet(ar) === L.facet(ar)
                : ar instanceof StateField
                ? V.field(ar, !1) == L.field(ar, !1)
                : !0,
            ) ||
            (f ? compareArray((se = s(L)), ht, o) : o((se = s(L)), ht))
          )
            return (L.values[l] = ht), 0;
        } else se = s(L);
        return (L.values[l] = se), 1;
      },
    };
  }
}
function compareArray(r, e, n) {
  if (r.length != e.length) return !1;
  for (let s = 0; s < r.length; s++) if (!n(r[s], e[s])) return !1;
  return !0;
}
function ensureAll(r, e) {
  let n = !1;
  for (let s of e) ensureAddr(r, s) & 1 && (n = !0);
  return n;
}
function dynamicFacetSlot(r, e, n) {
  let s = n.map((m) => r[m.id]),
    o = n.map((m) => m.type),
    a = s.filter((m) => !(m & 1)),
    l = r[e.id] >> 1;
  function f(m) {
    let v = [];
    for (let I = 0; I < s.length; I++) {
      let L = getAddr(m, s[I]);
      if (o[I] == 2) for (let V of L) v.push(V);
      else v.push(L);
    }
    return e.combine(v);
  }
  return {
    create(m) {
      for (let v of s) ensureAddr(m, v);
      return (m.values[l] = f(m)), 1;
    },
    update(m, v) {
      if (!ensureAll(m, a)) return 0;
      let I = f(m);
      return e.compare(I, m.values[l]) ? 0 : ((m.values[l] = I), 1);
    },
    reconfigure(m, v) {
      let I = ensureAll(m, s),
        L = v.config.facets[e.id],
        V = v.facet(e);
      if (L && !I && sameArray$1(n, L)) return (m.values[l] = V), 0;
      let se = f(m);
      return e.compare(se, V) ? ((m.values[l] = V), 0) : ((m.values[l] = se), 1);
    },
  };
}
const initField = Facet.define({ static: !0 });
class StateField {
  constructor(e, n, s, o, a) {
    (this.id = e),
      (this.createF = n),
      (this.updateF = s),
      (this.compareF = o),
      (this.spec = a),
      (this.provides = void 0);
  }
  static define(e) {
    let n = new StateField(nextID++, e.create, e.update, e.compare || ((s, o) => s === o), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(initField).find((s) => s.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (s) => ((s.values[n] = this.create(s)), 1),
      update: (s, o) => {
        let a = s.values[n],
          l = this.updateF(a, o);
        return this.compareF(a, l) ? 0 : ((s.values[n] = l), 1);
      },
      reconfigure: (s, o) =>
        o.config.address[this.id] != null ? ((s.values[n] = o.field(this)), 0) : ((s.values[n] = this.create(s)), 1),
    };
  }
  init(e) {
    return [this, initField.of({ field: this, create: e })];
  }
  get extension() {
    return this;
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(r) {
  return (e) => new PrecExtension(e, r);
}
const Prec = {
  highest: prec(Prec_.highest),
  high: prec(Prec_.high),
  default: prec(Prec_.default),
  low: prec(Prec_.low),
  lowest: prec(Prec_.lowest),
};
class PrecExtension {
  constructor(e, n) {
    (this.inner = e), (this.prec = n);
  }
}
class Compartment {
  of(e) {
    return new CompartmentInstance(this, e);
  }
  reconfigure(e) {
    return Compartment.reconfigure.of({ compartment: this, extension: e });
  }
  get(e) {
    return e.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(e, n) {
    (this.compartment = e), (this.inner = n);
  }
}
class Configuration {
  constructor(e, n, s, o, a, l) {
    for (
      this.base = e,
        this.compartments = n,
        this.dynamicSlots = s,
        this.address = o,
        this.staticValues = a,
        this.facets = l,
        this.statusTemplate = [];
      this.statusTemplate.length < s.length;

    )
      this.statusTemplate.push(0);
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, s) {
    let o = [],
      a = Object.create(null),
      l = new Map();
    for (let V of flatten(e, n, l))
      V instanceof StateField ? o.push(V) : (a[V.facet.id] || (a[V.facet.id] = [])).push(V);
    let f = Object.create(null),
      m = [],
      v = [];
    for (let V of o) (f[V.id] = v.length << 1), v.push((se) => V.slot(se));
    let I = s == null ? void 0 : s.config.facets;
    for (let V in a) {
      let se = a[V],
        Ee = se[0].facet,
        ht = (I && I[V]) || [];
      if (se.every((ar) => ar.type == 0))
        if (((f[Ee.id] = (m.length << 1) | 1), sameArray$1(ht, se))) m.push(s.facet(Ee));
        else {
          let ar = Ee.combine(se.map(($i) => $i.value));
          m.push(s && Ee.compare(ar, s.facet(Ee)) ? s.facet(Ee) : ar);
        }
      else {
        for (let ar of se)
          ar.type == 0
            ? ((f[ar.id] = (m.length << 1) | 1), m.push(ar.value))
            : ((f[ar.id] = v.length << 1), v.push(($i) => ar.dynamicSlot($i)));
        (f[Ee.id] = v.length << 1), v.push((ar) => dynamicFacetSlot(ar, Ee, se));
      }
    }
    let L = v.map((V) => V(f));
    return new Configuration(e, l, L, f, m, a);
  }
}
function flatten(r, e, n) {
  let s = [[], [], [], [], []],
    o = new Map();
  function a(l, f) {
    let m = o.get(l);
    if (m != null) {
      if (m <= f) return;
      let v = s[m].indexOf(l);
      v > -1 && s[m].splice(v, 1), l instanceof CompartmentInstance && n.delete(l.compartment);
    }
    if ((o.set(l, f), Array.isArray(l))) for (let v of l) a(v, f);
    else if (l instanceof CompartmentInstance) {
      if (n.has(l.compartment)) throw new RangeError('Duplicate use of compartment in extensions');
      let v = e.get(l.compartment) || l.inner;
      n.set(l.compartment, v), a(v, f);
    } else if (l instanceof PrecExtension) a(l.inner, l.prec);
    else if (l instanceof StateField) s[f].push(l), l.provides && a(l.provides, f);
    else if (l instanceof FacetProvider) s[f].push(l), l.facet.extensions && a(l.facet.extensions, Prec_.default);
    else {
      let v = l.extension;
      if (!v)
        throw new Error(
          `Unrecognized extension value in extension set (${l}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`,
        );
      a(v, f);
    }
  }
  return a(r, Prec_.default), s.reduce((l, f) => l.concat(f));
}
function ensureAddr(r, e) {
  if (e & 1) return 2;
  let n = e >> 1,
    s = r.status[n];
  if (s == 4) throw new Error('Cyclic dependency between fields and/or facets');
  if (s & 2) return s;
  r.status[n] = 4;
  let o = r.computeSlot(r, r.config.dynamicSlots[n]);
  return (r.status[n] = 2 | o);
}
function getAddr(r, e) {
  return e & 1 ? r.config.staticValues[e >> 1] : r.values[e >> 1];
}
const languageData = Facet.define(),
  allowMultipleSelections = Facet.define({ combine: (r) => r.some((e) => e), static: !0 }),
  lineSeparator = Facet.define({ combine: (r) => (r.length ? r[0] : void 0), static: !0 }),
  changeFilter = Facet.define(),
  transactionFilter = Facet.define(),
  transactionExtender = Facet.define(),
  readOnly = Facet.define({ combine: (r) => (r.length ? r[0] : !1) });
class Annotation {
  constructor(e, n) {
    (this.type = e), (this.value = n);
  }
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  of(e) {
    return new Annotation(this, e);
  }
}
class StateEffectType {
  constructor(e) {
    this.map = e;
  }
  of(e) {
    return new StateEffect(this, e);
  }
}
class StateEffect {
  constructor(e, n) {
    (this.type = e), (this.value = n);
  }
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new StateEffect(this.type, n);
  }
  is(e) {
    return this.type == e;
  }
  static define(e = {}) {
    return new StateEffectType(e.map || ((n) => n));
  }
  static mapEffects(e, n) {
    if (!e.length) return e;
    let s = [];
    for (let o of e) {
      let a = o.map(n);
      a && s.push(a);
    }
    return s;
  }
}
StateEffect.reconfigure = StateEffect.define();
StateEffect.appendConfig = StateEffect.define();
class Transaction {
  constructor(e, n, s, o, a, l) {
    (this.startState = e),
      (this.changes = n),
      (this.selection = s),
      (this.effects = o),
      (this.annotations = a),
      (this.scrollIntoView = l),
      (this._doc = null),
      (this._state = null),
      s && checkSelection(s, n.newLength),
      a.some((f) => f.type == Transaction.time) || (this.annotations = a.concat(Transaction.time.of(Date.now())));
  }
  static create(e, n, s, o, a, l) {
    return new Transaction(e, n, s, o, a, l);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(e) {
    for (let n of this.annotations) if (n.type == e) return n.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(e) {
    let n = this.annotation(Transaction.userEvent);
    return !!(n && (n == e || (n.length > e.length && n.slice(0, e.length) == e && n[e.length] == '.')));
  }
}
Transaction.time = Annotation.define();
Transaction.userEvent = Annotation.define();
Transaction.addToHistory = Annotation.define();
Transaction.remote = Annotation.define();
function joinRanges(r, e) {
  let n = [];
  for (let s = 0, o = 0; ; ) {
    let a, l;
    if (s < r.length && (o == e.length || e[o] >= r[s])) (a = r[s++]), (l = r[s++]);
    else if (o < e.length) (a = e[o++]), (l = e[o++]);
    else return n;
    !n.length || n[n.length - 1] < a ? n.push(a, l) : n[n.length - 1] < l && (n[n.length - 1] = l);
  }
}
function mergeTransaction(r, e, n) {
  var s;
  let o, a, l;
  return (
    n
      ? ((o = e.changes), (a = ChangeSet.empty(e.changes.length)), (l = r.changes.compose(e.changes)))
      : ((o = e.changes.map(r.changes)), (a = r.changes.mapDesc(e.changes, !0)), (l = r.changes.compose(o))),
    {
      changes: l,
      selection: e.selection ? e.selection.map(a) : (s = r.selection) === null || s === void 0 ? void 0 : s.map(o),
      effects: StateEffect.mapEffects(r.effects, o).concat(StateEffect.mapEffects(e.effects, a)),
      annotations: r.annotations.length ? r.annotations.concat(e.annotations) : e.annotations,
      scrollIntoView: r.scrollIntoView || e.scrollIntoView,
    }
  );
}
function resolveTransactionInner(r, e, n) {
  let s = e.selection,
    o = asArray$1(e.annotations);
  return (
    e.userEvent && (o = o.concat(Transaction.userEvent.of(e.userEvent))),
    {
      changes: e.changes instanceof ChangeSet ? e.changes : ChangeSet.of(e.changes || [], n, r.facet(lineSeparator)),
      selection: s && (s instanceof EditorSelection ? s : EditorSelection.single(s.anchor, s.head)),
      effects: asArray$1(e.effects),
      annotations: o,
      scrollIntoView: !!e.scrollIntoView,
    }
  );
}
function resolveTransaction(r, e, n) {
  let s = resolveTransactionInner(r, e.length ? e[0] : {}, r.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let a = 1; a < e.length; a++) {
    e[a].filter === !1 && (n = !1);
    let l = !!e[a].sequential;
    s = mergeTransaction(s, resolveTransactionInner(r, e[a], l ? s.changes.newLength : r.doc.length), l);
  }
  let o = Transaction.create(r, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(n ? filterTransaction(o) : o);
}
function filterTransaction(r) {
  let e = r.startState,
    n = !0;
  for (let o of e.facet(changeFilter)) {
    let a = o(r);
    if (a === !1) {
      n = !1;
      break;
    }
    Array.isArray(a) && (n = n === !0 ? a : joinRanges(n, a));
  }
  if (n !== !0) {
    let o, a;
    if (n === !1) (a = r.changes.invertedDesc), (o = ChangeSet.empty(e.doc.length));
    else {
      let l = r.changes.filter(n);
      (o = l.changes), (a = l.filtered.mapDesc(l.changes).invertedDesc);
    }
    r = Transaction.create(
      e,
      o,
      r.selection && r.selection.map(a),
      StateEffect.mapEffects(r.effects, a),
      r.annotations,
      r.scrollIntoView,
    );
  }
  let s = e.facet(transactionFilter);
  for (let o = s.length - 1; o >= 0; o--) {
    let a = s[o](r);
    a instanceof Transaction
      ? (r = a)
      : Array.isArray(a) && a.length == 1 && a[0] instanceof Transaction
      ? (r = a[0])
      : (r = resolveTransaction(e, asArray$1(a), !1));
  }
  return r;
}
function extendTransaction(r) {
  let e = r.startState,
    n = e.facet(transactionExtender),
    s = r;
  for (let o = n.length - 1; o >= 0; o--) {
    let a = n[o](r);
    a && Object.keys(a).length && (s = mergeTransaction(s, resolveTransactionInner(e, a, r.changes.newLength), !0));
  }
  return s == r ? r : Transaction.create(e, r.changes, r.selection, s.effects, s.annotations, s.scrollIntoView);
}
const none$2 = [];
function asArray$1(r) {
  return r == null ? none$2 : Array.isArray(r) ? r : [r];
}
var CharCategory = (function (r) {
  return (r[(r.Word = 0)] = 'Word'), (r[(r.Space = 1)] = 'Space'), (r[(r.Other = 2)] = 'Other'), r;
})(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar =
  /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = new RegExp('[\\p{Alphabetic}\\p{Number}_]', 'u');
} catch {}
function hasWordChar(r) {
  if (wordChar) return wordChar.test(r);
  for (let e = 0; e < r.length; e++) {
    let n = r[e];
    if (/\w/.test(n) || (n > '' && (n.toUpperCase() != n.toLowerCase() || nonASCIISingleCaseWordChar.test(n))))
      return !0;
  }
  return !1;
}
function makeCategorizer(r) {
  return (e) => {
    if (!/\S/.test(e)) return CharCategory.Space;
    if (hasWordChar(e)) return CharCategory.Word;
    for (let n = 0; n < r.length; n++) if (e.indexOf(r[n]) > -1) return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(e, n, s, o, a, l) {
    (this.config = e),
      (this.doc = n),
      (this.selection = s),
      (this.values = o),
      (this.status = e.statusTemplate.slice()),
      (this.computeSlot = a),
      l && (l._state = this);
    for (let f = 0; f < this.config.dynamicSlots.length; f++) ensureAddr(this, f << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let s = this.config.address[e.id];
    if (s == null) {
      if (n) throw new RangeError('Field is not present in this state');
      return;
    }
    return ensureAddr(this, s), getAddr(this, s);
  }
  update(...e) {
    return resolveTransaction(this, e, !0);
  }
  applyTransaction(e) {
    let n = this.config,
      { base: s, compartments: o } = n;
    for (let l of e.effects)
      l.is(Compartment.reconfigure)
        ? (n && ((o = new Map()), n.compartments.forEach((f, m) => o.set(m, f)), (n = null)),
          o.set(l.value.compartment, l.value.extension))
        : l.is(StateEffect.reconfigure)
        ? ((n = null), (s = l.value))
        : l.is(StateEffect.appendConfig) && ((n = null), (s = asArray$1(s).concat(l.value)));
    let a;
    n
      ? (a = e.startState.values.slice())
      : ((n = Configuration.resolve(s, o, this)),
        (a = new EditorState(
          n,
          this.doc,
          this.selection,
          n.dynamicSlots.map(() => null),
          (f, m) => m.reconfigure(f, this),
          null,
        ).values)),
      new EditorState(n, e.newDoc, e.newSelection, a, (l, f) => f.update(l, e), e);
  }
  replaceSelection(e) {
    return (
      typeof e == 'string' && (e = this.toText(e)),
      this.changeByRange((n) => ({
        changes: { from: n.from, to: n.to, insert: e },
        range: EditorSelection.cursor(n.from + e.length),
      }))
    );
  }
  changeByRange(e) {
    let n = this.selection,
      s = e(n.ranges[0]),
      o = this.changes(s.changes),
      a = [s.range],
      l = asArray$1(s.effects);
    for (let f = 1; f < n.ranges.length; f++) {
      let m = e(n.ranges[f]),
        v = this.changes(m.changes),
        I = v.map(o);
      for (let V = 0; V < f; V++) a[V] = a[V].map(I);
      let L = o.mapDesc(v, !0);
      a.push(m.range.map(L)),
        (o = o.compose(I)),
        (l = StateEffect.mapEffects(l, I).concat(StateEffect.mapEffects(asArray$1(m.effects), L)));
    }
    return { changes: o, selection: EditorSelection.create(a, n.mainIndex), effects: l };
  }
  changes(e = []) {
    return e instanceof ChangeSet ? e : ChangeSet.of(e, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  toText(e) {
    return Text.of(e.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (ensureAddr(this, n), getAddr(this, n));
  }
  toJSON(e) {
    let n = { doc: this.sliceDoc(), selection: this.selection.toJSON() };
    if (e)
      for (let s in e) {
        let o = e[s];
        o instanceof StateField && this.config.address[o.id] != null && (n[s] = o.spec.toJSON(this.field(e[s]), this));
      }
    return n;
  }
  static fromJSON(e, n = {}, s) {
    if (!e || typeof e.doc != 'string') throw new RangeError('Invalid JSON representation for EditorState');
    let o = [];
    if (s) {
      for (let a in s)
        if (Object.prototype.hasOwnProperty.call(e, a)) {
          let l = s[a],
            f = e[a];
          o.push(l.init((m) => l.spec.fromJSON(f, m)));
        }
    }
    return EditorState.create({
      doc: e.doc,
      selection: EditorSelection.fromJSON(e.selection),
      extensions: n.extensions ? o.concat([n.extensions]) : o,
    });
  }
  static create(e = {}) {
    let n = Configuration.resolve(e.extensions || [], new Map()),
      s =
        e.doc instanceof Text
          ? e.doc
          : Text.of((e.doc || '').split(n.staticFacet(EditorState.lineSeparator) || DefaultSplit)),
      o = e.selection
        ? e.selection instanceof EditorSelection
          ? e.selection
          : EditorSelection.single(e.selection.anchor, e.selection.head)
        : EditorSelection.single(0);
    return (
      checkSelection(o, s.length),
      n.staticFacet(allowMultipleSelections) || (o = o.asSingle()),
      new EditorState(
        n,
        s,
        o,
        n.dynamicSlots.map(() => null),
        (a, l) => l.create(a),
        null,
      )
    );
  }
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  get lineBreak() {
    return (
      this.facet(EditorState.lineSeparator) ||
      `
`
    );
  }
  get readOnly() {
    return this.facet(readOnly);
  }
  phrase(e, ...n) {
    for (let s of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(s, e)) {
        e = s[e];
        break;
      }
    return (
      n.length &&
        (e = e.replace(/\$(\$|\d*)/g, (s, o) => {
          if (o == '$') return '$';
          let a = +(o || 1);
          return !a || a > n.length ? s : n[a - 1];
        })),
      e
    );
  }
  languageDataAt(e, n, s = -1) {
    let o = [];
    for (let a of this.facet(languageData))
      for (let l of a(this, n, s)) Object.prototype.hasOwnProperty.call(l, e) && o.push(l[e]);
    return o;
  }
  charCategorizer(e) {
    return makeCategorizer(this.languageDataAt('wordChars', e).join(''));
  }
  wordAt(e) {
    let { text: n, from: s, length: o } = this.doc.lineAt(e),
      a = this.charCategorizer(e),
      l = e - s,
      f = e - s;
    for (; l > 0; ) {
      let m = findClusterBreak(n, l, !1);
      if (a(n.slice(m, l)) != CharCategory.Word) break;
      l = m;
    }
    for (; f < o; ) {
      let m = findClusterBreak(n, f);
      if (a(n.slice(f, m)) != CharCategory.Word) break;
      f = m;
    }
    return l == f ? null : EditorSelection.range(l + s, f + s);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = Facet.define({ combine: (r) => (r.length ? r[0] : 4) });
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = Facet.define({
  compare(r, e) {
    let n = Object.keys(r),
      s = Object.keys(e);
    return n.length == s.length && n.every((o) => r[o] == e[o]);
  },
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();
function combineConfig(r, e, n = {}) {
  let s = {};
  for (let o of r)
    for (let a of Object.keys(o)) {
      let l = o[a],
        f = s[a];
      if (f === void 0) s[a] = l;
      else if (!(f === l || l === void 0))
        if (Object.hasOwnProperty.call(n, a)) s[a] = n[a](f, l);
        else throw new Error('Config merge conflict for field ' + a);
    }
  for (let o in e) s[o] === void 0 && (s[o] = e[o]);
  return s;
}
class RangeValue {
  eq(e) {
    return this == e;
  }
  range(e, n = e) {
    return Range$1.create(e, n, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = !1;
RangeValue.prototype.mapMode = MapMode.TrackDel;
let Range$1 = class im {
  constructor(e, n, s) {
    (this.from = e), (this.to = n), (this.value = s);
  }
  static create(e, n, s) {
    return new im(e, n, s);
  }
};
function cmpRange(r, e) {
  return r.from - e.from || r.value.startSide - e.value.startSide;
}
class Chunk {
  constructor(e, n, s, o) {
    (this.from = e), (this.to = n), (this.value = s), (this.maxPoint = o);
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(e, n, s, o = 0) {
    let a = s ? this.to : this.from;
    for (let l = o, f = a.length; ; ) {
      if (l == f) return l;
      let m = (l + f) >> 1,
        v = a[m] - e || (s ? this.value[m].endSide : this.value[m].startSide) - n;
      if (m == l) return v >= 0 ? l : f;
      v >= 0 ? (f = m) : (l = m + 1);
    }
  }
  between(e, n, s, o) {
    for (let a = this.findIndex(n, -1e9, !0), l = this.findIndex(s, 1e9, !1, a); a < l; a++)
      if (o(this.from[a] + e, this.to[a] + e, this.value[a]) === !1) return !1;
  }
  map(e, n) {
    let s = [],
      o = [],
      a = [],
      l = -1,
      f = -1;
    for (let m = 0; m < this.value.length; m++) {
      let v = this.value[m],
        I = this.from[m] + e,
        L = this.to[m] + e,
        V,
        se;
      if (I == L) {
        let Ee = n.mapPos(I, v.startSide, v.mapMode);
        if (Ee == null || ((V = se = Ee), v.startSide != v.endSide && ((se = n.mapPos(I, v.endSide)), se < V)))
          continue;
      } else if (
        ((V = n.mapPos(I, v.startSide)),
        (se = n.mapPos(L, v.endSide)),
        V > se || (V == se && v.startSide > 0 && v.endSide <= 0))
      )
        continue;
      (se - V || v.endSide - v.startSide) < 0 ||
        (l < 0 && (l = V), v.point && (f = Math.max(f, se - V)), s.push(v), o.push(V - l), a.push(se - l));
    }
    return { mapped: s.length ? new Chunk(o, a, s, f) : null, pos: l };
  }
}
class RangeSet {
  constructor(e, n, s, o) {
    (this.chunkPos = e), (this.chunk = n), (this.nextLayer = s), (this.maxPoint = o);
  }
  static create(e, n, s, o) {
    return new RangeSet(e, n, s, o);
  }
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty) return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk) e += n.value.length;
    return e;
  }
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  update(e) {
    let { add: n = [], sort: s = !1, filterFrom: o = 0, filterTo: a = this.length } = e,
      l = e.filter;
    if (n.length == 0 && !l) return this;
    if ((s && (n = n.slice().sort(cmpRange)), this.isEmpty)) return n.length ? RangeSet.of(n) : this;
    let f = new LayerCursor(this, null, -1).goto(0),
      m = 0,
      v = [],
      I = new RangeSetBuilder();
    for (; f.value || m < n.length; )
      if (m < n.length && (f.from - n[m].from || f.startSide - n[m].value.startSide) >= 0) {
        let L = n[m++];
        I.addInner(L.from, L.to, L.value) || v.push(L);
      } else
        f.rangeIndex == 1 &&
        f.chunkIndex < this.chunk.length &&
        (m == n.length || this.chunkEnd(f.chunkIndex) < n[m].from) &&
        (!l || o > this.chunkEnd(f.chunkIndex) || a < this.chunkPos[f.chunkIndex]) &&
        I.addChunk(this.chunkPos[f.chunkIndex], this.chunk[f.chunkIndex])
          ? f.nextChunk()
          : ((!l || o > f.to || a < f.from || l(f.from, f.to, f.value)) &&
              (I.addInner(f.from, f.to, f.value) || v.push(Range$1.create(f.from, f.to, f.value))),
            f.next());
    return I.finishInner(
      this.nextLayer.isEmpty && !v.length
        ? RangeSet.empty
        : this.nextLayer.update({ add: v, filter: l, filterFrom: o, filterTo: a }),
    );
  }
  map(e) {
    if (e.empty || this.isEmpty) return this;
    let n = [],
      s = [],
      o = -1;
    for (let l = 0; l < this.chunk.length; l++) {
      let f = this.chunkPos[l],
        m = this.chunk[l],
        v = e.touchesRange(f, f + m.length);
      if (v === !1) (o = Math.max(o, m.maxPoint)), n.push(m), s.push(e.mapPos(f));
      else if (v === !0) {
        let { mapped: I, pos: L } = m.map(f, e);
        I && ((o = Math.max(o, I.maxPoint)), n.push(I), s.push(L));
      }
    }
    let a = this.nextLayer.map(e);
    return n.length == 0 ? a : new RangeSet(s, n, a || RangeSet.empty, o);
  }
  between(e, n, s) {
    if (!this.isEmpty) {
      for (let o = 0; o < this.chunk.length; o++) {
        let a = this.chunkPos[o],
          l = this.chunk[o];
        if (n >= a && e <= a + l.length && l.between(a, e - a, n - a, s) === !1) return;
      }
      this.nextLayer.between(e, n, s);
    }
  }
  iter(e = 0) {
    return HeapCursor.from([this]).goto(e);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(e, n = 0) {
    return HeapCursor.from(e).goto(n);
  }
  static compare(e, n, s, o, a = -1) {
    let l = e.filter((L) => L.maxPoint > 0 || (!L.isEmpty && L.maxPoint >= a)),
      f = n.filter((L) => L.maxPoint > 0 || (!L.isEmpty && L.maxPoint >= a)),
      m = findSharedChunks(l, f, s),
      v = new SpanCursor(l, m, a),
      I = new SpanCursor(f, m, a);
    s.iterGaps((L, V, se) => compare(v, L, I, V, se, o)), s.empty && s.length == 0 && compare(v, 0, I, 0, 0, o);
  }
  static eq(e, n, s = 0, o) {
    o == null && (o = 1e9 - 1);
    let a = e.filter((I) => !I.isEmpty && n.indexOf(I) < 0),
      l = n.filter((I) => !I.isEmpty && e.indexOf(I) < 0);
    if (a.length != l.length) return !1;
    if (!a.length) return !0;
    let f = findSharedChunks(a, l),
      m = new SpanCursor(a, f, 0).goto(s),
      v = new SpanCursor(l, f, 0).goto(s);
    for (;;) {
      if (m.to != v.to || !sameValues(m.active, v.active) || (m.point && (!v.point || !m.point.eq(v.point)))) return !1;
      if (m.to > o) return !0;
      m.next(), v.next();
    }
  }
  static spans(e, n, s, o, a = -1) {
    let l = new SpanCursor(e, null, a).goto(n),
      f = n,
      m = l.openStart;
    for (;;) {
      let v = Math.min(l.to, s);
      if (l.point) {
        let I = l.activeForPoint(l.to),
          L = l.pointFrom < n ? I.length + 1 : Math.min(I.length, m);
        o.point(f, v, l.point, I, L, l.pointRank), (m = Math.min(l.openEnd(v), I.length));
      } else v > f && (o.span(f, v, l.active, m), (m = l.openEnd(v)));
      if (l.to > s) return m + (l.point && l.to > s ? 1 : 0);
      (f = l.to), l.next();
    }
  }
  static of(e, n = !1) {
    let s = new RangeSetBuilder();
    for (let o of e instanceof Range$1 ? [e] : n ? lazySort(e) : e) s.add(o.from, o.to, o.value);
    return s.finish();
  }
}
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(r) {
  if (r.length > 1)
    for (let e = r[0], n = 1; n < r.length; n++) {
      let s = r[n];
      if (cmpRange(e, s) > 0) return r.slice().sort(cmpRange);
      e = s;
    }
  return r;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  finishChunk(e) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint)),
      this.chunkPos.push(this.chunkStart),
      (this.chunkStart = -1),
      (this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)),
      (this.maxPoint = -1),
      e && ((this.from = []), (this.to = []), (this.value = []));
  }
  constructor() {
    (this.chunks = []),
      (this.chunkPos = []),
      (this.chunkStart = -1),
      (this.last = null),
      (this.lastFrom = -1e9),
      (this.lastTo = -1e9),
      (this.from = []),
      (this.to = []),
      (this.value = []),
      (this.maxPoint = -1),
      (this.setMaxPoint = -1),
      (this.nextLayer = null);
  }
  add(e, n, s) {
    this.addInner(e, n, s) || (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(e, n, s);
  }
  addInner(e, n, s) {
    let o = e - this.lastTo || s.startSide - this.last.endSide;
    if (o <= 0 && (e - this.lastFrom || s.startSide - this.last.startSide) < 0)
      throw new Error('Ranges must be added sorted by `from` position and `startSide`');
    return o < 0
      ? !1
      : (this.from.length == 250 && this.finishChunk(!0),
        this.chunkStart < 0 && (this.chunkStart = e),
        this.from.push(e - this.chunkStart),
        this.to.push(n - this.chunkStart),
        (this.last = s),
        (this.lastFrom = e),
        (this.lastTo = n),
        this.value.push(s),
        s.point && (this.maxPoint = Math.max(this.maxPoint, n - e)),
        !0);
  }
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0) return !1;
    this.from.length && this.finishChunk(!0),
      (this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint)),
      this.chunks.push(n),
      this.chunkPos.push(e);
    let s = n.value.length - 1;
    return (this.last = n.value[s]), (this.lastFrom = n.from[s] + e), (this.lastTo = n.to[s] + e), !0;
  }
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  finishInner(e) {
    if ((this.from.length && this.finishChunk(!1), this.chunks.length == 0)) return e;
    let n = RangeSet.create(
      this.chunkPos,
      this.chunks,
      this.nextLayer ? this.nextLayer.finishInner(e) : e,
      this.setMaxPoint,
    );
    return (this.from = null), n;
  }
}
function findSharedChunks(r, e, n) {
  let s = new Map();
  for (let a of r)
    for (let l = 0; l < a.chunk.length; l++) a.chunk[l].maxPoint <= 0 && s.set(a.chunk[l], a.chunkPos[l]);
  let o = new Set();
  for (let a of e)
    for (let l = 0; l < a.chunk.length; l++) {
      let f = s.get(a.chunk[l]);
      f != null &&
        (n ? n.mapPos(f) : f) == a.chunkPos[l] &&
        !(n != null && n.touchesRange(f, f + a.chunk[l].length)) &&
        o.add(a.chunk[l]);
    }
  return o;
}
class LayerCursor {
  constructor(e, n, s, o = 0) {
    (this.layer = e), (this.skip = n), (this.minPoint = s), (this.rank = o);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return (this.chunkIndex = this.rangeIndex = 0), this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, s) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let o = this.layer.chunk[this.chunkIndex];
      if (!((this.skip && this.skip.has(o)) || this.layer.chunkEnd(this.chunkIndex) < e || o.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, (s = !1);
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let o = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!s || this.rangeIndex < o) && this.setRangeIndex(o);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (;;)
      if (this.chunkIndex == this.layer.chunk.length) {
        (this.from = this.to = 1e9), (this.value = null);
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex],
          n = this.layer.chunk[this.chunkIndex],
          s = e + n.from[this.rangeIndex];
        if (
          ((this.from = s),
          (this.to = e + n.to[this.rangeIndex]),
          (this.value = n.value[this.rangeIndex]),
          this.setRangeIndex(this.rangeIndex + 1),
          this.minPoint < 0 || (this.value.point && this.to - this.from >= this.minPoint))
        )
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if ((this.chunkIndex++, this.skip))
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, (this.rangeIndex = 0), this.next();
  }
  compare(e) {
    return (
      this.from - e.from ||
      this.startSide - e.startSide ||
      this.rank - e.rank ||
      this.to - e.to ||
      this.endSide - e.endSide
    );
  }
}
class HeapCursor {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, s = -1) {
    let o = [];
    for (let a = 0; a < e.length; a++)
      for (let l = e[a]; !l.isEmpty; l = l.nextLayer) l.maxPoint >= s && o.push(new LayerCursor(l, n, s, a));
    return o.length == 1 ? o[0] : new HeapCursor(o);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let s of this.heap) s.goto(e, n);
    for (let s = this.heap.length >> 1; s >= 0; s--) heapBubble(this.heap, s);
    return this.next(), this;
  }
  forward(e, n) {
    for (let s of this.heap) s.forward(e, n);
    for (let s = this.heap.length >> 1; s >= 0; s--) heapBubble(this.heap, s);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0) (this.from = this.to = 1e9), (this.value = null), (this.rank = -1);
    else {
      let e = this.heap[0];
      (this.from = e.from),
        (this.to = e.to),
        (this.value = e.value),
        (this.rank = e.rank),
        e.value && e.next(),
        heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(r, e) {
  for (let n = r[e]; ; ) {
    let s = (e << 1) + 1;
    if (s >= r.length) break;
    let o = r[s];
    if ((s + 1 < r.length && o.compare(r[s + 1]) >= 0 && ((o = r[s + 1]), s++), n.compare(o) < 0)) break;
    (r[s] = n), (r[e] = o), (e = s);
  }
}
class SpanCursor {
  constructor(e, n, s) {
    (this.minPoint = s),
      (this.active = []),
      (this.activeTo = []),
      (this.activeRank = []),
      (this.minActive = -1),
      (this.point = null),
      (this.pointFrom = 0),
      (this.pointRank = 0),
      (this.to = -1e9),
      (this.endSide = 0),
      (this.openStart = -1),
      (this.cursor = HeapCursor.from(e, n, s));
  }
  goto(e, n = -1e9) {
    return (
      this.cursor.goto(e, n),
      (this.active.length = this.activeTo.length = this.activeRank.length = 0),
      (this.minActive = -1),
      (this.to = e),
      (this.endSide = n),
      (this.openStart = -1),
      this.next(),
      this
    );
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    remove(this.active, e),
      remove(this.activeTo, e),
      remove(this.activeRank, e),
      (this.minActive = findMinIndex(this.active, this.activeTo));
  }
  addActive(e) {
    let n = 0,
      { value: s, to: o, rank: a } = this.cursor;
    for (; n < this.activeRank.length && this.activeRank[n] <= a; ) n++;
    insert(this.active, n, s),
      insert(this.activeTo, n, o),
      insert(this.activeRank, n, a),
      e && insert(e, n, this.cursor.from),
      (this.minActive = findMinIndex(this.active, this.activeTo));
  }
  next() {
    let e = this.to,
      n = this.point;
    this.point = null;
    let s = this.openStart < 0 ? [] : null;
    for (;;) {
      let o = this.minActive;
      if (o > -1 && (this.activeTo[o] - this.cursor.from || this.active[o].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[o] > e) {
          (this.to = this.activeTo[o]), (this.endSide = this.active[o].endSide);
          break;
        }
        this.removeActive(o), s && remove(s, o);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          (this.to = this.cursor.from), (this.endSide = this.cursor.startSide);
          break;
        } else {
          let a = this.cursor.value;
          if (!a.point) this.addActive(s), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to) this.cursor.next();
          else {
            (this.point = a),
              (this.pointFrom = this.cursor.from),
              (this.pointRank = this.cursor.rank),
              (this.to = this.cursor.to),
              (this.endSide = a.endSide),
              this.cursor.next(),
              this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (s) {
      this.openStart = 0;
      for (let o = s.length - 1; o >= 0 && s[o] < e; o--) this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length) return this.active;
    let n = [];
    for (let s = this.active.length - 1; s >= 0 && !(this.activeRank[s] < this.pointRank); s--)
      (this.activeTo[s] > e || (this.activeTo[s] == e && this.active[s].endSide >= this.point.endSide)) &&
        n.push(this.active[s]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let s = this.activeTo.length - 1; s >= 0 && this.activeTo[s] > e; s--) n++;
    return n;
  }
}
function compare(r, e, n, s, o, a) {
  r.goto(e), n.goto(s);
  let l = s + o,
    f = s,
    m = s - e;
  for (;;) {
    let v = r.to + m - n.to || r.endSide - n.endSide,
      I = v < 0 ? r.to + m : n.to,
      L = Math.min(I, l);
    if (
      (r.point || n.point
        ? (r.point &&
            n.point &&
            (r.point == n.point || r.point.eq(n.point)) &&
            sameValues(r.activeForPoint(r.to), n.activeForPoint(n.to))) ||
          a.comparePoint(f, L, r.point, n.point)
        : L > f && !sameValues(r.active, n.active) && a.compareRange(f, L, r.active, n.active),
      I > l)
    )
      break;
    (f = I), v <= 0 && r.next(), v >= 0 && n.next();
  }
}
function sameValues(r, e) {
  if (r.length != e.length) return !1;
  for (let n = 0; n < r.length; n++) if (r[n] != e[n] && !r[n].eq(e[n])) return !1;
  return !0;
}
function remove(r, e) {
  for (let n = e, s = r.length - 1; n < s; n++) r[n] = r[n + 1];
  r.pop();
}
function insert(r, e, n) {
  for (let s = r.length - 1; s >= e; s--) r[s + 1] = r[s];
  r[e] = n;
}
function findMinIndex(r, e) {
  let n = -1,
    s = 1e9;
  for (let o = 0; o < e.length; o++) (e[o] - s || r[o].endSide - r[n].endSide) < 0 && ((n = o), (s = e[o]));
  return n;
}
function countColumn(r, e, n = r.length) {
  let s = 0;
  for (let o = 0; o < n; ) r.charCodeAt(o) == 9 ? ((s += e - (s % e)), o++) : (s++, (o = findClusterBreak(r, o)));
  return s;
}
function findColumn(r, e, n, s) {
  for (let o = 0, a = 0; ; ) {
    if (a >= e) return o;
    if (o == r.length) break;
    (a += r.charCodeAt(o) == 9 ? n - (a % n) : 1), (o = findClusterBreak(r, o));
  }
  return s === !0 ? -1 : r.length;
}
const C$2 = 'ͼ',
  COUNT = typeof Symbol > 'u' ? '__' + C$2 : Symbol.for(C$2),
  SET = typeof Symbol > 'u' ? '__styleSet' + Math.floor(Math.random() * 1e8) : Symbol('styleSet'),
  top = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : {};
class StyleModule {
  constructor(e, n) {
    this.rules = [];
    let { finish: s } = n || {};
    function o(l) {
      return /^@/.test(l) ? [l] : l.split(/,\s*/);
    }
    function a(l, f, m, v) {
      let I = [],
        L = /^@(\w+)\b/.exec(l[0]),
        V = L && L[1] == 'keyframes';
      if (L && f == null) return m.push(l[0] + ';');
      for (let se in f) {
        let Ee = f[se];
        if (/&/.test(se))
          a(
            se
              .split(/,\s*/)
              .map((ht) => l.map((ar) => ht.replace(/&/, ar)))
              .reduce((ht, ar) => ht.concat(ar)),
            Ee,
            m,
          );
        else if (Ee && typeof Ee == 'object') {
          if (!L) throw new RangeError('The value of a property (' + se + ') should be a primitive value.');
          a(o(se), Ee, I, V);
        } else
          Ee != null &&
            I.push(se.replace(/_.*/, '').replace(/[A-Z]/g, (ht) => '-' + ht.toLowerCase()) + ': ' + Ee + ';');
      }
      (I.length || V) && m.push((s && !L && !v ? l.map(s) : l).join(', ') + ' {' + I.join(' ') + '}');
    }
    for (let l in e) a(o(l), e[l], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let e = top[COUNT] || 1;
    return (top[COUNT] = e + 1), C$2 + e.toString(36);
  }
  static mount(e, n, s) {
    let o = e[SET],
      a = s && s.nonce;
    o ? a && o.setNonce(a) : (o = new StyleSet(e, a)), o.mount(Array.isArray(n) ? n : [n]);
  }
}
let adoptedSet = new Map();
class StyleSet {
  constructor(e, n) {
    let s = e.ownerDocument || e,
      o = s.defaultView;
    if (!e.head && e.adoptedStyleSheets && o.CSSStyleSheet) {
      let a = adoptedSet.get(s);
      if (a) return (e.adoptedStyleSheets = [a.sheet, ...e.adoptedStyleSheets]), (e[SET] = a);
      (this.sheet = new o.CSSStyleSheet()),
        (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]),
        adoptedSet.set(s, this);
    } else {
      (this.styleTag = s.createElement('style')), n && this.styleTag.setAttribute('nonce', n);
      let a = e.head || e;
      a.insertBefore(this.styleTag, a.firstChild);
    }
    (this.modules = []), (e[SET] = this);
  }
  mount(e) {
    let n = this.sheet,
      s = 0,
      o = 0;
    for (let a = 0; a < e.length; a++) {
      let l = e[a],
        f = this.modules.indexOf(l);
      if ((f < o && f > -1 && (this.modules.splice(f, 1), o--, (f = -1)), f == -1)) {
        if ((this.modules.splice(o++, 0, l), n)) for (let m = 0; m < l.rules.length; m++) n.insertRule(l.rules[m], s++);
      } else {
        for (; o < f; ) s += this.modules[o++].rules.length;
        (s += l.rules.length), o++;
      }
    }
    if (!n) {
      let a = '';
      for (let l = 0; l < this.modules.length; l++)
        a +=
          this.modules[l].getRules() +
          `
`;
      this.styleTag.textContent = a;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute('nonce') != e && this.styleTag.setAttribute('nonce', e);
  }
}
var base = {
    8: 'Backspace',
    9: 'Tab',
    10: 'Enter',
    12: 'NumLock',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    44: 'PrintScreen',
    45: 'Insert',
    46: 'Delete',
    59: ';',
    61: '=',
    91: 'Meta',
    92: 'Meta',
    106: '*',
    107: '+',
    108: ',',
    109: '-',
    110: '.',
    111: '/',
    144: 'NumLock',
    145: 'ScrollLock',
    160: 'Shift',
    161: 'Shift',
    162: 'Control',
    163: 'Control',
    164: 'Alt',
    165: 'Alt',
    173: '-',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: "'",
  },
  shift = {
    48: ')',
    49: '!',
    50: '@',
    51: '#',
    52: '$',
    53: '%',
    54: '^',
    55: '&',
    56: '*',
    57: '(',
    59: ':',
    61: '+',
    173: '_',
    186: ':',
    187: '+',
    188: '<',
    189: '_',
    190: '>',
    191: '?',
    192: '~',
    219: '{',
    220: '|',
    221: '}',
    222: '"',
  },
  mac = typeof navigator < 'u' && /Mac/.test(navigator.platform),
  ie$2 = typeof navigator < 'u' && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = 'F' + i;
for (var i = 65; i <= 90; i++) (base[i] = String.fromCharCode(i + 32)), (shift[i] = String.fromCharCode(i));
for (var code in base) shift.hasOwnProperty(code) || (shift[code] = base[code]);
function keyName(r) {
  var e =
      (mac && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey) ||
      (ie$2 && r.shiftKey && r.key && r.key.length == 1) ||
      r.key == 'Unidentified',
    n = (!e && r.key) || (r.shiftKey ? shift : base)[r.keyCode] || r.key || 'Unidentified';
  return (
    n == 'Esc' && (n = 'Escape'),
    n == 'Del' && (n = 'Delete'),
    n == 'Left' && (n = 'ArrowLeft'),
    n == 'Up' && (n = 'ArrowUp'),
    n == 'Right' && (n = 'ArrowRight'),
    n == 'Down' && (n = 'ArrowDown'),
    n
  );
}
function getSelection(r) {
  let e;
  return r.nodeType == 11 ? (e = r.getSelection ? r : r.ownerDocument) : (e = r), e.getSelection();
}
function contains(r, e) {
  return e ? r == e || r.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function deepActiveElement(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
  return e;
}
function hasSelection(r, e) {
  if (!e.anchorNode) return !1;
  try {
    return contains(r, e.anchorNode);
  } catch {
    return !1;
  }
}
function clientRectsFor(r) {
  return r.nodeType == 3
    ? textRange(r, 0, r.nodeValue.length).getClientRects()
    : r.nodeType == 1
    ? r.getClientRects()
    : [];
}
function isEquivalentPosition(r, e, n, s) {
  return n ? scanFor(r, e, n, s, -1) || scanFor(r, e, n, s, 1) : !1;
}
function domIndex(r) {
  for (var e = 0; ; e++) if (((r = r.previousSibling), !r)) return e;
}
function scanFor(r, e, n, s, o) {
  for (;;) {
    if (r == n && e == s) return !0;
    if (e == (o < 0 ? 0 : maxOffset(r))) {
      if (r.nodeName == 'DIV') return !1;
      let a = r.parentNode;
      if (!a || a.nodeType != 1) return !1;
      (e = domIndex(r) + (o < 0 ? 0 : 1)), (r = a);
    } else if (r.nodeType == 1) {
      if (((r = r.childNodes[e + (o < 0 ? -1 : 0)]), r.nodeType == 1 && r.contentEditable == 'false')) return !1;
      e = o < 0 ? maxOffset(r) : 0;
    } else return !1;
  }
}
function maxOffset(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function flattenRect(r, e) {
  let n = e ? r.left : r.right;
  return { left: n, right: n, top: r.top, bottom: r.bottom };
}
function windowRect(r) {
  return { left: 0, right: r.innerWidth, top: 0, bottom: r.innerHeight };
}
function scrollRectIntoView(r, e, n, s, o, a, l, f) {
  let m = r.ownerDocument,
    v = m.defaultView || window;
  for (let I = r, L = !1; I && !L; )
    if (I.nodeType == 1) {
      let V,
        se = I == m.body,
        Ee = 1,
        ht = 1;
      if (se) V = windowRect(v);
      else {
        if (
          (/^(fixed|sticky)$/.test(getComputedStyle(I).position) && (L = !0),
          I.scrollHeight <= I.clientHeight && I.scrollWidth <= I.clientWidth)
        ) {
          I = I.assignedSlot || I.parentNode;
          continue;
        }
        let tl = I.getBoundingClientRect();
        (Ee = tl.width / I.offsetWidth),
          (ht = tl.height / I.offsetHeight),
          (V = {
            left: tl.left,
            right: tl.left + I.clientWidth * Ee,
            top: tl.top,
            bottom: tl.top + I.clientHeight * ht,
          });
      }
      let ar = 0,
        $i = 0;
      if (o == 'nearest')
        e.top < V.top
          ? (($i = -(V.top - e.top + l)), n > 0 && e.bottom > V.bottom + $i && ($i = e.bottom - V.bottom + $i + l))
          : e.bottom > V.bottom &&
            (($i = e.bottom - V.bottom + l), n < 0 && e.top - $i < V.top && ($i = -(V.top + $i - e.top + l)));
      else {
        let tl = e.bottom - e.top,
          Wi = V.bottom - V.top;
        $i =
          (o == 'center' && tl <= Wi
            ? e.top + tl / 2 - Wi / 2
            : o == 'start' || (o == 'center' && n < 0)
            ? e.top - l
            : e.bottom - Wi + l) - V.top;
      }
      if (
        (s == 'nearest'
          ? e.left < V.left
            ? ((ar = -(V.left - e.left + a)), n > 0 && e.right > V.right + ar && (ar = e.right - V.right + ar + a))
            : e.right > V.right &&
              ((ar = e.right - V.right + a), n < 0 && e.left < V.left + ar && (ar = -(V.left + ar - e.left + a)))
          : (ar =
              (s == 'center'
                ? e.left + (e.right - e.left) / 2 - (V.right - V.left) / 2
                : (s == 'start') == f
                ? e.left - a
                : e.right - (V.right - V.left) + a) - V.left),
        ar || $i)
      )
        if (se) v.scrollBy(ar, $i);
        else {
          let tl = 0,
            Wi = 0;
          if ($i) {
            let hl = I.scrollTop;
            (I.scrollTop += $i / ht), (Wi = (I.scrollTop - hl) * ht);
          }
          if (ar) {
            let hl = I.scrollLeft;
            (I.scrollLeft += ar / Ee), (tl = (I.scrollLeft - hl) * Ee);
          }
          (e = { left: e.left - tl, top: e.top - Wi, right: e.right - tl, bottom: e.bottom - Wi }),
            tl && Math.abs(tl - ar) < 1 && (s = 'nearest'),
            Wi && Math.abs(Wi - $i) < 1 && (o = 'nearest');
        }
      if (se) break;
      I = I.assignedSlot || I.parentNode;
    } else if (I.nodeType == 11) I = I.host;
    else break;
}
function scrollableParent(r) {
  let e = r.ownerDocument;
  for (let n = r.parentNode; n && n != e.body; )
    if (n.nodeType == 1) {
      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth) return n;
      n = n.assignedSlot || n.parentNode;
    } else if (n.nodeType == 11) n = n.host;
    else break;
  return null;
}
class DOMSelectionState {
  constructor() {
    (this.anchorNode = null), (this.anchorOffset = 0), (this.focusNode = null), (this.focusOffset = 0);
  }
  eq(e) {
    return (
      this.anchorNode == e.anchorNode &&
      this.anchorOffset == e.anchorOffset &&
      this.focusNode == e.focusNode &&
      this.focusOffset == e.focusOffset
    );
  }
  setRange(e) {
    let { anchorNode: n, focusNode: s } = e;
    this.set(n, Math.min(e.anchorOffset, n ? maxOffset(n) : 0), s, Math.min(e.focusOffset, s ? maxOffset(s) : 0));
  }
  set(e, n, s, o) {
    (this.anchorNode = e), (this.anchorOffset = n), (this.focusNode = s), (this.focusOffset = o);
  }
}
let preventScrollSupported = null;
function focusPreventScroll(r) {
  if (r.setActive) return r.setActive();
  if (preventScrollSupported) return r.focus(preventScrollSupported);
  let e = [];
  for (let n = r; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode);
  if (
    (r.focus(
      preventScrollSupported == null
        ? {
            get preventScroll() {
              return (preventScrollSupported = { preventScroll: !0 }), !0;
            },
          }
        : void 0,
    ),
    !preventScrollSupported)
  ) {
    preventScrollSupported = !1;
    for (let n = 0; n < e.length; ) {
      let s = e[n++],
        o = e[n++],
        a = e[n++];
      s.scrollTop != o && (s.scrollTop = o), s.scrollLeft != a && (s.scrollLeft = a);
    }
  }
}
let scratchRange;
function textRange(r, e, n = e) {
  let s = scratchRange || (scratchRange = document.createRange());
  return s.setEnd(r, n), s.setStart(r, e), s;
}
function dispatchKey(r, e, n) {
  let s = { key: e, code: e, keyCode: n, which: n, cancelable: !0 },
    o = new KeyboardEvent('keydown', s);
  (o.synthetic = !0), r.dispatchEvent(o);
  let a = new KeyboardEvent('keyup', s);
  return (a.synthetic = !0), r.dispatchEvent(a), o.defaultPrevented || a.defaultPrevented;
}
function getRoot(r) {
  for (; r; ) {
    if (r && (r.nodeType == 9 || (r.nodeType == 11 && r.host))) return r;
    r = r.assignedSlot || r.parentNode;
  }
  return null;
}
function clearAttributes(r) {
  for (; r.attributes.length; ) r.removeAttributeNode(r.attributes[0]);
}
function atElementStart(r, e) {
  let n = e.focusNode,
    s = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != s) return !1;
  for (s = Math.min(s, maxOffset(n)); ; )
    if (s) {
      if (n.nodeType != 1) return !1;
      let o = n.childNodes[s - 1];
      o.contentEditable == 'false' ? s-- : ((n = o), (s = maxOffset(n)));
    } else {
      if (n == r) return !0;
      (s = domIndex(n)), (n = n.parentNode);
    }
}
function isScrolledToBottom(r) {
  return r.scrollTop > Math.max(1, r.scrollHeight - r.clientHeight - 4);
}
class DOMPos {
  constructor(e, n, s = !0) {
    (this.node = e), (this.offset = n), (this.precise = s);
  }
  static before(e, n) {
    return new DOMPos(e.parentNode, domIndex(e), n);
  }
  static after(e, n) {
    return new DOMPos(e.parentNode, domIndex(e) + 1, n);
  }
}
const noChildren = [];
class ContentView {
  constructor() {
    (this.parent = null), (this.dom = null), (this.flags = 2);
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let s of this.children) {
      if (s == e) return n;
      n += s.length + s.breakAfter;
    }
    throw new RangeError('Invalid child in posBefore');
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let s = this.dom,
        o = null,
        a;
      for (let l of this.children) {
        if (l.flags & 7) {
          if (!l.dom && (a = o ? o.nextSibling : s.firstChild)) {
            let f = ContentView.get(a);
            (!f || (!f.parent && f.canReuseDOM(l))) && l.reuseDOM(a);
          }
          l.sync(e, n), (l.flags &= -8);
        }
        if (
          ((a = o ? o.nextSibling : s.firstChild),
          n && !n.written && n.node == s && a != l.dom && (n.written = !0),
          l.dom.parentNode == s)
        )
          for (; a && a != l.dom; ) a = rm$1(a);
        else s.insertBefore(l.dom, a);
        o = l.dom;
      }
      for (a = o ? o.nextSibling : s.firstChild, a && n && n.node == s && (n.written = !0); a; ) a = rm$1(a);
    } else if (this.flags & 1) for (let s of this.children) s.flags & 7 && (s.sync(e, n), (s.flags &= -8));
  }
  reuseDOM(e) {}
  localPosFromDOM(e, n) {
    let s;
    if (e == this.dom) s = this.dom.childNodes[n];
    else {
      let o = maxOffset(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (;;) {
        let a = e.parentNode;
        if (a == this.dom) break;
        o == 0 && a.firstChild != a.lastChild && (e == a.firstChild ? (o = -1) : (o = 1)), (e = a);
      }
      o < 0 ? (s = e) : (s = e.nextSibling);
    }
    if (s == this.dom.firstChild) return 0;
    for (; s && !ContentView.get(s); ) s = s.nextSibling;
    if (!s) return this.length;
    for (let o = 0, a = 0; ; o++) {
      let l = this.children[o];
      if (l.dom == s) return a;
      a += l.length + l.breakAfter;
    }
  }
  domBoundsAround(e, n, s = 0) {
    let o = -1,
      a = -1,
      l = -1,
      f = -1;
    for (let m = 0, v = s, I = s; m < this.children.length; m++) {
      let L = this.children[m],
        V = v + L.length;
      if (v < e && V > n) return L.domBoundsAround(e, n, v);
      if ((V >= e && o == -1 && ((o = m), (a = v)), v > n && L.dom.parentNode == this.dom)) {
        (l = m), (f = I);
        break;
      }
      (I = V), (v = V + L.breakAfter);
    }
    return {
      from: a,
      to: f < 0 ? s + this.length : f,
      startDOM: (o ? this.children[o - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: l < this.children.length && l >= 0 ? this.children[l].dom : null,
    };
  }
  markDirty(e = !1) {
    (this.flags |= 2), this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if ((e && (n.flags |= 2), n.flags & 1)) return;
      (n.flags |= 1), (e = !1);
    }
  }
  setParent(e) {
    this.parent != e && ((this.parent = e), this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), (this.dom = e), (e.cmView = this));
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n) return e;
      e = n;
    }
  }
  replaceChildren(e, n, s = noChildren) {
    this.markDirty();
    for (let o = e; o < n; o++) {
      let a = this.children[o];
      a.parent == this && a.destroy();
    }
    this.children.splice(e, n - e, ...s);
    for (let o = 0; o < s.length; o++) s[o].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new ChildCursor(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace('View', '');
    return (
      e +
      (this.children.length
        ? '(' + this.children.join() + ')'
        : this.length
        ? '[' + (e == 'Text' ? this.text : this.length) + ']'
        : '') +
      (this.breakAfter ? '#' : '')
    );
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, s, o, a, l) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
ContentView.prototype.breakAfter = 0;
function rm$1(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class ChildCursor {
  constructor(e, n, s) {
    (this.children = e), (this.pos = n), (this.i = s), (this.off = 0);
  }
  findPos(e, n = 1) {
    for (;;) {
      if (e > this.pos || (e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)))
        return (this.off = e - this.pos), this;
      let s = this.children[--this.i];
      this.pos -= s.length + s.breakAfter;
    }
  }
}
function replaceRange(r, e, n, s, o, a, l, f, m) {
  let { children: v } = r,
    I = v.length ? v[e] : null,
    L = a.length ? a[a.length - 1] : null,
    V = L ? L.breakAfter : l;
  if (!(e == s && I && !l && !V && a.length < 2 && I.merge(n, o, a.length ? L : null, n == 0, f, m))) {
    if (s < v.length) {
      let se = v[s];
      se && (o < se.length || (se.breakAfter && L != null && L.breakAfter))
        ? (e == s && ((se = se.split(o)), (o = 0)),
          !V && L && se.merge(0, o, L, !0, 0, m)
            ? (a[a.length - 1] = se)
            : ((o || (se.children.length && !se.children[0].length)) && se.merge(0, o, null, !1, 0, m), a.push(se)))
        : se != null && se.breakAfter && (L ? (L.breakAfter = 1) : (l = 1)),
        s++;
    }
    for (
      I &&
      ((I.breakAfter = l),
      n > 0 &&
        (!l && a.length && I.merge(n, I.length, a[0], !1, f, 0)
          ? (I.breakAfter = a.shift().breakAfter)
          : (n < I.length || (I.children.length && I.children[I.children.length - 1].length == 0)) &&
            I.merge(n, I.length, null, !1, f, 0),
        e++));
      e < s && a.length;

    )
      if (v[s - 1].become(a[a.length - 1])) s--, a.pop(), (m = a.length ? 0 : f);
      else if (v[e].become(a[0])) e++, a.shift(), (f = a.length ? 0 : m);
      else break;
    !a.length && e && s < v.length && !v[e - 1].breakAfter && v[s].merge(0, 0, v[e - 1], !1, f, m) && e--,
      (e < s || a.length) && r.replaceChildren(e, s, a);
  }
}
function mergeChildrenInto(r, e, n, s, o, a) {
  let l = r.childCursor(),
    { i: f, off: m } = l.findPos(n, 1),
    { i: v, off: I } = l.findPos(e, -1),
    L = e - n;
  for (let V of s) L += V.length;
  (r.length += L), replaceRange(r, v, I, f, m, s, 0, o, a);
}
let nav = typeof navigator < 'u' ? navigator : { userAgent: '', vendor: '', platform: '' },
  doc = typeof document < 'u' ? document : { documentElement: { style: {} } };
const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent),
  ie_upto10 = /MSIE \d/.test(nav.userAgent),
  ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent),
  ie$1 = !!(ie_upto10 || ie_11up || ie_edge),
  gecko = !ie$1 && /gecko\/(\d+)/i.test(nav.userAgent),
  chrome = !ie$1 && /Chrome\/(\d+)/.exec(nav.userAgent),
  webkit = 'webkitFontSmoothing' in doc.documentElement.style,
  safari = !ie$1 && /Apple Computer/.test(nav.vendor),
  ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /Mac/.test(nav.platform),
  windows: /Win/.test(nav.platform),
  linux: /Linux|X11/.test(nav.platform),
  ie: ie$1,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? 'tab-size' : '-moz-tab-size',
};
const MaxJoinLen = 256;
class TextView extends ContentView {
  constructor(e) {
    super(), (this.text = e);
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(),
      this.dom.nodeValue != this.text &&
        (n && n.node == this.dom && (n.written = !0), (this.dom.nodeValue = this.text));
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, s) {
    return this.flags & 8 ||
      (s && (!(s instanceof TextView) || this.length - (n - e) + s.length > MaxJoinLen || s.flags & 8))
      ? !1
      : ((this.text = this.text.slice(0, e) + (s ? s.text : '') + this.text.slice(n)), this.markDirty(), !0);
  }
  split(e) {
    let n = new TextView(this.text.slice(e));
    return (this.text = this.text.slice(0, e)), this.markDirty(), (n.flags |= this.flags & 8), n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new DOMPos(this.dom, e);
  }
  domBoundsAround(e, n, s) {
    return { from: s, to: s + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return textCoords(this.dom, e, n);
  }
}
class MarkView extends ContentView {
  constructor(e, n = [], s = 0) {
    super(), (this.mark = e), (this.children = n), (this.length = s);
    for (let o of n) o.setParent(this);
  }
  setAttrs(e) {
    if ((clearAttributes(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs))
      for (let n in this.mark.attrs) e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, n) {
    this.dom
      ? this.flags & 4 && this.setAttrs(this.dom)
      : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
      super.sync(e, n);
  }
  merge(e, n, s, o, a, l) {
    return s && (!(s instanceof MarkView && s.mark.eq(this.mark)) || (e && a <= 0) || (n < this.length && l <= 0))
      ? !1
      : (mergeChildrenInto(this, e, n, s ? s.children : [], a - 1, l - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [],
      s = 0,
      o = -1,
      a = 0;
    for (let f of this.children) {
      let m = s + f.length;
      m > e && n.push(s < e ? f.split(e - s) : f), o < 0 && s >= e && (o = a), (s = m), a++;
    }
    let l = this.length - e;
    return (this.length = e), o > -1 && ((this.children.length = o), this.markDirty()), new MarkView(this.mark, n, l);
  }
  domAtPos(e) {
    return inlineDOMAtPos(this, e);
  }
  coordsAt(e, n) {
    return coordsInChildren(this, e, n);
  }
}
function textCoords(r, e, n) {
  let s = r.nodeValue.length;
  e > s && (e = s);
  let o = e,
    a = e,
    l = 0;
  (e == 0 && n < 0) || (e == s && n >= 0)
    ? browser.chrome || browser.gecko || (e ? (o--, (l = 1)) : a < s && (a++, (l = -1)))
    : n < 0
    ? o--
    : a < s && a++;
  let f = textRange(r, o, a).getClientRects();
  if (!f.length) return null;
  let m = f[(l ? l < 0 : n >= 0) ? 0 : f.length - 1];
  return (
    browser.safari && !l && m.width == 0 && (m = Array.prototype.find.call(f, (v) => v.width) || m),
    l ? flattenRect(m, l < 0) : m || null
  );
}
class WidgetView extends ContentView {
  static create(e, n, s) {
    return new WidgetView(e, n, s);
  }
  constructor(e, n, s) {
    super(), (this.widget = e), (this.length = n), (this.side = s), (this.prevWidget = null);
  }
  split(e) {
    let n = WidgetView.create(this.widget, this.length - e, this.side);
    return (this.length -= e), n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      (this.dom.contentEditable = 'false'));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, s, o, a, l) {
    return s &&
      (!(s instanceof WidgetView) || !this.widget.compare(s.widget) || (e > 0 && a <= 0) || (n < this.length && l <= 0))
      ? !1
      : ((this.length = e + (s ? s.length : 0) + (this.length - n)), !0);
  }
  become(e) {
    return e instanceof WidgetView && e.side == this.side && this.widget.constructor == e.widget.constructor
      ? (this.widget.compare(e.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0) return Text.empty;
    let e = this;
    for (; e.parent; ) e = e.parent;
    let { view: n } = e,
      s = n && n.state.doc,
      o = this.posAtStart;
    return s ? s.slice(o, o + this.length) : Text.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let s = this.widget.coordsAt(this.dom, e, n);
    if (s) return s;
    let o = this.dom.getClientRects(),
      a = null;
    if (!o.length) return null;
    let l = this.side ? this.side < 0 : e > 0;
    for (
      let f = l ? o.length - 1 : 0;
      (a = o[f]), !(e > 0 ? f == 0 : f == o.length - 1 || a.top < a.bottom);
      f += l ? -1 : 1
    );
    return flattenRect(a, !l);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class WidgetBufferView extends ContentView {
  constructor(e) {
    super(), (this.side = e);
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof WidgetBufferView && e.side == this.side;
  }
  split() {
    return new WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement('img');
      (e.className = 'cm-widgetBuffer'), e.setAttribute('aria-hidden', 'true'), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
  get isHidden() {
    return !0;
  }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(r, e) {
  let n = r.dom,
    { children: s } = r,
    o = 0;
  for (let a = 0; o < s.length; o++) {
    let l = s[o],
      f = a + l.length;
    if (!(f == a && l.getSide() <= 0)) {
      if (e > a && e < f && l.dom.parentNode == n) return l.domAtPos(e - a);
      if (e <= a) break;
      a = f;
    }
  }
  for (let a = o; a > 0; a--) {
    let l = s[a - 1];
    if (l.dom.parentNode == n) return l.domAtPos(l.length);
  }
  for (let a = o; a < s.length; a++) {
    let l = s[a];
    if (l.dom.parentNode == n) return l.domAtPos(0);
  }
  return new DOMPos(n, 0);
}
function joinInlineInto(r, e, n) {
  let s,
    { children: o } = r;
  n > 0 && e instanceof MarkView && o.length && (s = o[o.length - 1]) instanceof MarkView && s.mark.eq(e.mark)
    ? joinInlineInto(s, e.children[0], n - 1)
    : (o.push(e), e.setParent(r)),
    (r.length += e.length);
}
function coordsInChildren(r, e, n) {
  let s = null,
    o = -1,
    a = null,
    l = -1;
  function f(v, I) {
    for (let L = 0, V = 0; L < v.children.length && V <= I; L++) {
      let se = v.children[L],
        Ee = V + se.length;
      Ee >= I &&
        (se.children.length
          ? f(se, I - V)
          : (!a || (a.isHidden && n > 0)) && (Ee > I || (V == Ee && se.getSide() > 0))
          ? ((a = se), (l = I - V))
          : (V < I || (V == Ee && se.getSide() < 0 && !se.isHidden)) && ((s = se), (o = I - V))),
        (V = Ee);
    }
  }
  f(r, e);
  let m = (n < 0 ? s : a) || s || a;
  return m ? m.coordsAt(Math.max(0, m == s ? o : l), n) : fallbackRect(r);
}
function fallbackRect(r) {
  let e = r.dom.lastChild;
  if (!e) return r.dom.getBoundingClientRect();
  let n = clientRectsFor(e);
  return n[n.length - 1] || null;
}
function combineAttrs(r, e) {
  for (let n in r)
    n == 'class' && e.class
      ? (e.class += ' ' + r.class)
      : n == 'style' && e.style
      ? (e.style += ';' + r.style)
      : (e[n] = r[n]);
  return e;
}
const noAttrs = Object.create(null);
function attrsEq(r, e, n) {
  if (r == e) return !0;
  r || (r = noAttrs), e || (e = noAttrs);
  let s = Object.keys(r),
    o = Object.keys(e);
  if (s.length - (n && s.indexOf(n) > -1 ? 1 : 0) != o.length - (n && o.indexOf(n) > -1 ? 1 : 0)) return !1;
  for (let a of s) if (a != n && (o.indexOf(a) == -1 || r[a] !== e[a])) return !1;
  return !0;
}
function updateAttrs(r, e, n) {
  let s = !1;
  if (e) for (let o in e) (n && o in n) || ((s = !0), o == 'style' ? (r.style.cssText = '') : r.removeAttribute(o));
  if (n)
    for (let o in n)
      (e && e[o] == n[o]) || ((s = !0), o == 'style' ? (r.style.cssText = n[o]) : r.setAttribute(o, n[o]));
  return s;
}
function getAttrs(r) {
  let e = Object.create(null);
  for (let n = 0; n < r.attributes.length; n++) {
    let s = r.attributes[n];
    e[s.name] = s.value;
  }
  return e;
}
class LineView extends ContentView {
  constructor() {
    super(...arguments),
      (this.children = []),
      (this.length = 0),
      (this.prevAttrs = void 0),
      (this.attrs = null),
      (this.breakAfter = 0);
  }
  merge(e, n, s, o, a, l) {
    if (s) {
      if (!(s instanceof LineView)) return !1;
      this.dom || s.transferDOM(this);
    }
    return o && this.setDeco(s ? s.attrs : null), mergeChildrenInto(this, e, n, s ? s.children : [], a, l), !0;
  }
  split(e) {
    let n = new LineView();
    if (((n.breakAfter = this.breakAfter), this.length == 0)) return n;
    let { i: s, off: o } = this.childPos(e);
    o &&
      (n.append(this.children[s].split(o), 0), this.children[s].merge(o, this.children[s].length, null, !1, 0, 0), s++);
    for (let a = s; a < this.children.length; a++) n.append(this.children[a], 0);
    for (; s > 0 && this.children[s - 1].length == 0; ) this.children[--s].destroy();
    return (this.children.length = s), this.markDirty(), (this.length = e), n;
  }
  transferDOM(e) {
    this.dom &&
      (this.markDirty(),
      e.setDOM(this.dom),
      (e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs),
      (this.prevAttrs = void 0),
      (this.dom = null));
  }
  setDeco(e) {
    attrsEq(this.attrs, e) || (this.dom && ((this.prevAttrs = this.attrs), this.markDirty()), (this.attrs = e));
  }
  append(e, n) {
    joinInlineInto(this, e, n);
  }
  addLineDeco(e) {
    let n = e.spec.attributes,
      s = e.spec.class;
    n && (this.attrs = combineAttrs(n, this.attrs || {})),
      s && (this.attrs = combineAttrs({ class: s }, this.attrs || {}));
  }
  domAtPos(e) {
    return inlineDOMAtPos(this, e);
  }
  reuseDOM(e) {
    e.nodeName == 'DIV' && (this.setDOM(e), (this.flags |= 6));
  }
  sync(e, n) {
    var s;
    this.dom
      ? this.flags & 4 &&
        (clearAttributes(this.dom), (this.dom.className = 'cm-line'), (this.prevAttrs = this.attrs ? null : void 0))
      : (this.setDOM(document.createElement('div')),
        (this.dom.className = 'cm-line'),
        (this.prevAttrs = this.attrs ? null : void 0)),
      this.prevAttrs !== void 0 &&
        (updateAttrs(this.dom, this.prevAttrs, this.attrs),
        this.dom.classList.add('cm-line'),
        (this.prevAttrs = void 0)),
      super.sync(e, n);
    let o = this.dom.lastChild;
    for (; o && ContentView.get(o) instanceof MarkView; ) o = o.lastChild;
    if (
      !o ||
      !this.length ||
      (o.nodeName != 'BR' &&
        ((s = ContentView.get(o)) === null || s === void 0 ? void 0 : s.isEditable) == !1 &&
        (!browser.ios || !this.children.some((a) => a instanceof TextView)))
    ) {
      let a = document.createElement('BR');
      (a.cmIgnore = !0), this.dom.appendChild(a);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null;
    let e = 0,
      n;
    for (let s of this.children) {
      if (!(s instanceof TextView) || /[^ -~]/.test(s.text)) return null;
      let o = clientRectsFor(s.dom);
      if (o.length != 1) return null;
      (e += o[0].width), (n = o[0].height);
    }
    return e
      ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: e / this.length, textHeight: n }
      : null;
  }
  coordsAt(e, n) {
    let s = coordsInChildren(this, e, n);
    if (!this.children.length && s && this.parent) {
      let { heightOracle: o } = this.parent.view.viewState,
        a = s.bottom - s.top;
      if (Math.abs(a - o.lineHeight) < 2 && o.textHeight < a) {
        let l = (a - o.textHeight) / 2;
        return { top: s.top + l, bottom: s.bottom - l, left: s.left, right: s.left };
      }
    }
    return s;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let s = 0, o = 0; s < e.children.length; s++) {
      let a = e.children[s],
        l = o + a.length;
      if (l >= n) {
        if (a instanceof LineView) return a;
        if (l > n) break;
      }
      o = l + a.breakAfter;
    }
    return null;
  }
}
class BlockWidgetView extends ContentView {
  constructor(e, n, s) {
    super(), (this.widget = e), (this.length = n), (this.deco = s), (this.breakAfter = 0), (this.prevWidget = null);
  }
  merge(e, n, s, o, a, l) {
    return s &&
      (!(s instanceof BlockWidgetView) ||
        !this.widget.compare(s.widget) ||
        (e > 0 && a <= 0) ||
        (n < this.length && l <= 0))
      ? !1
      : ((this.length = e + (s ? s.length : 0) + (this.length - n)), !0);
  }
  domAtPos(e) {
    return e == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let s = new BlockWidgetView(this.widget, n, this.deco);
    return (s.breakAfter = this.breakAfter), s;
  }
  get children() {
    return noChildren;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      (this.dom.contentEditable = 'false'));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof BlockWidgetView && e.widget.constructor == this.widget.constructor
      ? (e.widget.compare(this.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        (this.deco = e.deco),
        (this.breakAfter = e.breakAfter),
        !0)
      : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    return this.widget.coordsAt(this.dom, e, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: s } = this.deco;
    return n == s ? !1 : e < 0 ? n < 0 : s > 0;
  }
}
class WidgetType {
  eq(e) {
    return !1;
  }
  updateDOM(e, n) {
    return !1;
  }
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(e) {
    return !0;
  }
  coordsAt(e, n, s) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  destroy(e) {}
}
var BlockType = (function (r) {
  return (
    (r[(r.Text = 0)] = 'Text'),
    (r[(r.WidgetBefore = 1)] = 'WidgetBefore'),
    (r[(r.WidgetAfter = 2)] = 'WidgetAfter'),
    (r[(r.WidgetRange = 3)] = 'WidgetRange'),
    r
  );
})(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
  constructor(e, n, s, o) {
    super(), (this.startSide = e), (this.endSide = n), (this.widget = s), (this.spec = o);
  }
  get heightRelevant() {
    return !1;
  }
  static mark(e) {
    return new MarkDecoration(e);
  }
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)),
      s = !!e.block;
    return (
      (n += s && !e.inlineOrder ? (n > 0 ? 3e8 : -4e8) : n > 0 ? 1e8 : -1e8),
      new PointDecoration(e, n, n, s, e.widget || null, !1)
    );
  }
  static replace(e) {
    let n = !!e.block,
      s,
      o;
    if (e.isBlockGap) (s = -5e8), (o = 4e8);
    else {
      let { start: a, end: l } = getInclusive(e, n);
      (s = (a ? (n ? -3e8 : -1) : 5e8) - 1), (o = (l ? (n ? 2e8 : 1) : -6e8) + 1);
    }
    return new PointDecoration(e, s, o, n, e.widget || null, !0);
  }
  static line(e) {
    return new LineDecoration(e);
  }
  static set(e, n = !1) {
    return RangeSet.of(e, n);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
  constructor(e) {
    let { start: n, end: s } = getInclusive(e);
    super(n ? -1 : 5e8, s ? 1 : -6e8, null, e),
      (this.tagName = e.tagName || 'span'),
      (this.class = e.class || ''),
      (this.attrs = e.attributes || null);
  }
  eq(e) {
    var n, s;
    return (
      this == e ||
      (e instanceof MarkDecoration &&
        this.tagName == e.tagName &&
        (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) ==
          (e.class || ((s = e.attrs) === null || s === void 0 ? void 0 : s.class)) &&
        attrsEq(this.attrs, e.attrs, 'class'))
    );
  }
  range(e, n = e) {
    if (e >= n) throw new RangeError('Mark decorations may not be empty');
    return super.range(e, n);
  }
}
MarkDecoration.prototype.point = !1;
class LineDecoration extends Decoration {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return (
      e instanceof LineDecoration && this.spec.class == e.spec.class && attrsEq(this.spec.attributes, e.spec.attributes)
    );
  }
  range(e, n = e) {
    if (n != e) throw new RangeError('Line decoration ranges must be zero-length');
    return super.range(e, n);
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = !0;
class PointDecoration extends Decoration {
  constructor(e, n, s, o, a, l) {
    super(n, s, a, e),
      (this.block = o),
      (this.isReplace = l),
      (this.mapMode = o ? (n <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter) : MapMode.TrackDel);
  }
  get type() {
    return this.startSide != this.endSide
      ? BlockType.WidgetRange
      : this.startSide <= 0
      ? BlockType.WidgetBefore
      : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || (!!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0));
  }
  eq(e) {
    return (
      e instanceof PointDecoration &&
      widgetsEq(this.widget, e.widget) &&
      this.block == e.block &&
      this.startSide == e.startSide &&
      this.endSide == e.endSide
    );
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || (e == n && this.startSide > 0 && this.endSide <= 0)))
      throw new RangeError('Invalid range for replacement decoration');
    if (!this.isReplace && n != e) throw new RangeError('Widget decorations can only have zero-length ranges');
    return super.range(e, n);
  }
}
PointDecoration.prototype.point = !0;
function getInclusive(r, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: s } = r;
  return n == null && (n = r.inclusive), s == null && (s = r.inclusive), { start: n ?? e, end: s ?? e };
}
function widgetsEq(r, e) {
  return r == e || !!(r && e && r.compare(e));
}
function addRange(r, e, n, s = 0) {
  let o = n.length - 1;
  o >= 0 && n[o] + s >= r ? (n[o] = Math.max(n[o], e)) : n.push(r, e);
}
class ContentBuilder {
  constructor(e, n, s, o) {
    (this.doc = e),
      (this.pos = n),
      (this.end = s),
      (this.disallowBlockEffectsFor = o),
      (this.content = []),
      (this.curLine = null),
      (this.breakAtStart = 0),
      (this.pendingBuffer = 0),
      (this.bufferMarks = []),
      (this.atCursorPos = !0),
      (this.openStart = -1),
      (this.openEnd = -1),
      (this.text = ''),
      (this.textOff = 0),
      (this.cursor = e.iter()),
      (this.skip = n);
  }
  posCovered() {
    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || (e instanceof BlockWidgetView && e.deco.endSide < 0));
  }
  getLine() {
    return this.curLine || (this.content.push((this.curLine = new LineView())), (this.atCursorPos = !0)), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer &&
      (this.curLine.append(wrapMarks(new WidgetBufferView(-1), e), e.length), (this.pendingBuffer = 0));
  }
  addBlockWidget(e) {
    this.flushBuffer(), (this.curLine = null), this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : (this.pendingBuffer = 0),
      !this.posCovered() &&
        !(e && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView) &&
        this.getLine();
  }
  buildText(e, n, s) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: a, lineBreak: l, done: f } = this.cursor.next(this.skip);
        if (((this.skip = 0), f)) throw new Error('Ran out of text content when drawing inline views');
        if (l) {
          this.posCovered() || this.getLine(),
            this.content.length ? (this.content[this.content.length - 1].breakAfter = 1) : (this.breakAtStart = 1),
            this.flushBuffer(),
            (this.curLine = null),
            (this.atCursorPos = !0),
            e--;
          continue;
        } else (this.text = a), (this.textOff = 0);
      }
      let o = Math.min(this.text.length - this.textOff, e, 512);
      this.flushBuffer(n.slice(n.length - s)),
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + o)), n), s),
        (this.atCursorPos = !0),
        (this.textOff += o),
        (e -= o),
        (s = 0);
    }
  }
  span(e, n, s, o) {
    this.buildText(n - e, s, o), (this.pos = n), this.openStart < 0 && (this.openStart = o);
  }
  point(e, n, s, o, a, l) {
    if (this.disallowBlockEffectsFor[l] && s instanceof PointDecoration) {
      if (s.block) throw new RangeError('Block decorations may not be specified via plugins');
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError('Decorations that replace line breaks may not be specified via plugins');
    }
    let f = n - e;
    if (s instanceof PointDecoration)
      if (s.block)
        s.startSide > 0 && !this.posCovered() && this.getLine(),
          this.addBlockWidget(new BlockWidgetView(s.widget || new NullWidget('div'), f, s));
      else {
        let m = WidgetView.create(s.widget || new NullWidget('span'), f, f ? 0 : s.startSide),
          v = this.atCursorPos && !m.isEditable && a <= o.length && (e < n || s.startSide > 0),
          I = !m.isEditable && (e < n || a > o.length || s.startSide <= 0),
          L = this.getLine();
        this.pendingBuffer == 2 && !v && !m.isEditable && (this.pendingBuffer = 0),
          this.flushBuffer(o),
          v && (L.append(wrapMarks(new WidgetBufferView(1), o), a), (a = o.length + Math.max(0, a - o.length))),
          L.append(wrapMarks(m, o), a),
          (this.atCursorPos = I),
          (this.pendingBuffer = I ? (e < n || a > o.length ? 1 : 2) : 0),
          this.pendingBuffer && (this.bufferMarks = o.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(s);
    f &&
      (this.textOff + f <= this.text.length
        ? (this.textOff += f)
        : ((this.skip += f - (this.text.length - this.textOff)), (this.text = ''), (this.textOff = 0)),
      (this.pos = n)),
      this.openStart < 0 && (this.openStart = a);
  }
  static build(e, n, s, o, a) {
    let l = new ContentBuilder(e, n, s, a);
    return (
      (l.openEnd = RangeSet.spans(o, n, s, l)), l.openStart < 0 && (l.openStart = l.openEnd), l.finish(l.openEnd), l
    );
  }
}
function wrapMarks(r, e) {
  for (let n of e) r = new MarkView(n, [r], r.length);
  return r;
}
class NullWidget extends WidgetType {
  constructor(e) {
    super(), (this.tag = e);
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const clickAddsSelectionRange = Facet.define(),
  dragMovesSelection$1 = Facet.define(),
  mouseSelectionStyle = Facet.define(),
  exceptionSink = Facet.define(),
  updateListener = Facet.define(),
  inputHandler$1 = Facet.define(),
  focusChangeEffect = Facet.define(),
  perLineTextDirection = Facet.define({ combine: (r) => r.some((e) => e) }),
  nativeSelectionHidden = Facet.define({ combine: (r) => r.some((e) => e) });
class ScrollTarget {
  constructor(e, n = 'nearest', s = 'nearest', o = 5, a = 5) {
    (this.range = e), (this.y = n), (this.x = s), (this.yMargin = o), (this.xMargin = a);
  }
  map(e) {
    return e.empty ? this : new ScrollTarget(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const scrollIntoView$1 = StateEffect.define({ map: (r, e) => r.map(e) });
function logException(r, e, n) {
  let s = r.facet(exceptionSink);
  s.length
    ? s[0](e)
    : window.onerror
    ? window.onerror(String(e), n, void 0, void 0, e)
    : n
    ? console.error(n + ':', e)
    : console.error(e);
}
const editable = Facet.define({ combine: (r) => (r.length ? r[0] : !0) });
let nextPluginID = 0;
const viewPlugin = Facet.define();
class ViewPlugin {
  constructor(e, n, s, o, a) {
    (this.id = e),
      (this.create = n),
      (this.domEventHandlers = s),
      (this.domEventObservers = o),
      (this.extension = a(this));
  }
  static define(e, n) {
    const { eventHandlers: s, eventObservers: o, provide: a, decorations: l } = n || {};
    return new ViewPlugin(nextPluginID++, e, s, o, (f) => {
      let m = [viewPlugin.of(f)];
      return (
        l &&
          m.push(
            decorations.of((v) => {
              let I = v.plugin(f);
              return I ? l(I) : Decoration.none;
            }),
          ),
        a && m.push(a(f)),
        m
      );
    });
  }
  static fromClass(e, n) {
    return ViewPlugin.define((s) => new e(s), n);
  }
}
class PluginInstance {
  constructor(e) {
    (this.spec = e), (this.mustUpdate = null), (this.value = null);
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (((this.mustUpdate = null), this.value.update))
          try {
            this.value.update(n);
          } catch (s) {
            if ((logException(n.state, s, 'CodeMirror plugin crashed'), this.value.destroy))
              try {
                this.value.destroy();
              } catch {}
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        logException(e.state, n, 'CodeMirror plugin crashed'), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (s) {
        logException(e.state, s, 'CodeMirror plugin crashed');
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = Facet.define(),
  contentAttributes = Facet.define(),
  decorations = Facet.define(),
  atomicRanges = Facet.define(),
  bidiIsolatedRanges = Facet.define();
function getIsolatedRanges(r, e, n) {
  let s = r.state.facet(bidiIsolatedRanges);
  if (!s.length) return s;
  let o = s.map((l) => (l instanceof Function ? l(r) : l)),
    a = [];
  return (
    RangeSet.spans(o, e, n, {
      point() {},
      span(l, f, m, v) {
        let I = a;
        for (let L = m.length - 1; L >= 0; L--, v--) {
          let V = m[L].spec.bidiIsolate,
            se;
          if (V != null)
            if (v > 0 && I.length && (se = I[I.length - 1]).to == l && se.direction == V) (se.to = f), (I = se.inner);
            else {
              let Ee = { from: l, to: f, direction: V, inner: [] };
              I.push(Ee), (I = Ee.inner);
            }
        }
      },
    }),
    a
  );
}
const scrollMargins = Facet.define();
function getScrollMargins(r) {
  let e = 0,
    n = 0,
    s = 0,
    o = 0;
  for (let a of r.state.facet(scrollMargins)) {
    let l = a(r);
    l &&
      (l.left != null && (e = Math.max(e, l.left)),
      l.right != null && (n = Math.max(n, l.right)),
      l.top != null && (s = Math.max(s, l.top)),
      l.bottom != null && (o = Math.max(o, l.bottom)));
  }
  return { left: e, right: n, top: s, bottom: o };
}
const styleModule = Facet.define();
class ChangedRange {
  constructor(e, n, s, o) {
    (this.fromA = e), (this.toA = n), (this.fromB = s), (this.toB = o);
  }
  join(e) {
    return new ChangedRange(
      Math.min(this.fromA, e.fromA),
      Math.max(this.toA, e.toA),
      Math.min(this.fromB, e.fromB),
      Math.max(this.toB, e.toB),
    );
  }
  addToSet(e) {
    let n = e.length,
      s = this;
    for (; n > 0; n--) {
      let o = e[n - 1];
      if (!(o.fromA > s.toA)) {
        if (o.toA < s.fromA) break;
        (s = s.join(o)), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, s), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0) return e;
    let s = [];
    for (let o = 0, a = 0, l = 0, f = 0; ; o++) {
      let m = o == e.length ? null : e[o],
        v = l - f,
        I = m ? m.fromB : 1e9;
      for (; a < n.length && n[a] < I; ) {
        let L = n[a],
          V = n[a + 1],
          se = Math.max(f, L),
          Ee = Math.min(I, V);
        if ((se <= Ee && new ChangedRange(se + v, Ee + v, se, Ee).addToSet(s), V > I)) break;
        a += 2;
      }
      if (!m) return s;
      new ChangedRange(m.fromA, m.toA, m.fromB, m.toB).addToSet(s), (l = m.toA), (f = m.toB);
    }
  }
}
class ViewUpdate {
  constructor(e, n, s) {
    (this.view = e),
      (this.state = n),
      (this.transactions = s),
      (this.flags = 0),
      (this.startState = e.state),
      (this.changes = ChangeSet.empty(this.startState.doc.length));
    for (let a of s) this.changes = this.changes.compose(a.changes);
    let o = [];
    this.changes.iterChangedRanges((a, l, f, m) => o.push(new ChangedRange(a, l, f, m))), (this.changedRanges = o);
  }
  static create(e, n, s) {
    return new ViewUpdate(e, n, s);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Direction = (function (r) {
  return (r[(r.LTR = 0)] = 'LTR'), (r[(r.RTL = 1)] = 'RTL'), r;
})(Direction || (Direction = {}));
const LTR = Direction.LTR,
  RTL = Direction.RTL;
function dec(r) {
  let e = [];
  for (let n = 0; n < r.length; n++) e.push(1 << +r[n]);
  return e;
}
const LowTypes = dec(
    '88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008',
  ),
  ArabicTypes = dec(
    '4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333',
  ),
  Brackets = Object.create(null),
  BracketStack = [];
for (let r of ['()', '[]', '{}']) {
  let e = r.charCodeAt(0),
    n = r.charCodeAt(1);
  (Brackets[e] = n), (Brackets[n] = -e);
}
function charType(r) {
  return r <= 247
    ? LowTypes[r]
    : 1424 <= r && r <= 1524
    ? 2
    : 1536 <= r && r <= 1785
    ? ArabicTypes[r - 1536]
    : 1774 <= r && r <= 2220
    ? 4
    : 8192 <= r && r <= 8203
    ? 256
    : 64336 <= r && r <= 65023
    ? 4
    : r == 8204
    ? 256
    : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  constructor(e, n, s) {
    (this.from = e), (this.to = n), (this.level = s);
  }
  side(e, n) {
    return (this.dir == n) == e ? this.to : this.from;
  }
  static find(e, n, s, o) {
    let a = -1;
    for (let l = 0; l < e.length; l++) {
      let f = e[l];
      if (f.from <= n && f.to >= n) {
        if (f.level == s) return l;
        (a < 0 || (o != 0 ? (o < 0 ? f.from < n : f.to > n) : e[a].level > f.level)) && (a = l);
      }
    }
    if (a < 0) throw new RangeError('Index out of range');
    return a;
  }
}
function isolatesEq(r, e) {
  if (r.length != e.length) return !1;
  for (let n = 0; n < r.length; n++) {
    let s = r[n],
      o = e[n];
    if (s.from != o.from || s.to != o.to || s.direction != o.direction || !isolatesEq(s.inner, o.inner)) return !1;
  }
  return !0;
}
const types = [];
function computeCharTypes(r, e, n, s, o) {
  for (let a = 0; a <= s.length; a++) {
    let l = a ? s[a - 1].to : e,
      f = a < s.length ? s[a].from : n,
      m = a ? 256 : o;
    for (let v = l, I = m, L = m; v < f; v++) {
      let V = charType(r.charCodeAt(v));
      V == 512 ? (V = I) : V == 8 && L == 4 && (V = 16), (types[v] = V == 4 ? 2 : V), V & 7 && (L = V), (I = V);
    }
    for (let v = l, I = m, L = m; v < f; v++) {
      let V = types[v];
      if (V == 128) v < f - 1 && I == types[v + 1] && I & 24 ? (V = types[v] = I) : (types[v] = 256);
      else if (V == 64) {
        let se = v + 1;
        for (; se < f && types[se] == 64; ) se++;
        let Ee = (v && I == 8) || (se < n && types[se] == 8) ? (L == 1 ? 1 : 8) : 256;
        for (let ht = v; ht < se; ht++) types[ht] = Ee;
        v = se - 1;
      } else V == 8 && L == 1 && (types[v] = 1);
      (I = V), V & 7 && (L = V);
    }
  }
}
function processBracketPairs(r, e, n, s, o) {
  let a = o == 1 ? 2 : 1;
  for (let l = 0, f = 0, m = 0; l <= s.length; l++) {
    let v = l ? s[l - 1].to : e,
      I = l < s.length ? s[l].from : n;
    for (let L = v, V, se, Ee; L < I; L++)
      if ((se = Brackets[(V = r.charCodeAt(L))]))
        if (se < 0) {
          for (let ht = f - 3; ht >= 0; ht -= 3)
            if (BracketStack[ht + 1] == -se) {
              let ar = BracketStack[ht + 2],
                $i = ar & 2 ? o : ar & 4 ? (ar & 1 ? a : o) : 0;
              $i && (types[L] = types[BracketStack[ht]] = $i), (f = ht);
              break;
            }
        } else {
          if (BracketStack.length == 189) break;
          (BracketStack[f++] = L), (BracketStack[f++] = V), (BracketStack[f++] = m);
        }
      else if ((Ee = types[L]) == 2 || Ee == 1) {
        let ht = Ee == o;
        m = ht ? 0 : 1;
        for (let ar = f - 3; ar >= 0; ar -= 3) {
          let $i = BracketStack[ar + 2];
          if ($i & 2) break;
          if (ht) BracketStack[ar + 2] |= 2;
          else {
            if ($i & 4) break;
            BracketStack[ar + 2] |= 4;
          }
        }
      }
  }
}
function processNeutrals(r, e, n, s) {
  for (let o = 0, a = s; o <= n.length; o++) {
    let l = o ? n[o - 1].to : r,
      f = o < n.length ? n[o].from : e;
    for (let m = l; m < f; ) {
      let v = types[m];
      if (v == 256) {
        let I = m + 1;
        for (;;)
          if (I == f) {
            if (o == n.length) break;
            (I = n[o++].to), (f = o < n.length ? n[o].from : e);
          } else if (types[I] == 256) I++;
          else break;
        let L = a == 1,
          V = (I < e ? types[I] : s) == 1,
          se = L == V ? (L ? 1 : 2) : s;
        for (let Ee = I, ht = o, ar = ht ? n[ht - 1].to : r; Ee > m; )
          Ee == ar && ((Ee = n[--ht].from), (ar = ht ? n[ht - 1].to : r)), (types[--Ee] = se);
        m = I;
      } else (a = v), m++;
    }
  }
}
function emitSpans(r, e, n, s, o, a, l) {
  let f = s % 2 ? 2 : 1;
  if (s % 2 == o % 2)
    for (let m = e, v = 0; m < n; ) {
      let I = !0,
        L = !1;
      if (v == a.length || m < a[v].from) {
        let ht = types[m];
        ht != f && ((I = !1), (L = ht == 16));
      }
      let V = !I && f == 1 ? [] : null,
        se = I ? s : s + 1,
        Ee = m;
      e: for (;;)
        if (v < a.length && Ee == a[v].from) {
          if (L) break e;
          let ht = a[v];
          if (!I)
            for (let ar = ht.to, $i = v + 1; ; ) {
              if (ar == n) break e;
              if ($i < a.length && a[$i].from == ar) ar = a[$i++].to;
              else {
                if (types[ar] == f) break e;
                break;
              }
            }
          if ((v++, V)) V.push(ht);
          else {
            ht.from > m && l.push(new BidiSpan(m, ht.from, se));
            let ar = (ht.direction == LTR) != !(se % 2);
            computeSectionOrder(r, ar ? s + 1 : s, o, ht.inner, ht.from, ht.to, l), (m = ht.to);
          }
          Ee = ht.to;
        } else {
          if (Ee == n || (I ? types[Ee] != f : types[Ee] == f)) break;
          Ee++;
        }
      V ? emitSpans(r, m, Ee, s + 1, o, V, l) : m < Ee && l.push(new BidiSpan(m, Ee, se)), (m = Ee);
    }
  else
    for (let m = n, v = a.length; m > e; ) {
      let I = !0,
        L = !1;
      if (!v || m > a[v - 1].to) {
        let ht = types[m - 1];
        ht != f && ((I = !1), (L = ht == 16));
      }
      let V = !I && f == 1 ? [] : null,
        se = I ? s : s + 1,
        Ee = m;
      e: for (;;)
        if (v && Ee == a[v - 1].to) {
          if (L) break e;
          let ht = a[--v];
          if (!I)
            for (let ar = ht.from, $i = v; ; ) {
              if (ar == e) break e;
              if ($i && a[$i - 1].to == ar) ar = a[--$i].from;
              else {
                if (types[ar - 1] == f) break e;
                break;
              }
            }
          if (V) V.push(ht);
          else {
            ht.to < m && l.push(new BidiSpan(ht.to, m, se));
            let ar = (ht.direction == LTR) != !(se % 2);
            computeSectionOrder(r, ar ? s + 1 : s, o, ht.inner, ht.from, ht.to, l), (m = ht.from);
          }
          Ee = ht.from;
        } else {
          if (Ee == e || (I ? types[Ee - 1] != f : types[Ee - 1] == f)) break;
          Ee--;
        }
      V ? emitSpans(r, Ee, m, s + 1, o, V, l) : Ee < m && l.push(new BidiSpan(Ee, m, se)), (m = Ee);
    }
}
function computeSectionOrder(r, e, n, s, o, a, l) {
  let f = e % 2 ? 2 : 1;
  computeCharTypes(r, o, a, s, f),
    processBracketPairs(r, o, a, s, f),
    processNeutrals(o, a, s, f),
    emitSpans(r, o, a, e, n, s, l);
}
function computeOrder(r, e, n) {
  if (!r) return [new BidiSpan(0, 0, e == RTL ? 1 : 0)];
  if (e == LTR && !n.length && !BidiRE.test(r)) return trivialOrder(r.length);
  if (n.length) for (; r.length > types.length; ) types[types.length] = 256;
  let s = [],
    o = e == LTR ? 0 : 1;
  return computeSectionOrder(r, o, o, n, 0, r.length, s), s;
}
function trivialOrder(r) {
  return [new BidiSpan(0, r, 0)];
}
let movedOver = '';
function moveVisually(r, e, n, s, o) {
  var a;
  let l = s.head - r.from,
    f = -1;
  if (l == 0) {
    if (!o || !r.length) return null;
    e[0].level != n && ((l = e[0].side(!1, n)), (f = 0));
  } else if (l == r.length) {
    if (o) return null;
    let V = e[e.length - 1];
    V.level != n && ((l = V.side(!0, n)), (f = e.length - 1));
  }
  f < 0 && (f = BidiSpan.find(e, l, (a = s.bidiLevel) !== null && a !== void 0 ? a : -1, s.assoc));
  let m = e[f];
  l == m.side(o, n) && ((m = e[(f += o ? 1 : -1)]), (l = m.side(!o, n)));
  let v = o == (m.dir == n),
    I = findClusterBreak(r.text, l, v);
  if (((movedOver = r.text.slice(Math.min(l, I), Math.max(l, I))), I != m.side(o, n)))
    return EditorSelection.cursor(I + r.from, v ? -1 : 1, m.level);
  let L = f == (o ? e.length - 1 : 0) ? null : e[f + (o ? 1 : -1)];
  return !L && m.level != n
    ? EditorSelection.cursor(o ? r.to : r.from, o ? -1 : 1, n)
    : L && L.level < m.level
    ? EditorSelection.cursor(L.side(!o, n) + r.from, o ? 1 : -1, L.level)
    : EditorSelection.cursor(I + r.from, o ? -1 : 1, m.level);
}
class DocView extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(),
      (this.view = e),
      (this.decorations = []),
      (this.dynamicDecorationMap = []),
      (this.domChanged = null),
      (this.hasComposition = null),
      (this.markedForComposition = new Set()),
      (this.minWidth = 0),
      (this.minWidthFrom = 0),
      (this.minWidthTo = 0),
      (this.impreciseAnchor = null),
      (this.impreciseHead = null),
      (this.forceSelection = !1),
      (this.lastUpdate = Date.now()),
      this.setDOM(e.contentDOM),
      (this.children = [new LineView()]),
      this.children[0].setParent(this),
      this.updateDeco(),
      this.updateInner([new ChangedRange(0, 0, 0, e.state.doc.length)], 0, null);
  }
  update(e) {
    var n;
    let s = e.changedRanges;
    this.minWidth > 0 &&
      s.length &&
      (s.every(({ fromA: v, toA: I }) => I < this.minWidthFrom || v > this.minWidthTo)
        ? ((this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1)),
          (this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)))
        : (this.minWidth = this.minWidthFrom = this.minWidthTo = 0));
    let o = -1;
    this.view.inputState.composing >= 0 &&
      (!((n = this.domChanged) === null || n === void 0) && n.newSel
        ? (o = this.domChanged.newSel.head)
        : !touchesComposition(e.changes, this.hasComposition) && !e.selectionSet && (o = e.state.selection.main.head));
    let a = o > -1 ? findCompositionRange(this.view, e.changes, o) : null;
    if (((this.domChanged = null), this.hasComposition)) {
      this.markedForComposition.clear();
      let { from: v, to: I } = this.hasComposition;
      s = new ChangedRange(v, I, e.changes.mapPos(v, -1), e.changes.mapPos(I, 1)).addToSet(s.slice());
    }
    (this.hasComposition = a ? { from: a.range.fromB, to: a.range.toB } : null),
      (browser.ie || browser.chrome) &&
        !a &&
        e &&
        e.state.doc.lines != e.startState.doc.lines &&
        (this.forceSelection = !0);
    let l = this.decorations,
      f = this.updateDeco(),
      m = findChangedDeco(l, f, e.changes);
    return (
      (s = ChangedRange.extendWithRanges(s, m)),
      !(this.flags & 7) && s.length == 0
        ? !1
        : (this.updateInner(s, e.startState.doc.length, a), e.transactions.length && (this.lastUpdate = Date.now()), !0)
    );
  }
  updateInner(e, n, s) {
    (this.view.viewState.mustMeasureContent = !0), this.updateChildren(e, n, s);
    let { observer: o } = this.view;
    o.ignore(() => {
      (this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + 'px'),
        (this.dom.style.flexBasis = this.minWidth ? this.minWidth + 'px' : '');
      let l = browser.chrome || browser.ios ? { node: o.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, l),
        (this.flags &= -8),
        l && (l.written || o.selectionRange.focusNode != l.node) && (this.forceSelection = !0),
        (this.dom.style.height = '');
    }),
      this.markedForComposition.forEach((l) => (l.flags &= -9));
    let a = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let l of this.children) l instanceof BlockWidgetView && l.widget instanceof BlockGapWidget && a.push(l.dom);
    o.updateGaps(a);
  }
  updateChildren(e, n, s) {
    let o = s ? s.range.addToSet(e.slice()) : e,
      a = this.childCursor(n);
    for (let l = o.length - 1; ; l--) {
      let f = l >= 0 ? o[l] : null;
      if (!f) break;
      let { fromA: m, toA: v, fromB: I, toB: L } = f,
        V,
        se,
        Ee,
        ht;
      if (s && s.range.fromB < L && s.range.toB > I) {
        let hl = ContentBuilder.build(
            this.view.state.doc,
            I,
            s.range.fromB,
            this.decorations,
            this.dynamicDecorationMap,
          ),
          fl = ContentBuilder.build(this.view.state.doc, s.range.toB, L, this.decorations, this.dynamicDecorationMap);
        (se = hl.breakAtStart), (Ee = hl.openStart), (ht = fl.openEnd);
        let dl = this.compositionView(s);
        fl.breakAtStart
          ? (dl.breakAfter = 1)
          : fl.content.length &&
            dl.merge(dl.length, dl.length, fl.content[0], !1, fl.openStart, 0) &&
            ((dl.breakAfter = fl.content[0].breakAfter), fl.content.shift()),
          hl.content.length && dl.merge(0, 0, hl.content[hl.content.length - 1], !0, 0, hl.openEnd) && hl.content.pop(),
          (V = hl.content.concat(dl).concat(fl.content));
      } else
        ({
          content: V,
          breakAtStart: se,
          openStart: Ee,
          openEnd: ht,
        } = ContentBuilder.build(this.view.state.doc, I, L, this.decorations, this.dynamicDecorationMap));
      let { i: ar, off: $i } = a.findPos(v, 1),
        { i: tl, off: Wi } = a.findPos(m, -1);
      replaceRange(this, tl, Wi, ar, $i, V, se, Ee, ht);
    }
    s && this.fixCompositionDOM(s);
  }
  compositionView(e) {
    let n = new TextView(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: o } of e.marks) n = new MarkView(o, [n], n.length);
    let s = new LineView();
    return s.append(n, 0), s;
  }
  fixCompositionDOM(e) {
    let n = (a, l) => {
        (l.flags |= 8 | (l.children.some((m) => m.flags & 7) ? 1 : 0)), this.markedForComposition.add(l);
        let f = ContentView.get(a);
        f && f != l && (f.dom = null), l.setDOM(a);
      },
      s = this.childPos(e.range.fromB, 1),
      o = this.children[s.i];
    n(e.line, o);
    for (let a = e.marks.length - 1; a >= -1; a--)
      (s = o.childPos(s.off, 1)), (o = o.children[s.i]), n(a >= 0 ? e.marks[a].node : e.text, o);
  }
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s = this.view.root.activeElement,
      o = s == this.dom,
      a = !o && hasSelection(this.dom, this.view.observer.selectionRange) && !(s && this.dom.contains(s));
    if (!(o || n || a)) return;
    let l = this.forceSelection;
    this.forceSelection = !1;
    let f = this.view.state.selection.main,
      m = this.moveToLine(this.domAtPos(f.anchor)),
      v = f.empty ? m : this.moveToLine(this.domAtPos(f.head));
    if (browser.gecko && f.empty && !this.hasComposition && betweenUneditable(m)) {
      let L = document.createTextNode('');
      this.view.observer.ignore(() => m.node.insertBefore(L, m.node.childNodes[m.offset] || null)),
        (m = v = new DOMPos(L, 0)),
        (l = !0);
    }
    let I = this.view.observer.selectionRange;
    (l ||
      !I.focusNode ||
      !isEquivalentPosition(m.node, m.offset, I.anchorNode, I.anchorOffset) ||
      !isEquivalentPosition(v.node, v.offset, I.focusNode, I.focusOffset)) &&
      (this.view.observer.ignore(() => {
        browser.android &&
          browser.chrome &&
          this.dom.contains(I.focusNode) &&
          inUneditable(I.focusNode, this.dom) &&
          (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
        let L = getSelection(this.view.root);
        if (L)
          if (f.empty) {
            if (browser.gecko) {
              let V = nextToUneditable(m.node, m.offset);
              if (V && V != 3) {
                let se = nearbyTextNode(m.node, m.offset, V == 1 ? 1 : -1);
                se && (m = new DOMPos(se.node, se.offset));
              }
            }
            L.collapse(m.node, m.offset),
              f.bidiLevel != null && L.caretBidiLevel !== void 0 && (L.caretBidiLevel = f.bidiLevel);
          } else if (L.extend) {
            L.collapse(m.node, m.offset);
            try {
              L.extend(v.node, v.offset);
            } catch {}
          } else {
            let V = document.createRange();
            f.anchor > f.head && ([m, v] = [v, m]),
              V.setEnd(v.node, v.offset),
              V.setStart(m.node, m.offset),
              L.removeAllRanges(),
              L.addRange(V);
          }
        a && this.view.root.activeElement == this.dom && (this.dom.blur(), s && s.focus());
      }),
      this.view.observer.setSelectionRange(m, v)),
      (this.impreciseAnchor = m.precise ? null : new DOMPos(I.anchorNode, I.anchorOffset)),
      (this.impreciseHead = v.precise ? null : new DOMPos(I.focusNode, I.focusOffset));
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: e } = this,
      n = e.state.selection.main,
      s = getSelection(e.root),
      { anchorNode: o, anchorOffset: a } = e.observer.selectionRange;
    if (!s || !n.empty || !n.assoc || !s.modify) return;
    let l = LineView.find(this, n.head);
    if (!l) return;
    let f = l.posAtStart;
    if (n.head == f || n.head == f + l.length) return;
    let m = this.coordsAt(n.head, -1),
      v = this.coordsAt(n.head, 1);
    if (!m || !v || m.bottom > v.top) return;
    let I = this.domAtPos(n.head + n.assoc);
    s.collapse(I.node, I.offset),
      s.modify('move', n.assoc < 0 ? 'forward' : 'backward', 'lineboundary'),
      e.observer.readSelectionRange();
    let L = e.observer.selectionRange;
    e.docView.posFromDOM(L.anchorNode, L.anchorOffset) != n.from && s.collapse(o, a);
  }
  moveToLine(e) {
    let n = this.dom,
      s;
    if (e.node != n) return e;
    for (let o = e.offset; !s && o < n.childNodes.length; o++) {
      let a = ContentView.get(n.childNodes[o]);
      a instanceof LineView && (s = a.domAtPos(0));
    }
    for (let o = e.offset - 1; !s && o >= 0; o--) {
      let a = ContentView.get(n.childNodes[o]);
      a instanceof LineView && (s = a.domAtPos(a.length));
    }
    return s ? new DOMPos(s.node, s.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let s = ContentView.get(n);
      if (s && s.rootView == this) return s;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let s = this.nearest(e);
    if (!s) throw new RangeError('Trying to find position for a DOM position outside of the document');
    return s.localPosFromDOM(e, n) + s.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: s } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let o = this.children[n];
      if (s < o.length || o instanceof LineView) break;
      n++, (s = 0);
    }
    return this.children[n].domAtPos(s);
  }
  coordsAt(e, n) {
    let s = null,
      o = 0;
    for (let a = this.length, l = this.children.length - 1; l >= 0; l--) {
      let f = this.children[l],
        m = a - f.breakAfter,
        v = m - f.length;
      if (m < e) break;
      v <= e &&
        (v < e || f.covers(-1)) &&
        (m > e || f.covers(1)) &&
        (!s || (f instanceof LineView && !(s instanceof LineView && n >= 0))) &&
        ((s = f), (o = v)),
        (a = v);
    }
    return s ? s.coordsAt(e - o, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: s } = this.childPos(e, 1),
      o = this.children[n];
    if (!(o instanceof LineView)) return null;
    for (; o.children.length; ) {
      let { i: f, off: m } = o.childPos(s, 1);
      for (; ; f++) {
        if (f == o.children.length) return null;
        if ((o = o.children[f]).length) break;
      }
      s = m;
    }
    if (!(o instanceof TextView)) return null;
    let a = findClusterBreak(o.text, s);
    if (a == s) return null;
    let l = textRange(o.dom, s, a).getClientRects();
    return !l.length || l[0].top >= l[0].bottom ? null : l[0];
  }
  measureVisibleLineHeights(e) {
    let n = [],
      { from: s, to: o } = e,
      a = this.view.contentDOM.clientWidth,
      l = a > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
      f = -1,
      m = this.view.textDirection == Direction.LTR;
    for (let v = 0, I = 0; I < this.children.length; I++) {
      let L = this.children[I],
        V = v + L.length;
      if (V > o) break;
      if (v >= s) {
        let se = L.dom.getBoundingClientRect();
        if ((n.push(se.height), l)) {
          let Ee = L.dom.lastChild,
            ht = Ee ? clientRectsFor(Ee) : [];
          if (ht.length) {
            let ar = ht[ht.length - 1],
              $i = m ? ar.right - se.left : se.right - ar.left;
            $i > f && ((f = $i), (this.minWidth = a), (this.minWidthFrom = v), (this.minWidthTo = V));
          }
        }
      }
      v = V + L.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == 'rtl' ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let a of this.children)
      if (a instanceof LineView) {
        let l = a.measureTextSize();
        if (l) return l;
      }
    let e = document.createElement('div'),
      n,
      s,
      o;
    return (
      (e.className = 'cm-line'),
      (e.style.width = '99999px'),
      (e.style.position = 'absolute'),
      (e.textContent = 'abc def ghi jkl mno pqr stu'),
      this.view.observer.ignore(() => {
        this.dom.appendChild(e);
        let a = clientRectsFor(e.firstChild)[0];
        (n = e.getBoundingClientRect().height), (s = a ? a.width / 27 : 7), (o = a ? a.height : n), e.remove();
      }),
      { lineHeight: n, charWidth: s, textHeight: o }
    );
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new ChildCursor(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [],
      n = this.view.viewState;
    for (let s = 0, o = 0; ; o++) {
      let a = o == n.viewports.length ? null : n.viewports[o],
        l = a ? a.from - 1 : this.length;
      if (l > s) {
        let f = (n.lineBlockAt(l).bottom - n.lineBlockAt(s).top) / this.view.scaleY;
        e.push(
          Decoration.replace({ widget: new BlockGapWidget(f), block: !0, inclusive: !0, isBlockGap: !0 }).range(s, l),
        );
      }
      if (!a) break;
      s = a.to + 1;
    }
    return Decoration.set(e);
  }
  updateDeco() {
    let e = this.view.state
      .facet(decorations)
      .map((n, s) => ((this.dynamicDecorationMap[s] = typeof n == 'function') ? n(this.view) : n));
    for (let n = e.length; n < e.length + 3; n++) this.dynamicDecorationMap[n] = !1;
    return (this.decorations = [...e, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]);
  }
  scrollIntoView(e) {
    let { range: n } = e,
      s = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1),
      o;
    if (!s) return;
    !n.empty &&
      (o = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) &&
      (s = {
        left: Math.min(s.left, o.left),
        top: Math.min(s.top, o.top),
        right: Math.max(s.right, o.right),
        bottom: Math.max(s.bottom, o.bottom),
      });
    let a = getScrollMargins(this.view),
      l = { left: s.left - a.left, top: s.top - a.top, right: s.right + a.right, bottom: s.bottom + a.bottom };
    scrollRectIntoView(
      this.view.scrollDOM,
      l,
      n.head < n.anchor ? -1 : 1,
      e.x,
      e.y,
      e.xMargin,
      e.yMargin,
      this.view.textDirection == Direction.LTR,
    );
  }
}
function betweenUneditable(r) {
  return (
    r.node.nodeType == 1 &&
    r.node.firstChild &&
    (r.offset == 0 || r.node.childNodes[r.offset - 1].contentEditable == 'false') &&
    (r.offset == r.node.childNodes.length || r.node.childNodes[r.offset].contentEditable == 'false')
  );
}
class BlockGapWidget extends WidgetType {
  constructor(e) {
    super(), (this.height = e);
  }
  toDOM() {
    let e = document.createElement('div');
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return (e.style.height = this.height + 'px'), !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function findCompositionNode(r, e) {
  let n = r.observer.selectionRange,
    s = n.focusNode && nearbyTextNode(n.focusNode, n.focusOffset, 0);
  if (!s) return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function findCompositionRange(r, e, n) {
  let s = findCompositionNode(r, n);
  if (!s) return null;
  let { node: o, from: a, to: l } = s,
    f = o.nodeValue;
  if (/[\n\r]/.test(f) || r.state.doc.sliceString(s.from, s.to) != f) return null;
  let m = e.invertedDesc,
    v = new ChangedRange(m.mapPos(a), m.mapPos(l), a, l),
    I = [];
  for (let L = o.parentNode; ; L = L.parentNode) {
    let V = ContentView.get(L);
    if (V instanceof MarkView) I.push({ node: L, deco: V.mark });
    else {
      if (V instanceof LineView || (L.nodeName == 'DIV' && L.parentNode == r.contentDOM))
        return { range: v, text: o, marks: I, line: L };
      if (L != r.contentDOM)
        I.push({
          node: L,
          deco: new MarkDecoration({ inclusive: !0, attributes: getAttrs(L), tagName: L.tagName.toLowerCase() }),
        });
      else return null;
    }
  }
}
function nearbyTextNode(r, e, n) {
  if (n <= 0)
    for (let s = r, o = e; ; ) {
      if (s.nodeType == 3) return { node: s, offset: o };
      if (s.nodeType == 1 && o > 0) (s = s.childNodes[o - 1]), (o = maxOffset(s));
      else break;
    }
  if (n >= 0)
    for (let s = r, o = e; ; ) {
      if (s.nodeType == 3) return { node: s, offset: o };
      if (s.nodeType == 1 && o < s.childNodes.length && n >= 0) (s = s.childNodes[o]), (o = 0);
      else break;
    }
  return null;
}
function nextToUneditable(r, e) {
  return r.nodeType != 1
    ? 0
    : (e && r.childNodes[e - 1].contentEditable == 'false' ? 1 : 0) |
        (e < r.childNodes.length && r.childNodes[e].contentEditable == 'false' ? 2 : 0);
}
let DecorationComparator$1 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    addRange(e, n, this.changes);
  }
  comparePoint(e, n) {
    addRange(e, n, this.changes);
  }
};
function findChangedDeco(r, e, n) {
  let s = new DecorationComparator$1();
  return RangeSet.compare(r, e, n, s), s.changes;
}
function inUneditable(r, e) {
  for (let n = r; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == 'false') return !0;
  return !1;
}
function touchesComposition(r, e) {
  let n = !1;
  return (
    e &&
      r.iterChangedRanges((s, o) => {
        s < e.to && o > e.from && (n = !0);
      }),
    n
  );
}
function groupAt(r, e, n = 1) {
  let s = r.charCategorizer(e),
    o = r.doc.lineAt(e),
    a = e - o.from;
  if (o.length == 0) return EditorSelection.cursor(e);
  a == 0 ? (n = 1) : a == o.length && (n = -1);
  let l = a,
    f = a;
  n < 0 ? (l = findClusterBreak(o.text, a, !1)) : (f = findClusterBreak(o.text, a));
  let m = s(o.text.slice(l, f));
  for (; l > 0; ) {
    let v = findClusterBreak(o.text, l, !1);
    if (s(o.text.slice(v, l)) != m) break;
    l = v;
  }
  for (; f < o.length; ) {
    let v = findClusterBreak(o.text, f);
    if (s(o.text.slice(f, v)) != m) break;
    f = v;
  }
  return EditorSelection.range(l + o.from, f + o.from);
}
function getdx(r, e) {
  return e.left > r ? e.left - r : Math.max(0, r - e.right);
}
function getdy(r, e) {
  return e.top > r ? e.top - r : Math.max(0, r - e.bottom);
}
function yOverlap(r, e) {
  return r.top < e.bottom - 1 && r.bottom > e.top + 1;
}
function upTop(r, e) {
  return e < r.top ? { top: e, left: r.left, right: r.right, bottom: r.bottom } : r;
}
function upBot(r, e) {
  return e > r.bottom ? { top: r.top, left: r.left, right: r.right, bottom: e } : r;
}
function domPosAtCoords(r, e, n) {
  let s,
    o,
    a,
    l,
    f = !1,
    m,
    v,
    I,
    L;
  for (let Ee = r.firstChild; Ee; Ee = Ee.nextSibling) {
    let ht = clientRectsFor(Ee);
    for (let ar = 0; ar < ht.length; ar++) {
      let $i = ht[ar];
      o && yOverlap(o, $i) && ($i = upTop(upBot($i, o.bottom), o.top));
      let tl = getdx(e, $i),
        Wi = getdy(n, $i);
      if (tl == 0 && Wi == 0) return Ee.nodeType == 3 ? domPosInText(Ee, e, n) : domPosAtCoords(Ee, e, n);
      if (!s || l > Wi || (l == Wi && a > tl)) {
        (s = Ee), (o = $i), (a = tl), (l = Wi);
        let hl = Wi ? (n < $i.top ? -1 : 1) : tl ? (e < $i.left ? -1 : 1) : 0;
        f = !hl || (hl > 0 ? ar < ht.length - 1 : ar > 0);
      }
      tl == 0
        ? n > $i.bottom && (!I || I.bottom < $i.bottom)
          ? ((m = Ee), (I = $i))
          : n < $i.top && (!L || L.top > $i.top) && ((v = Ee), (L = $i))
        : I && yOverlap(I, $i)
        ? (I = upBot(I, $i.bottom))
        : L && yOverlap(L, $i) && (L = upTop(L, $i.top));
    }
  }
  if ((I && I.bottom >= n ? ((s = m), (o = I)) : L && L.top <= n && ((s = v), (o = L)), !s))
    return { node: r, offset: 0 };
  let V = Math.max(o.left, Math.min(o.right, e));
  if (s.nodeType == 3) return domPosInText(s, V, n);
  if (f && s.contentEditable != 'false') return domPosAtCoords(s, V, n);
  let se = Array.prototype.indexOf.call(r.childNodes, s) + (e >= (o.left + o.right) / 2 ? 1 : 0);
  return { node: r, offset: se };
}
function domPosInText(r, e, n) {
  let s = r.nodeValue.length,
    o = -1,
    a = 1e9,
    l = 0;
  for (let f = 0; f < s; f++) {
    let m = textRange(r, f, f + 1).getClientRects();
    for (let v = 0; v < m.length; v++) {
      let I = m[v];
      if (I.top == I.bottom) continue;
      l || (l = e - I.left);
      let L = (I.top > n ? I.top - n : n - I.bottom) - 1;
      if (I.left - 1 <= e && I.right + 1 >= e && L < a) {
        let V = e >= (I.left + I.right) / 2,
          se = V;
        if (
          ((browser.chrome || browser.gecko) && textRange(r, f).getBoundingClientRect().left == I.right && (se = !V),
          L <= 0)
        )
          return { node: r, offset: f + (se ? 1 : 0) };
        (o = f + (se ? 1 : 0)), (a = L);
      }
    }
  }
  return { node: r, offset: o > -1 ? o : l > 0 ? r.nodeValue.length : 0 };
}
function posAtCoords(r, e, n, s = -1) {
  var o, a;
  let l = r.contentDOM.getBoundingClientRect(),
    f = l.top + r.viewState.paddingTop,
    m,
    { docHeight: v } = r.viewState,
    { x: I, y: L } = e,
    V = L - f;
  if (V < 0) return 0;
  if (V > v) return r.state.doc.length;
  for (
    let hl = r.viewState.heightOracle.textHeight / 2, fl = !1;
    (m = r.elementAtHeight(V)), m.type != BlockType.Text;

  )
    for (; (V = s > 0 ? m.bottom + hl : m.top - hl), !(V >= 0 && V <= v); ) {
      if (fl) return n ? null : 0;
      (fl = !0), (s = -s);
    }
  L = f + V;
  let se = m.from;
  if (se < r.viewport.from) return r.viewport.from == 0 ? 0 : n ? null : posAtCoordsImprecise(r, l, m, I, L);
  if (se > r.viewport.to)
    return r.viewport.to == r.state.doc.length ? r.state.doc.length : n ? null : posAtCoordsImprecise(r, l, m, I, L);
  let Ee = r.dom.ownerDocument,
    ht = r.root.elementFromPoint ? r.root : Ee,
    ar = ht.elementFromPoint(I, L);
  ar && !r.contentDOM.contains(ar) && (ar = null),
    ar ||
      ((I = Math.max(l.left + 1, Math.min(l.right - 1, I))),
      (ar = ht.elementFromPoint(I, L)),
      ar && !r.contentDOM.contains(ar) && (ar = null));
  let $i,
    tl = -1;
  if (ar && ((o = r.docView.nearest(ar)) === null || o === void 0 ? void 0 : o.isEditable) != !1) {
    if (Ee.caretPositionFromPoint) {
      let hl = Ee.caretPositionFromPoint(I, L);
      hl && ({ offsetNode: $i, offset: tl } = hl);
    } else if (Ee.caretRangeFromPoint) {
      let hl = Ee.caretRangeFromPoint(I, L);
      hl &&
        (({ startContainer: $i, startOffset: tl } = hl),
        (!r.contentDOM.contains($i) ||
          (browser.safari && isSuspiciousSafariCaretResult($i, tl, I)) ||
          (browser.chrome && isSuspiciousChromeCaretResult($i, tl, I))) &&
          ($i = void 0));
    }
  }
  if (!$i || !r.docView.dom.contains($i)) {
    let hl = LineView.find(r.docView, se);
    if (!hl) return V > m.top + m.height / 2 ? m.to : m.from;
    ({ node: $i, offset: tl } = domPosAtCoords(hl.dom, I, L));
  }
  let Wi = r.docView.nearest($i);
  if (!Wi) return null;
  if (Wi.isWidget && ((a = Wi.dom) === null || a === void 0 ? void 0 : a.nodeType) == 1) {
    let hl = Wi.dom.getBoundingClientRect();
    return e.y < hl.top || (e.y <= hl.bottom && e.x <= (hl.left + hl.right) / 2) ? Wi.posAtStart : Wi.posAtEnd;
  } else return Wi.localPosFromDOM($i, tl) + Wi.posAtStart;
}
function posAtCoordsImprecise(r, e, n, s, o) {
  let a = Math.round((s - e.left) * r.defaultCharacterWidth);
  if (r.lineWrapping && n.height > r.defaultLineHeight * 1.5) {
    let f = r.viewState.heightOracle.textHeight,
      m = Math.floor((o - n.top - (r.defaultLineHeight - f) * 0.5) / f);
    a += m * r.viewState.heightOracle.lineLength;
  }
  let l = r.state.sliceDoc(n.from, n.to);
  return n.from + findColumn(l, a, r.state.tabSize);
}
function isSuspiciousSafariCaretResult(r, e, n) {
  let s;
  if (r.nodeType != 3 || e != (s = r.nodeValue.length)) return !1;
  for (let o = r.nextSibling; o; o = o.nextSibling) if (o.nodeType != 1 || o.nodeName != 'BR') return !1;
  return textRange(r, s - 1, s).getBoundingClientRect().left > n;
}
function isSuspiciousChromeCaretResult(r, e, n) {
  if (e != 0) return !1;
  for (let o = r; ; ) {
    let a = o.parentNode;
    if (!a || a.nodeType != 1 || a.firstChild != o) return !1;
    if (a.classList.contains('cm-line')) break;
    o = a;
  }
  let s =
    r.nodeType == 1
      ? r.getBoundingClientRect()
      : textRange(r, 0, Math.max(r.nodeValue.length, 1)).getBoundingClientRect();
  return n - s.left > 5;
}
function blockAt(r, e) {
  let n = r.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let s of n.type) if (s.to > e || (s.to == e && (s.to == n.to || s.type == BlockType.Text))) return s;
  }
  return n;
}
function moveToLineBoundary(r, e, n, s) {
  let o = blockAt(r, e.head),
    a =
      !s || o.type != BlockType.Text || !(r.lineWrapping || o.widgetLineBreaks)
        ? null
        : r.coordsAtPos(e.assoc < 0 && e.head > o.from ? e.head - 1 : e.head);
  if (a) {
    let l = r.dom.getBoundingClientRect(),
      f = r.textDirectionAt(o.from),
      m = r.posAtCoords({ x: n == (f == Direction.LTR) ? l.right - 1 : l.left + 1, y: (a.top + a.bottom) / 2 });
    if (m != null) return EditorSelection.cursor(m, n ? -1 : 1);
  }
  return EditorSelection.cursor(n ? o.to : o.from, n ? -1 : 1);
}
function moveByChar(r, e, n, s) {
  let o = r.state.doc.lineAt(e.head),
    a = r.bidiSpans(o),
    l = r.textDirectionAt(o.from);
  for (let f = e, m = null; ; ) {
    let v = moveVisually(o, a, l, f, n),
      I = movedOver;
    if (!v) {
      if (o.number == (n ? r.state.doc.lines : 1)) return f;
      (I = `
`),
        (o = r.state.doc.line(o.number + (n ? 1 : -1))),
        (a = r.bidiSpans(o)),
        (v = EditorSelection.cursor(n ? o.from : o.to));
    }
    if (m) {
      if (!m(I)) return f;
    } else {
      if (!s) return v;
      m = s(I);
    }
    f = v;
  }
}
function byGroup(r, e, n) {
  let s = r.state.charCategorizer(e),
    o = s(n);
  return (a) => {
    let l = s(a);
    return o == CharCategory.Space && (o = l), o == l;
  };
}
function moveVertically(r, e, n, s) {
  let o = e.head,
    a = n ? 1 : -1;
  if (o == (n ? r.state.doc.length : 0)) return EditorSelection.cursor(o, e.assoc);
  let l = e.goalColumn,
    f,
    m = r.contentDOM.getBoundingClientRect(),
    v = r.coordsAtPos(o, e.assoc || -1),
    I = r.documentTop;
  if (v) l == null && (l = v.left - m.left), (f = a < 0 ? v.top : v.bottom);
  else {
    let se = r.viewState.lineBlockAt(o);
    l == null && (l = Math.min(m.right - m.left, r.defaultCharacterWidth * (o - se.from))),
      (f = (a < 0 ? se.top : se.bottom) + I);
  }
  let L = m.left + l,
    V = s ?? r.viewState.heightOracle.textHeight >> 1;
  for (let se = 0; ; se += 10) {
    let Ee = f + (V + se) * a,
      ht = posAtCoords(r, { x: L, y: Ee }, !1, a);
    if (Ee < m.top || Ee > m.bottom || (a < 0 ? ht < o : ht > o)) {
      let ar = r.docView.coordsForChar(ht),
        $i = !ar || Ee < ar.top ? -1 : 1;
      return EditorSelection.cursor(ht, $i, void 0, l);
    }
  }
}
function skipAtomicRanges(r, e, n) {
  for (;;) {
    let s = 0;
    for (let o of r)
      o.between(e - 1, e + 1, (a, l, f) => {
        if (e > a && e < l) {
          let m = s || n || (e - a < l - e ? -1 : 1);
          (e = m < 0 ? a : l), (s = m);
        }
      });
    if (!s) return e;
  }
}
function skipAtoms(r, e, n) {
  let s = skipAtomicRanges(
    r.state.facet(atomicRanges).map((o) => o(r)),
    n.from,
    e.head > n.from ? -1 : 1,
  );
  return s == n.from ? n : EditorSelection.cursor(s, s < n.from ? 1 : -1);
}
class InputState {
  setSelectionOrigin(e) {
    (this.lastSelectionOrigin = e), (this.lastSelectionTime = Date.now());
  }
  constructor(e) {
    (this.view = e),
      (this.lastKeyCode = 0),
      (this.lastKeyTime = 0),
      (this.lastTouchTime = 0),
      (this.lastFocusTime = 0),
      (this.lastScrollTop = 0),
      (this.lastScrollLeft = 0),
      (this.pendingIOSKey = void 0),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastEscPress = 0),
      (this.lastContextMenu = 0),
      (this.scrollHandlers = []),
      (this.handlers = Object.create(null)),
      (this.composing = -1),
      (this.compositionFirstChange = null),
      (this.compositionEndedAt = 0),
      (this.compositionPendingKey = !1),
      (this.compositionPendingChange = !1),
      (this.mouseSelection = null),
      (this.handleEvent = this.handleEvent.bind(this)),
      e.scrollDOM.addEventListener('mousedown', (n) => {
        if (
          n.target == e.scrollDOM &&
          n.clientY > e.contentDOM.getBoundingClientRect().bottom &&
          (this.runHandlers('mousedown', n), !n.defaultPrevented && n.button == 2)
        ) {
          let s = e.contentDOM.style.minHeight;
          (e.contentDOM.style.minHeight = '100%'), setTimeout(() => (e.contentDOM.style.minHeight = s), 200);
        }
      }),
      e.scrollDOM.addEventListener('drop', (n) => {
        n.target == e.scrollDOM &&
          n.clientY > e.contentDOM.getBoundingClientRect().bottom &&
          this.runHandlers('drop', n);
      }),
      (this.notifiedFocused = e.hasFocus),
      browser.safari && e.contentDOM.addEventListener('input', () => null),
      browser.gecko && firefoxCopyCutHack(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !eventBelongsToEditor(this.view, e) ||
      this.ignoreDuringComposition(e) ||
      (e.type == 'keydown' && this.keydown(e)) ||
      this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let s = this.handlers[e];
    if (s) {
      for (let o of s.observers) o(this.view, n);
      for (let o of s.handlers) {
        if (n.defaultPrevented) break;
        if (o(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = computeHandlers(e),
      s = this.handlers,
      o = this.view.contentDOM;
    for (let a in n)
      if (a != 'scroll') {
        let l = !n[a].handlers.length,
          f = s[a];
        f && l != !f.handlers.length && (o.removeEventListener(a, this.handleEvent), (f = null)),
          f || o.addEventListener(a, this.handleEvent, { passive: l });
      }
    for (let a in s) a != 'scroll' && !n[a] && o.removeEventListener(a, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (
      ((this.lastKeyCode = e.keyCode),
      (this.lastKeyTime = Date.now()),
      e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
    )
      return !0;
    if (
      (e.keyCode != 27 && modifierCodes.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0),
      browser.android && browser.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
    )
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return browser.ios &&
      !e.synthetic &&
      !e.altKey &&
      !e.metaKey &&
      (((n = PendingKeys.find((s) => s.keyCode == e.keyCode)) && !e.ctrlKey) ||
        (EmacsyPendingKeys.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey))
      ? ((this.pendingIOSKey = n || e), setTimeout(() => this.flushIOSKey(), 250), !0)
      : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? ((this.pendingIOSKey = void 0), dispatchKey(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type)
      ? this.composing > 0
        ? !0
        : browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100
        ? ((this.compositionPendingKey = !1), !0)
        : !1
      : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), (this.mouseSelection = e);
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e),
      e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function bindHandler(r, e) {
  return (n, s) => {
    try {
      return e.call(r, s, n);
    } catch (o) {
      logException(n.state, o);
    }
  };
}
function computeHandlers(r) {
  let e = Object.create(null);
  function n(s) {
    return e[s] || (e[s] = { observers: [], handlers: [] });
  }
  for (let s of r) {
    let o = s.spec;
    if (o && o.domEventHandlers)
      for (let a in o.domEventHandlers) {
        let l = o.domEventHandlers[a];
        l && n(a).handlers.push(bindHandler(s.value, l));
      }
    if (o && o.domEventObservers)
      for (let a in o.domEventObservers) {
        let l = o.domEventObservers[a];
        l && n(a).observers.push(bindHandler(s.value, l));
      }
  }
  for (let s in handlers) n(s).handlers.push(handlers[s]);
  for (let s in observers) n(s).observers.push(observers[s]);
  return e;
}
const PendingKeys = [
    { key: 'Backspace', keyCode: 8, inputType: 'deleteContentBackward' },
    { key: 'Enter', keyCode: 13, inputType: 'insertParagraph' },
    { key: 'Enter', keyCode: 13, inputType: 'insertLineBreak' },
    { key: 'Delete', keyCode: 46, inputType: 'deleteContentForward' },
  ],
  EmacsyPendingKeys = 'dthko',
  modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225],
  dragScrollMargin = 6;
function dragScrollSpeed(r) {
  return Math.max(0, r) * 0.7 + 8;
}
function dist(r, e) {
  return Math.max(Math.abs(r.clientX - e.clientX), Math.abs(r.clientY - e.clientY));
}
class MouseSelection {
  constructor(e, n, s, o) {
    (this.view = e),
      (this.startEvent = n),
      (this.style = s),
      (this.mustSelect = o),
      (this.scrollSpeed = { x: 0, y: 0 }),
      (this.scrolling = -1),
      (this.lastEvent = n),
      (this.scrollParent = scrollableParent(e.contentDOM)),
      (this.atoms = e.state.facet(atomicRanges).map((l) => l(e)));
    let a = e.contentDOM.ownerDocument;
    a.addEventListener('mousemove', (this.move = this.move.bind(this))),
      a.addEventListener('mouseup', (this.up = this.up.bind(this))),
      (this.extend = n.shiftKey),
      (this.multiple = e.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(e, n)),
      (this.dragging = isInPrimarySelection(e, n) && getClickType(n) == 1 ? null : !1);
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var n;
    if (e.buttons == 0) return this.destroy();
    if (this.dragging || (this.dragging == null && dist(this.startEvent, e) < 10)) return;
    this.select((this.lastEvent = e));
    let s = 0,
      o = 0,
      a = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || {
        left: 0,
        top: 0,
        right: this.view.win.innerWidth,
        bottom: this.view.win.innerHeight,
      },
      l = getScrollMargins(this.view);
    e.clientX - l.left <= a.left + dragScrollMargin
      ? (s = -dragScrollSpeed(a.left - e.clientX))
      : e.clientX + l.right >= a.right - dragScrollMargin && (s = dragScrollSpeed(e.clientX - a.right)),
      e.clientY - l.top <= a.top + dragScrollMargin
        ? (o = -dragScrollSpeed(a.top - e.clientY))
        : e.clientY + l.bottom >= a.bottom - dragScrollMargin && (o = dragScrollSpeed(e.clientY - a.bottom)),
      this.setScrollSpeed(s, o);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener('mousemove', this.move),
      e.removeEventListener('mouseup', this.up),
      (this.view.inputState.mouseSelection = null);
  }
  setScrollSpeed(e, n) {
    (this.scrollSpeed = { x: e, y: n }),
      e || n
        ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50))
        : this.scrolling > -1 && (clearInterval(this.scrolling), (this.scrolling = -1));
  }
  scroll() {
    this.scrollParent
      ? ((this.scrollParent.scrollLeft += this.scrollSpeed.x), (this.scrollParent.scrollTop += this.scrollSpeed.y))
      : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
      this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let s = 0; s < e.ranges.length; s++) {
      let o = e.ranges[s],
        a = null;
      if (o.empty) {
        let l = skipAtomicRanges(this.atoms, o.from, 0);
        l != o.from && (a = EditorSelection.cursor(l, -1));
      } else {
        let l = skipAtomicRanges(this.atoms, o.from, -1),
          f = skipAtomicRanges(this.atoms, o.to, 1);
        (l != o.from || f != o.to) && (a = EditorSelection.range(o.from == o.anchor ? l : f, o.from == o.head ? l : f));
      }
      a && (n || (n = e.ranges.slice()), (n[s] = a));
    }
    return n ? EditorSelection.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this,
      s = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect ||
      !s.eq(n.state.selection) ||
      (s.main.assoc != n.state.selection.main.assoc && this.dragging === !1)) &&
      this.view.dispatch({ selection: s, userEvent: 'select.pointer' }),
      (this.mustSelect = !1);
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)),
      this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(r, e) {
  let n = r.state.facet(clickAddsSelectionRange);
  return n.length ? n[0](e) : browser.mac ? e.metaKey : e.ctrlKey;
}
function dragMovesSelection(r, e) {
  let n = r.state.facet(dragMovesSelection$1);
  return n.length ? n[0](e) : browser.mac ? !e.altKey : !e.ctrlKey;
}
function isInPrimarySelection(r, e) {
  let { main: n } = r.state.selection;
  if (n.empty) return !1;
  let s = getSelection(r.root);
  if (!s || s.rangeCount == 0) return !0;
  let o = s.getRangeAt(0).getClientRects();
  for (let a = 0; a < o.length; a++) {
    let l = o[a];
    if (l.left <= e.clientX && l.right >= e.clientX && l.top <= e.clientY && l.bottom >= e.clientY) return !0;
  }
  return !1;
}
function eventBelongsToEditor(r, e) {
  if (!e.bubbles) return !0;
  if (e.defaultPrevented) return !1;
  for (let n = e.target, s; n != r.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || ((s = ContentView.get(n)) && s.ignoreEvent(e))) return !1;
  return !0;
}
const handlers = Object.create(null),
  observers = Object.create(null),
  brokenClipboardAPI = (browser.ie && browser.ie_version < 15) || (browser.ios && browser.webkit_version < 604);
function capturePaste(r) {
  let e = r.dom.parentNode;
  if (!e) return;
  let n = e.appendChild(document.createElement('textarea'));
  (n.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    n.focus(),
    setTimeout(() => {
      r.focus(), n.remove(), doPaste(r, n.value);
    }, 50);
}
function doPaste(r, e) {
  let { state: n } = r,
    s,
    o = 1,
    a = n.toText(e),
    l = a.lines == n.selection.ranges.length;
  if (lastLinewiseCopy != null && n.selection.ranges.every((m) => m.empty) && lastLinewiseCopy == a.toString()) {
    let m = -1;
    s = n.changeByRange((v) => {
      let I = n.doc.lineAt(v.from);
      if (I.from == m) return { range: v };
      m = I.from;
      let L = n.toText((l ? a.line(o++).text : e) + n.lineBreak);
      return { changes: { from: I.from, insert: L }, range: EditorSelection.cursor(v.from + L.length) };
    });
  } else
    l
      ? (s = n.changeByRange((m) => {
          let v = a.line(o++);
          return {
            changes: { from: m.from, to: m.to, insert: v.text },
            range: EditorSelection.cursor(m.from + v.length),
          };
        }))
      : (s = n.replaceSelection(a));
  r.dispatch(s, { userEvent: 'input.paste', scrollIntoView: !0 });
}
observers.scroll = (r) => {
  (r.inputState.lastScrollTop = r.scrollDOM.scrollTop), (r.inputState.lastScrollLeft = r.scrollDOM.scrollLeft);
};
handlers.keydown = (r, e) => (
  r.inputState.setSelectionOrigin('select'), e.keyCode == 27 && (r.inputState.lastEscPress = Date.now()), !1
);
observers.touchstart = (r, e) => {
  (r.inputState.lastTouchTime = Date.now()), r.inputState.setSelectionOrigin('select.pointer');
};
observers.touchmove = (r) => {
  r.inputState.setSelectionOrigin('select.pointer');
};
handlers.mousedown = (r, e) => {
  if ((r.observer.flush(), r.inputState.lastTouchTime > Date.now() - 2e3)) return !1;
  let n = null;
  for (let s of r.state.facet(mouseSelectionStyle)) if (((n = s(r, e)), n)) break;
  if ((!n && e.button == 0 && (n = basicMouseSelection(r, e)), n)) {
    let s = !r.hasFocus;
    r.inputState.startMouseSelection(new MouseSelection(r, e, n, s)),
      s && r.observer.ignore(() => focusPreventScroll(r.contentDOM));
    let o = r.inputState.mouseSelection;
    if (o) return o.start(e), o.dragging === !1;
  }
  return !1;
};
function rangeForClick(r, e, n, s) {
  if (s == 1) return EditorSelection.cursor(e, n);
  if (s == 2) return groupAt(r.state, e, n);
  {
    let o = LineView.find(r.docView, e),
      a = r.state.doc.lineAt(o ? o.posAtEnd : e),
      l = o ? o.posAtStart : a.from,
      f = o ? o.posAtEnd : a.to;
    return f < r.state.doc.length && f == a.to && f++, EditorSelection.range(l, f);
  }
}
let insideY = (r, e) => r >= e.top && r <= e.bottom,
  inside = (r, e, n) => insideY(e, n) && r >= n.left && r <= n.right;
function findPositionSide(r, e, n, s) {
  let o = LineView.find(r.docView, e);
  if (!o) return 1;
  let a = e - o.posAtStart;
  if (a == 0) return 1;
  if (a == o.length) return -1;
  let l = o.coordsAt(a, -1);
  if (l && inside(n, s, l)) return -1;
  let f = o.coordsAt(a, 1);
  return f && inside(n, s, f) ? 1 : l && insideY(s, l) ? -1 : 1;
}
function queryPos(r, e) {
  let n = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: findPositionSide(r, n, e.clientX, e.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null,
  lastMouseDownCount = 0,
  lastMouseDownTime = 0;
function getClickType(r) {
  if (!BadMouseDetail) return r.detail;
  let e = lastMouseDown,
    n = lastMouseDownTime;
  return (
    (lastMouseDown = r),
    (lastMouseDownTime = Date.now()),
    (lastMouseDownCount =
      !e || (n > Date.now() - 400 && Math.abs(e.clientX - r.clientX) < 2 && Math.abs(e.clientY - r.clientY) < 2)
        ? (lastMouseDownCount + 1) % 3
        : 1)
  );
}
function basicMouseSelection(r, e) {
  let n = queryPos(r, e),
    s = getClickType(e),
    o = r.state.selection;
  return {
    update(a) {
      a.docChanged && ((n.pos = a.changes.mapPos(n.pos)), (o = o.map(a.changes)));
    },
    get(a, l, f) {
      let m = queryPos(r, a),
        v,
        I = rangeForClick(r, m.pos, m.bias, s);
      if (n.pos != m.pos && !l) {
        let L = rangeForClick(r, n.pos, n.bias, s),
          V = Math.min(L.from, I.from),
          se = Math.max(L.to, I.to);
        I = V < I.from ? EditorSelection.range(V, se) : EditorSelection.range(se, V);
      }
      return l
        ? o.replaceRange(o.main.extend(I.from, I.to))
        : f && s == 1 && o.ranges.length > 1 && (v = removeRangeAround(o, m.pos))
        ? v
        : f
        ? o.addRange(I)
        : EditorSelection.create([I]);
    },
  };
}
function removeRangeAround(r, e) {
  for (let n = 0; n < r.ranges.length; n++) {
    let { from: s, to: o } = r.ranges[n];
    if (s <= e && o >= e)
      return EditorSelection.create(
        r.ranges.slice(0, n).concat(r.ranges.slice(n + 1)),
        r.mainIndex == n ? 0 : r.mainIndex - (r.mainIndex > n ? 1 : 0),
      );
  }
  return null;
}
handlers.dragstart = (r, e) => {
  let {
      selection: { main: n },
    } = r.state,
    { mouseSelection: s } = r.inputState;
  return (
    s && (s.dragging = n),
    e.dataTransfer &&
      (e.dataTransfer.setData('Text', r.state.sliceDoc(n.from, n.to)), (e.dataTransfer.effectAllowed = 'copyMove')),
    !1
  );
};
function dropText(r, e, n, s) {
  if (!n) return;
  let o = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    { mouseSelection: a } = r.inputState,
    l = s && a && a.dragging && dragMovesSelection(r, e) ? { from: a.dragging.from, to: a.dragging.to } : null,
    f = { from: o, insert: n },
    m = r.state.changes(l ? [l, f] : f);
  r.focus(),
    r.dispatch({
      changes: m,
      selection: { anchor: m.mapPos(o, -1), head: m.mapPos(o, 1) },
      userEvent: l ? 'move.drop' : 'input.drop',
    });
}
handlers.drop = (r, e) => {
  if (!e.dataTransfer) return !1;
  if (r.state.readOnly) return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let s = Array(n.length),
      o = 0,
      a = () => {
        ++o == n.length && dropText(r, e, s.filter((l) => l != null).join(r.state.lineBreak), !1);
      };
    for (let l = 0; l < n.length; l++) {
      let f = new FileReader();
      (f.onerror = a),
        (f.onload = () => {
          /[\x00-\x08\x0e-\x1f]{2}/.test(f.result) || (s[l] = f.result), a();
        }),
        f.readAsText(n[l]);
    }
    return !0;
  } else {
    let s = e.dataTransfer.getData('Text');
    if (s) return dropText(r, e, s, !0), !0;
  }
  return !1;
};
handlers.paste = (r, e) => {
  if (r.state.readOnly) return !0;
  r.observer.flush();
  let n = brokenClipboardAPI ? null : e.clipboardData;
  return n ? (doPaste(r, n.getData('text/plain') || n.getData('text/uri-text')), !0) : (capturePaste(r), !1);
};
function captureCopy(r, e) {
  let n = r.dom.parentNode;
  if (!n) return;
  let s = n.appendChild(document.createElement('textarea'));
  (s.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    (s.value = e),
    s.focus(),
    (s.selectionEnd = e.length),
    (s.selectionStart = 0),
    setTimeout(() => {
      s.remove(), r.focus();
    }, 50);
}
function copiedRange(r) {
  let e = [],
    n = [],
    s = !1;
  for (let o of r.selection.ranges) o.empty || (e.push(r.sliceDoc(o.from, o.to)), n.push(o));
  if (!e.length) {
    let o = -1;
    for (let { from: a } of r.selection.ranges) {
      let l = r.doc.lineAt(a);
      l.number > o && (e.push(l.text), n.push({ from: l.from, to: Math.min(r.doc.length, l.to + 1) })), (o = l.number);
    }
    s = !0;
  }
  return { text: e.join(r.lineBreak), ranges: n, linewise: s };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (r, e) => {
  let { text: n, ranges: s, linewise: o } = copiedRange(r.state);
  if (!n && !o) return !1;
  (lastLinewiseCopy = o ? n : null),
    e.type == 'cut' && !r.state.readOnly && r.dispatch({ changes: s, scrollIntoView: !0, userEvent: 'delete.cut' });
  let a = brokenClipboardAPI ? null : e.clipboardData;
  return a ? (a.clearData(), a.setData('text/plain', n), !0) : (captureCopy(r, n), !1);
};
const isFocusChange = Annotation.define();
function focusChangeTransaction(r, e) {
  let n = [];
  for (let s of r.facet(focusChangeEffect)) {
    let o = s(r, e);
    o && n.push(o);
  }
  return n ? r.update({ effects: n, annotations: isFocusChange.of(!0) }) : null;
}
function updateForFocusChange(r) {
  setTimeout(() => {
    let e = r.hasFocus;
    if (e != r.inputState.notifiedFocused) {
      let n = focusChangeTransaction(r.state, e);
      n ? r.dispatch(n) : r.update([]);
    }
  }, 10);
}
observers.focus = (r) => {
  (r.inputState.lastFocusTime = Date.now()),
    !r.scrollDOM.scrollTop &&
      (r.inputState.lastScrollTop || r.inputState.lastScrollLeft) &&
      ((r.scrollDOM.scrollTop = r.inputState.lastScrollTop), (r.scrollDOM.scrollLeft = r.inputState.lastScrollLeft)),
    updateForFocusChange(r);
};
observers.blur = (r) => {
  r.observer.clearSelectionRange(), updateForFocusChange(r);
};
observers.compositionstart = observers.compositionupdate = (r) => {
  r.inputState.compositionFirstChange == null && (r.inputState.compositionFirstChange = !0),
    r.inputState.composing < 0 && (r.inputState.composing = 0);
};
observers.compositionend = (r) => {
  (r.inputState.composing = -1),
    (r.inputState.compositionEndedAt = Date.now()),
    (r.inputState.compositionPendingKey = !0),
    (r.inputState.compositionPendingChange = r.observer.pendingRecords().length > 0),
    (r.inputState.compositionFirstChange = null),
    browser.chrome && browser.android
      ? r.observer.flushSoon()
      : r.inputState.compositionPendingChange
      ? Promise.resolve().then(() => r.observer.flush())
      : setTimeout(() => {
          r.inputState.composing < 0 && r.docView.hasComposition && r.update([]);
        }, 50);
};
observers.contextmenu = (r) => {
  r.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (r, e) => {
  var n;
  let s;
  if (
    browser.chrome &&
    browser.android &&
    (s = PendingKeys.find((o) => o.inputType == e.inputType)) &&
    (r.observer.delayAndroidKey(s.key, s.keyCode), s.key == 'Backspace' || s.key == 'Delete')
  ) {
    let o = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > o + 10 &&
        r.hasFocus &&
        (r.contentDOM.blur(), r.focus());
    }, 100);
  }
  return !1;
};
const appliedFirefoxHack = new Set();
function firefoxCopyCutHack(r) {
  appliedFirefoxHack.has(r) ||
    (appliedFirefoxHack.add(r), r.addEventListener('copy', () => {}), r.addEventListener('cut', () => {}));
}
const wrappingWhiteSpace = ['pre-wrap', 'normal', 'pre-line', 'break-spaces'];
class HeightOracle {
  constructor(e) {
    (this.lineWrapping = e),
      (this.doc = Text.empty),
      (this.heightSamples = {}),
      (this.lineHeight = 14),
      (this.charWidth = 7),
      (this.textHeight = 14),
      (this.lineLength = 30),
      (this.heightChanged = !1);
  }
  heightForGap(e, n) {
    let s = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return (
      this.lineWrapping && (s += Math.max(0, Math.ceil((n - e - s * this.lineLength * 0.5) / this.lineLength))),
      this.lineHeight * s
    );
  }
  heightForLine(e) {
    return this.lineWrapping
      ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight
      : this.lineHeight;
  }
  setDoc(e) {
    return (this.doc = e), this;
  }
  mustRefreshForWrapping(e) {
    return wrappingWhiteSpace.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      o < 0 ? s++ : this.heightSamples[Math.floor(o * 10)] || ((n = !0), (this.heightSamples[Math.floor(o * 10)] = !0));
    }
    return n;
  }
  refresh(e, n, s, o, a, l) {
    let f = wrappingWhiteSpace.indexOf(e) > -1,
      m = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != f;
    if (
      ((this.lineWrapping = f),
      (this.lineHeight = n),
      (this.charWidth = s),
      (this.textHeight = o),
      (this.lineLength = a),
      m)
    ) {
      this.heightSamples = {};
      for (let v = 0; v < l.length; v++) {
        let I = l[v];
        I < 0 ? v++ : (this.heightSamples[Math.floor(I * 10)] = !0);
      }
    }
    return m;
  }
}
class MeasuredHeights {
  constructor(e, n) {
    (this.from = e), (this.heights = n), (this.index = 0);
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  constructor(e, n, s, o, a) {
    (this.from = e), (this.length = n), (this.top = s), (this.height = o), (this._content = a);
  }
  get type() {
    return typeof this._content == 'number'
      ? BlockType.Text
      : Array.isArray(this._content)
      ? this._content
      : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == 'number' ? this._content : 0;
  }
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(
      Array.isArray(e._content) ? e._content : [e],
    );
    return new BlockInfo(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var QueryType$1 = (function (r) {
  return (
    (r[(r.ByPos = 0)] = 'ByPos'), (r[(r.ByHeight = 1)] = 'ByHeight'), (r[(r.ByPosNoHeight = 2)] = 'ByPosNoHeight'), r
  );
})(QueryType$1 || (QueryType$1 = {}));
const Epsilon = 0.001;
class HeightMap {
  constructor(e, n, s = 2) {
    (this.length = e), (this.height = n), (this.flags = s);
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | (this.flags & -3);
  }
  setHeight(e, n) {
    this.height != n && (Math.abs(this.height - n) > Epsilon && (e.heightChanged = !0), (this.height = n));
  }
  replace(e, n, s) {
    return HeightMap.of(s);
  }
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, s, o) {
    let a = this,
      l = s.doc;
    for (let f = o.length - 1; f >= 0; f--) {
      let { fromA: m, toA: v, fromB: I, toB: L } = o[f],
        V = a.lineAt(m, QueryType$1.ByPosNoHeight, s.setDoc(n), 0, 0),
        se = V.to >= v ? V : a.lineAt(v, QueryType$1.ByPosNoHeight, s, 0, 0);
      for (L += se.to - v, v = se.to; f > 0 && V.from <= o[f - 1].toA; )
        (m = o[f - 1].fromA),
          (I = o[f - 1].fromB),
          f--,
          m < V.from && (V = a.lineAt(m, QueryType$1.ByPosNoHeight, s, 0, 0));
      (I += V.from - m), (m = V.from);
      let Ee = NodeBuilder.build(s.setDoc(l), e, I, L);
      a = a.replace(m, v, Ee);
    }
    return a.updateHeight(s, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  static of(e) {
    if (e.length == 1) return e[0];
    let n = 0,
      s = e.length,
      o = 0,
      a = 0;
    for (;;)
      if (n == s)
        if (o > a * 2) {
          let f = e[n - 1];
          f.break ? e.splice(--n, 1, f.left, null, f.right) : e.splice(--n, 1, f.left, f.right),
            (s += 1 + f.break),
            (o -= f.size);
        } else if (a > o * 2) {
          let f = e[s];
          f.break ? e.splice(s, 1, f.left, null, f.right) : e.splice(s, 1, f.left, f.right),
            (s += 2 + f.break),
            (a -= f.size);
        } else break;
      else if (o < a) {
        let f = e[n++];
        f && (o += f.size);
      } else {
        let f = e[--s];
        f && (a += f.size);
      }
    let l = 0;
    return (
      e[n - 1] == null ? ((l = 1), n--) : e[n] == null && ((l = 1), s++),
      new HeightMapBranch(HeightMap.of(e.slice(0, n)), l, HeightMap.of(e.slice(s)))
    );
  }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
  constructor(e, n, s) {
    super(e, n), (this.deco = s);
  }
  blockAt(e, n, s, o) {
    return new BlockInfo(o, this.length, s, this.height, this.deco || 0);
  }
  lineAt(e, n, s, o, a) {
    return this.blockAt(0, s, o, a);
  }
  forEachLine(e, n, s, o, a, l) {
    e <= a + this.length && n >= a && l(this.blockAt(0, s, o, a));
  }
  updateHeight(e, n = 0, s = !1, o) {
    return o && o.from <= n && o.more && this.setHeight(e, o.heights[o.index++]), (this.outdated = !1), this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(e, n) {
    super(e, n, null), (this.collapsed = 0), (this.widgetHeight = 0), (this.breaks = 0);
  }
  blockAt(e, n, s, o) {
    return new BlockInfo(o, this.length, s, this.height, this.breaks);
  }
  replace(e, n, s) {
    let o = s[0];
    return s.length == 1 &&
      (o instanceof HeightMapText || (o instanceof HeightMapGap && o.flags & 4)) &&
      Math.abs(this.length - o.length) < 10
      ? (o instanceof HeightMapGap ? (o = new HeightMapText(o.length, this.height)) : (o.height = this.height),
        this.outdated || (o.outdated = !1),
        o)
      : HeightMap.of(s);
  }
  updateHeight(e, n = 0, s = !1, o) {
    return (
      o && o.from <= n && o.more
        ? this.setHeight(e, o.heights[o.index++])
        : (s || this.outdated) &&
          this.setHeight(
            e,
            Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight,
          ),
      (this.outdated = !1),
      this
    );
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ''}${
      this.widgetHeight ? ':' + this.widgetHeight : ''
    })`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let s = e.doc.lineAt(n).number,
      o = e.doc.lineAt(n + this.length).number,
      a = o - s + 1,
      l,
      f = 0;
    if (e.lineWrapping) {
      let m = Math.min(this.height, e.lineHeight * a);
      (l = m / a), this.length > a + 1 && (f = (this.height - m) / (this.length - a - 1));
    } else l = this.height / a;
    return { firstLine: s, lastLine: o, perLine: l, perChar: f };
  }
  blockAt(e, n, s, o) {
    let { firstLine: a, lastLine: l, perLine: f, perChar: m } = this.heightMetrics(n, o);
    if (n.lineWrapping) {
      let v = o + Math.round(Math.max(0, Math.min(1, (e - s) / this.height)) * this.length),
        I = n.doc.lineAt(v),
        L = f + I.length * m,
        V = Math.max(s, e - L / 2);
      return new BlockInfo(I.from, I.length, V, L, 0);
    } else {
      let v = Math.max(0, Math.min(l - a, Math.floor((e - s) / f))),
        { from: I, length: L } = n.doc.line(a + v);
      return new BlockInfo(I, L, s + f * v, f, 0);
    }
  }
  lineAt(e, n, s, o, a) {
    if (n == QueryType$1.ByHeight) return this.blockAt(e, s, o, a);
    if (n == QueryType$1.ByPosNoHeight) {
      let { from: se, to: Ee } = s.doc.lineAt(e);
      return new BlockInfo(se, Ee - se, 0, 0, 0);
    }
    let { firstLine: l, perLine: f, perChar: m } = this.heightMetrics(s, a),
      v = s.doc.lineAt(e),
      I = f + v.length * m,
      L = v.number - l,
      V = o + f * L + m * (v.from - a - L);
    return new BlockInfo(v.from, v.length, Math.max(o, Math.min(V, o + this.height - I)), I, 0);
  }
  forEachLine(e, n, s, o, a, l) {
    (e = Math.max(e, a)), (n = Math.min(n, a + this.length));
    let { firstLine: f, perLine: m, perChar: v } = this.heightMetrics(s, a);
    for (let I = e, L = o; I <= n; ) {
      let V = s.doc.lineAt(I);
      if (I == e) {
        let Ee = V.number - f;
        L += m * Ee + v * (e - a - Ee);
      }
      let se = m + v * V.length;
      l(new BlockInfo(V.from, V.length, L, se, 0)), (L += se), (I = V.to + 1);
    }
  }
  replace(e, n, s) {
    let o = this.length - n;
    if (o > 0) {
      let a = s[s.length - 1];
      a instanceof HeightMapGap
        ? (s[s.length - 1] = new HeightMapGap(a.length + o))
        : s.push(null, new HeightMapGap(o - 1));
    }
    if (e > 0) {
      let a = s[0];
      a instanceof HeightMapGap ? (s[0] = new HeightMapGap(e + a.length)) : s.unshift(new HeightMapGap(e - 1), null);
    }
    return HeightMap.of(s);
  }
  decomposeLeft(e, n) {
    n.push(new HeightMapGap(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new HeightMapGap(this.length - e - 1));
  }
  updateHeight(e, n = 0, s = !1, o) {
    let a = n + this.length;
    if (o && o.from <= n + this.length && o.more) {
      let l = [],
        f = Math.max(n, o.from),
        m = -1;
      for (o.from > n && l.push(new HeightMapGap(o.from - n - 1).updateHeight(e, n)); f <= a && o.more; ) {
        let I = e.doc.lineAt(f).length;
        l.length && l.push(null);
        let L = o.heights[o.index++];
        m == -1 ? (m = L) : Math.abs(L - m) >= Epsilon && (m = -2);
        let V = new HeightMapText(I, L);
        (V.outdated = !1), l.push(V), (f += I + 1);
      }
      f <= a && l.push(null, new HeightMapGap(a - f).updateHeight(e, f));
      let v = HeightMap.of(l);
      return (
        (m < 0 ||
          Math.abs(v.height - this.height) >= Epsilon ||
          Math.abs(m - this.heightMetrics(e, n).perLine) >= Epsilon) &&
          (e.heightChanged = !0),
        v
      );
    } else (s || this.outdated) && (this.setHeight(e, e.heightForGap(n, n + this.length)), (this.outdated = !1));
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(e, n, s) {
    super(e.length + n + s.length, e.height + s.height, n | (e.outdated || s.outdated ? 2 : 0)),
      (this.left = e),
      (this.right = s),
      (this.size = e.size + s.size);
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, s, o) {
    let a = s + this.left.height;
    return e < a ? this.left.blockAt(e, n, s, o) : this.right.blockAt(e, n, a, o + this.left.length + this.break);
  }
  lineAt(e, n, s, o, a) {
    let l = o + this.left.height,
      f = a + this.left.length + this.break,
      m = n == QueryType$1.ByHeight ? e < l : e < f,
      v = m ? this.left.lineAt(e, n, s, o, a) : this.right.lineAt(e, n, s, l, f);
    if (this.break || (m ? v.to < f : v.from > f)) return v;
    let I = n == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos;
    return m ? v.join(this.right.lineAt(f, I, s, l, f)) : this.left.lineAt(f, I, s, o, a).join(v);
  }
  forEachLine(e, n, s, o, a, l) {
    let f = o + this.left.height,
      m = a + this.left.length + this.break;
    if (this.break)
      e < m && this.left.forEachLine(e, n, s, o, a, l), n >= m && this.right.forEachLine(e, n, s, f, m, l);
    else {
      let v = this.lineAt(m, QueryType$1.ByPos, s, o, a);
      e < v.from && this.left.forEachLine(e, v.from - 1, s, o, a, l),
        v.to >= e && v.from <= n && l(v),
        n > v.to && this.right.forEachLine(v.to + 1, n, s, f, m, l);
    }
  }
  replace(e, n, s) {
    let o = this.left.length + this.break;
    if (n < o) return this.balanced(this.left.replace(e, n, s), this.right);
    if (e > this.left.length) return this.balanced(this.left, this.right.replace(e - o, n - o, s));
    let a = [];
    e > 0 && this.decomposeLeft(e, a);
    let l = a.length;
    for (let f of s) a.push(f);
    if ((e > 0 && mergeGaps(a, l - 1), n < this.length)) {
      let f = a.length;
      this.decomposeRight(n, a), mergeGaps(a, f);
    }
    return HeightMap.of(a);
  }
  decomposeLeft(e, n) {
    let s = this.left.length;
    if (e <= s) return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (s++, e >= s && n.push(null)), e > s && this.right.decomposeLeft(e - s, n);
  }
  decomposeRight(e, n) {
    let s = this.left.length,
      o = s + this.break;
    if (e >= o) return this.right.decomposeRight(e - o, n);
    e < s && this.left.decomposeRight(e, n), this.break && e < o && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size
      ? HeightMap.of(this.break ? [e, null, n] : [e, n])
      : ((this.left = e),
        (this.right = n),
        (this.height = e.height + n.height),
        (this.outdated = e.outdated || n.outdated),
        (this.size = e.size + n.size),
        (this.length = e.length + this.break + n.length),
        this);
  }
  updateHeight(e, n = 0, s = !1, o) {
    let { left: a, right: l } = this,
      f = n + a.length + this.break,
      m = null;
    return (
      o && o.from <= n + a.length && o.more ? (m = a = a.updateHeight(e, n, s, o)) : a.updateHeight(e, n, s),
      o && o.from <= f + l.length && o.more ? (m = l = l.updateHeight(e, f, s, o)) : l.updateHeight(e, f, s),
      m ? this.balanced(a, l) : ((this.height = this.left.height + this.right.height), (this.outdated = !1), this)
    );
  }
  toString() {
    return this.left + (this.break ? ' ' : '-') + this.right;
  }
}
function mergeGaps(r, e) {
  let n, s;
  r[e] == null &&
    (n = r[e - 1]) instanceof HeightMapGap &&
    (s = r[e + 1]) instanceof HeightMapGap &&
    r.splice(e - 1, 3, new HeightMapGap(n.length + 1 + s.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(e, n) {
    (this.pos = e),
      (this.oracle = n),
      (this.nodes = []),
      (this.lineStart = -1),
      (this.lineEnd = -1),
      (this.covering = null),
      (this.writtenTo = e);
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let s = Math.min(n, this.lineEnd),
        o = this.nodes[this.nodes.length - 1];
      o instanceof HeightMapText
        ? (o.length += s - this.pos)
        : (s > this.pos || !this.isCovered) && this.nodes.push(new HeightMapText(s - this.pos, -1)),
        (this.writtenTo = s),
        n > s && (this.nodes.push(null), this.writtenTo++, (this.lineStart = -1));
    }
    this.pos = n;
  }
  point(e, n, s) {
    if (e < n || s.heightRelevant) {
      let o = s.widget ? s.widget.estimatedHeight : 0,
        a = s.widget ? s.widget.lineBreaks : 0;
      o < 0 && (o = this.oracle.lineHeight);
      let l = n - e;
      s.block
        ? this.addBlock(new HeightMapBlock(l, o, s))
        : (l || a || o >= relevantWidgetHeight) && this.addLineDeco(o, a, l);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    (this.lineStart = e),
      (this.lineEnd = n),
      this.writtenTo < e &&
        ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) &&
          this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
        this.nodes.push(null)),
      this.pos > e && this.nodes.push(new HeightMapText(this.pos - e, -1)),
      (this.writtenTo = this.pos);
  }
  blankContent(e, n) {
    let s = new HeightMapGap(n - e);
    return this.oracle.doc.lineAt(e).to == n && (s.flags |= 4), s;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof HeightMapText) return e;
    let n = new HeightMapText(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(),
      this.nodes.push(e),
      (this.writtenTo = this.pos = this.pos + e.length),
      n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, s) {
    let o = this.ensureLine();
    (o.length += s),
      (o.collapsed += s),
      (o.widgetHeight = Math.max(o.widgetHeight, e)),
      (o.breaks += n),
      (this.writtenTo = this.pos = this.pos + s);
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof HeightMapText) && !this.isCovered
      ? this.nodes.push(new HeightMapText(0, -1))
      : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let s = e;
    for (let o of this.nodes) o instanceof HeightMapText && o.updateHeight(this.oracle, s), (s += o ? o.length : 1);
    return this.nodes;
  }
  static build(e, n, s, o) {
    let a = new NodeBuilder(s, e);
    return RangeSet.spans(n, s, o, a, 0), a.finish(s);
  }
}
function heightRelevantDecoChanges(r, e, n) {
  let s = new DecorationComparator();
  return RangeSet.compare(r, e, n, s, 0), s.changes;
}
class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange() {}
  comparePoint(e, n, s, o) {
    (e < n || (s && s.heightRelevant) || (o && o.heightRelevant)) && addRange(e, n, this.changes, 5);
  }
}
function visiblePixelRange(r, e) {
  let n = r.getBoundingClientRect(),
    s = r.ownerDocument,
    o = s.defaultView || window,
    a = Math.max(0, n.left),
    l = Math.min(o.innerWidth, n.right),
    f = Math.max(0, n.top),
    m = Math.min(o.innerHeight, n.bottom);
  for (let v = r.parentNode; v && v != s.body; )
    if (v.nodeType == 1) {
      let I = v,
        L = window.getComputedStyle(I);
      if ((I.scrollHeight > I.clientHeight || I.scrollWidth > I.clientWidth) && L.overflow != 'visible') {
        let V = I.getBoundingClientRect();
        (a = Math.max(a, V.left)),
          (l = Math.min(l, V.right)),
          (f = Math.max(f, V.top)),
          (m = v == r.parentNode ? V.bottom : Math.min(m, V.bottom));
      }
      v = L.position == 'absolute' || L.position == 'fixed' ? I.offsetParent : I.parentNode;
    } else if (v.nodeType == 11) v = v.host;
    else break;
  return {
    left: a - n.left,
    right: Math.max(a, l) - n.left,
    top: f - (n.top + e),
    bottom: Math.max(f, m) - (n.top + e),
  };
}
function fullPixelRange(r, e) {
  let n = r.getBoundingClientRect();
  return { left: 0, right: n.right - n.left, top: e, bottom: n.bottom - (n.top + e) };
}
class LineGap {
  constructor(e, n, s) {
    (this.from = e), (this.to = n), (this.size = s);
  }
  static same(e, n) {
    if (e.length != n.length) return !1;
    for (let s = 0; s < e.length; s++) {
      let o = e[s],
        a = n[s];
      if (o.from != a.from || o.to != a.to || o.size != a.size) return !1;
    }
    return !0;
  }
  draw(e, n) {
    return Decoration.replace({ widget: new LineGapWidget(this.size * (n ? e.scaleY : e.scaleX), n) }).range(
      this.from,
      this.to,
    );
  }
}
class LineGapWidget extends WidgetType {
  constructor(e, n) {
    super(), (this.size = e), (this.vertical = n);
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement('div');
    return (
      this.vertical
        ? (e.style.height = this.size + 'px')
        : ((e.style.width = this.size + 'px'), (e.style.height = '2px'), (e.style.display = 'inline-block')),
      e
    );
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(e) {
    (this.state = e),
      (this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }),
      (this.inView = !0),
      (this.paddingTop = 0),
      (this.paddingBottom = 0),
      (this.contentDOMWidth = 0),
      (this.contentDOMHeight = 0),
      (this.editorHeight = 0),
      (this.editorWidth = 0),
      (this.scrollTop = 0),
      (this.scrolledToBottom = !0),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.scrollAnchorPos = 0),
      (this.scrollAnchorHeight = -1),
      (this.scaler = IdScaler),
      (this.scrollTarget = null),
      (this.printing = !1),
      (this.mustMeasureContent = !0),
      (this.defaultTextDirection = Direction.LTR),
      (this.visibleRanges = []),
      (this.mustEnforceCursorAssoc = !1);
    let n = e.facet(contentAttributes).some((s) => typeof s != 'function' && s.class == 'cm-lineWrapping');
    (this.heightOracle = new HeightOracle(n)),
      (this.stateDeco = e.facet(decorations).filter((s) => typeof s != 'function')),
      (this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(e.doc), [
        new ChangedRange(0, 0, 0, e.doc.length),
      ])),
      (this.viewport = this.getViewport(0, null)),
      this.updateViewportLines(),
      this.updateForViewport(),
      (this.lineGaps = this.ensureLineGaps([])),
      (this.lineGapDeco = Decoration.set(this.lineGaps.map((s) => s.draw(this, !1)))),
      this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport],
      { main: n } = this.state.selection;
    for (let s = 0; s <= 1; s++) {
      let o = s ? n.head : n.anchor;
      if (!e.some(({ from: a, to: l }) => o >= a && o <= l)) {
        let { from: a, to: l } = this.lineBlockAt(o);
        e.push(new Viewport(a, l));
      }
    }
    (this.viewports = e.sort((s, o) => s.from - o.from)),
      (this.scaler =
        this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports));
  }
  updateViewportLines() {
    (this.viewportLines = []),
      this.heightMap.forEachLine(
        this.viewport.from,
        this.viewport.to,
        this.heightOracle.setDoc(this.state.doc),
        0,
        0,
        (e) => {
          this.viewportLines.push(this.scaler.scale == 1 ? e : scaleBlock(e, this.scaler));
        },
      );
  }
  update(e, n = null) {
    this.state = e.state;
    let s = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((I) => typeof I != 'function');
    let o = e.changedRanges,
      a = ChangedRange.extendWithRanges(
        o,
        heightRelevantDecoChanges(s, this.stateDeco, e ? e.changes : ChangeSet.empty(this.state.doc.length)),
      ),
      l = this.heightMap.height,
      f = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    (this.heightMap = this.heightMap.applyChanges(
      this.stateDeco,
      e.startState.doc,
      this.heightOracle.setDoc(this.state.doc),
      a,
    )),
      this.heightMap.height != l && (e.flags |= 2),
      f
        ? ((this.scrollAnchorPos = e.changes.mapPos(f.from, -1)), (this.scrollAnchorHeight = f.top))
        : ((this.scrollAnchorPos = -1), (this.scrollAnchorHeight = this.heightMap.height));
    let m = a.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    ((n && (n.range.head < m.from || n.range.head > m.to)) || !this.viewportIsAppropriate(m)) &&
      (m = this.getViewport(0, n));
    let v = !e.changes.empty || e.flags & 2 || m.from != this.viewport.from || m.to != this.viewport.to;
    (this.viewport = m),
      this.updateForViewport(),
      v && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))),
      (e.flags |= this.computeVisibleRanges()),
      n && (this.scrollTarget = n),
      !this.mustEnforceCursorAssoc &&
        e.selectionSet &&
        e.view.lineWrapping &&
        e.state.selection.main.empty &&
        e.state.selection.main.assoc &&
        !e.state.facet(nativeSelectionHidden) &&
        (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM,
      s = window.getComputedStyle(n),
      o = this.heightOracle,
      a = s.whiteSpace;
    this.defaultTextDirection = s.direction == 'rtl' ? Direction.RTL : Direction.LTR;
    let l = this.heightOracle.mustRefreshForWrapping(a),
      f = n.getBoundingClientRect(),
      m = l || this.mustMeasureContent || this.contentDOMHeight != f.height;
    (this.contentDOMHeight = f.height), (this.mustMeasureContent = !1);
    let v = 0,
      I = 0;
    if (f.width && f.height) {
      let hl = f.width / n.offsetWidth,
        fl = f.height / n.offsetHeight;
      ((hl > 0.995 && hl < 1.005) || !isFinite(hl) || Math.abs(f.width - n.offsetWidth) < 1) && (hl = 1),
        ((fl > 0.995 && fl < 1.005) || !isFinite(fl) || Math.abs(f.height - n.offsetHeight) < 1) && (fl = 1),
        (this.scaleX != hl || this.scaleY != fl) && ((this.scaleX = hl), (this.scaleY = fl), (v |= 8), (l = m = !0));
    }
    let L = (parseInt(s.paddingTop) || 0) * this.scaleY,
      V = (parseInt(s.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != L || this.paddingBottom != V) && ((this.paddingTop = L), (this.paddingBottom = V), (v |= 10)),
      this.editorWidth != e.scrollDOM.clientWidth &&
        (o.lineWrapping && (m = !0), (this.editorWidth = e.scrollDOM.clientWidth), (v |= 8));
    let se = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != se && ((this.scrollAnchorHeight = -1), (this.scrollTop = se)),
      (this.scrolledToBottom = isScrolledToBottom(e.scrollDOM));
    let Ee = (this.printing ? fullPixelRange : visiblePixelRange)(n, this.paddingTop),
      ht = Ee.top - this.pixelViewport.top,
      ar = Ee.bottom - this.pixelViewport.bottom;
    this.pixelViewport = Ee;
    let $i = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (($i != this.inView && ((this.inView = $i), $i && (m = !0)), !this.inView && !this.scrollTarget)) return 0;
    let tl = f.width;
    if (
      ((this.contentDOMWidth != tl || this.editorHeight != e.scrollDOM.clientHeight) &&
        ((this.contentDOMWidth = f.width), (this.editorHeight = e.scrollDOM.clientHeight), (v |= 8)),
      m)
    ) {
      let hl = e.docView.measureVisibleLineHeights(this.viewport);
      if (
        (o.mustRefreshForHeights(hl) && (l = !0),
        l || (o.lineWrapping && Math.abs(tl - this.contentDOMWidth) > o.charWidth))
      ) {
        let { lineHeight: fl, charWidth: dl, textHeight: Al } = e.docView.measureTextSize();
        (l = fl > 0 && o.refresh(a, fl, dl, Al, tl / dl, hl)), l && ((e.docView.minWidth = 0), (v |= 8));
      }
      ht > 0 && ar > 0 ? (I = Math.max(ht, ar)) : ht < 0 && ar < 0 && (I = Math.min(ht, ar)), (o.heightChanged = !1);
      for (let fl of this.viewports) {
        let dl = fl.from == this.viewport.from ? hl : e.docView.measureVisibleLineHeights(fl);
        this.heightMap = (
          l
            ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [
                new ChangedRange(0, 0, 0, e.state.doc.length),
              ])
            : this.heightMap
        ).updateHeight(o, 0, l, new MeasuredHeights(fl.from, dl));
      }
      o.heightChanged && (v |= 2);
    }
    let Wi =
      !this.viewportIsAppropriate(this.viewport, I) ||
      (this.scrollTarget &&
        (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to));
    return (
      Wi && (this.viewport = this.getViewport(I, this.scrollTarget)),
      this.updateForViewport(),
      (v & 2 || Wi) && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(l ? [] : this.lineGaps, e)),
      (v |= this.computeVisibleRanges()),
      this.mustEnforceCursorAssoc && ((this.mustEnforceCursorAssoc = !1), e.docView.enforceCursorAssoc()),
      v
    );
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let s = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)),
      o = this.heightMap,
      a = this.heightOracle,
      { visibleTop: l, visibleBottom: f } = this,
      m = new Viewport(
        o.lineAt(l - s * 1e3, QueryType$1.ByHeight, a, 0, 0).from,
        o.lineAt(f + (1 - s) * 1e3, QueryType$1.ByHeight, a, 0, 0).to,
      );
    if (n) {
      let { head: v } = n.range;
      if (v < m.from || v > m.to) {
        let I = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top),
          L = o.lineAt(v, QueryType$1.ByPos, a, 0, 0),
          V;
        n.y == 'center'
          ? (V = (L.top + L.bottom) / 2 - I / 2)
          : n.y == 'start' || (n.y == 'nearest' && v < m.from)
          ? (V = L.top)
          : (V = L.bottom - I),
          (m = new Viewport(
            o.lineAt(V - 1e3 / 2, QueryType$1.ByHeight, a, 0, 0).from,
            o.lineAt(V + I + 1e3 / 2, QueryType$1.ByHeight, a, 0, 0).to,
          ));
      }
    }
    return m;
  }
  mapViewport(e, n) {
    let s = n.mapPos(e.from, -1),
      o = n.mapPos(e.to, 1);
    return new Viewport(
      this.heightMap.lineAt(s, QueryType$1.ByPos, this.heightOracle, 0, 0).from,
      this.heightMap.lineAt(o, QueryType$1.ByPos, this.heightOracle, 0, 0).to,
    );
  }
  viewportIsAppropriate({ from: e, to: n }, s = 0) {
    if (!this.inView) return !0;
    let { top: o } = this.heightMap.lineAt(e, QueryType$1.ByPos, this.heightOracle, 0, 0),
      { bottom: a } = this.heightMap.lineAt(n, QueryType$1.ByPos, this.heightOracle, 0, 0),
      { visibleTop: l, visibleBottom: f } = this;
    return (
      (e == 0 || o <= l - Math.max(10, Math.min(-s, 250))) &&
      (n == this.state.doc.length || a >= f + Math.max(10, Math.min(s, 250))) &&
      o > l - 2 * 1e3 &&
      a < f + 2 * 1e3
    );
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty) return e;
    let s = [];
    for (let o of e) n.touchesRange(o.from, o.to) || s.push(new LineGap(n.mapPos(o.from), n.mapPos(o.to), o.size));
    return s;
  }
  ensureLineGaps(e, n) {
    let s = this.heightOracle.lineWrapping,
      o = s ? 1e4 : 2e3,
      a = o >> 1,
      l = o << 1;
    if (this.defaultTextDirection != Direction.LTR && !s) return [];
    let f = [],
      m = (v, I, L, V) => {
        if (I - v < a) return;
        let se = this.state.selection.main,
          Ee = [se.from];
        se.empty || Ee.push(se.to);
        for (let ar of Ee)
          if (ar > v && ar < I) {
            m(v, ar - 10, L, V), m(ar + 10, I, L, V);
            return;
          }
        let ht = find(
          e,
          (ar) =>
            ar.from >= L.from &&
            ar.to <= L.to &&
            Math.abs(ar.from - v) < a &&
            Math.abs(ar.to - I) < a &&
            !Ee.some(($i) => ar.from < $i && ar.to > $i),
        );
        if (!ht) {
          if (I < L.to && n && s && n.visibleRanges.some((ar) => ar.from <= I && ar.to >= I)) {
            let ar = n.moveToLineBoundary(EditorSelection.cursor(I), !1, !0).head;
            ar > v && (I = ar);
          }
          ht = new LineGap(v, I, this.gapSize(L, v, I, V));
        }
        f.push(ht);
      };
    for (let v of this.viewportLines) {
      if (v.length < l) continue;
      let I = lineStructure(v.from, v.to, this.stateDeco);
      if (I.total < l) continue;
      let L = this.scrollTarget ? this.scrollTarget.range.head : null,
        V,
        se;
      if (s) {
        let Ee = (o / this.heightOracle.lineLength) * this.heightOracle.lineHeight,
          ht,
          ar;
        if (L != null) {
          let $i = findFraction(I, L),
            tl = ((this.visibleBottom - this.visibleTop) / 2 + Ee) / v.height;
          (ht = $i - tl), (ar = $i + tl);
        } else (ht = (this.visibleTop - v.top - Ee) / v.height), (ar = (this.visibleBottom - v.top + Ee) / v.height);
        (V = findPosition(I, ht)), (se = findPosition(I, ar));
      } else {
        let Ee = I.total * this.heightOracle.charWidth,
          ht = o * this.heightOracle.charWidth,
          ar,
          $i;
        if (L != null) {
          let tl = findFraction(I, L),
            Wi = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + ht) / Ee;
          (ar = tl - Wi), ($i = tl + Wi);
        } else (ar = (this.pixelViewport.left - ht) / Ee), ($i = (this.pixelViewport.right + ht) / Ee);
        (V = findPosition(I, ar)), (se = findPosition(I, $i));
      }
      V > v.from && m(v.from, V, v, I), se < v.to && m(se, v.to, v, I);
    }
    return f;
  }
  gapSize(e, n, s, o) {
    let a = findFraction(o, s) - findFraction(o, n);
    return this.heightOracle.lineWrapping ? e.height * a : o.total * this.heightOracle.charWidth * a;
  }
  updateLineGaps(e) {
    LineGap.same(e, this.lineGaps) ||
      ((this.lineGaps = e),
      (this.lineGapDeco = Decoration.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping)))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let n = [];
    RangeSet.spans(
      e,
      this.viewport.from,
      this.viewport.to,
      {
        span(o, a) {
          n.push({ from: o, to: a });
        },
        point() {},
      },
      20,
    );
    let s =
      n.length != this.visibleRanges.length ||
      this.visibleRanges.some((o, a) => o.from != n[a].from || o.to != n[a].to);
    return (this.visibleRanges = n), s ? 4 : 0;
  }
  lineBlockAt(e) {
    return (
      (e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e)) ||
      scaleBlock(this.heightMap.lineAt(e, QueryType$1.ByPos, this.heightOracle, 0, 0), this.scaler)
    );
  }
  lineBlockAtHeight(e) {
    return scaleBlock(
      this.heightMap.lineAt(this.scaler.fromDOM(e), QueryType$1.ByHeight, this.heightOracle, 0, 0),
      this.scaler,
    );
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(e, n) {
    (this.from = e), (this.to = n);
  }
}
function lineStructure(r, e, n) {
  let s = [],
    o = r,
    a = 0;
  return (
    RangeSet.spans(
      n,
      r,
      e,
      {
        span() {},
        point(l, f) {
          l > o && (s.push({ from: o, to: l }), (a += l - o)), (o = f);
        },
      },
      20,
    ),
    o < e && (s.push({ from: o, to: e }), (a += e - o)),
    { total: a, ranges: s }
  );
}
function findPosition({ total: r, ranges: e }, n) {
  if (n <= 0) return e[0].from;
  if (n >= 1) return e[e.length - 1].to;
  let s = Math.floor(r * n);
  for (let o = 0; ; o++) {
    let { from: a, to: l } = e[o],
      f = l - a;
    if (s <= f) return a + s;
    s -= f;
  }
}
function findFraction(r, e) {
  let n = 0;
  for (let { from: s, to: o } of r.ranges) {
    if (e <= o) {
      n += e - s;
      break;
    }
    n += o - s;
  }
  return n / r.total;
}
function find(r, e) {
  for (let n of r) if (e(n)) return n;
}
const IdScaler = {
  toDOM(r) {
    return r;
  },
  fromDOM(r) {
    return r;
  },
  scale: 1,
};
class BigScaler {
  constructor(e, n, s) {
    let o = 0,
      a = 0,
      l = 0;
    (this.viewports = s.map(({ from: f, to: m }) => {
      let v = n.lineAt(f, QueryType$1.ByPos, e, 0, 0).top,
        I = n.lineAt(m, QueryType$1.ByPos, e, 0, 0).bottom;
      return (o += I - v), { from: f, to: m, top: v, bottom: I, domTop: 0, domBottom: 0 };
    })),
      (this.scale = (7e6 - o) / (n.height - o));
    for (let f of this.viewports)
      (f.domTop = l + (f.top - a) * this.scale), (l = f.domBottom = f.domTop + (f.bottom - f.top)), (a = f.bottom);
  }
  toDOM(e) {
    for (let n = 0, s = 0, o = 0; ; n++) {
      let a = n < this.viewports.length ? this.viewports[n] : null;
      if (!a || e < a.top) return o + (e - s) * this.scale;
      if (e <= a.bottom) return a.domTop + (e - a.top);
      (s = a.bottom), (o = a.domBottom);
    }
  }
  fromDOM(e) {
    for (let n = 0, s = 0, o = 0; ; n++) {
      let a = n < this.viewports.length ? this.viewports[n] : null;
      if (!a || e < a.domTop) return s + (e - o) / this.scale;
      if (e <= a.domBottom) return a.top + (e - a.domTop);
      (s = a.bottom), (o = a.domBottom);
    }
  }
}
function scaleBlock(r, e) {
  if (e.scale == 1) return r;
  let n = e.toDOM(r.top),
    s = e.toDOM(r.bottom);
  return new BlockInfo(
    r.from,
    r.length,
    n,
    s - n,
    Array.isArray(r._content) ? r._content.map((o) => scaleBlock(o, e)) : r._content,
  );
}
const theme$1 = Facet.define({ combine: (r) => r.join(' ') }),
  darkTheme = Facet.define({ combine: (r) => r.indexOf(!0) > -1 }),
  baseThemeID = StyleModule.newName(),
  baseLightID = StyleModule.newName(),
  baseDarkID = StyleModule.newName(),
  lightDarkIDs = { '&light': '.' + baseLightID, '&dark': '.' + baseDarkID };
function buildTheme(r, e, n) {
  return new StyleModule(e, {
    finish(s) {
      return /&/.test(s)
        ? s.replace(/&\w*/, (o) => {
            if (o == '&') return r;
            if (!n || !n[o]) throw new RangeError(`Unsupported selector: ${o}`);
            return n[o];
          })
        : r + ' ' + s;
    },
  });
}
const baseTheme$1$3 = buildTheme(
    '.' + baseThemeID,
    {
      '&': {
        'position': 'relative !important',
        'boxSizing': 'border-box',
        '&.cm-focused': { outline: '1px dotted #212121' },
        'display': 'flex !important',
        'flexDirection': 'column',
      },
      '.cm-scroller': {
        display: 'flex !important',
        alignItems: 'flex-start !important',
        fontFamily: 'monospace',
        lineHeight: 1.4,
        height: '100%',
        overflowX: 'auto',
        position: 'relative',
        zIndex: 0,
      },
      '.cm-content': {
        'margin': 0,
        'flexGrow': 2,
        'flexShrink': 0,
        'display': 'block',
        'whiteSpace': 'pre',
        'wordWrap': 'normal',
        'boxSizing': 'border-box',
        'padding': '4px 0',
        'outline': 'none',
        '&[contenteditable=true]': { WebkitUserModify: 'read-write-plaintext-only' },
      },
      '.cm-lineWrapping': {
        whiteSpace_fallback: 'pre-wrap',
        whiteSpace: 'break-spaces',
        wordBreak: 'break-word',
        overflowWrap: 'anywhere',
        flexShrink: 1,
      },
      '&light .cm-content': { caretColor: 'black' },
      '&dark .cm-content': { caretColor: 'white' },
      '.cm-line': { display: 'block', padding: '0 2px 0 6px' },
      '.cm-layer': {
        'position': 'absolute',
        'left': 0,
        'top': 0,
        'contain': 'size style',
        '& > *': { position: 'absolute' },
      },
      '&light .cm-selectionBackground': { background: '#d9d9d9' },
      '&dark .cm-selectionBackground': { background: '#222' },
      '&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': { background: '#d7d4f0' },
      '&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': { background: '#233' },
      '.cm-cursorLayer': { pointerEvents: 'none' },
      '&.cm-focused > .cm-scroller > .cm-cursorLayer': { animation: 'steps(1) cm-blink 1.2s infinite' },
      '@keyframes cm-blink': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
      '@keyframes cm-blink2': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
      '.cm-cursor, .cm-dropCursor': { borderLeft: '1.2px solid black', marginLeft: '-0.6px', pointerEvents: 'none' },
      '.cm-cursor': { display: 'none' },
      '&dark .cm-cursor': { borderLeftColor: '#444' },
      '.cm-dropCursor': { position: 'absolute' },
      '&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor': { display: 'block' },
      '&light .cm-activeLine': { backgroundColor: '#cceeff44' },
      '&dark .cm-activeLine': { backgroundColor: '#99eeff33' },
      '&light .cm-specialChar': { color: 'red' },
      '&dark .cm-specialChar': { color: '#f78' },
      '.cm-gutters': {
        flexShrink: 0,
        display: 'flex',
        height: '100%',
        boxSizing: 'border-box',
        insetInlineStart: 0,
        zIndex: 200,
      },
      '&light .cm-gutters': { backgroundColor: '#f5f5f5', color: '#6c6c6c', borderRight: '1px solid #ddd' },
      '&dark .cm-gutters': { backgroundColor: '#333338', color: '#ccc' },
      '.cm-gutter': {
        display: 'flex !important',
        flexDirection: 'column',
        flexShrink: 0,
        boxSizing: 'border-box',
        minHeight: '100%',
        overflow: 'hidden',
      },
      '.cm-gutterElement': { boxSizing: 'border-box' },
      '.cm-lineNumbers .cm-gutterElement': {
        padding: '0 3px 0 5px',
        minWidth: '20px',
        textAlign: 'right',
        whiteSpace: 'nowrap',
      },
      '&light .cm-activeLineGutter': { backgroundColor: '#e2f2ff' },
      '&dark .cm-activeLineGutter': { backgroundColor: '#222227' },
      '.cm-panels': { boxSizing: 'border-box', position: 'sticky', left: 0, right: 0 },
      '&light .cm-panels': { backgroundColor: '#f5f5f5', color: 'black' },
      '&light .cm-panels-top': { borderBottom: '1px solid #ddd' },
      '&light .cm-panels-bottom': { borderTop: '1px solid #ddd' },
      '&dark .cm-panels': { backgroundColor: '#333338', color: 'white' },
      '.cm-tab': { display: 'inline-block', overflow: 'hidden', verticalAlign: 'bottom' },
      '.cm-widgetBuffer': { verticalAlign: 'text-top', height: '1em', width: 0, display: 'inline' },
      '.cm-placeholder': { color: '#888', display: 'inline-block', verticalAlign: 'top' },
      '.cm-highlightSpace:before': {
        content: 'attr(data-display)',
        position: 'absolute',
        pointerEvents: 'none',
        color: '#888',
      },
      '.cm-highlightTab': {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: 'auto 100%',
        backgroundPosition: 'right 90%',
        backgroundRepeat: 'no-repeat',
      },
      '.cm-trailingSpace': { backgroundColor: '#ff332255' },
      '.cm-button': {
        verticalAlign: 'middle',
        color: 'inherit',
        fontSize: '70%',
        padding: '.2em 1em',
        borderRadius: '1px',
      },
      '&light .cm-button': {
        'backgroundImage': 'linear-gradient(#eff1f5, #d9d9df)',
        'border': '1px solid #888',
        '&:active': { backgroundImage: 'linear-gradient(#b4b4b4, #d0d3d6)' },
      },
      '&dark .cm-button': {
        'backgroundImage': 'linear-gradient(#393939, #111)',
        'border': '1px solid #888',
        '&:active': { backgroundImage: 'linear-gradient(#111, #333)' },
      },
      '.cm-textfield': {
        verticalAlign: 'middle',
        color: 'inherit',
        fontSize: '70%',
        border: '1px solid silver',
        padding: '.2em .5em',
      },
      '&light .cm-textfield': { backgroundColor: 'white' },
      '&dark .cm-textfield': { border: '1px solid #555', backgroundColor: 'inherit' },
    },
    lightDarkIDs,
  ),
  LineBreakPlaceholder = '￿';
class DOMReader {
  constructor(e, n) {
    (this.points = e), (this.text = ''), (this.lineSeparator = n.facet(EditorState.lineSeparator));
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(e, n) {
    if (!e) return this;
    let s = e.parentNode;
    for (let o = e; ; ) {
      this.findPointBefore(s, o);
      let a = this.text.length;
      this.readNode(o);
      let l = o.nextSibling;
      if (l == n) break;
      let f = ContentView.get(o),
        m = ContentView.get(l);
      (f && m
        ? f.breakAfter
        : (f ? f.breakAfter : isBlockElement(o)) ||
          (isBlockElement(l) && (o.nodeName != 'BR' || o.cmIgnore) && this.text.length > a)) && this.lineBreak(),
        (o = l);
    }
    return this.findPointBefore(s, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let s of this.points) s.node == e && (s.pos = this.text.length + Math.min(s.offset, n.length));
    for (let s = 0, o = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let a = -1,
        l = 1,
        f;
      if (
        (this.lineSeparator
          ? ((a = n.indexOf(this.lineSeparator, s)), (l = this.lineSeparator.length))
          : (f = o.exec(n)) && ((a = f.index), (l = f[0].length)),
        this.append(n.slice(s, a < 0 ? n.length : a)),
        a < 0)
      )
        break;
      if ((this.lineBreak(), l > 1))
        for (let m of this.points) m.node == e && m.pos > this.text.length && (m.pos -= l - 1);
      s = a + l;
    }
  }
  readNode(e) {
    if (e.cmIgnore) return;
    let n = ContentView.get(e),
      s = n && n.overrideDOMText;
    if (s != null) {
      this.findPointInside(e, s.length);
      for (let o = s.iter(); !o.next().done; ) o.lineBreak ? this.lineBreak() : this.append(o.value);
    } else
      e.nodeType == 3
        ? this.readTextNode(e)
        : e.nodeName == 'BR'
        ? e.nextSibling && this.lineBreak()
        : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let s of this.points) s.node == e && e.childNodes[s.offset] == n && (s.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let s of this.points)
      (e.nodeType == 3 ? s.node == e : e.contains(s.node)) &&
        (s.pos = this.text.length + (isAtEnd(e, s.node, s.offset) ? n : 0));
  }
}
function isAtEnd(r, e, n) {
  for (;;) {
    if (!e || n < maxOffset(e)) return !1;
    if (e == r) return !0;
    (n = domIndex(e) + 1), (e = e.parentNode);
  }
}
function isBlockElement(r) {
  return r.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(r.nodeName);
}
class DOMPoint {
  constructor(e, n) {
    (this.node = e), (this.offset = n), (this.pos = -1);
  }
}
class DOMChange {
  constructor(e, n, s, o) {
    (this.typeOver = o), (this.bounds = null), (this.text = '');
    let { impreciseHead: a, impreciseAnchor: l } = e.docView;
    if (e.state.readOnly && n > -1) this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, s, 0))) {
      let f = a || l ? [] : selectionPoints(e),
        m = new DOMReader(f, e.state);
      m.readRange(this.bounds.startDOM, this.bounds.endDOM),
        (this.text = m.text),
        (this.newSel = selectionFromPoints(f, this.bounds.from));
    } else {
      let f = e.observer.selectionRange,
        m =
          (a && a.node == f.focusNode && a.offset == f.focusOffset) || !contains(e.contentDOM, f.focusNode)
            ? e.state.selection.main.head
            : e.docView.posFromDOM(f.focusNode, f.focusOffset),
        v =
          (l && l.node == f.anchorNode && l.offset == f.anchorOffset) || !contains(e.contentDOM, f.anchorNode)
            ? e.state.selection.main.anchor
            : e.docView.posFromDOM(f.anchorNode, f.anchorOffset);
      this.newSel = EditorSelection.single(v, m);
    }
  }
}
function applyDOMChange(r, e) {
  let n,
    { newSel: s } = e,
    o = r.state.selection.main,
    a = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: l, to: f } = e.bounds,
      m = o.from,
      v = null;
    (a === 8 || (browser.android && e.text.length < f - l)) && ((m = o.to), (v = 'end'));
    let I = findDiff(r.state.doc.sliceString(l, f, LineBreakPlaceholder), e.text, m - l, v);
    I &&
      (browser.chrome &&
        a == 13 &&
        I.toB == I.from + 2 &&
        e.text.slice(I.from, I.toB) == LineBreakPlaceholder + LineBreakPlaceholder &&
        I.toB--,
      (n = {
        from: l + I.from,
        to: l + I.toA,
        insert: Text.of(e.text.slice(I.from, I.toB).split(LineBreakPlaceholder)),
      }));
  } else s && ((!r.hasFocus && r.state.facet(editable)) || s.main.eq(o)) && (s = null);
  if (!n && !s) return !1;
  if (
    (!n && e.typeOver && !o.empty && s && s.main.empty
      ? (n = { from: o.from, to: o.to, insert: r.state.doc.slice(o.from, o.to) })
      : n &&
        n.from >= o.from &&
        n.to <= o.to &&
        (n.from != o.from || n.to != o.to) &&
        o.to - o.from - (n.to - n.from) <= 4
      ? (n = {
          from: o.from,
          to: o.to,
          insert: r.state.doc.slice(o.from, n.from).append(n.insert).append(r.state.doc.slice(n.to, o.to)),
        })
      : (browser.mac || browser.android) &&
        n &&
        n.from == n.to &&
        n.from == o.head - 1 &&
        /^\. ?$/.test(n.insert.toString()) &&
        r.contentDOM.getAttribute('autocorrect') == 'off'
      ? (s && n.insert.length == 2 && (s = EditorSelection.single(s.main.anchor - 1, s.main.head - 1)),
        (n = { from: o.from, to: o.to, insert: Text.of([' ']) }))
      : browser.chrome &&
        n &&
        n.from == n.to &&
        n.from == o.head &&
        n.insert.toString() ==
          `
 ` &&
        r.lineWrapping &&
        (s && (s = EditorSelection.single(s.main.anchor - 1, s.main.head - 1)),
        (n = { from: o.from, to: o.to, insert: Text.of([' ']) })),
    n)
  ) {
    if (
      (browser.ios && r.inputState.flushIOSKey()) ||
      (browser.android &&
        ((n.from == o.from &&
          n.to == o.to &&
          n.insert.length == 1 &&
          n.insert.lines == 2 &&
          dispatchKey(r.contentDOM, 'Enter', 13)) ||
          (((n.from == o.from - 1 && n.to == o.to && n.insert.length == 0) ||
            (a == 8 && n.insert.length < n.to - n.from && n.to > o.head)) &&
            dispatchKey(r.contentDOM, 'Backspace', 8)) ||
          (n.from == o.from && n.to == o.to + 1 && n.insert.length == 0 && dispatchKey(r.contentDOM, 'Delete', 46))))
    )
      return !0;
    let l = n.insert.toString();
    r.inputState.composing >= 0 && r.inputState.composing++;
    let f,
      m = () => f || (f = applyDefaultInsert(r, n, s));
    return r.state.facet(inputHandler$1).some((v) => v(r, n.from, n.to, l, m)) || r.dispatch(m()), !0;
  } else if (s && !s.main.eq(o)) {
    let l = !1,
      f = 'select';
    return (
      r.inputState.lastSelectionTime > Date.now() - 50 &&
        (r.inputState.lastSelectionOrigin == 'select' && (l = !0), (f = r.inputState.lastSelectionOrigin)),
      r.dispatch({ selection: s, scrollIntoView: l, userEvent: f }),
      !0
    );
  } else return !1;
}
function applyDefaultInsert(r, e, n) {
  let s,
    o = r.state,
    a = o.selection.main;
  if (
    e.from >= a.from &&
    e.to <= a.to &&
    e.to - e.from >= (a.to - a.from) / 3 &&
    (!n || (n.main.empty && n.main.from == e.from + e.insert.length)) &&
    r.inputState.composing < 0
  ) {
    let f = a.from < e.from ? o.sliceDoc(a.from, e.from) : '',
      m = a.to > e.to ? o.sliceDoc(e.to, a.to) : '';
    s = o.replaceSelection(r.state.toText(f + e.insert.sliceString(0, void 0, r.state.lineBreak) + m));
  } else {
    let f = o.changes(e),
      m = n && n.main.to <= f.newLength ? n.main : void 0;
    if (o.selection.ranges.length > 1 && r.inputState.composing >= 0 && e.to <= a.to && e.to >= a.to - 10) {
      let v = r.state.sliceDoc(e.from, e.to),
        I,
        L = n && findCompositionNode(r, n.main.head);
      if (L) {
        let Ee = e.insert.length - (e.to - e.from);
        I = { from: L.from, to: L.to - Ee };
      } else I = r.state.doc.lineAt(a.head);
      let V = a.to - e.to,
        se = a.to - a.from;
      s = o.changeByRange((Ee) => {
        if (Ee.from == a.from && Ee.to == a.to) return { changes: f, range: m || Ee.map(f) };
        let ht = Ee.to - V,
          ar = ht - v.length;
        if (Ee.to - Ee.from != se || r.state.sliceDoc(ar, ht) != v || (Ee.to >= I.from && Ee.from <= I.to))
          return { range: Ee };
        let $i = o.changes({ from: ar, to: ht, insert: e.insert }),
          tl = Ee.to - a.to;
        return {
          changes: $i,
          range: m ? EditorSelection.range(Math.max(0, m.anchor + tl), Math.max(0, m.head + tl)) : Ee.map($i),
        };
      });
    } else s = { changes: f, selection: m && o.selection.replaceRange(m) };
  }
  let l = 'input.type';
  return (
    (r.composing || (r.inputState.compositionPendingChange && r.inputState.compositionEndedAt > Date.now() - 50)) &&
      ((r.inputState.compositionPendingChange = !1),
      (l += '.compose'),
      r.inputState.compositionFirstChange && ((l += '.start'), (r.inputState.compositionFirstChange = !1))),
    o.update(s, { userEvent: l, scrollIntoView: !0 })
  );
}
function findDiff(r, e, n, s) {
  let o = Math.min(r.length, e.length),
    a = 0;
  for (; a < o && r.charCodeAt(a) == e.charCodeAt(a); ) a++;
  if (a == o && r.length == e.length) return null;
  let l = r.length,
    f = e.length;
  for (; l > 0 && f > 0 && r.charCodeAt(l - 1) == e.charCodeAt(f - 1); ) l--, f--;
  if (s == 'end') {
    let m = Math.max(0, a - Math.min(l, f));
    n -= l + m - a;
  }
  if (l < a && r.length < e.length) {
    let m = n <= a && n >= l ? a - n : 0;
    (a -= m), (f = a + (f - l)), (l = a);
  } else if (f < a) {
    let m = n <= a && n >= f ? a - n : 0;
    (a -= m), (l = a + (l - f)), (f = a);
  }
  return { from: a, toA: l, toB: f };
}
function selectionPoints(r) {
  let e = [];
  if (r.root.activeElement != r.contentDOM) return e;
  let { anchorNode: n, anchorOffset: s, focusNode: o, focusOffset: a } = r.observer.selectionRange;
  return n && (e.push(new DOMPoint(n, s)), (o != n || a != s) && e.push(new DOMPoint(o, a))), e;
}
function selectionFromPoints(r, e) {
  if (r.length == 0) return null;
  let n = r[0].pos,
    s = r.length == 2 ? r[1].pos : n;
  return n > -1 && s > -1 ? EditorSelection.single(n + e, s + e) : null;
}
const observeOptions = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 },
  useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
  constructor(e) {
    (this.view = e),
      (this.active = !1),
      (this.selectionRange = new DOMSelectionState()),
      (this.selectionChanged = !1),
      (this.delayedFlush = -1),
      (this.resizeTimeout = -1),
      (this.queue = []),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1),
      (this.lastChange = 0),
      (this.scrollTargets = []),
      (this.intersection = null),
      (this.resizeScroll = null),
      (this.resizeContent = null),
      (this.intersecting = !1),
      (this.gapIntersection = null),
      (this.gaps = []),
      (this.parentCheck = -1),
      (this.dom = e.contentDOM),
      (this.observer = new MutationObserver((n) => {
        for (let s of n) this.queue.push(s);
        ((browser.ie && browser.ie_version <= 11) || (browser.ios && e.composing)) &&
        n.some(
          (s) =>
            (s.type == 'childList' && s.removedNodes.length) ||
            (s.type == 'characterData' && s.oldValue.length > s.target.nodeValue.length),
        )
          ? this.flushSoon()
          : this.flush();
      })),
      useCharData &&
        (this.onCharData = (n) => {
          this.queue.push({ target: n.target, type: 'characterData', oldValue: n.prevValue }), this.flushSoon();
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this)),
      (this.onResize = this.onResize.bind(this)),
      (this.onPrint = this.onPrint.bind(this)),
      (this.onScroll = this.onScroll.bind(this)),
      typeof ResizeObserver == 'function' &&
        ((this.resizeScroll = new ResizeObserver(() => {
          var n;
          ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 &&
            this.onResize();
        })),
        this.resizeScroll.observe(e.scrollDOM),
        (this.resizeContent = new ResizeObserver(() => this.view.requestMeasure())),
        this.resizeContent.observe(e.contentDOM)),
      this.addWindowListeners((this.win = e.win)),
      this.start(),
      typeof IntersectionObserver == 'function' &&
        ((this.intersection = new IntersectionObserver(
          (n) => {
            this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)),
              n.length > 0 &&
                n[n.length - 1].intersectionRatio > 0 != this.intersecting &&
                ((this.intersecting = !this.intersecting),
                this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent('Event')));
          },
          { threshold: [0, 0.001] },
        )),
        this.intersection.observe(this.dom),
        (this.gapIntersection = new IntersectionObserver((n) => {
          n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent('Event'));
        }, {}))),
      this.listenForScroll(),
      this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers('scroll', e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 &&
      (this.resizeTimeout = setTimeout(() => {
        (this.resizeTimeout = -1), this.view.requestMeasure();
      }, 50));
  }
  onPrint() {
    (this.view.viewState.printing = !0),
      this.view.measure(),
      setTimeout(() => {
        (this.view.viewState.printing = !1), this.view.requestMeasure();
      }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, s) => n != e[s]))) {
      this.gapIntersection.disconnect();
      for (let n of e) this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: s } = this,
      o = this.selectionRange;
    if (s.state.facet(editable) ? s.root.activeElement != this.dom : !hasSelection(s.dom, o)) return;
    let a = o.anchorNode && s.docView.nearest(o.anchorNode);
    if (a && a.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    ((browser.ie && browser.ie_version <= 11) || (browser.android && browser.chrome)) &&
    !s.state.selection.main.empty &&
    o.focusNode &&
    isEquivalentPosition(o.focusNode, o.focusOffset, o.anchorNode, o.anchorOffset)
      ? this.flushSoon()
      : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this,
      n =
        (browser.safari &&
          e.root.nodeType == 11 &&
          deepActiveElement(this.dom.ownerDocument) == this.dom &&
          safariSelectionRangeHack(this.view)) ||
        getSelection(e.root);
    if (!n || this.selectionRange.eq(n)) return !1;
    let s = hasSelection(this.dom, n);
    return s &&
      !this.selectionChanged &&
      e.inputState.lastFocusTime > Date.now() - 200 &&
      e.inputState.lastTouchTime < Date.now() - 300 &&
      atElementStart(this.dom, n)
      ? ((this.view.inputState.lastFocusTime = 0), e.docView.updateSelection(), !1)
      : (this.selectionRange.setRange(n), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), (this.selectionChanged = !1);
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0,
      n = null;
    for (let s = this.dom; s; )
      if (s.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == s
          ? e++
          : n || (n = this.scrollTargets.slice(0, e)),
          n && n.push(s),
          (s = s.assignedSlot || s.parentNode);
      else if (s.nodeType == 11) s = s.host;
      else break;
    if ((e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n)) {
      for (let s of this.scrollTargets) s.removeEventListener('scroll', this.onScroll);
      for (let s of (this.scrollTargets = n)) s.addEventListener('scroll', this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active) return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active ||
      (this.observer.observe(this.dom, observeOptions),
      useCharData && this.dom.addEventListener('DOMCharacterDataModified', this.onCharData),
      (this.active = !0));
  }
  stop() {
    this.active &&
      ((this.active = !1),
      this.observer.disconnect(),
      useCharData && this.dom.removeEventListener('DOMCharacterDataModified', this.onCharData));
  }
  clear() {
    this.processRecords(), (this.queue.length = 0), (this.selectionChanged = !1);
  }
  delayAndroidKey(e, n) {
    var s;
    if (!this.delayedAndroidKey) {
      let o = () => {
        let a = this.delayedAndroidKey;
        a &&
          (this.clearDelayedAndroidKey(),
          (this.view.inputState.lastKeyCode = a.keyCode),
          (this.view.inputState.lastKeyTime = Date.now()),
          !this.flush() && a.force && dispatchKey(this.dom, a.key, a.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(o);
    }
    (!this.delayedAndroidKey || e == 'Enter') &&
      (this.delayedAndroidKey = {
        key: e,
        keyCode: n,
        force:
          this.lastChange < Date.now() - 50 || !!(!((s = this.delayedAndroidKey) === null || s === void 0) && s.force),
      });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1);
  }
  flushSoon() {
    this.delayedFlush < 0 &&
      (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        (this.delayedFlush = -1), this.flush();
      }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), (this.delayedFlush = -1)),
      this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords()) this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1,
      s = -1,
      o = !1;
    for (let a of e) {
      let l = this.readMutation(a);
      l &&
        (l.typeOver && (o = !0),
        n == -1 ? ({ from: n, to: s } = l) : ((n = Math.min(l.from, n)), (s = Math.max(l.to, s))));
    }
    return { from: n, to: s, typeOver: o };
  }
  readChange() {
    let { from: e, to: n, typeOver: s } = this.processRecords(),
      o = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (e < 0 && !o) return null;
    e > -1 && (this.lastChange = Date.now()), (this.view.inputState.lastFocusTime = 0), (this.selectionChanged = !1);
    let a = new DOMChange(this.view, e, n, s);
    return (this.view.docView.domChanged = { newSel: a.newSel ? a.newSel.main : null }), a;
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n) return !1;
    let s = this.view.state,
      o = applyDOMChange(this.view, n);
    return this.view.state == s && this.view.update([]), o;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e)) return null;
    if ((n.markDirty(e.type == 'attributes'), e.type == 'attributes' && (n.flags |= 4), e.type == 'childList')) {
      let s = findChild(n, e.previousSibling || e.target.previousSibling, -1),
        o = findChild(n, e.nextSibling || e.target.nextSibling, 1);
      return { from: s ? n.posAfter(s) : n.posAtStart, to: o ? n.posBefore(o) : n.posAtEnd, typeOver: !1 };
    } else
      return e.type == 'characterData'
        ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }
        : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), (this.win = e), this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener('resize', this.onResize),
      e.addEventListener('beforeprint', this.onPrint),
      e.addEventListener('scroll', this.onScroll),
      e.document.addEventListener('selectionchange', this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener('scroll', this.onScroll),
      e.removeEventListener('resize', this.onResize),
      e.removeEventListener('beforeprint', this.onPrint),
      e.document.removeEventListener('selectionchange', this.onSelectionChange);
  }
  destroy() {
    var e, n, s, o;
    this.stop(),
      (e = this.intersection) === null || e === void 0 || e.disconnect(),
      (n = this.gapIntersection) === null || n === void 0 || n.disconnect(),
      (s = this.resizeScroll) === null || s === void 0 || s.disconnect(),
      (o = this.resizeContent) === null || o === void 0 || o.disconnect();
    for (let a of this.scrollTargets) a.removeEventListener('scroll', this.onScroll);
    this.removeWindowListeners(this.win),
      clearTimeout(this.parentCheck),
      clearTimeout(this.resizeTimeout),
      this.win.cancelAnimationFrame(this.delayedFlush),
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function findChild(r, e, n) {
  for (; e; ) {
    let s = ContentView.get(e);
    if (s && s.parent == r) return s;
    let o = e.parentNode;
    e = o != r.dom ? o : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(r) {
  let e = null;
  function n(m) {
    m.preventDefault(), m.stopImmediatePropagation(), (e = m.getTargetRanges()[0]);
  }
  if (
    (r.contentDOM.addEventListener('beforeinput', n, !0),
    r.dom.ownerDocument.execCommand('indent'),
    r.contentDOM.removeEventListener('beforeinput', n, !0),
    !e)
  )
    return null;
  let s = e.startContainer,
    o = e.startOffset,
    a = e.endContainer,
    l = e.endOffset,
    f = r.docView.domAtPos(r.state.selection.main.anchor);
  return (
    isEquivalentPosition(f.node, f.offset, a, l) && ([s, o, a, l] = [a, l, s, o]),
    { anchorNode: s, anchorOffset: o, focusNode: a, focusOffset: l }
  );
}
class EditorView {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(e = {}) {
    (this.plugins = []),
      (this.pluginMap = new Map()),
      (this.editorAttrs = {}),
      (this.contentAttrs = {}),
      (this.bidiCache = []),
      (this.destroyed = !1),
      (this.updateState = 2),
      (this.measureScheduled = -1),
      (this.measureRequests = []),
      (this.contentDOM = document.createElement('div')),
      (this.scrollDOM = document.createElement('div')),
      (this.scrollDOM.tabIndex = -1),
      (this.scrollDOM.className = 'cm-scroller'),
      this.scrollDOM.appendChild(this.contentDOM),
      (this.announceDOM = document.createElement('div')),
      (this.announceDOM.style.cssText = 'position: fixed; top: -10000px'),
      this.announceDOM.setAttribute('aria-live', 'polite'),
      (this.dom = document.createElement('div')),
      this.dom.appendChild(this.announceDOM),
      this.dom.appendChild(this.scrollDOM);
    let { dispatch: n } = e;
    (this.dispatchTransactions =
      e.dispatchTransactions || (n && ((s) => s.forEach((o) => n(o, this)))) || ((s) => this.update(s))),
      (this.dispatch = this.dispatch.bind(this)),
      (this._root = e.root || getRoot(e.parent) || document),
      (this.viewState = new ViewState(e.state || EditorState.create(e))),
      (this.plugins = this.state.facet(viewPlugin).map((s) => new PluginInstance(s)));
    for (let s of this.plugins) s.update(this);
    (this.observer = new DOMObserver(this)),
      (this.inputState = new InputState(this)),
      this.inputState.ensureHandlers(this.plugins),
      (this.docView = new DocView(this)),
      this.mountStyles(),
      this.updateAttrs(),
      (this.updateState = 0),
      this.requestMeasure(),
      e.parent && e.parent.appendChild(this.dom);
  }
  dispatch(...e) {
    let n =
      e.length == 1 && e[0] instanceof Transaction
        ? e
        : e.length == 1 && Array.isArray(e[0])
        ? e[0]
        : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  update(e) {
    if (this.updateState != 0)
      throw new Error('Calls to EditorView.update are not allowed while an update is in progress');
    let n = !1,
      s = !1,
      o,
      a = this.state;
    for (let V of e) {
      if (V.startState != a)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      a = V.state;
    }
    if (this.destroyed) {
      this.viewState.state = a;
      return;
    }
    let l = this.hasFocus,
      f = 0,
      m = null;
    e.some((V) => V.annotation(isFocusChange))
      ? ((this.inputState.notifiedFocused = l), (f = 1))
      : l != this.inputState.notifiedFocused &&
        ((this.inputState.notifiedFocused = l), (m = focusChangeTransaction(a, l)), m || (f = 1));
    let v = this.observer.delayedAndroidKey,
      I = null;
    if (
      (v
        ? (this.observer.clearDelayedAndroidKey(),
          (I = this.observer.readChange()),
          ((I && !this.state.doc.eq(a.doc)) || !this.state.selection.eq(a.selection)) && (I = null))
        : this.observer.clear(),
      a.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
    )
      return this.setState(a);
    (o = ViewUpdate.create(this, a, e)), (o.flags |= f);
    let L = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let V of e) {
        if ((L && (L = L.map(V.changes)), V.scrollIntoView)) {
          let { main: se } = V.state.selection;
          L = new ScrollTarget(se.empty ? se : EditorSelection.cursor(se.head, se.head > se.anchor ? -1 : 1));
        }
        for (let se of V.effects) se.is(scrollIntoView$1) && (L = se.value);
      }
      this.viewState.update(o, L),
        (this.bidiCache = CachedOrder.update(this.bidiCache, o.changes)),
        o.empty || (this.updatePlugins(o), this.inputState.update(o)),
        (n = this.docView.update(o)),
        this.state.facet(styleModule) != this.styleModules && this.mountStyles(),
        (s = this.updateAttrs()),
        this.showAnnouncements(e),
        this.docView.updateSelection(
          n,
          e.some((V) => V.isUserEvent('select.pointer')),
        );
    } finally {
      this.updateState = 0;
    }
    if (
      (o.startState.facet(theme$1) != o.state.facet(theme$1) && (this.viewState.mustMeasureContent = !0),
      (n || s || L || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) &&
        this.requestMeasure(),
      !o.empty)
    )
      for (let V of this.state.facet(updateListener)) V(o);
    (m || I) &&
      Promise.resolve().then(() => {
        m && this.state == m.startState && this.dispatch(m),
          I && !applyDOMChange(this, I) && v.force && dispatchKey(this.contentDOM, v.key, v.keyCode);
      });
  }
  setState(e) {
    if (this.updateState != 0)
      throw new Error('Calls to EditorView.setState are not allowed while an update is in progress');
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let s of this.plugins) s.destroy(this);
      (this.viewState = new ViewState(e)),
        (this.plugins = e.facet(viewPlugin).map((s) => new PluginInstance(s))),
        this.pluginMap.clear();
      for (let s of this.plugins) s.update(this);
      (this.docView = new DocView(this)),
        this.inputState.ensureHandlers(this.plugins),
        this.mountStyles(),
        this.updateAttrs(),
        (this.bidiCache = []);
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(viewPlugin),
      s = e.state.facet(viewPlugin);
    if (n != s) {
      let o = [];
      for (let a of s) {
        let l = n.indexOf(a);
        if (l < 0) o.push(new PluginInstance(a));
        else {
          let f = this.plugins[l];
          (f.mustUpdate = e), o.push(f);
        }
      }
      for (let a of this.plugins) a.mustUpdate != e && a.destroy(this);
      (this.plugins = o), this.pluginMap.clear();
    } else for (let o of this.plugins) o.mustUpdate = e;
    for (let o = 0; o < this.plugins.length; o++) this.plugins[o].update(this);
    n != s && this.inputState.ensureHandlers(this.plugins);
  }
  measure(e = !0) {
    if (this.destroyed) return;
    if (
      (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
      this.observer.delayedAndroidKey)
    ) {
      (this.measureScheduled = -1), this.requestMeasure();
      return;
    }
    (this.measureScheduled = 0), e && this.observer.forceFlush();
    let n = null,
      s = this.scrollDOM,
      o = s.scrollTop * this.scaleY,
      { scrollAnchorPos: a, scrollAnchorHeight: l } = this.viewState;
    Math.abs(o - this.viewState.scrollTop) > 1 && (l = -1), (this.viewState.scrollAnchorHeight = -1);
    try {
      for (let f = 0; ; f++) {
        if (l < 0)
          if (isScrolledToBottom(s)) (a = -1), (l = this.viewState.heightMap.height);
          else {
            let se = this.viewState.scrollAnchorAt(o);
            (a = se.from), (l = se.top);
          }
        this.updateState = 1;
        let m = this.viewState.measure(this);
        if (!m && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
        if (f > 5) {
          console.warn(
            this.measureRequests.length ? 'Measure loop restarted more than 5 times' : 'Viewport failed to stabilize',
          );
          break;
        }
        let v = [];
        m & 4 || ([this.measureRequests, v] = [v, this.measureRequests]);
        let I = v.map((se) => {
            try {
              return se.read(this);
            } catch (Ee) {
              return logException(this.state, Ee), BadMeasure;
            }
          }),
          L = ViewUpdate.create(this, this.state, []),
          V = !1;
        (L.flags |= m),
          n ? (n.flags |= m) : (n = L),
          (this.updateState = 2),
          L.empty ||
            (this.updatePlugins(L), this.inputState.update(L), this.updateAttrs(), (V = this.docView.update(L)));
        for (let se = 0; se < v.length; se++)
          if (I[se] != BadMeasure)
            try {
              let Ee = v[se];
              Ee.write && Ee.write(I[se], this);
            } catch (Ee) {
              logException(this.state, Ee);
            }
        if ((V && this.docView.updateSelection(!0), !L.viewportChanged && this.measureRequests.length == 0)) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), (this.viewState.scrollTarget = null);
              continue;
            } else {
              let Ee = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - l;
              if (Ee > 1 || Ee < -1) {
                (o = o + Ee), (s.scrollTop = o / this.scaleY), (l = -1);
                continue;
              }
            }
          break;
        }
      }
    } finally {
      (this.updateState = 0), (this.measureScheduled = -1);
    }
    if (n && !n.empty) for (let f of this.state.facet(updateListener)) f(n);
  }
  get themeClasses() {
    return (
      baseThemeID + ' ' + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + ' ' + this.state.facet(theme$1)
    );
  }
  updateAttrs() {
    let e = attrsFromFacet(this, editorAttributes, {
        class: 'cm-editor' + (this.hasFocus ? ' cm-focused ' : ' ') + this.themeClasses,
      }),
      n = {
        'spellcheck': 'false',
        'autocorrect': 'off',
        'autocapitalize': 'off',
        'translate': 'no',
        'contenteditable': this.state.facet(editable) ? 'true' : 'false',
        'class': 'cm-content',
        'style': `${browser.tabSize}: ${this.state.tabSize}`,
        'role': 'textbox',
        'aria-multiline': 'true',
      };
    this.state.readOnly && (n['aria-readonly'] = 'true'), attrsFromFacet(this, contentAttributes, n);
    let s = this.observer.ignore(() => {
      let o = updateAttrs(this.contentDOM, this.contentAttrs, n),
        a = updateAttrs(this.dom, this.editorAttrs, e);
      return o || a;
    });
    return (this.editorAttrs = e), (this.contentAttrs = n), s;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let s of e)
      for (let o of s.effects)
        if (o.is(EditorView.announce)) {
          n && (this.announceDOM.textContent = ''), (n = !1);
          let a = this.announceDOM.appendChild(document.createElement('div'));
          a.textContent = o.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let e = this.state.facet(EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$3).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(e) {
    if (
      (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e)
    ) {
      if (this.measureRequests.indexOf(e) > -1) return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (
      (n === void 0 || (n && n.spec != e)) &&
        this.pluginMap.set(e, (n = this.plugins.find((s) => s.spec == e) || null)),
      n && n.update(this).value
    );
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(e, n, s) {
    return skipAtoms(this, e, moveByChar(this, e, n, s));
  }
  moveByGroup(e, n) {
    return skipAtoms(
      this,
      e,
      moveByChar(this, e, n, (s) => byGroup(this, e.head, s)),
    );
  }
  moveToLineBoundary(e, n, s = !0) {
    return moveToLineBoundary(this, e, n, s);
  }
  moveVertically(e, n, s) {
    return skipAtoms(this, e, moveVertically(this, e, n, s));
  }
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), posAtCoords(this, e, n);
  }
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let s = this.docView.coordsAt(e, n);
    if (!s || s.left == s.right) return s;
    let o = this.state.doc.lineAt(e),
      a = this.bidiSpans(o),
      l = a[BidiSpan.find(a, e - o.from, -1, n)];
    return flattenRect(s, (l.dir == Direction.LTR) == n > 0);
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(e) {
    return !this.state.facet(perLineTextDirection) || e < this.viewport.from || e > this.viewport.to
      ? this.textDirection
      : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(e) {
    if (e.length > MaxBidiLine) return trivialOrder(e.length);
    let n = this.textDirectionAt(e.from),
      s;
    for (let a of this.bidiCache)
      if (
        a.from == e.from &&
        a.dir == n &&
        (a.fresh || isolatesEq(a.isolates, (s = getIsolatedRanges(this, e.from, e.to))))
      )
        return a.order;
    s || (s = getIsolatedRanges(this, e.from, e.to));
    let o = computeOrder(e.text, n, s);
    return this.bidiCache.push(new CachedOrder(e.from, e.to, n, s, !0, o)), o;
  }
  get hasFocus() {
    var e;
    return (
      (this.dom.ownerDocument.hasFocus() ||
        (browser.safari &&
          ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4)) &&
      this.root.activeElement == this.contentDOM
    );
  }
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(e) {
    this._root != e &&
      ((this._root = e),
      this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window),
      this.mountStyles());
  }
  destroy() {
    for (let e of this.plugins) e.destroy(this);
    (this.plugins = []),
      this.inputState.destroy(),
      this.dom.remove(),
      this.observer.destroy(),
      this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
      (this.destroyed = !0);
  }
  static scrollIntoView(e, n = {}) {
    return scrollIntoView$1.of(
      new ScrollTarget(typeof e == 'number' ? EditorSelection.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin),
    );
  }
  static domEventHandlers(e) {
    return ViewPlugin.define(() => ({}), { eventHandlers: e });
  }
  static domEventObservers(e) {
    return ViewPlugin.define(() => ({}), { eventObservers: e });
  }
  static theme(e, n) {
    let s = StyleModule.newName(),
      o = [theme$1.of(s), styleModule.of(buildTheme(`.${s}`, e))];
    return n && n.dark && o.push(darkTheme.of(!0)), o;
  }
  static baseTheme(e) {
    return Prec.lowest(styleModule.of(buildTheme('.' + baseThemeID, e, lightDarkIDs)));
  }
  static findFromDOM(e) {
    var n;
    let s = e.querySelector('.cm-content'),
      o = (s && ContentView.get(s)) || ContentView.get(e);
    return ((n = o == null ? void 0 : o.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler$1;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = Facet.define({ combine: (r) => (r.length ? r[0] : '') });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = EditorView.contentAttributes.of({ class: 'cm-lineWrapping' });
EditorView.announce = StateEffect.define();
const MaxBidiLine = 4096,
  BadMeasure = {};
class CachedOrder {
  constructor(e, n, s, o, a, l) {
    (this.from = e), (this.to = n), (this.dir = s), (this.isolates = o), (this.fresh = a), (this.order = l);
  }
  static update(e, n) {
    if (n.empty && !e.some((a) => a.fresh)) return e;
    let s = [],
      o = e.length ? e[e.length - 1].dir : Direction.LTR;
    for (let a = Math.max(0, e.length - 10); a < e.length; a++) {
      let l = e[a];
      l.dir == o &&
        !n.touchesRange(l.from, l.to) &&
        s.push(new CachedOrder(n.mapPos(l.from, 1), n.mapPos(l.to, -1), l.dir, l.isolates, !1, l.order));
    }
    return s;
  }
}
function attrsFromFacet(r, e, n) {
  for (let s = r.state.facet(e), o = s.length - 1; o >= 0; o--) {
    let a = s[o],
      l = typeof a == 'function' ? a(r) : a;
    l && combineAttrs(l, n);
  }
  return n;
}
const currentPlatform = browser.mac ? 'mac' : browser.windows ? 'win' : browser.linux ? 'linux' : 'key';
function normalizeKeyName(r, e) {
  const n = r.split(/-(?!$)/);
  let s = n[n.length - 1];
  s == 'Space' && (s = ' ');
  let o, a, l, f;
  for (let m = 0; m < n.length - 1; ++m) {
    const v = n[m];
    if (/^(cmd|meta|m)$/i.test(v)) f = !0;
    else if (/^a(lt)?$/i.test(v)) o = !0;
    else if (/^(c|ctrl|control)$/i.test(v)) a = !0;
    else if (/^s(hift)?$/i.test(v)) l = !0;
    else if (/^mod$/i.test(v)) e == 'mac' ? (f = !0) : (a = !0);
    else throw new Error('Unrecognized modifier name: ' + v);
  }
  return o && (s = 'Alt-' + s), a && (s = 'Ctrl-' + s), f && (s = 'Meta-' + s), l && (s = 'Shift-' + s), s;
}
function modifiers(r, e, n) {
  return (
    e.altKey && (r = 'Alt-' + r),
    e.ctrlKey && (r = 'Ctrl-' + r),
    e.metaKey && (r = 'Meta-' + r),
    n !== !1 && e.shiftKey && (r = 'Shift-' + r),
    r
  );
}
const handleKeyEvents = Prec.default(
    EditorView.domEventHandlers({
      keydown(r, e) {
        return runHandlers(getKeymap(e.state), r, e, 'editor');
      },
    }),
  ),
  keymap = Facet.define({ enables: handleKeyEvents }),
  Keymaps = new WeakMap();
function getKeymap(r) {
  let e = r.facet(keymap),
    n = Keymaps.get(e);
  return n || Keymaps.set(e, (n = buildKeymap(e.reduce((s, o) => s.concat(o), [])))), n;
}
function runScopeHandlers(r, e, n) {
  return runHandlers(getKeymap(r.state), e, r, n);
}
let storedPrefix = null;
const PrefixTimeout = 4e3;
function buildKeymap(r, e = currentPlatform) {
  let n = Object.create(null),
    s = Object.create(null),
    o = (l, f) => {
      let m = s[l];
      if (m == null) s[l] = f;
      else if (m != f)
        throw new Error('Key binding ' + l + ' is used both as a regular binding and as a multi-stroke prefix');
    },
    a = (l, f, m, v, I) => {
      var L, V;
      let se = n[l] || (n[l] = Object.create(null)),
        Ee = f.split(/ (?!$)/).map(($i) => normalizeKeyName($i, e));
      for (let $i = 1; $i < Ee.length; $i++) {
        let tl = Ee.slice(0, $i).join(' ');
        o(tl, !0),
          se[tl] ||
            (se[tl] = {
              preventDefault: !0,
              stopPropagation: !1,
              run: [
                (Wi) => {
                  let hl = (storedPrefix = { view: Wi, prefix: tl, scope: l });
                  return (
                    setTimeout(() => {
                      storedPrefix == hl && (storedPrefix = null);
                    }, PrefixTimeout),
                    !0
                  );
                },
              ],
            });
      }
      let ht = Ee.join(' ');
      o(ht, !1);
      let ar =
        se[ht] ||
        (se[ht] = {
          preventDefault: !1,
          stopPropagation: !1,
          run:
            ((V = (L = se._any) === null || L === void 0 ? void 0 : L.run) === null || V === void 0
              ? void 0
              : V.slice()) || [],
        });
      m && ar.run.push(m), v && (ar.preventDefault = !0), I && (ar.stopPropagation = !0);
    };
  for (let l of r) {
    let f = l.scope ? l.scope.split(' ') : ['editor'];
    if (l.any)
      for (let v of f) {
        let I = n[v] || (n[v] = Object.create(null));
        I._any || (I._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let L in I) I[L].run.push(l.any);
      }
    let m = l[e] || l.key;
    if (m)
      for (let v of f)
        a(v, m, l.run, l.preventDefault, l.stopPropagation),
          l.shift && a(v, 'Shift-' + m, l.shift, l.preventDefault, l.stopPropagation);
  }
  return n;
}
function runHandlers(r, e, n, s) {
  let o = keyName(e),
    a = codePointAt(o, 0),
    l = codePointSize(a) == o.length && o != ' ',
    f = '',
    m = !1,
    v = !1,
    I = !1;
  storedPrefix &&
    storedPrefix.view == n &&
    storedPrefix.scope == s &&
    ((f = storedPrefix.prefix + ' '), modifierCodes.indexOf(e.keyCode) < 0 && ((v = !0), (storedPrefix = null)));
  let L = new Set(),
    V = (ar) => {
      if (ar) {
        for (let $i of ar.run) if (!L.has($i) && (L.add($i), $i(n, e))) return ar.stopPropagation && (I = !0), !0;
        ar.preventDefault && (ar.stopPropagation && (I = !0), (v = !0));
      }
      return !1;
    },
    se = r[s],
    Ee,
    ht;
  return (
    se &&
      (V(se[f + modifiers(o, e, !l)])
        ? (m = !0)
        : l &&
          (e.altKey || e.metaKey || e.ctrlKey) &&
          !(browser.windows && e.ctrlKey && e.altKey) &&
          (Ee = base[e.keyCode]) &&
          Ee != o
        ? (V(se[f + modifiers(Ee, e, !0)]) ||
            (e.shiftKey && (ht = shift[e.keyCode]) != o && ht != Ee && V(se[f + modifiers(ht, e, !1)]))) &&
          (m = !0)
        : l && e.shiftKey && V(se[f + modifiers(o, e, !0)]) && (m = !0),
      !m && V(se._any) && (m = !0)),
    v && (m = !0),
    m && I && e.stopPropagation(),
    m
  );
}
class RectangleMarker {
  constructor(e, n, s, o, a) {
    (this.className = e), (this.left = n), (this.top = s), (this.width = o), (this.height = a);
  }
  draw() {
    let e = document.createElement('div');
    return (e.className = this.className), this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    (e.style.left = this.left + 'px'),
      (e.style.top = this.top + 'px'),
      this.width != null && (e.style.width = this.width + 'px'),
      (e.style.height = this.height + 'px');
  }
  eq(e) {
    return (
      this.left == e.left &&
      this.top == e.top &&
      this.width == e.width &&
      this.height == e.height &&
      this.className == e.className
    );
  }
  static forRange(e, n, s) {
    if (s.empty) {
      let o = e.coordsAtPos(s.head, s.assoc || 1);
      if (!o) return [];
      let a = getBase(e);
      return [new RectangleMarker(n, o.left - a.left, o.top - a.top, null, o.bottom - o.top)];
    } else return rectanglesForRange(e, n, s);
  }
}
function getBase(r) {
  let e = r.scrollDOM.getBoundingClientRect();
  return {
    left:
      (r.textDirection == Direction.LTR ? e.left : e.right - r.scrollDOM.clientWidth * r.scaleX) -
      r.scrollDOM.scrollLeft * r.scaleX,
    top: e.top - r.scrollDOM.scrollTop * r.scaleY,
  };
}
function wrappedLine(r, e, n) {
  let s = EditorSelection.cursor(e);
  return {
    from: Math.max(n.from, r.moveToLineBoundary(s, !1, !0).from),
    to: Math.min(n.to, r.moveToLineBoundary(s, !0, !0).from),
    type: BlockType.Text,
  };
}
function rectanglesForRange(r, e, n) {
  if (n.to <= r.viewport.from || n.from >= r.viewport.to) return [];
  let s = Math.max(n.from, r.viewport.from),
    o = Math.min(n.to, r.viewport.to),
    a = r.textDirection == Direction.LTR,
    l = r.contentDOM,
    f = l.getBoundingClientRect(),
    m = getBase(r),
    v = l.querySelector('.cm-line'),
    I = v && window.getComputedStyle(v),
    L = f.left + (I ? parseInt(I.paddingLeft) + Math.min(0, parseInt(I.textIndent)) : 0),
    V = f.right - (I ? parseInt(I.paddingRight) : 0),
    se = blockAt(r, s),
    Ee = blockAt(r, o),
    ht = se.type == BlockType.Text ? se : null,
    ar = Ee.type == BlockType.Text ? Ee : null;
  if (
    (ht && (r.lineWrapping || se.widgetLineBreaks) && (ht = wrappedLine(r, s, ht)),
    ar && (r.lineWrapping || Ee.widgetLineBreaks) && (ar = wrappedLine(r, o, ar)),
    ht && ar && ht.from == ar.from)
  )
    return tl(Wi(n.from, n.to, ht));
  {
    let fl = ht ? Wi(n.from, null, ht) : hl(se, !1),
      dl = ar ? Wi(null, n.to, ar) : hl(Ee, !0),
      Al = [];
    return (
      (ht || se).to < (ar || Ee).from - (ht && ar ? 1 : 0) ||
      (se.widgetLineBreaks > 1 && fl.bottom + r.defaultLineHeight / 2 < dl.top)
        ? Al.push($i(L, fl.bottom, V, dl.top))
        : fl.bottom < dl.top &&
          r.elementAtHeight((fl.bottom + dl.top) / 2).type == BlockType.Text &&
          (fl.bottom = dl.top = (fl.bottom + dl.top) / 2),
      tl(fl).concat(Al).concat(tl(dl))
    );
  }
  function $i(fl, dl, Al, Fl) {
    return new RectangleMarker(e, fl - m.left, dl - m.top - 0.01, Al - fl, Fl - dl + 0.01);
  }
  function tl({ top: fl, bottom: dl, horizontal: Al }) {
    let Fl = [];
    for (let vl = 0; vl < Al.length; vl += 2) Fl.push($i(Al[vl], fl, Al[vl + 1], dl));
    return Fl;
  }
  function Wi(fl, dl, Al) {
    let Fl = 1e9,
      vl = -1e9,
      kl = [];
    function El(Il, Ll, Nl, Hl, Bl) {
      let ql = r.coordsAtPos(Il, Il == Al.to ? -2 : 2),
        Yl = r.coordsAtPos(Nl, Nl == Al.from ? 2 : -2);
      !ql ||
        !Yl ||
        ((Fl = Math.min(ql.top, Yl.top, Fl)),
        (vl = Math.max(ql.bottom, Yl.bottom, vl)),
        Bl == Direction.LTR
          ? kl.push(a && Ll ? L : ql.left, a && Hl ? V : Yl.right)
          : kl.push(!a && Hl ? L : Yl.left, !a && Ll ? V : ql.right));
    }
    let Jl = fl ?? Al.from,
      Kc = dl ?? Al.to;
    for (let Il of r.visibleRanges)
      if (Il.to > Jl && Il.from < Kc)
        for (let Ll = Math.max(Il.from, Jl), Nl = Math.min(Il.to, Kc); ; ) {
          let Hl = r.state.doc.lineAt(Ll);
          for (let Bl of r.bidiSpans(Hl)) {
            let ql = Bl.from + Hl.from,
              Yl = Bl.to + Hl.from;
            if (ql >= Nl) break;
            Yl > Ll && El(Math.max(ql, Ll), fl == null && ql <= Jl, Math.min(Yl, Nl), dl == null && Yl >= Kc, Bl.dir);
          }
          if (((Ll = Hl.to + 1), Ll >= Nl)) break;
        }
    return (
      kl.length == 0 && El(Jl, fl == null, Kc, dl == null, r.textDirection), { top: Fl, bottom: vl, horizontal: kl }
    );
  }
  function hl(fl, dl) {
    let Al = f.top + (dl ? fl.top : fl.bottom);
    return { top: Al, bottom: Al, horizontal: [] };
  }
}
function sameMarker(r, e) {
  return r.constructor == e.constructor && r.eq(e);
}
class LayerView {
  constructor(e, n) {
    (this.view = e),
      (this.layer = n),
      (this.drawn = []),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }),
      (this.dom = e.scrollDOM.appendChild(document.createElement('div'))),
      this.dom.classList.add('cm-layer'),
      n.above && this.dom.classList.add('cm-layer-above'),
      n.class && this.dom.classList.add(n.class),
      this.scale(),
      this.dom.setAttribute('aria-hidden', 'true'),
      this.setOrder(e.state),
      e.requestMeasure(this.measureReq),
      n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(layerOrder) != e.state.facet(layerOrder) && this.setOrder(e.state),
      (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let n = 0,
      s = e.facet(layerOrder);
    for (; n < s.length && s[n] != this.layer; ) n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) &&
      ((this.scaleX = e), (this.scaleY = n), (this.dom.style.transform = `scale(${1 / e}, ${1 / n})`));
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, s) => !sameMarker(n, this.drawn[s]))) {
      let n = this.dom.firstChild,
        s = 0;
      for (let o of e)
        o.update && n && o.constructor && this.drawn[s].constructor && o.update(n, this.drawn[s])
          ? ((n = n.nextSibling), s++)
          : this.dom.insertBefore(o.draw(), n);
      for (; n; ) {
        let o = n.nextSibling;
        n.remove(), (n = o);
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const layerOrder = Facet.define();
function layer(r) {
  return [ViewPlugin.define((e) => new LayerView(e, r)), layerOrder.of(r)];
}
const CanHidePrimary = !browser.ios,
  selectionConfig = Facet.define({
    combine(r) {
      return combineConfig(
        r,
        { cursorBlinkRate: 1200, drawRangeCursor: !0 },
        { cursorBlinkRate: (e, n) => Math.min(e, n), drawRangeCursor: (e, n) => e || n },
      );
    },
  });
function drawSelection(r = {}) {
  return [selectionConfig.of(r), cursorLayer, selectionLayer, hideNativeSelection, nativeSelectionHidden.of(!0)];
}
function configChanged(r) {
  return r.startState.facet(selectionConfig) != r.state.facet(selectionConfig);
}
const cursorLayer = layer({
  above: !0,
  markers(r) {
    let { state: e } = r,
      n = e.facet(selectionConfig),
      s = [];
    for (let o of e.selection.ranges) {
      let a = o == e.selection.main;
      if (o.empty ? !a || CanHidePrimary : n.drawRangeCursor) {
        let l = a ? 'cm-cursor cm-cursor-primary' : 'cm-cursor cm-cursor-secondary',
          f = o.empty ? o : EditorSelection.cursor(o.head, o.head > o.anchor ? -1 : 1);
        for (let m of RectangleMarker.forRange(r, l, f)) s.push(m);
      }
    }
    return s;
  },
  update(r, e) {
    r.transactions.some((s) => s.selection) &&
      (e.style.animationName = e.style.animationName == 'cm-blink' ? 'cm-blink2' : 'cm-blink');
    let n = configChanged(r);
    return n && setBlinkRate(r.state, e), r.docChanged || r.selectionSet || n;
  },
  mount(r, e) {
    setBlinkRate(e.state, r);
  },
  class: 'cm-cursorLayer',
});
function setBlinkRate(r, e) {
  e.style.animationDuration = r.facet(selectionConfig).cursorBlinkRate + 'ms';
}
const selectionLayer = layer({
    above: !1,
    markers(r) {
      return r.state.selection.ranges
        .map((e) => (e.empty ? [] : RectangleMarker.forRange(r, 'cm-selectionBackground', e)))
        .reduce((e, n) => e.concat(n));
    },
    update(r, e) {
      return r.docChanged || r.selectionSet || r.viewportChanged || configChanged(r);
    },
    class: 'cm-selectionLayer',
  }),
  themeSpec = {
    '.cm-line': {
      '& ::selection': { backgroundColor: 'transparent !important' },
      '&::selection': { backgroundColor: 'transparent !important' },
    },
  };
CanHidePrimary && (themeSpec['.cm-line'].caretColor = 'transparent !important');
const hideNativeSelection = Prec.highest(EditorView.theme(themeSpec)),
  setDropCursorPos = StateEffect.define({
    map(r, e) {
      return r == null ? null : e.mapPos(r);
    },
  }),
  dropCursorPos = StateField.define({
    create() {
      return null;
    },
    update(r, e) {
      return (
        r != null && (r = e.changes.mapPos(r)), e.effects.reduce((n, s) => (s.is(setDropCursorPos) ? s.value : n), r)
      );
    },
  }),
  drawDropCursor = ViewPlugin.fromClass(
    class {
      constructor(r) {
        (this.view = r),
          (this.cursor = null),
          (this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) });
      }
      update(r) {
        var e;
        let n = r.state.field(dropCursorPos);
        n == null
          ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), (this.cursor = null))
          : (this.cursor ||
              ((this.cursor = this.view.scrollDOM.appendChild(document.createElement('div'))),
              (this.cursor.className = 'cm-dropCursor')),
            (r.startState.field(dropCursorPos) != n || r.docChanged || r.geometryChanged) &&
              this.view.requestMeasure(this.measureReq));
      }
      readPos() {
        let { view: r } = this,
          e = r.state.field(dropCursorPos),
          n = e != null && r.coordsAtPos(e);
        if (!n) return null;
        let s = r.scrollDOM.getBoundingClientRect();
        return {
          left: n.left - s.left + r.scrollDOM.scrollLeft * r.scaleX,
          top: n.top - s.top + r.scrollDOM.scrollTop * r.scaleY,
          height: n.bottom - n.top,
        };
      }
      drawCursor(r) {
        if (this.cursor) {
          let { scaleX: e, scaleY: n } = this.view;
          r
            ? ((this.cursor.style.left = r.left / e + 'px'),
              (this.cursor.style.top = r.top / n + 'px'),
              (this.cursor.style.height = r.height / n + 'px'))
            : (this.cursor.style.left = '-100000px');
        }
      }
      destroy() {
        this.cursor && this.cursor.remove();
      }
      setDropPos(r) {
        this.view.state.field(dropCursorPos) != r && this.view.dispatch({ effects: setDropCursorPos.of(r) });
      }
    },
    {
      eventObservers: {
        dragover(r) {
          this.setDropPos(this.view.posAtCoords({ x: r.clientX, y: r.clientY }));
        },
        dragleave(r) {
          (r.target == this.view.contentDOM || !this.view.contentDOM.contains(r.relatedTarget)) &&
            this.setDropPos(null);
        },
        dragend() {
          this.setDropPos(null);
        },
        drop() {
          this.setDropPos(null);
        },
      },
    },
  );
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(r, e, n, s, o) {
  e.lastIndex = 0;
  for (let a = r.iterRange(n, s), l = n, f; !a.next().done; l += a.value.length)
    if (!a.lineBreak) for (; (f = e.exec(a.value)); ) o(l + f.index, f);
}
function matchRanges(r, e) {
  let n = r.visibleRanges;
  if (n.length == 1 && n[0].from == r.viewport.from && n[0].to == r.viewport.to) return n;
  let s = [];
  for (let { from: o, to: a } of n)
    (o = Math.max(r.state.doc.lineAt(o).from, o - e)),
      (a = Math.min(r.state.doc.lineAt(a).to, a + e)),
      s.length && s[s.length - 1].to >= o ? (s[s.length - 1].to = a) : s.push({ from: o, to: a });
  return s;
}
class MatchDecorator {
  constructor(e) {
    const { regexp: n, decoration: s, decorate: o, boundary: a, maxLength: l = 1e3 } = e;
    if (!n.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (((this.regexp = n), o)) this.addMatch = (f, m, v, I) => o(I, v, v + f[0].length, f, m);
    else if (typeof s == 'function')
      this.addMatch = (f, m, v, I) => {
        let L = s(f, m, v);
        L && I(v, v + f[0].length, L);
      };
    else if (s) this.addMatch = (f, m, v, I) => I(v, v + f[0].length, s);
    else throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    (this.boundary = a), (this.maxLength = l);
  }
  createDeco(e) {
    let n = new RangeSetBuilder(),
      s = n.add.bind(n);
    for (let { from: o, to: a } of matchRanges(e, this.maxLength))
      iterMatches(e.state.doc, this.regexp, o, a, (l, f) => this.addMatch(f, e, l, s));
    return n.finish();
  }
  updateDeco(e, n) {
    let s = 1e9,
      o = -1;
    return (
      e.docChanged &&
        e.changes.iterChanges((a, l, f, m) => {
          m > e.view.viewport.from && f < e.view.viewport.to && ((s = Math.min(f, s)), (o = Math.max(m, o)));
        }),
      e.viewportChanged || o - s > 1e3
        ? this.createDeco(e.view)
        : o > -1
        ? this.updateRange(e.view, n.map(e.changes), s, o)
        : n
    );
  }
  updateRange(e, n, s, o) {
    for (let a of e.visibleRanges) {
      let l = Math.max(a.from, s),
        f = Math.min(a.to, o);
      if (f > l) {
        let m = e.state.doc.lineAt(l),
          v = m.to < f ? e.state.doc.lineAt(f) : m,
          I = Math.max(a.from, m.from),
          L = Math.min(a.to, v.to);
        if (this.boundary) {
          for (; l > m.from; l--)
            if (this.boundary.test(m.text[l - 1 - m.from])) {
              I = l;
              break;
            }
          for (; f < v.to; f++)
            if (this.boundary.test(v.text[f - v.from])) {
              L = f;
              break;
            }
        }
        let V = [],
          se,
          Ee = (ht, ar, $i) => V.push($i.range(ht, ar));
        if (m == v)
          for (this.regexp.lastIndex = I - m.from; (se = this.regexp.exec(m.text)) && se.index < L - m.from; )
            this.addMatch(se, e, se.index + m.from, Ee);
        else iterMatches(e.state.doc, this.regexp, I, L, (ht, ar) => this.addMatch(ar, e, ht, Ee));
        n = n.update({ filterFrom: I, filterTo: L, filter: (ht, ar) => ht < I || ar > L, add: V });
      }
    }
    return n;
  }
}
const UnicodeRegexpSupport = /x/.unicode != null ? 'gu' : 'g',
  Specials = new RegExp(
    `[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`,
    UnicodeRegexpSupport,
  ),
  Names = {
    0: 'null',
    7: 'bell',
    8: 'backspace',
    10: 'newline',
    11: 'vertical tab',
    13: 'carriage return',
    27: 'escape',
    8203: 'zero width space',
    8204: 'zero width non-joiner',
    8205: 'zero width joiner',
    8206: 'left-to-right mark',
    8207: 'right-to-left mark',
    8232: 'line separator',
    8237: 'left-to-right override',
    8238: 'right-to-left override',
    8294: 'left-to-right isolate',
    8295: 'right-to-left isolate',
    8297: 'pop directional isolate',
    8233: 'paragraph separator',
    65279: 'zero width no-break space',
    65532: 'object replacement',
  };
let _supportsTabSize = null;
function supportsTabSize() {
  var r;
  if (_supportsTabSize == null && typeof document < 'u' && document.body) {
    let e = document.body.style;
    _supportsTabSize = ((r = e.tabSize) !== null && r !== void 0 ? r : e.MozTabSize) != null;
  }
  return _supportsTabSize || !1;
}
const specialCharConfig = Facet.define({
  combine(r) {
    let e = combineConfig(r, { render: null, specialChars: Specials, addSpecialChars: null });
    return (
      (e.replaceTabs = !supportsTabSize()) &&
        (e.specialChars = new RegExp('	|' + e.specialChars.source, UnicodeRegexpSupport)),
      e.addSpecialChars &&
        (e.specialChars = new RegExp(e.specialChars.source + '|' + e.addSpecialChars.source, UnicodeRegexpSupport)),
      e
    );
  },
});
function highlightSpecialChars(r = {}) {
  return [specialCharConfig.of(r), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
  return (
    _plugin ||
    (_plugin = ViewPlugin.fromClass(
      class {
        constructor(r) {
          (this.view = r),
            (this.decorations = Decoration.none),
            (this.decorationCache = Object.create(null)),
            (this.decorator = this.makeDecorator(r.state.facet(specialCharConfig))),
            (this.decorations = this.decorator.createDeco(r));
        }
        makeDecorator(r) {
          return new MatchDecorator({
            regexp: r.specialChars,
            decoration: (e, n, s) => {
              let { doc: o } = n.state,
                a = codePointAt(e[0], 0);
              if (a == 9) {
                let l = o.lineAt(s),
                  f = n.state.tabSize,
                  m = countColumn(l.text, f, s - l.from);
                return Decoration.replace({
                  widget: new TabWidget(((f - (m % f)) * this.view.defaultCharacterWidth) / this.view.scaleX),
                });
              }
              return (
                this.decorationCache[a] ||
                (this.decorationCache[a] = Decoration.replace({ widget: new SpecialCharWidget(r, a) }))
              );
            },
            boundary: r.replaceTabs ? void 0 : /[^]/,
          });
        }
        update(r) {
          let e = r.state.facet(specialCharConfig);
          r.startState.facet(specialCharConfig) != e
            ? ((this.decorator = this.makeDecorator(e)), (this.decorations = this.decorator.createDeco(r.view)))
            : (this.decorations = this.decorator.updateDeco(r, this.decorations));
        }
      },
      { decorations: (r) => r.decorations },
    ))
  );
}
const DefaultPlaceholder = '•';
function placeholder$1(r) {
  return r >= 32 ? DefaultPlaceholder : r == 10 ? '␤' : String.fromCharCode(9216 + r);
}
class SpecialCharWidget extends WidgetType {
  constructor(e, n) {
    super(), (this.options = e), (this.code = n);
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = placeholder$1(this.code),
      s = e.state.phrase('Control character') + ' ' + (Names[this.code] || '0x' + this.code.toString(16)),
      o = this.options.render && this.options.render(this.code, s, n);
    if (o) return o;
    let a = document.createElement('span');
    return (a.textContent = n), (a.title = s), a.setAttribute('aria-label', s), (a.className = 'cm-specialChar'), a;
  }
  ignoreEvent() {
    return !1;
  }
}
class TabWidget extends WidgetType {
  constructor(e) {
    super(), (this.width = e);
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement('span');
    return (e.textContent = '	'), (e.className = 'cm-tab'), (e.style.width = this.width + 'px'), e;
  }
  ignoreEvent() {
    return !1;
  }
}
function highlightActiveLine() {
  return activeLineHighlighter;
}
const lineDeco = Decoration.line({ class: 'cm-activeLine' }),
  activeLineHighlighter = ViewPlugin.fromClass(
    class {
      constructor(r) {
        this.decorations = this.getDeco(r);
      }
      update(r) {
        (r.docChanged || r.selectionSet) && (this.decorations = this.getDeco(r.view));
      }
      getDeco(r) {
        let e = -1,
          n = [];
        for (let s of r.state.selection.ranges) {
          let o = r.lineBlockAt(s.head);
          o.from > e && (n.push(lineDeco.range(o.from)), (e = o.from));
        }
        return Decoration.set(n);
      }
    },
    { decorations: (r) => r.decorations },
  );
class Placeholder extends WidgetType {
  constructor(e) {
    super(), (this.content = e);
  }
  toDOM() {
    let e = document.createElement('span');
    return (
      (e.className = 'cm-placeholder'),
      (e.style.pointerEvents = 'none'),
      e.appendChild(typeof this.content == 'string' ? document.createTextNode(this.content) : this.content),
      typeof this.content == 'string'
        ? e.setAttribute('aria-label', 'placeholder ' + this.content)
        : e.setAttribute('aria-hidden', 'true'),
      e
    );
  }
  coordsAt(e) {
    let n = e.firstChild ? clientRectsFor(e.firstChild) : [];
    if (!n.length) return null;
    let s = window.getComputedStyle(e.parentNode),
      o = flattenRect(n[0], s.direction != 'rtl'),
      a = parseInt(s.lineHeight);
    return o.bottom - o.top > a * 1.5 ? { left: o.left, right: o.right, top: o.top, bottom: o.top + a } : o;
  }
  ignoreEvent() {
    return !1;
  }
}
function placeholder(r) {
  return ViewPlugin.fromClass(
    class {
      constructor(e) {
        (this.view = e),
          (this.placeholder = r
            ? Decoration.set([Decoration.widget({ widget: new Placeholder(r), side: 1 }).range(0)])
            : Decoration.none);
      }
      get decorations() {
        return this.view.state.doc.length ? Decoration.none : this.placeholder;
      }
    },
    { decorations: (e) => e.decorations },
  );
}
const MaxOff = 2e3;
function rectangleFor(r, e, n) {
  let s = Math.min(e.line, n.line),
    o = Math.max(e.line, n.line),
    a = [];
  if (e.off > MaxOff || n.off > MaxOff || e.col < 0 || n.col < 0) {
    let l = Math.min(e.off, n.off),
      f = Math.max(e.off, n.off);
    for (let m = s; m <= o; m++) {
      let v = r.doc.line(m);
      v.length <= f && a.push(EditorSelection.range(v.from + l, v.to + f));
    }
  } else {
    let l = Math.min(e.col, n.col),
      f = Math.max(e.col, n.col);
    for (let m = s; m <= o; m++) {
      let v = r.doc.line(m),
        I = findColumn(v.text, l, r.tabSize, !0);
      if (I < 0) a.push(EditorSelection.cursor(v.to));
      else {
        let L = findColumn(v.text, f, r.tabSize);
        a.push(EditorSelection.range(v.from + I, v.from + L));
      }
    }
  }
  return a;
}
function absoluteColumn(r, e) {
  let n = r.coordsAtPos(r.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / r.defaultCharacterWidth)) : -1;
}
function getPos(r, e) {
  let n = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    s = r.state.doc.lineAt(n),
    o = n - s.from,
    a =
      o > MaxOff ? -1 : o == s.length ? absoluteColumn(r, e.clientX) : countColumn(s.text, r.state.tabSize, n - s.from);
  return { line: s.number, col: a, off: o };
}
function rectangleSelectionStyle(r, e) {
  let n = getPos(r, e),
    s = r.state.selection;
  return n
    ? {
        update(o) {
          if (o.docChanged) {
            let a = o.changes.mapPos(o.startState.doc.line(n.line).from),
              l = o.state.doc.lineAt(a);
            (n = { line: l.number, col: n.col, off: Math.min(n.off, l.length) }), (s = s.map(o.changes));
          }
        },
        get(o, a, l) {
          let f = getPos(r, o);
          if (!f) return s;
          let m = rectangleFor(r.state, n, f);
          return m.length ? (l ? EditorSelection.create(m.concat(s.ranges)) : EditorSelection.create(m)) : s;
        },
      }
    : null;
}
function rectangularSelection(r) {
  let e = (r == null ? void 0 : r.eventFilter) || ((n) => n.altKey && n.button == 0);
  return EditorView.mouseSelectionStyle.of((n, s) => (e(s) ? rectangleSelectionStyle(n, s) : null));
}
const keys = {
    Alt: [18, (r) => !!r.altKey],
    Control: [17, (r) => !!r.ctrlKey],
    Shift: [16, (r) => !!r.shiftKey],
    Meta: [91, (r) => !!r.metaKey],
  },
  showCrosshair = { style: 'cursor: crosshair' };
function crosshairCursor(r = {}) {
  let [e, n] = keys[r.key || 'Alt'],
    s = ViewPlugin.fromClass(
      class {
        constructor(o) {
          (this.view = o), (this.isDown = !1);
        }
        set(o) {
          this.isDown != o && ((this.isDown = o), this.view.update([]));
        }
      },
      {
        eventObservers: {
          keydown(o) {
            this.set(o.keyCode == e || n(o));
          },
          keyup(o) {
            (o.keyCode == e || !n(o)) && this.set(!1);
          },
          mousemove(o) {
            this.set(n(o));
          },
        },
      },
    );
  return [
    s,
    EditorView.contentAttributes.of((o) => {
      var a;
      return !((a = o.plugin(s)) === null || a === void 0) && a.isDown ? showCrosshair : null;
    }),
  ];
}
const Outside = '-10000px';
class TooltipViewManager {
  constructor(e, n, s) {
    (this.facet = n),
      (this.createTooltipView = s),
      (this.input = e.state.facet(n)),
      (this.tooltips = this.input.filter((o) => o)),
      (this.tooltipViews = this.tooltips.map(s));
  }
  update(e) {
    var n;
    let s = e.state.facet(this.facet),
      o = s.filter((l) => l);
    if (s === this.input) {
      for (let l of this.tooltipViews) l.update && l.update(e);
      return !1;
    }
    let a = [];
    for (let l = 0; l < o.length; l++) {
      let f = o[l],
        m = -1;
      if (f) {
        for (let v = 0; v < this.tooltips.length; v++) {
          let I = this.tooltips[v];
          I && I.create == f.create && (m = v);
        }
        if (m < 0) a[l] = this.createTooltipView(f);
        else {
          let v = (a[l] = this.tooltipViews[m]);
          v.update && v.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (l.dom.remove(), (n = l.destroy) === null || n === void 0 || n.call(l));
    return (this.input = s), (this.tooltips = o), (this.tooltipViews = a), !0;
  }
}
function windowSpace(r) {
  let { win: e } = r;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const tooltipConfig = Facet.define({
    combine: (r) => {
      var e, n, s;
      return {
        position: browser.ios
          ? 'absolute'
          : ((e = r.find((o) => o.position)) === null || e === void 0 ? void 0 : e.position) || 'fixed',
        parent: ((n = r.find((o) => o.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
        tooltipSpace:
          ((s = r.find((o) => o.tooltipSpace)) === null || s === void 0 ? void 0 : s.tooltipSpace) || windowSpace,
      };
    },
  }),
  knownHeight = new WeakMap(),
  tooltipPlugin = ViewPlugin.fromClass(
    class {
      constructor(r) {
        (this.view = r),
          (this.inView = !0),
          (this.madeAbsolute = !1),
          (this.lastTransaction = 0),
          (this.measureTimeout = -1);
        let e = r.state.facet(tooltipConfig);
        (this.position = e.position),
          (this.parent = e.parent),
          (this.classes = r.themeClasses),
          this.createContainer(),
          (this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }),
          (this.manager = new TooltipViewManager(r, showTooltip, (n) => this.createTooltip(n))),
          (this.intersectionObserver =
            typeof IntersectionObserver == 'function'
              ? new IntersectionObserver(
                  (n) => {
                    Date.now() > this.lastTransaction - 50 &&
                      n.length > 0 &&
                      n[n.length - 1].intersectionRatio < 1 &&
                      this.measureSoon();
                  },
                  { threshold: [1] },
                )
              : null),
          this.observeIntersection(),
          r.win.addEventListener('resize', (this.measureSoon = this.measureSoon.bind(this))),
          this.maybeMeasure();
      }
      createContainer() {
        this.parent
          ? ((this.container = document.createElement('div')),
            (this.container.style.position = 'relative'),
            (this.container.className = this.view.themeClasses),
            this.parent.appendChild(this.container))
          : (this.container = this.view.dom);
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          for (let r of this.manager.tooltipViews) this.intersectionObserver.observe(r.dom);
        }
      }
      measureSoon() {
        this.measureTimeout < 0 &&
          (this.measureTimeout = setTimeout(() => {
            (this.measureTimeout = -1), this.maybeMeasure();
          }, 50));
      }
      update(r) {
        r.transactions.length && (this.lastTransaction = Date.now());
        let e = this.manager.update(r);
        e && this.observeIntersection();
        let n = e || r.geometryChanged,
          s = r.state.facet(tooltipConfig);
        if (s.position != this.position && !this.madeAbsolute) {
          this.position = s.position;
          for (let o of this.manager.tooltipViews) o.dom.style.position = this.position;
          n = !0;
        }
        if (s.parent != this.parent) {
          this.parent && this.container.remove(), (this.parent = s.parent), this.createContainer();
          for (let o of this.manager.tooltipViews) this.container.appendChild(o.dom);
          n = !0;
        } else
          this.parent &&
            this.view.themeClasses != this.classes &&
            (this.classes = this.container.className = this.view.themeClasses);
        n && this.maybeMeasure();
      }
      createTooltip(r) {
        let e = r.create(this.view);
        if ((e.dom.classList.add('cm-tooltip'), r.arrow && !e.dom.querySelector('.cm-tooltip > .cm-tooltip-arrow'))) {
          let n = document.createElement('div');
          (n.className = 'cm-tooltip-arrow'), e.dom.appendChild(n);
        }
        return (
          (e.dom.style.position = this.position),
          (e.dom.style.top = Outside),
          this.container.appendChild(e.dom),
          e.mount && e.mount(this.view),
          e
        );
      }
      destroy() {
        var r, e;
        this.view.win.removeEventListener('resize', this.measureSoon);
        for (let n of this.manager.tooltipViews) n.dom.remove(), (r = n.destroy) === null || r === void 0 || r.call(n);
        this.parent && this.container.remove(),
          (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(),
          clearTimeout(this.measureTimeout);
      }
      readMeasure() {
        let r = this.view.dom.getBoundingClientRect(),
          e = 1,
          n = 1,
          s = !1;
        if (this.position == 'fixed' && this.manager.tooltipViews.length) {
          let { offsetParent: o } = this.manager.tooltipViews[0].dom;
          s = !!(o && o != this.container.ownerDocument.body);
        }
        if (s || this.position == 'absolute')
          if (this.parent) {
            let o = this.parent.getBoundingClientRect();
            o.width && o.height && ((e = o.width / this.parent.offsetWidth), (n = o.height / this.parent.offsetHeight));
          } else ({ scaleX: e, scaleY: n } = this.view.viewState);
        return {
          editor: r,
          parent: this.parent ? this.container.getBoundingClientRect() : r,
          pos: this.manager.tooltips.map((o, a) => {
            let l = this.manager.tooltipViews[a];
            return l.getCoords ? l.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
          }),
          size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
          space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
          scaleX: e,
          scaleY: n,
          makeAbsolute: s,
        };
      }
      writeMeasure(r) {
        var e;
        if (r.makeAbsolute) {
          (this.madeAbsolute = !0), (this.position = 'absolute');
          for (let f of this.manager.tooltipViews) f.dom.style.position = 'absolute';
        }
        let { editor: n, space: s, scaleX: o, scaleY: a } = r,
          l = [];
        for (let f = 0; f < this.manager.tooltips.length; f++) {
          let m = this.manager.tooltips[f],
            v = this.manager.tooltipViews[f],
            { dom: I } = v,
            L = r.pos[f],
            V = r.size[f];
          if (
            !L ||
            L.bottom <= Math.max(n.top, s.top) ||
            L.top >= Math.min(n.bottom, s.bottom) ||
            L.right < Math.max(n.left, s.left) - 0.1 ||
            L.left > Math.min(n.right, s.right) + 0.1
          ) {
            I.style.top = Outside;
            continue;
          }
          let se = m.arrow ? v.dom.querySelector('.cm-tooltip-arrow') : null,
            Ee = se ? 7 : 0,
            ht = V.right - V.left,
            ar = (e = knownHeight.get(v)) !== null && e !== void 0 ? e : V.bottom - V.top,
            $i = v.offset || noOffset,
            tl = this.view.textDirection == Direction.LTR,
            Wi =
              V.width > s.right - s.left
                ? tl
                  ? s.left
                  : s.right - V.width
                : tl
                ? Math.min(L.left - (se ? 14 : 0) + $i.x, s.right - ht)
                : Math.max(s.left, L.left - ht + (se ? 14 : 0) - $i.x),
            hl = !!m.above;
          !m.strictSide &&
            (hl ? L.top - (V.bottom - V.top) - $i.y < s.top : L.bottom + (V.bottom - V.top) + $i.y > s.bottom) &&
            hl == s.bottom - L.bottom > L.top - s.top &&
            (hl = !hl);
          let fl = (hl ? L.top - s.top : s.bottom - L.bottom) - Ee;
          if (fl < ar && v.resize !== !1) {
            if (fl < this.view.defaultLineHeight) {
              I.style.top = Outside;
              continue;
            }
            knownHeight.set(v, ar), (I.style.height = (ar = fl) / a + 'px');
          } else I.style.height && (I.style.height = '');
          let dl = hl ? L.top - ar - Ee - $i.y : L.bottom + Ee + $i.y,
            Al = Wi + ht;
          if (v.overlap !== !0)
            for (let Fl of l)
              Fl.left < Al &&
                Fl.right > Wi &&
                Fl.top < dl + ar &&
                Fl.bottom > dl &&
                (dl = hl ? Fl.top - ar - 2 - Ee : Fl.bottom + Ee + 2);
          if (
            (this.position == 'absolute'
              ? ((I.style.top = (dl - r.parent.top) / a + 'px'), (I.style.left = (Wi - r.parent.left) / o + 'px'))
              : ((I.style.top = dl / a + 'px'), (I.style.left = Wi / o + 'px')),
            se)
          ) {
            let Fl = L.left + (tl ? $i.x : -$i.x) - (Wi + 14 - 7);
            se.style.left = Fl / o + 'px';
          }
          v.overlap !== !0 && l.push({ left: Wi, top: dl, right: Al, bottom: dl + ar }),
            I.classList.toggle('cm-tooltip-above', hl),
            I.classList.toggle('cm-tooltip-below', !hl),
            v.positioned && v.positioned(r.space);
        }
      }
      maybeMeasure() {
        if (
          this.manager.tooltips.length &&
          (this.view.inView && this.view.requestMeasure(this.measureReq),
          this.inView != this.view.inView && ((this.inView = this.view.inView), !this.inView))
        )
          for (let r of this.manager.tooltipViews) r.dom.style.top = Outside;
      }
    },
    {
      eventObservers: {
        scroll() {
          this.maybeMeasure();
        },
      },
    },
  ),
  baseTheme$4 = EditorView.baseTheme({
    '.cm-tooltip': { zIndex: 100, boxSizing: 'border-box' },
    '&light .cm-tooltip': { border: '1px solid #bbb', backgroundColor: '#f5f5f5' },
    '&light .cm-tooltip-section:not(:first-child)': { borderTop: '1px solid #bbb' },
    '&dark .cm-tooltip': { backgroundColor: '#333338', color: 'white' },
    '.cm-tooltip-arrow': {
      'height': '7px',
      'width': `${7 * 2}px`,
      'position': 'absolute',
      'zIndex': -1,
      'overflow': 'hidden',
      '&:before, &:after': {
        content: "''",
        position: 'absolute',
        width: 0,
        height: 0,
        borderLeft: '7px solid transparent',
        borderRight: '7px solid transparent',
      },
      '.cm-tooltip-above &': {
        'bottom': '-7px',
        '&:before': { borderTop: '7px solid #bbb' },
        '&:after': { borderTop: '7px solid #f5f5f5', bottom: '1px' },
      },
      '.cm-tooltip-below &': {
        'top': '-7px',
        '&:before': { borderBottom: '7px solid #bbb' },
        '&:after': { borderBottom: '7px solid #f5f5f5', top: '1px' },
      },
    },
    '&dark .cm-tooltip .cm-tooltip-arrow': {
      '&:before': { borderTopColor: '#333338', borderBottomColor: '#333338' },
      '&:after': { borderTopColor: 'transparent', borderBottomColor: 'transparent' },
    },
  }),
  noOffset = { x: 0, y: 0 },
  showTooltip = Facet.define({ enables: [tooltipPlugin, baseTheme$4] }),
  showHoverTooltip = Facet.define();
class HoverTooltipHost {
  static create(e) {
    return new HoverTooltipHost(e);
  }
  constructor(e) {
    (this.view = e),
      (this.mounted = !1),
      (this.dom = document.createElement('div')),
      this.dom.classList.add('cm-tooltip-hover'),
      (this.manager = new TooltipViewManager(e, showHoverTooltip, (n) => this.createHostedView(n)));
  }
  createHostedView(e) {
    let n = e.create(this.view);
    return (
      n.dom.classList.add('cm-tooltip-section'),
      this.dom.appendChild(n.dom),
      this.mounted && n.mount && n.mount(this.view),
      n
    );
  }
  mount(e) {
    for (let n of this.manager.tooltipViews) n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews) n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews) (e = n.destroy) === null || e === void 0 || e.call(n);
  }
}
const showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (r) => {
  let e = r.facet(showHoverTooltip).filter((n) => n);
  return e.length === 0
    ? null
    : {
        pos: Math.min(...e.map((n) => n.pos)),
        end: Math.max(...e.filter((n) => n.end != null).map((n) => n.end)),
        create: HoverTooltipHost.create,
        above: e[0].above,
        arrow: e.some((n) => n.arrow),
      };
});
class HoverPlugin {
  constructor(e, n, s, o, a) {
    (this.view = e),
      (this.source = n),
      (this.field = s),
      (this.setHover = o),
      (this.hoverTime = a),
      (this.hoverTimeout = -1),
      (this.restartTimeout = -1),
      (this.pending = null),
      (this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }),
      (this.checkHover = this.checkHover.bind(this)),
      e.dom.addEventListener('mouseleave', (this.mouseleave = this.mouseleave.bind(this))),
      e.dom.addEventListener('mousemove', (this.mousemove = this.mousemove.bind(this)));
  }
  update() {
    this.pending &&
      ((this.pending = null),
      clearTimeout(this.restartTimeout),
      (this.restartTimeout = setTimeout(() => this.startHover(), 20)));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (((this.hoverTimeout = -1), this.active)) return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e)) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this,
      s = e.docView.nearest(n.target);
    if (!s) return;
    let o,
      a = 1;
    if (s instanceof WidgetView) o = s.posAtStart;
    else {
      if (((o = e.posAtCoords(n)), o == null)) return;
      let f = e.coordsAtPos(o);
      if (
        !f ||
        n.y < f.top ||
        n.y > f.bottom ||
        n.x < f.left - e.defaultCharacterWidth ||
        n.x > f.right + e.defaultCharacterWidth
      )
        return;
      let m = e.bidiSpans(e.state.doc.lineAt(o)).find((I) => I.from <= o && I.to >= o),
        v = m && m.dir == Direction.RTL ? -1 : 1;
      a = n.x < f.left ? -v : v;
    }
    let l = this.source(e, o, a);
    if (l != null && l.then) {
      let f = (this.pending = { pos: o });
      l.then(
        (m) => {
          this.pending == f && ((this.pending = null), m && e.dispatch({ effects: this.setHover.of(m) }));
        },
        (m) => logException(e.state, m, 'hover tooltip'),
      );
    } else l && e.dispatch({ effects: this.setHover.of(l) });
  }
  mousemove(e) {
    var n;
    (this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }),
      this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let s = this.active;
    if ((s && !isInTooltip(this.lastMove.target)) || this.pending) {
      let { pos: o } = s || this.pending,
        a = (n = s == null ? void 0 : s.end) !== null && n !== void 0 ? n : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !isOverRange(this.view, o, a, e.clientX, e.clientY)) &&
        (this.view.dispatch({ effects: this.setHover.of(null) }), (this.pending = null));
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout),
      (this.hoverTimeout = -1),
      this.active && !isInTooltip(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout),
      this.view.dom.removeEventListener('mouseleave', this.mouseleave),
      this.view.dom.removeEventListener('mousemove', this.mousemove);
  }
}
function isInTooltip(r) {
  for (let e = r; e; e = e.parentNode) if (e.nodeType == 1 && e.classList.contains('cm-tooltip')) return !0;
  return !1;
}
function isOverRange(r, e, n, s, o, a) {
  let l = r.scrollDOM.getBoundingClientRect(),
    f = r.documentTop + r.documentPadding.top + r.contentHeight;
  if (l.left > s || l.right < s || l.top > o || Math.min(l.bottom, f) < o) return !1;
  let m = r.posAtCoords({ x: s, y: o }, !1);
  return m >= e && m <= n;
}
function hoverTooltip(r, e = {}) {
  let n = StateEffect.define(),
    s = StateField.define({
      create() {
        return null;
      },
      update(o, a) {
        if (o && ((e.hideOnChange && (a.docChanged || a.selection)) || (e.hideOn && e.hideOn(a, o)))) return null;
        if (o && a.docChanged) {
          let l = a.changes.mapPos(o.pos, -1, MapMode.TrackDel);
          if (l == null) return null;
          let f = Object.assign(Object.create(null), o);
          (f.pos = l), o.end != null && (f.end = a.changes.mapPos(o.end)), (o = f);
        }
        for (let l of a.effects) l.is(n) && (o = l.value), l.is(closeHoverTooltipEffect) && (o = null);
        return o;
      },
      provide: (o) => showHoverTooltip.from(o),
    });
  return [s, ViewPlugin.define((o) => new HoverPlugin(o, r, s, n, e.hoverTime || 300)), showHoverTooltipHost];
}
function getTooltip(r, e) {
  let n = r.plugin(tooltipPlugin);
  if (!n) return null;
  let s = n.manager.tooltips.indexOf(e);
  return s < 0 ? null : n.manager.tooltipViews[s];
}
const closeHoverTooltipEffect = StateEffect.define(),
  panelConfig = Facet.define({
    combine(r) {
      let e, n;
      for (let s of r) (e = e || s.topContainer), (n = n || s.bottomContainer);
      return { topContainer: e, bottomContainer: n };
    },
  });
function getPanel(r, e) {
  let n = r.plugin(panelPlugin),
    s = n ? n.specs.indexOf(e) : -1;
  return s > -1 ? n.panels[s] : null;
}
const panelPlugin = ViewPlugin.fromClass(
  class {
    constructor(r) {
      (this.input = r.state.facet(showPanel)),
        (this.specs = this.input.filter((n) => n)),
        (this.panels = this.specs.map((n) => n(r)));
      let e = r.state.facet(panelConfig);
      (this.top = new PanelGroup(r, !0, e.topContainer)),
        (this.bottom = new PanelGroup(r, !1, e.bottomContainer)),
        this.top.sync(this.panels.filter((n) => n.top)),
        this.bottom.sync(this.panels.filter((n) => !n.top));
      for (let n of this.panels) n.dom.classList.add('cm-panel'), n.mount && n.mount();
    }
    update(r) {
      let e = r.state.facet(panelConfig);
      this.top.container != e.topContainer &&
        (this.top.sync([]), (this.top = new PanelGroup(r.view, !0, e.topContainer))),
        this.bottom.container != e.bottomContainer &&
          (this.bottom.sync([]), (this.bottom = new PanelGroup(r.view, !1, e.bottomContainer))),
        this.top.syncClasses(),
        this.bottom.syncClasses();
      let n = r.state.facet(showPanel);
      if (n != this.input) {
        let s = n.filter((m) => m),
          o = [],
          a = [],
          l = [],
          f = [];
        for (let m of s) {
          let v = this.specs.indexOf(m),
            I;
          v < 0 ? ((I = m(r.view)), f.push(I)) : ((I = this.panels[v]), I.update && I.update(r)),
            o.push(I),
            (I.top ? a : l).push(I);
        }
        (this.specs = s), (this.panels = o), this.top.sync(a), this.bottom.sync(l);
        for (let m of f) m.dom.classList.add('cm-panel'), m.mount && m.mount();
      } else for (let s of this.panels) s.update && s.update(r);
    }
    destroy() {
      this.top.sync([]), this.bottom.sync([]);
    }
  },
  {
    provide: (r) =>
      EditorView.scrollMargins.of((e) => {
        let n = e.plugin(r);
        return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
      }),
  },
);
class PanelGroup {
  constructor(e, n, s) {
    (this.view = e),
      (this.top = n),
      (this.container = s),
      (this.dom = void 0),
      (this.classes = ''),
      (this.panels = []),
      this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels) n.destroy && e.indexOf(n) < 0 && n.destroy();
    (this.panels = e), this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), (this.dom = void 0));
      return;
    }
    if (!this.dom) {
      (this.dom = document.createElement('div')),
        (this.dom.className = this.top ? 'cm-panels cm-panels-top' : 'cm-panels cm-panels-bottom'),
        (this.dom.style[this.top ? 'top' : 'bottom'] = '0');
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; ) e = rm(e);
        e = e.nextSibling;
      } else this.dom.insertBefore(n.dom, e);
    for (; e; ) e = rm(e);
  }
  scrollMargin() {
    return !this.dom || this.container
      ? 0
      : Math.max(
          0,
          this.top
            ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
            : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) -
                this.dom.getBoundingClientRect().top,
        );
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(' ')) e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(' ')) e && this.container.classList.add(e);
    }
  }
}
function rm(r) {
  let e = r.nextSibling;
  return r.remove(), e;
}
const showPanel = Facet.define({ enables: panelPlugin });
class GutterMarker extends RangeValue {
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e));
  }
  eq(e) {
    return !1;
  }
  destroy(e) {}
}
GutterMarker.prototype.elementClass = '';
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = !0;
const gutterLineClass = Facet.define(),
  defaults$1 = {
    class: '',
    renderEmptyElements: !1,
    elementStyle: '',
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {},
  },
  activeGutters = Facet.define();
function gutter(r) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults$1), r))];
}
const unfixGutters = Facet.define({ combine: (r) => r.some((e) => e) });
function gutters(r) {
  let e = [gutterView];
  return r && r.fixed === !1 && e.push(unfixGutters.of(!0)), e;
}
const gutterView = ViewPlugin.fromClass(
  class {
    constructor(r) {
      (this.view = r),
        (this.prevViewport = r.viewport),
        (this.dom = document.createElement('div')),
        (this.dom.className = 'cm-gutters'),
        this.dom.setAttribute('aria-hidden', 'true'),
        (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + 'px'),
        (this.gutters = r.state.facet(activeGutters).map((e) => new SingleGutterView(r, e)));
      for (let e of this.gutters) this.dom.appendChild(e.dom);
      (this.fixed = !r.state.facet(unfixGutters)),
        this.fixed && (this.dom.style.position = 'sticky'),
        this.syncGutters(!1),
        r.scrollDOM.insertBefore(this.dom, r.contentDOM);
    }
    update(r) {
      if (this.updateGutters(r)) {
        let e = this.prevViewport,
          n = r.view.viewport,
          s = Math.min(e.to, n.to) - Math.max(e.from, n.from);
        this.syncGutters(s < (n.to - n.from) * 0.8);
      }
      r.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + 'px'),
        this.view.state.facet(unfixGutters) != !this.fixed &&
          ((this.fixed = !this.fixed), (this.dom.style.position = this.fixed ? 'sticky' : '')),
        (this.prevViewport = r.view.viewport);
    }
    syncGutters(r) {
      let e = this.dom.nextSibling;
      r && this.dom.remove();
      let n = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from),
        s = [],
        o = this.gutters.map((a) => new UpdateContext(a, this.view.viewport, -this.view.documentPadding.top));
      for (let a of this.view.viewportLineBlocks)
        if ((s.length && (s = []), Array.isArray(a.type))) {
          let l = !0;
          for (let f of a.type)
            if (f.type == BlockType.Text && l) {
              advanceCursor(n, s, f.from);
              for (let m of o) m.line(this.view, f, s);
              l = !1;
            } else if (f.widget) for (let m of o) m.widget(this.view, f);
        } else if (a.type == BlockType.Text) {
          advanceCursor(n, s, a.from);
          for (let l of o) l.line(this.view, a, s);
        } else if (a.widget) for (let l of o) l.widget(this.view, a);
      for (let a of o) a.finish();
      r && this.view.scrollDOM.insertBefore(this.dom, e);
    }
    updateGutters(r) {
      let e = r.startState.facet(activeGutters),
        n = r.state.facet(activeGutters),
        s =
          r.docChanged ||
          r.heightChanged ||
          r.viewportChanged ||
          !RangeSet.eq(
            r.startState.facet(gutterLineClass),
            r.state.facet(gutterLineClass),
            r.view.viewport.from,
            r.view.viewport.to,
          );
      if (e == n) for (let o of this.gutters) o.update(r) && (s = !0);
      else {
        s = !0;
        let o = [];
        for (let a of n) {
          let l = e.indexOf(a);
          l < 0 ? o.push(new SingleGutterView(this.view, a)) : (this.gutters[l].update(r), o.push(this.gutters[l]));
        }
        for (let a of this.gutters) a.dom.remove(), o.indexOf(a) < 0 && a.destroy();
        for (let a of o) this.dom.appendChild(a.dom);
        this.gutters = o;
      }
      return s;
    }
    destroy() {
      for (let r of this.gutters) r.destroy();
      this.dom.remove();
    }
  },
  {
    provide: (r) =>
      EditorView.scrollMargins.of((e) => {
        let n = e.plugin(r);
        return !n || n.gutters.length == 0 || !n.fixed
          ? null
          : e.textDirection == Direction.LTR
          ? { left: n.dom.offsetWidth * e.scaleX }
          : { right: n.dom.offsetWidth * e.scaleX };
      }),
  },
);
function asArray(r) {
  return Array.isArray(r) ? r : [r];
}
function advanceCursor(r, e, n) {
  for (; r.value && r.from <= n; ) r.from == n && e.push(r.value), r.next();
}
class UpdateContext {
  constructor(e, n, s) {
    (this.gutter = e), (this.height = s), (this.i = 0), (this.cursor = RangeSet.iter(e.markers, n.from));
  }
  addElement(e, n, s) {
    let { gutter: o } = this,
      a = (n.top - this.height) / e.scaleY,
      l = n.height / e.scaleY;
    if (this.i == o.elements.length) {
      let f = new GutterElement(e, l, a, s);
      o.elements.push(f), o.dom.appendChild(f.dom);
    } else o.elements[this.i].update(e, l, a, s);
    (this.height = n.bottom), this.i++;
  }
  line(e, n, s) {
    let o = [];
    advanceCursor(this.cursor, o, n.from), s.length && (o = o.concat(s));
    let a = this.gutter.config.lineMarker(e, n, o);
    a && o.unshift(a);
    let l = this.gutter;
    (o.length == 0 && !l.config.renderEmptyElements) || this.addElement(e, n, o);
  }
  widget(e, n) {
    let s = this.gutter.config.widgetMarker(e, n.widget, n);
    s && this.addElement(e, n, [s]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class SingleGutterView {
  constructor(e, n) {
    (this.view = e),
      (this.config = n),
      (this.elements = []),
      (this.spacer = null),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-gutter' + (this.config.class ? ' ' + this.config.class : ''));
    for (let s in n.domEventHandlers)
      this.dom.addEventListener(s, (o) => {
        let a = o.target,
          l;
        if (a != this.dom && this.dom.contains(a)) {
          for (; a.parentNode != this.dom; ) a = a.parentNode;
          let m = a.getBoundingClientRect();
          l = (m.top + m.bottom) / 2;
        } else l = o.clientY;
        let f = e.lineBlockAtHeight(l - e.documentTop);
        n.domEventHandlers[s](e, f, o) && o.preventDefault();
      });
    (this.markers = asArray(n.markers(e))),
      n.initialSpacer &&
        ((this.spacer = new GutterElement(e, 0, 0, [n.initialSpacer(e)])),
        this.dom.appendChild(this.spacer.dom),
        (this.spacer.dom.style.cssText += 'visibility: hidden; pointer-events: none'));
  }
  update(e) {
    let n = this.markers;
    if (((this.markers = asArray(this.config.markers(e.view))), this.spacer && this.config.updateSpacer)) {
      let o = this.config.updateSpacer(this.spacer.markers[0], e);
      o != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [o]);
    }
    let s = e.view.viewport;
    return (
      !RangeSet.eq(this.markers, n, s.from, s.to) ||
      (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1)
    );
  }
  destroy() {
    for (let e of this.elements) e.destroy();
  }
}
class GutterElement {
  constructor(e, n, s, o) {
    (this.height = -1),
      (this.above = 0),
      (this.markers = []),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-gutterElement'),
      this.update(e, n, s, o);
  }
  update(e, n, s, o) {
    this.height != n && ((this.height = n), (this.dom.style.height = n + 'px')),
      this.above != s && (this.dom.style.marginTop = (this.above = s) ? s + 'px' : ''),
      sameMarkers(this.markers, o) || this.setMarkers(e, o);
  }
  setMarkers(e, n) {
    let s = 'cm-gutterElement',
      o = this.dom.firstChild;
    for (let a = 0, l = 0; ; ) {
      let f = l,
        m = a < n.length ? n[a++] : null,
        v = !1;
      if (m) {
        let I = m.elementClass;
        I && (s += ' ' + I);
        for (let L = l; L < this.markers.length; L++)
          if (this.markers[L].compare(m)) {
            (f = L), (v = !0);
            break;
          }
      } else f = this.markers.length;
      for (; l < f; ) {
        let I = this.markers[l++];
        if (I.toDOM) {
          I.destroy(o);
          let L = o.nextSibling;
          o.remove(), (o = L);
        }
      }
      if (!m) break;
      m.toDOM && (v ? (o = o.nextSibling) : this.dom.insertBefore(m.toDOM(e), o)), v && l++;
    }
    (this.dom.className = s), (this.markers = n);
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function sameMarkers(r, e) {
  if (r.length != e.length) return !1;
  for (let n = 0; n < r.length; n++) if (!r[n].compare(e[n])) return !1;
  return !0;
}
const lineNumberMarkers = Facet.define(),
  lineNumberConfig = Facet.define({
    combine(r) {
      return combineConfig(
        r,
        { formatNumber: String, domEventHandlers: {} },
        {
          domEventHandlers(e, n) {
            let s = Object.assign({}, e);
            for (let o in n) {
              let a = s[o],
                l = n[o];
              s[o] = a ? (f, m, v) => a(f, m, v) || l(f, m, v) : l;
            }
            return s;
          },
        },
      );
    },
  });
class NumberMarker extends GutterMarker {
  constructor(e) {
    super(), (this.number = e);
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function formatNumber(r, e) {
  return r.state.facet(lineNumberConfig).formatNumber(e, r.state);
}
const lineNumberGutter = activeGutters.compute([lineNumberConfig], (r) => ({
  class: 'cm-lineNumbers',
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(lineNumberMarkers);
  },
  lineMarker(e, n, s) {
    return s.some((o) => o.toDOM) ? null : new NumberMarker(formatNumber(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(lineNumberConfig) != e.state.facet(lineNumberConfig),
  initialSpacer(e) {
    return new NumberMarker(formatNumber(e, maxLineNumber(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let s = formatNumber(n.view, maxLineNumber(n.view.state.doc.lines));
    return s == e.number ? e : new NumberMarker(s);
  },
  domEventHandlers: r.facet(lineNumberConfig).domEventHandlers,
}));
function lineNumbers(r = {}) {
  return [lineNumberConfig.of(r), gutters(), lineNumberGutter];
}
function maxLineNumber(r) {
  let e = 9;
  for (; e < r; ) e = e * 10 + 9;
  return e;
}
const activeLineGutterMarker = new (class extends GutterMarker {
    constructor() {
      super(...arguments), (this.elementClass = 'cm-activeLineGutter');
    }
  })(),
  activeLineGutterHighlighter = gutterLineClass.compute(['selection'], (r) => {
    let e = [],
      n = -1;
    for (let s of r.selection.ranges) {
      let o = r.doc.lineAt(s.head).from;
      o > n && ((n = o), e.push(activeLineGutterMarker.range(o)));
    }
    return RangeSet.of(e);
  });
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
var standalone = { exports: {} };
(function (r, e) {
  (function (n) {
    function s() {
      var o = n();
      return o.default || o;
    }
    r.exports = s();
  })(function () {
    var n = Object.create,
      s = Object.defineProperty,
      o = Object.getOwnPropertyDescriptor,
      a = Object.getOwnPropertyNames,
      l = Object.getPrototypeOf,
      f = Object.prototype.hasOwnProperty,
      m = (W, Ge) => () => (W && (Ge = W((W = 0))), Ge),
      v = (W, Ge) => () => (Ge || W((Ge = { exports: {} }).exports, Ge), Ge.exports),
      I = (W, Ge) => {
        for (var An in Ge) s(W, An, { get: Ge[An], enumerable: !0 });
      },
      L = (W, Ge, An, Vi) => {
        if ((Ge && typeof Ge == 'object') || typeof Ge == 'function')
          for (let qi of a(Ge))
            !f.call(W, qi) &&
              qi !== An &&
              s(W, qi, { get: () => Ge[qi], enumerable: !(Vi = o(Ge, qi)) || Vi.enumerable });
        return W;
      },
      V = (W, Ge, An) => (
        (An = W != null ? n(l(W)) : {}),
        L(Ge || !W || !W.__esModule ? s(An, 'default', { value: W, enumerable: !0 }) : An, W)
      ),
      se = (W) => L(s({}, '__esModule', { value: !0 }), W),
      Ee = (W, Ge, An) => {
        if (!Ge.has(W)) throw TypeError('Cannot ' + An);
      },
      ht = (W, Ge, An) => {
        if (Ge.has(W)) throw TypeError('Cannot add the same private member more than once');
        Ge instanceof WeakSet ? Ge.add(W) : Ge.set(W, An);
      },
      ar = (W, Ge, An) => (Ee(W, Ge, 'access private method'), An),
      $i = v((W) => {
        Object.defineProperty(W, '__esModule', { value: !0 }), (W.default = Ge);
        function Ge() {}
        Ge.prototype = {
          diff: function (qi, el) {
            var Cl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
              Sl = Cl.callback;
            typeof Cl == 'function' && ((Sl = Cl), (Cl = {})), (this.options = Cl);
            var Tl = this;
            function Ml(Eh) {
              return Sl
                ? (setTimeout(function () {
                    Sl(void 0, Eh);
                  }, 0),
                  !0)
                : Eh;
            }
            (qi = this.castInput(qi)),
              (el = this.castInput(el)),
              (qi = this.removeEmpty(this.tokenize(qi))),
              (el = this.removeEmpty(this.tokenize(el)));
            var $l = el.length,
              Ql = qi.length,
              Ol = 1,
              Xl = $l + Ql;
            Cl.maxEditLength && (Xl = Math.min(Xl, Cl.maxEditLength));
            var Vl = [{ newPos: -1, components: [] }],
              nh = this.extractCommon(Vl[0], el, qi, 0);
            if (Vl[0].newPos + 1 >= $l && nh + 1 >= Ql) return Ml([{ value: this.join(el), count: el.length }]);
            function fh() {
              for (var Eh = -1 * Ol; Eh <= Ol; Eh += 2) {
                var wh = void 0,
                  Bh = Vl[Eh - 1],
                  Nh = Vl[Eh + 1],
                  qh = (Nh ? Nh.newPos : 0) - Eh;
                Bh && (Vl[Eh - 1] = void 0);
                var zh = Bh && Bh.newPos + 1 < $l,
                  Gh = Nh && 0 <= qh && qh < Ql;
                if (!zh && !Gh) {
                  Vl[Eh] = void 0;
                  continue;
                }
                if (
                  (!zh || (Gh && Bh.newPos < Nh.newPos)
                    ? ((wh = Vi(Nh)), Tl.pushComponent(wh.components, void 0, !0))
                    : ((wh = Bh), wh.newPos++, Tl.pushComponent(wh.components, !0, void 0)),
                  (qh = Tl.extractCommon(wh, el, qi, Eh)),
                  wh.newPos + 1 >= $l && qh + 1 >= Ql)
                )
                  return Ml(An(Tl, wh.components, el, qi, Tl.useLongestToken));
                Vl[Eh] = wh;
              }
              Ol++;
            }
            if (Sl)
              (function Eh() {
                setTimeout(function () {
                  if (Ol > Xl) return Sl();
                  fh() || Eh();
                }, 0);
              })();
            else
              for (; Ol <= Xl; ) {
                var vh = fh();
                if (vh) return vh;
              }
          },
          pushComponent: function (qi, el, Cl) {
            var Sl = qi[qi.length - 1];
            Sl && Sl.added === el && Sl.removed === Cl
              ? (qi[qi.length - 1] = { count: Sl.count + 1, added: el, removed: Cl })
              : qi.push({ count: 1, added: el, removed: Cl });
          },
          extractCommon: function (qi, el, Cl, Sl) {
            for (
              var Tl = el.length, Ml = Cl.length, $l = qi.newPos, Ql = $l - Sl, Ol = 0;
              $l + 1 < Tl && Ql + 1 < Ml && this.equals(el[$l + 1], Cl[Ql + 1]);

            )
              $l++, Ql++, Ol++;
            return Ol && qi.components.push({ count: Ol }), (qi.newPos = $l), Ql;
          },
          equals: function (qi, el) {
            return this.options.comparator
              ? this.options.comparator(qi, el)
              : qi === el || (this.options.ignoreCase && qi.toLowerCase() === el.toLowerCase());
          },
          removeEmpty: function (qi) {
            for (var el = [], Cl = 0; Cl < qi.length; Cl++) qi[Cl] && el.push(qi[Cl]);
            return el;
          },
          castInput: function (qi) {
            return qi;
          },
          tokenize: function (qi) {
            return qi.split('');
          },
          join: function (qi) {
            return qi.join('');
          },
        };
        function An(qi, el, Cl, Sl, Tl) {
          for (var Ml = 0, $l = el.length, Ql = 0, Ol = 0; Ml < $l; Ml++) {
            var Xl = el[Ml];
            if (Xl.removed) {
              if (((Xl.value = qi.join(Sl.slice(Ol, Ol + Xl.count))), (Ol += Xl.count), Ml && el[Ml - 1].added)) {
                var Vl = el[Ml - 1];
                (el[Ml - 1] = el[Ml]), (el[Ml] = Vl);
              }
            } else {
              if (!Xl.added && Tl) {
                var nh = Cl.slice(Ql, Ql + Xl.count);
                (nh = nh.map(function (vh, Eh) {
                  var wh = Sl[Ol + Eh];
                  return wh.length > vh.length ? wh : vh;
                })),
                  (Xl.value = qi.join(nh));
              } else Xl.value = qi.join(Cl.slice(Ql, Ql + Xl.count));
              (Ql += Xl.count), Xl.added || (Ol += Xl.count);
            }
          }
          var fh = el[$l - 1];
          return (
            $l > 1 &&
              typeof fh.value == 'string' &&
              (fh.added || fh.removed) &&
              qi.equals('', fh.value) &&
              ((el[$l - 2].value += fh.value), el.pop()),
            el
          );
        }
        function Vi(qi) {
          return { newPos: qi.newPos, components: qi.components.slice(0) };
        }
      }),
      tl = v((W) => {
        Object.defineProperty(W, '__esModule', { value: !0 }), (W.diffArrays = qi), (W.arrayDiff = void 0);
        var Ge = An($i());
        function An(el) {
          return el && el.__esModule ? el : { default: el };
        }
        var Vi = new Ge.default();
        (W.arrayDiff = Vi),
          (Vi.tokenize = function (el) {
            return el.slice();
          }),
          (Vi.join = Vi.removeEmpty =
            function (el) {
              return el;
            });
        function qi(el, Cl, Sl) {
          return Vi.diff(el, Cl, Sl);
        }
      }),
      Wi = v((W, Ge) => {
        var An = new Proxy(String, { get: () => An });
        Ge.exports = An;
      }),
      hl = {};
    I(hl, { default: () => dl, shouldHighlight: () => fl });
    var fl,
      dl,
      Al = m(() => {
        (fl = () => !1), (dl = String);
      }),
      Fl = v((W) => {
        Object.defineProperty(W, '__esModule', { value: !0 }), (W.codeFrameColumns = $l), (W.default = Ql);
        var Ge = (Al(), se(hl)),
          An = Wi(),
          Vi = An,
          qi;
        function el(Ol) {
          return Ol ? (qi != null || (qi = new Vi.constructor({ enabled: !0, level: 1 })), qi) : Vi;
        }
        var Cl = !1;
        function Sl(Ol) {
          return { gutter: Ol.grey, marker: Ol.red.bold, message: Ol.red.bold };
        }
        var Tl = /\r\n|[\n\r\u2028\u2029]/;
        function Ml(Ol, Xl, Vl) {
          let nh = Object.assign({ column: 0, line: -1 }, Ol.start),
            fh = Object.assign({}, nh, Ol.end),
            { linesAbove: vh = 2, linesBelow: Eh = 3 } = Vl || {},
            wh = nh.line,
            Bh = nh.column,
            Nh = fh.line,
            qh = fh.column,
            zh = Math.max(wh - (vh + 1), 0),
            Gh = Math.min(Xl.length, Nh + Eh);
          wh === -1 && (zh = 0), Nh === -1 && (Gh = Xl.length);
          let Ed = Nh - wh,
            Kh = {};
          if (Ed)
            for (let pd = 0; pd <= Ed; pd++) {
              let bd = pd + wh;
              if (!Bh) Kh[bd] = !0;
              else if (pd === 0) {
                let xf = Xl[bd - 1].length;
                Kh[bd] = [Bh, xf - Bh + 1];
              } else if (pd === Ed) Kh[bd] = [0, qh];
              else {
                let xf = Xl[bd - pd].length;
                Kh[bd] = [0, xf];
              }
            }
          else Bh === qh ? (Bh ? (Kh[wh] = [Bh, 0]) : (Kh[wh] = !0)) : (Kh[wh] = [Bh, qh - Bh]);
          return { start: zh, end: Gh, markerLines: Kh };
        }
        function $l(Ol, Xl, Vl = {}) {
          let nh = (Vl.highlightCode || Vl.forceColor) && (0, Ge.shouldHighlight)(Vl),
            fh = el(Vl.forceColor),
            vh = Sl(fh),
            Eh = (Kh, pd) => (nh ? Kh(pd) : pd),
            wh = Ol.split(Tl),
            { start: Bh, end: Nh, markerLines: qh } = Ml(Xl, wh, Vl),
            zh = Xl.start && typeof Xl.start.column == 'number',
            Gh = String(Nh).length,
            Ed = (nh ? (0, Ge.default)(Ol, Vl) : Ol)
              .split(Tl, Nh)
              .slice(Bh, Nh)
              .map((Kh, pd) => {
                let bd = Bh + 1 + pd,
                  xf = ` ${` ${bd}`.slice(-Gh)} |`,
                  v0 = qh[bd],
                  u1 = !qh[bd + 1];
                if (v0) {
                  let L0 = '';
                  if (Array.isArray(v0)) {
                    let c1 = Kh.slice(0, Math.max(v0[0] - 1, 0)).replace(/[^\t]/g, ' '),
                      h1 = v0[1] || 1;
                    (L0 = [
                      `
 `,
                      Eh(vh.gutter, xf.replace(/\d/g, ' ')),
                      ' ',
                      c1,
                      Eh(vh.marker, '^').repeat(h1),
                    ].join('')),
                      u1 && Vl.message && (L0 += ' ' + Eh(vh.message, Vl.message));
                  }
                  return [Eh(vh.marker, '>'), Eh(vh.gutter, xf), Kh.length > 0 ? ` ${Kh}` : '', L0].join('');
                } else return ` ${Eh(vh.gutter, xf)}${Kh.length > 0 ? ` ${Kh}` : ''}`;
              }).join(`
`);
          return (
            Vl.message &&
              !zh &&
              (Ed = `${' '.repeat(Gh + 1)}${Vl.message}
${Ed}`),
            nh ? fh.reset(Ed) : Ed
          );
        }
        function Ql(Ol, Xl, Vl, nh = {}) {
          if (!Cl) {
            Cl = !0;
            let fh =
              'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.';
            {
              let vh = new Error(fh);
              (vh.name = 'DeprecationWarning'), console.warn(new Error(fh));
            }
          }
          return (Vl = Math.max(Vl, 0)), $l(Ol, { start: { column: Vl, line: Xl } }, nh);
        }
      }),
      vl = {};
    I(vl, {
      __debug: () => l1,
      check: () => o1,
      doc: () => em,
      format: () => nm,
      formatWithCursor: () => tm,
      getSupportInfo: () => a1,
      util: () => Z0,
      version: () => s1,
    });
    var kl = (W, Ge, An, Vi) => {
        if (!(W && Ge == null))
          return Ge.replaceAll ? Ge.replaceAll(An, Vi) : An.global ? Ge.replace(An, Vi) : Ge.split(An).join(Vi);
      },
      El = kl,
      Jl = V(tl(), 1),
      Kc = 'string',
      Il = 'array',
      Ll = 'cursor',
      Nl = 'indent',
      Hl = 'align',
      Bl = 'trim',
      ql = 'group',
      Yl = 'fill',
      ih = 'if-break',
      ph = 'indent-if-break',
      gh = 'line-suffix',
      xh = 'line-suffix-boundary',
      bh = 'line',
      Ah = 'label',
      wl = 'break-parent',
      zl = new Set([Ll, Nl, Hl, Bl, ql, Yl, ih, ph, gh, xh, bh, Ah, wl]);
    function zc(W) {
      if (typeof W == 'string') return Kc;
      if (Array.isArray(W)) return Il;
      if (!W) return;
      let { type: Ge } = W;
      if (zl.has(Ge)) return Ge;
    }
    var Ul = zc,
      Dh = (W) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(W);
    function gl(W) {
      let Ge = W === null ? 'null' : typeof W;
      if (Ge !== 'string' && Ge !== 'object')
        return `Unexpected doc '${Ge}', 
Expected it to be 'string' or 'object'.`;
      if (Ul(W)) throw new Error('doc is valid.');
      let An = Object.prototype.toString.call(W);
      if (An !== '[object Object]') return `Unexpected doc '${An}'.`;
      let Vi = Dh([...zl].map((qi) => `'${qi}'`));
      return `Unexpected doc.type '${W.type}'.
Expected it to be ${Vi}.`;
    }
    var bl = class extends Error {
        constructor(Ge) {
          super(gl(Ge));
          Cf(this, 'name', 'InvalidDocError');
          this.doc = Ge;
        }
      },
      Pl = bl,
      Rl = {};
    function Wl(W, Ge, An, Vi) {
      let qi = [W];
      for (; qi.length > 0; ) {
        let el = qi.pop();
        if (el === Rl) {
          An(qi.pop());
          continue;
        }
        An && qi.push(el, Rl);
        let Cl = Ul(el);
        if (!Cl) throw new Pl(el);
        if ((Ge == null ? void 0 : Ge(el)) !== !1)
          switch (Cl) {
            case Il:
            case Yl: {
              let Sl = Cl === Il ? el : el.parts;
              for (let Tl = Sl.length, Ml = Tl - 1; Ml >= 0; --Ml) qi.push(Sl[Ml]);
              break;
            }
            case ih:
              qi.push(el.flatContents, el.breakContents);
              break;
            case ql:
              if (Vi && el.expandedStates)
                for (let Sl = el.expandedStates.length, Tl = Sl - 1; Tl >= 0; --Tl) qi.push(el.expandedStates[Tl]);
              else qi.push(el.contents);
              break;
            case Hl:
            case Nl:
            case ph:
            case Ah:
            case gh:
              qi.push(el.contents);
              break;
            case Kc:
            case Ll:
            case Bl:
            case xh:
            case bh:
            case wl:
              break;
            default:
              throw new Pl(el);
          }
      }
    }
    var Kl = Wl,
      th = () => {},
      Hc = th;
    function Qc(W) {
      return { type: Nl, contents: W };
    }
    function Gl(W, Ge) {
      return { type: Hl, contents: Ge, n: W };
    }
    function ch(W, Ge = {}) {
      return (
        Hc(Ge.expandedStates),
        { type: ql, id: Ge.id, contents: W, break: !!Ge.shouldBreak, expandedStates: Ge.expandedStates }
      );
    }
    function lh(W) {
      return Gl(Number.NEGATIVE_INFINITY, W);
    }
    function dh(W) {
      return Gl({ type: 'root' }, W);
    }
    function mh(W) {
      return Gl(-1, W);
    }
    function yh(W, Ge) {
      return ch(W[0], { ...Ge, expandedStates: W });
    }
    function kh(W) {
      return { type: Yl, parts: W };
    }
    function Sh(W, Ge = '', An = {}) {
      return { type: ih, breakContents: W, flatContents: Ge, groupId: An.groupId };
    }
    function Fh(W, Ge) {
      return { type: ph, contents: W, groupId: Ge.groupId, negate: Ge.negate };
    }
    function Lh(W) {
      return { type: gh, contents: W };
    }
    var Yh = { type: xh },
      td = { type: wl },
      rd = { type: Bl },
      nd = { type: bh, hard: !0 },
      $h = { type: bh, hard: !0, literal: !0 },
      Rh = { type: bh },
      Hh = { type: bh, soft: !0 },
      Wh = [nd, td],
      Ad = [$h, td],
      $d = { type: Ll };
    function qd(W, Ge) {
      let An = [];
      for (let Vi = 0; Vi < Ge.length; Vi++) Vi !== 0 && An.push(W), An.push(Ge[Vi]);
      return An;
    }
    function Kd(W, Ge, An) {
      let Vi = W;
      if (Ge > 0) {
        for (let qi = 0; qi < Math.floor(Ge / An); ++qi) Vi = Qc(Vi);
        (Vi = Gl(Ge % An, Vi)), (Vi = Gl(Number.NEGATIVE_INFINITY, Vi));
      }
      return Vi;
    }
    function Jd(W, Ge) {
      return W ? { type: Ah, label: W, contents: Ge } : Ge;
    }
    var Rd = (W, Ge, An) => {
        if (!(W && Ge == null))
          return Array.isArray(Ge) || typeof Ge == 'string' ? Ge[An < 0 ? Ge.length + An : An] : Ge.at(An);
      },
      Ih = Rd;
    function Gd(W) {
      let Ge = W.indexOf('\r');
      return Ge >= 0
        ? W.charAt(Ge + 1) ===
          `
`
          ? 'crlf'
          : 'cr'
        : 'lf';
    }
    function _d(W) {
      switch (W) {
        case 'cr':
          return '\r';
        case 'crlf':
          return `\r
`;
        default:
          return `
`;
      }
    }
    function uh(W, Ge) {
      let An;
      switch (Ge) {
        case `
`:
          An = /\n/g;
          break;
        case '\r':
          An = /\r/g;
          break;
        case `\r
`:
          An = /\r\n/g;
          break;
        default:
          throw new Error(`Unexpected "eol" ${JSON.stringify(Ge)}.`);
      }
      let Vi = W.match(An);
      return Vi ? Vi.length : 0;
    }
    function dd(W) {
      return El(
        !1,
        W,
        /\r\n?/g,
        `
`,
      );
    }
    var t0 = () =>
        /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g,
      Yd = {
        eastAsianWidth(W) {
          var Ge = W.charCodeAt(0),
            An = W.length == 2 ? W.charCodeAt(1) : 0,
            Vi = Ge;
          return (
            55296 <= Ge &&
              Ge <= 56319 &&
              56320 <= An &&
              An <= 57343 &&
              ((Ge &= 1023), (An &= 1023), (Vi = (Ge << 10) | An), (Vi += 65536)),
            Vi == 12288 || (65281 <= Vi && Vi <= 65376) || (65504 <= Vi && Vi <= 65510)
              ? 'F'
              : (4352 <= Vi && Vi <= 4447) ||
                (4515 <= Vi && Vi <= 4519) ||
                (4602 <= Vi && Vi <= 4607) ||
                (9001 <= Vi && Vi <= 9002) ||
                (11904 <= Vi && Vi <= 11929) ||
                (11931 <= Vi && Vi <= 12019) ||
                (12032 <= Vi && Vi <= 12245) ||
                (12272 <= Vi && Vi <= 12283) ||
                (12289 <= Vi && Vi <= 12350) ||
                (12353 <= Vi && Vi <= 12438) ||
                (12441 <= Vi && Vi <= 12543) ||
                (12549 <= Vi && Vi <= 12589) ||
                (12593 <= Vi && Vi <= 12686) ||
                (12688 <= Vi && Vi <= 12730) ||
                (12736 <= Vi && Vi <= 12771) ||
                (12784 <= Vi && Vi <= 12830) ||
                (12832 <= Vi && Vi <= 12871) ||
                (12880 <= Vi && Vi <= 13054) ||
                (13056 <= Vi && Vi <= 19903) ||
                (19968 <= Vi && Vi <= 42124) ||
                (42128 <= Vi && Vi <= 42182) ||
                (43360 <= Vi && Vi <= 43388) ||
                (44032 <= Vi && Vi <= 55203) ||
                (55216 <= Vi && Vi <= 55238) ||
                (55243 <= Vi && Vi <= 55291) ||
                (63744 <= Vi && Vi <= 64255) ||
                (65040 <= Vi && Vi <= 65049) ||
                (65072 <= Vi && Vi <= 65106) ||
                (65108 <= Vi && Vi <= 65126) ||
                (65128 <= Vi && Vi <= 65131) ||
                (110592 <= Vi && Vi <= 110593) ||
                (127488 <= Vi && Vi <= 127490) ||
                (127504 <= Vi && Vi <= 127546) ||
                (127552 <= Vi && Vi <= 127560) ||
                (127568 <= Vi && Vi <= 127569) ||
                (131072 <= Vi && Vi <= 194367) ||
                (177984 <= Vi && Vi <= 196605) ||
                (196608 <= Vi && Vi <= 262141)
              ? 'W'
              : 'N'
          );
        },
      },
      Xd = /[^\x20-\x7F]/;
    function r0(W) {
      if (!W) return 0;
      if (!Xd.test(W)) return W.length;
      W = W.replace(t0(), '  ');
      let Ge = 0;
      for (let An of W) {
        let Vi = An.codePointAt(0);
        if (Vi <= 31 || (Vi >= 127 && Vi <= 159) || (Vi >= 768 && Vi <= 879)) continue;
        let qi = Yd.eastAsianWidth(An);
        Ge += qi === 'F' || qi === 'W' ? 2 : 1;
      }
      return Ge;
    }
    var jd = r0,
      Ef = (W) => {
        if (Array.isArray(W)) return W;
        if (W.type !== Yl) throw new Error(`Expect doc to be 'array' or '${Yl}'.`);
        return W.parts;
      };
    function vd(W, Ge) {
      if (typeof W == 'string') return Ge(W);
      let An = new Map();
      return Vi(W);
      function Vi(el) {
        if (An.has(el)) return An.get(el);
        let Cl = qi(el);
        return An.set(el, Cl), Cl;
      }
      function qi(el) {
        switch (Ul(el)) {
          case Il:
            return Ge(el.map(Vi));
          case Yl:
            return Ge({ ...el, parts: el.parts.map(Vi) });
          case ih:
            return Ge({ ...el, breakContents: Vi(el.breakContents), flatContents: Vi(el.flatContents) });
          case ql: {
            let { expandedStates: Cl, contents: Sl } = el;
            return (
              Cl ? ((Cl = Cl.map(Vi)), (Sl = Cl[0])) : (Sl = Vi(Sl)), Ge({ ...el, contents: Sl, expandedStates: Cl })
            );
          }
          case Hl:
          case Nl:
          case ph:
          case Ah:
          case gh:
            return Ge({ ...el, contents: Vi(el.contents) });
          case Kc:
          case Ll:
          case Bl:
          case xh:
          case bh:
          case wl:
            return Ge(el);
          default:
            throw new Pl(el);
        }
      }
    }
    function Qd(W, Ge, An) {
      let Vi = An,
        qi = !1;
      function el(Cl) {
        if (qi) return !1;
        let Sl = Ge(Cl);
        Sl !== void 0 && ((qi = !0), (Vi = Sl));
      }
      return Kl(W, el), Vi;
    }
    function Sd(W) {
      if ((W.type === ql && W.break) || (W.type === bh && W.hard) || W.type === wl) return !0;
    }
    function wd(W) {
      return Qd(W, Sd, !1);
    }
    function bf(W) {
      if (W.length > 0) {
        let Ge = Ih(!1, W, -1);
        !Ge.expandedStates && !Ge.break && (Ge.break = 'propagated');
      }
      return null;
    }
    function Af(W) {
      let Ge = new Set(),
        An = [];
      function Vi(el) {
        if ((el.type === wl && bf(An), el.type === ql)) {
          if ((An.push(el), Ge.has(el))) return !1;
          Ge.add(el);
        }
      }
      function qi(el) {
        el.type === ql && An.pop().break && bf(An);
      }
      Kl(W, Vi, qi, !0);
    }
    function Vd(W) {
      return W.type === bh && !W.hard ? (W.soft ? '' : ' ') : W.type === ih ? W.flatContents : W;
    }
    function ld(W) {
      return vd(W, Vd);
    }
    function fd(W) {
      for (W = [...W]; W.length >= 2 && Ih(!1, W, -2).type === bh && Ih(!1, W, -1).type === wl; ) W.length -= 2;
      if (W.length > 0) {
        let Ge = id(Ih(!1, W, -1));
        W[W.length - 1] = Ge;
      }
      return W;
    }
    function id(W) {
      switch (Ul(W)) {
        case Hl:
        case Nl:
        case ph:
        case ql:
        case gh:
        case Ah: {
          let Ge = id(W.contents);
          return { ...W, contents: Ge };
        }
        case ih:
          return { ...W, breakContents: id(W.breakContents), flatContents: id(W.flatContents) };
        case Yl:
          return { ...W, parts: fd(W.parts) };
        case Il:
          return fd(W);
        case Kc:
          return W.replace(/[\n\r]*$/, '');
        case Ll:
        case Bl:
        case xh:
        case bh:
        case wl:
          break;
        default:
          throw new Pl(W);
      }
      return W;
    }
    function Zd(W) {
      return id(Sf(W));
    }
    function vf(W) {
      switch (Ul(W)) {
        case Yl:
          if (W.parts.every((Ge) => Ge === '')) return '';
          break;
        case ql:
          if (!W.contents && !W.id && !W.break && !W.expandedStates) return '';
          if (
            W.contents.type === ql &&
            W.contents.id === W.id &&
            W.contents.break === W.break &&
            W.contents.expandedStates === W.expandedStates
          )
            return W.contents;
          break;
        case Hl:
        case Nl:
        case ph:
        case gh:
          if (!W.contents) return '';
          break;
        case ih:
          if (!W.flatContents && !W.breakContents) return '';
          break;
        case Il: {
          let Ge = [];
          for (let An of W) {
            if (!An) continue;
            let [Vi, ...qi] = Array.isArray(An) ? An : [An];
            typeof Vi == 'string' && typeof Ih(!1, Ge, -1) == 'string' ? (Ge[Ge.length - 1] += Vi) : Ge.push(Vi),
              Ge.push(...qi);
          }
          return Ge.length === 0 ? '' : Ge.length === 1 ? Ge[0] : Ge;
        }
        case Kc:
        case Ll:
        case Bl:
        case xh:
        case bh:
        case Ah:
        case wl:
          break;
        default:
          throw new Pl(W);
      }
      return W;
    }
    function Sf(W) {
      return vd(W, (Ge) => vf(Ge));
    }
    function n0(W, Ge = Ad) {
      return vd(W, (An) =>
        typeof An == 'string'
          ? qd(
              Ge,
              An.split(`
`),
            )
          : An,
      );
    }
    function ef(W) {
      if (W.type === bh) return !0;
    }
    function Hd(W) {
      return Qd(W, ef, !1);
    }
    function tf(W, Ge) {
      return W.type === Ah ? { ...W, contents: Ge(W.contents) } : Ge(W);
    }
    var _h = Symbol('MODE_BREAK'),
      Xh = Symbol('MODE_FLAT'),
      ud = Symbol('cursor');
    function rf() {
      return { value: '', length: 0, queue: [] };
    }
    function wf(W, Ge) {
      return nf(W, { type: 'indent' }, Ge);
    }
    function i0(W, Ge, An) {
      return Ge === Number.NEGATIVE_INFINITY
        ? W.root || rf()
        : Ge < 0
        ? nf(W, { type: 'dedent' }, An)
        : Ge
        ? Ge.type === 'root'
          ? { ...W, root: W }
          : nf(W, { type: typeof Ge == 'string' ? 'stringAlign' : 'numberAlign', n: Ge }, An)
        : W;
    }
    function nf(W, Ge, An) {
      let Vi = Ge.type === 'dedent' ? W.queue.slice(0, -1) : [...W.queue, Ge],
        qi = '',
        el = 0,
        Cl = 0,
        Sl = 0;
      for (let Vl of Vi)
        switch (Vl.type) {
          case 'indent':
            $l(), An.useTabs ? Tl(1) : Ml(An.tabWidth);
            break;
          case 'stringAlign':
            $l(), (qi += Vl.n), (el += Vl.n.length);
            break;
          case 'numberAlign':
            (Cl += 1), (Sl += Vl.n);
            break;
          default:
            throw new Error(`Unexpected type '${Vl.type}'`);
        }
      return Ol(), { ...W, value: qi, length: el, queue: Vi };
      function Tl(Vl) {
        (qi += '	'.repeat(Vl)), (el += An.tabWidth * Vl);
      }
      function Ml(Vl) {
        (qi += ' '.repeat(Vl)), (el += Vl);
      }
      function $l() {
        An.useTabs ? Ql() : Ol();
      }
      function Ql() {
        Cl > 0 && Tl(Cl), Xl();
      }
      function Ol() {
        Sl > 0 && Ml(Sl), Xl();
      }
      function Xl() {
        (Cl = 0), (Sl = 0);
      }
    }
    function sd(W) {
      let Ge = 0,
        An = 0,
        Vi = W.length;
      e: for (; Vi--; ) {
        let qi = W[Vi];
        if (qi === ud) {
          An++;
          continue;
        }
        for (let el = qi.length - 1; el >= 0; el--) {
          let Cl = qi[el];
          if (Cl === ' ' || Cl === '	') Ge++;
          else {
            W[Vi] = qi.slice(0, el + 1);
            break e;
          }
        }
      }
      if (Ge > 0 || An > 0) for (W.length = Vi + 1; An-- > 0; ) W.push(ud);
      return Ge;
    }
    function Fd(W, Ge, An, Vi, qi, el) {
      if (An === Number.POSITIVE_INFINITY) return !0;
      let Cl = Ge.length,
        Sl = [W],
        Tl = [];
      for (; An >= 0; ) {
        if (Sl.length === 0) {
          if (Cl === 0) return !0;
          Sl.push(Ge[--Cl]);
          continue;
        }
        let { mode: Ml, doc: $l } = Sl.pop();
        switch (Ul($l)) {
          case Kc:
            Tl.push($l), (An -= jd($l));
            break;
          case Il:
          case Yl: {
            let Ql = Ef($l);
            for (let Ol = Ql.length - 1; Ol >= 0; Ol--) Sl.push({ mode: Ml, doc: Ql[Ol] });
            break;
          }
          case Nl:
          case Hl:
          case ph:
          case Ah:
            Sl.push({ mode: Ml, doc: $l.contents });
            break;
          case Bl:
            An += sd(Tl);
            break;
          case ql: {
            if (el && $l.break) return !1;
            let Ql = $l.break ? _h : Ml,
              Ol = $l.expandedStates && Ql === _h ? Ih(!1, $l.expandedStates, -1) : $l.contents;
            Sl.push({ mode: Ql, doc: Ol });
            break;
          }
          case ih: {
            let Ql = ($l.groupId ? qi[$l.groupId] || Xh : Ml) === _h ? $l.breakContents : $l.flatContents;
            Ql && Sl.push({ mode: Ml, doc: Ql });
            break;
          }
          case bh:
            if (Ml === _h || $l.hard) return !0;
            $l.soft || (Tl.push(' '), An--);
            break;
          case gh:
            Vi = !0;
            break;
          case xh:
            if (Vi) return !1;
            break;
        }
      }
      return !1;
    }
    function Jh(W, Ge) {
      let An = {},
        Vi = Ge.printWidth,
        qi = _d(Ge.endOfLine),
        el = 0,
        Cl = [{ ind: rf(), mode: _h, doc: W }],
        Sl = [],
        Tl = !1,
        Ml = [],
        $l = 0;
      for (Af(W); Cl.length > 0; ) {
        let { ind: Ol, mode: Xl, doc: Vl } = Cl.pop();
        switch (Ul(Vl)) {
          case Kc: {
            let nh =
              qi !==
              `
`
                ? El(
                    !1,
                    Vl,
                    `
`,
                    qi,
                  )
                : Vl;
            Sl.push(nh), Cl.length > 0 && (el += jd(nh));
            break;
          }
          case Il:
            for (let nh = Vl.length - 1; nh >= 0; nh--) Cl.push({ ind: Ol, mode: Xl, doc: Vl[nh] });
            break;
          case Ll:
            if ($l >= 2) throw new Error("There are too many 'cursor' in doc.");
            Sl.push(ud), $l++;
            break;
          case Nl:
            Cl.push({ ind: wf(Ol, Ge), mode: Xl, doc: Vl.contents });
            break;
          case Hl:
            Cl.push({ ind: i0(Ol, Vl.n, Ge), mode: Xl, doc: Vl.contents });
            break;
          case Bl:
            el -= sd(Sl);
            break;
          case ql:
            switch (Xl) {
              case Xh:
                if (!Tl) {
                  Cl.push({ ind: Ol, mode: Vl.break ? _h : Xh, doc: Vl.contents });
                  break;
                }
              case _h: {
                Tl = !1;
                let nh = { ind: Ol, mode: Xh, doc: Vl.contents },
                  fh = Vi - el,
                  vh = Ml.length > 0;
                if (!Vl.break && Fd(nh, Cl, fh, vh, An)) Cl.push(nh);
                else if (Vl.expandedStates) {
                  let Eh = Ih(!1, Vl.expandedStates, -1);
                  if (Vl.break) {
                    Cl.push({ ind: Ol, mode: _h, doc: Eh });
                    break;
                  } else
                    for (let wh = 1; wh < Vl.expandedStates.length + 1; wh++)
                      if (wh >= Vl.expandedStates.length) {
                        Cl.push({ ind: Ol, mode: _h, doc: Eh });
                        break;
                      } else {
                        let Bh = Vl.expandedStates[wh],
                          Nh = { ind: Ol, mode: Xh, doc: Bh };
                        if (Fd(Nh, Cl, fh, vh, An)) {
                          Cl.push(Nh);
                          break;
                        }
                      }
                } else Cl.push({ ind: Ol, mode: _h, doc: Vl.contents });
                break;
              }
            }
            Vl.id && (An[Vl.id] = Ih(!1, Cl, -1).mode);
            break;
          case Yl: {
            let nh = Vi - el,
              { parts: fh } = Vl;
            if (fh.length === 0) break;
            let [vh, Eh] = fh,
              wh = { ind: Ol, mode: Xh, doc: vh },
              Bh = { ind: Ol, mode: _h, doc: vh },
              Nh = Fd(wh, [], nh, Ml.length > 0, An, !0);
            if (fh.length === 1) {
              Nh ? Cl.push(wh) : Cl.push(Bh);
              break;
            }
            let qh = { ind: Ol, mode: Xh, doc: Eh },
              zh = { ind: Ol, mode: _h, doc: Eh };
            if (fh.length === 2) {
              Nh ? Cl.push(qh, wh) : Cl.push(zh, Bh);
              break;
            }
            fh.splice(0, 2);
            let Gh = { ind: Ol, mode: Xl, doc: kh(fh) },
              Ed = fh[0];
            Fd({ ind: Ol, mode: Xh, doc: [vh, Eh, Ed] }, [], nh, Ml.length > 0, An, !0)
              ? Cl.push(Gh, qh, wh)
              : Nh
              ? Cl.push(Gh, zh, wh)
              : Cl.push(Gh, zh, Bh);
            break;
          }
          case ih:
          case ph: {
            let nh = Vl.groupId ? An[Vl.groupId] : Xl;
            if (nh === _h) {
              let fh = Vl.type === ih ? Vl.breakContents : Vl.negate ? Vl.contents : Qc(Vl.contents);
              fh && Cl.push({ ind: Ol, mode: Xl, doc: fh });
            }
            if (nh === Xh) {
              let fh = Vl.type === ih ? Vl.flatContents : Vl.negate ? Qc(Vl.contents) : Vl.contents;
              fh && Cl.push({ ind: Ol, mode: Xl, doc: fh });
            }
            break;
          }
          case gh:
            Ml.push({ ind: Ol, mode: Xl, doc: Vl.contents });
            break;
          case xh:
            Ml.length > 0 && Cl.push({ ind: Ol, mode: Xl, doc: nd });
            break;
          case bh:
            switch (Xl) {
              case Xh:
                if (Vl.hard) Tl = !0;
                else {
                  Vl.soft || (Sl.push(' '), (el += 1));
                  break;
                }
              case _h:
                if (Ml.length > 0) {
                  Cl.push({ ind: Ol, mode: Xl, doc: Vl }, ...Ml.reverse()), (Ml.length = 0);
                  break;
                }
                Vl.literal
                  ? Ol.root
                    ? (Sl.push(qi, Ol.root.value), (el = Ol.root.length))
                    : (Sl.push(qi), (el = 0))
                  : ((el -= sd(Sl)), Sl.push(qi + Ol.value), (el = Ol.length));
                break;
            }
            break;
          case Ah:
            Cl.push({ ind: Ol, mode: Xl, doc: Vl.contents });
            break;
          case wl:
            break;
          default:
            throw new Pl(Vl);
        }
        Cl.length === 0 && Ml.length > 0 && (Cl.push(...Ml.reverse()), (Ml.length = 0));
      }
      let Ql = Sl.indexOf(ud);
      if (Ql !== -1) {
        let Ol = Sl.indexOf(ud, Ql + 1),
          Xl = Sl.slice(0, Ql).join(''),
          Vl = Sl.slice(Ql + 1, Ol).join(''),
          nh = Sl.slice(Ol + 1).join('');
        return { formatted: Xl + Vl + nh, cursorNodeStart: Xl.length, cursorNodeText: Vl };
      }
      return { formatted: Sl.join('') };
    }
    function Qh(W) {
      var Ge;
      if (!W) return '';
      if (Array.isArray(W)) {
        let An = [];
        for (let Vi of W)
          if (Array.isArray(Vi)) An.push(...Qh(Vi));
          else {
            let qi = Qh(Vi);
            qi !== '' && An.push(qi);
          }
        return An;
      }
      return W.type === ih
        ? { ...W, breakContents: Qh(W.breakContents), flatContents: Qh(W.flatContents) }
        : W.type === ql
        ? { ...W, contents: Qh(W.contents), expandedStates: (Ge = W.expandedStates) == null ? void 0 : Ge.map(Qh) }
        : W.type === Yl
        ? { type: 'fill', parts: W.parts.map(Qh) }
        : W.contents
        ? { ...W, contents: Qh(W.contents) }
        : W;
    }
    function Ff(W) {
      let Ge = Object.create(null),
        An = new Set();
      return Vi(Qh(W));
      function Vi(el, Cl, Sl) {
        var Tl, Ml;
        if (typeof el == 'string') return JSON.stringify(el);
        if (Array.isArray(el)) {
          let $l = el.map(Vi).filter(Boolean);
          return $l.length === 1 ? $l[0] : `[${$l.join(', ')}]`;
        }
        if (el.type === bh) {
          let $l = ((Tl = Sl == null ? void 0 : Sl[Cl + 1]) == null ? void 0 : Tl.type) === wl;
          return el.literal
            ? $l
              ? 'literalline'
              : 'literallineWithoutBreakParent'
            : el.hard
            ? $l
              ? 'hardline'
              : 'hardlineWithoutBreakParent'
            : el.soft
            ? 'softline'
            : 'line';
        }
        if (el.type === wl)
          return ((Ml = Sl == null ? void 0 : Sl[Cl - 1]) == null ? void 0 : Ml.type) === bh && Sl[Cl - 1].hard
            ? void 0
            : 'breakParent';
        if (el.type === Bl) return 'trim';
        if (el.type === Nl) return 'indent(' + Vi(el.contents) + ')';
        if (el.type === Hl)
          return el.n === Number.NEGATIVE_INFINITY
            ? 'dedentToRoot(' + Vi(el.contents) + ')'
            : el.n < 0
            ? 'dedent(' + Vi(el.contents) + ')'
            : el.n.type === 'root'
            ? 'markAsRoot(' + Vi(el.contents) + ')'
            : 'align(' + JSON.stringify(el.n) + ', ' + Vi(el.contents) + ')';
        if (el.type === ih)
          return (
            'ifBreak(' +
            Vi(el.breakContents) +
            (el.flatContents ? ', ' + Vi(el.flatContents) : '') +
            (el.groupId ? (el.flatContents ? '' : ', ""') + `, { groupId: ${qi(el.groupId)} }` : '') +
            ')'
          );
        if (el.type === ph) {
          let $l = [];
          el.negate && $l.push('negate: true'), el.groupId && $l.push(`groupId: ${qi(el.groupId)}`);
          let Ql = $l.length > 0 ? `, { ${$l.join(', ')} }` : '';
          return `indentIfBreak(${Vi(el.contents)}${Ql})`;
        }
        if (el.type === ql) {
          let $l = [];
          el.break && el.break !== 'propagated' && $l.push('shouldBreak: true'), el.id && $l.push(`id: ${qi(el.id)}`);
          let Ql = $l.length > 0 ? `, { ${$l.join(', ')} }` : '';
          return el.expandedStates
            ? `conditionalGroup([${el.expandedStates.map((Ol) => Vi(Ol)).join(',')}]${Ql})`
            : `group(${Vi(el.contents)}${Ql})`;
        }
        if (el.type === Yl) return `fill([${el.parts.map(($l) => Vi($l)).join(', ')}])`;
        if (el.type === gh) return 'lineSuffix(' + Vi(el.contents) + ')';
        if (el.type === xh) return 'lineSuffixBoundary';
        if (el.type === Ah) return `label(${JSON.stringify(el.label)}, ${Vi(el.contents)})`;
        throw new Error('Unknown doc type ' + el.type);
      }
      function qi(el) {
        if (typeof el != 'symbol') return JSON.stringify(String(el));
        if (el in Ge) return Ge[el];
        let Cl = el.description || 'symbol';
        for (let Sl = 0; ; Sl++) {
          let Tl = Cl + (Sl > 0 ? ` #${Sl}` : '');
          if (!An.has(Tl)) return An.add(Tl), (Ge[el] = `Symbol.for(${JSON.stringify(Tl)})`);
        }
      }
    }
    function s0(W, Ge, An = 0) {
      let Vi = 0;
      for (let qi = An; qi < W.length; ++qi) W[qi] === '	' ? (Vi = Vi + Ge - (Vi % Ge)) : Vi++;
      return Vi;
    }
    var md = s0,
      sf = class extends Error {
        constructor() {
          super(...arguments);
          Cf(this, 'name', 'ConfigError');
        }
      },
      Tf = class extends Error {
        constructor() {
          super(...arguments);
          Cf(this, 'name', 'UndefinedParserError');
        }
      },
      o0 = {
        cursorOffset: {
          category: 'Special',
          type: 'int',
          default: -1,
          range: { start: -1, end: 1 / 0, step: 1 },
          description: `Print (to stderr) where a cursor at the given position would move to after formatting.
This option cannot be used with --range-start and --range-end.`,
          cliCategory: 'Editor',
        },
        endOfLine: {
          category: 'Global',
          type: 'choice',
          default: 'lf',
          description: 'Which end of line characters to apply.',
          choices: [
            { value: 'lf', description: 'Line Feed only (\\n), common on Linux and macOS as well as inside git repos' },
            { value: 'crlf', description: 'Carriage Return + Line Feed characters (\\r\\n), common on Windows' },
            { value: 'cr', description: 'Carriage Return character only (\\r), used very rarely' },
            {
              value: 'auto',
              description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)`,
            },
          ],
        },
        filepath: {
          category: 'Special',
          type: 'path',
          description: 'Specify the input filepath. This will be used to do parser inference.',
          cliName: 'stdin-filepath',
          cliCategory: 'Other',
          cliDescription: 'Path to the file to pretend that stdin comes from.',
        },
        insertPragma: {
          category: 'Special',
          type: 'boolean',
          default: !1,
          description: "Insert @format pragma into file's first docblock comment.",
          cliCategory: 'Other',
        },
        parser: {
          category: 'Global',
          type: 'choice',
          default: void 0,
          description: 'Which parser to use.',
          exception: (W) => typeof W == 'string' || typeof W == 'function',
          choices: [
            { value: 'flow', description: 'Flow' },
            { value: 'babel', description: 'JavaScript' },
            { value: 'babel-flow', description: 'Flow' },
            { value: 'babel-ts', description: 'TypeScript' },
            { value: 'typescript', description: 'TypeScript' },
            { value: 'acorn', description: 'JavaScript' },
            { value: 'espree', description: 'JavaScript' },
            { value: 'meriyah', description: 'JavaScript' },
            { value: 'css', description: 'CSS' },
            { value: 'less', description: 'Less' },
            { value: 'scss', description: 'SCSS' },
            { value: 'json', description: 'JSON' },
            { value: 'json5', description: 'JSON5' },
            { value: 'json-stringify', description: 'JSON.stringify' },
            { value: 'graphql', description: 'GraphQL' },
            { value: 'markdown', description: 'Markdown' },
            { value: 'mdx', description: 'MDX' },
            { value: 'vue', description: 'Vue' },
            { value: 'yaml', description: 'YAML' },
            { value: 'glimmer', description: 'Ember / Handlebars' },
            { value: 'html', description: 'HTML' },
            { value: 'angular', description: 'Angular' },
            { value: 'lwc', description: 'Lightning Web Components' },
          ],
        },
        plugins: {
          type: 'path',
          array: !0,
          default: [{ value: [] }],
          category: 'Global',
          description: 'Add a plugin. Multiple plugins can be passed as separate `--plugin`s.',
          exception: (W) => typeof W == 'string' || typeof W == 'object',
          cliName: 'plugin',
          cliCategory: 'Config',
        },
        printWidth: {
          category: 'Global',
          type: 'int',
          default: 80,
          description: 'The line length where Prettier will try wrap.',
          range: { start: 0, end: 1 / 0, step: 1 },
        },
        rangeEnd: {
          category: 'Special',
          type: 'int',
          default: 1 / 0,
          range: { start: 0, end: 1 / 0, step: 1 },
          description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.
This option cannot be used with --cursor-offset.`,
          cliCategory: 'Editor',
        },
        rangeStart: {
          category: 'Special',
          type: 'int',
          default: 0,
          range: { start: 0, end: 1 / 0, step: 1 },
          description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.
This option cannot be used with --cursor-offset.`,
          cliCategory: 'Editor',
        },
        requirePragma: {
          category: 'Special',
          type: 'boolean',
          default: !1,
          description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`,
          cliCategory: 'Other',
        },
        tabWidth: {
          type: 'int',
          category: 'Global',
          default: 2,
          description: 'Number of spaces per indentation level.',
          range: { start: 0, end: 1 / 0, step: 1 },
        },
        useTabs: {
          category: 'Global',
          type: 'boolean',
          default: !1,
          description: 'Indent with tabs instead of spaces.',
        },
        embeddedLanguageFormatting: {
          category: 'Global',
          type: 'choice',
          default: 'auto',
          description: 'Control how Prettier formats quoted code embedded in the file.',
          choices: [
            { value: 'auto', description: 'Format embedded code if Prettier can automatically identify it.' },
            { value: 'off', description: 'Never automatically format embedded code.' },
          ],
        },
      };
    function kf({ plugins: W = [], showDeprecated: Ge = !1 } = {}) {
      let An = W.flatMap((qi) => qi.languages ?? []),
        Vi = [];
      for (let qi of of(Object.assign({}, ...W.map(({ options: el }) => el), o0)))
        (!Ge && qi.deprecated) ||
          (Array.isArray(qi.choices) &&
            (Ge || (qi.choices = qi.choices.filter((el) => !el.deprecated)),
            qi.name === 'parser' && (qi.choices = [...qi.choices, ...a0(qi.choices, An, W)])),
          (qi.pluginDefaults = Object.fromEntries(
            W.filter((el) => {
              var Cl;
              return ((Cl = el.defaultOptions) == null ? void 0 : Cl[qi.name]) !== void 0;
            }).map((el) => [el.name, el.defaultOptions[qi.name]]),
          )),
          Vi.push(qi));
      return { languages: An, options: Vi };
    }
    function* a0(W, Ge, An) {
      let Vi = new Set(W.map((qi) => qi.value));
      for (let qi of Ge)
        if (qi.parsers) {
          for (let el of qi.parsers)
            if (!Vi.has(el)) {
              Vi.add(el);
              let Cl = An.find((Tl) => Tl.parsers && Object.prototype.hasOwnProperty.call(Tl.parsers, el)),
                Sl = qi.name;
              Cl != null && Cl.name && (Sl += ` (plugin: ${Cl.name})`), yield { value: el, description: Sl };
            }
        }
    }
    function of(W) {
      let Ge = [];
      for (let [An, Vi] of Object.entries(W)) {
        let qi = { name: An, ...Vi };
        Array.isArray(qi.default) && (qi.default = Ih(!1, qi.default, -1).value), Ge.push(qi);
      }
      return Ge;
    }
    var gd = (W) => W.split(/[/\\]/).pop();
    function af(W, Ge) {
      if (!Ge) return;
      let An = gd(Ge).toLowerCase();
      return W.find((Vi) => {
        var qi, el;
        return (
          ((qi = Vi.extensions) == null ? void 0 : qi.some((Cl) => An.endsWith(Cl))) ||
          ((el = Vi.filenames) == null ? void 0 : el.some((Cl) => Cl.toLowerCase() === An))
        );
      });
    }
    function Td(W, Ge) {
      if (Ge)
        return (
          W.find(({ name: An }) => An.toLowerCase() === Ge) ??
          W.find(({ aliases: An }) => (An == null ? void 0 : An.includes(Ge))) ??
          W.find(({ extensions: An }) => (An == null ? void 0 : An.includes(`.${Ge}`)))
        );
    }
    function Pf(W, Ge) {
      let An = W.plugins.flatMap((qi) => qi.languages ?? []),
        Vi = Td(An, Ge.language) ?? af(An, Ge.physicalFile) ?? af(An, Ge.file) ?? (Ge.physicalFile, void 0);
      return Vi == null ? void 0 : Vi.parsers[0];
    }
    var yd = Pf,
      cd = {
        key: (W) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(W) ? W : JSON.stringify(W)),
        value(W) {
          if (W === null || typeof W != 'object') return JSON.stringify(W);
          if (Array.isArray(W)) return `[${W.map((An) => cd.value(An)).join(', ')}]`;
          let Ge = Object.keys(W);
          return Ge.length === 0 ? '{}' : `{ ${Ge.map((An) => `${cd.key(An)}: ${cd.value(W[An])}`).join(', ')} }`;
        },
        pair: ({ key: W, value: Ge }) => cd.value({ [W]: Ge }),
      },
      kd = V(Wi(), 1),
      l0 = (W, Ge, { descriptor: An }) => {
        let Vi = [`${kd.default.yellow(typeof W == 'string' ? An.key(W) : An.pair(W))} is deprecated`];
        return (
          Ge && Vi.push(`we now treat it as ${kd.default.blue(typeof Ge == 'string' ? An.key(Ge) : An.pair(Ge))}`),
          Vi.join('; ') + '.'
        );
      },
      Zh = V(Wi(), 1),
      Pd = Symbol.for('vnopts.VALUE_NOT_EXIST'),
      Dd = Symbol.for('vnopts.VALUE_UNCHANGED'),
      Bf = ' '.repeat(2),
      ed = (W, Ge, An) => {
        let { text: Vi, list: qi } = An.normalizeExpectedResult(An.schemas[W].expected(An)),
          el = [];
        return (
          Vi && el.push(Nf(W, Ge, Vi, An.descriptor)),
          qi &&
            el.push(
              [Nf(W, Ge, qi.title, An.descriptor)].concat(qi.values.map((Cl) => If(Cl, An.loggerPrintWidth))).join(`
`),
            ),
          Mf(el, An.loggerPrintWidth)
        );
      };
    function Nf(W, Ge, An, Vi) {
      return [
        `Invalid ${Zh.default.red(Vi.key(W))} value.`,
        `Expected ${Zh.default.blue(An)},`,
        `but received ${Ge === Pd ? Zh.default.gray('nothing') : Zh.default.red(Vi.value(Ge))}.`,
      ].join(' ');
    }
    function If({ text: W, list: Ge }, An) {
      let Vi = [];
      return (
        W && Vi.push(`- ${Zh.default.blue(W)}`),
        Ge &&
          Vi.push(
            [`- ${Zh.default.blue(Ge.title)}:`].concat(
              Ge.values.map((qi) => If(qi, An - Bf.length).replace(/^|\n/g, `$&${Bf}`)),
            ).join(`
`),
          ),
        Mf(Vi, An)
      );
    }
    function Mf(W, Ge) {
      if (W.length === 1) return W[0];
      let [An, Vi] = W,
        [qi, el] = W.map(
          (Cl) =>
            Cl.split(
              `
`,
              1,
            )[0].length,
        );
      return qi > Ge && qi > el ? Vi : An;
    }
    var hh = V(Wi(), 1),
      lf = [],
      uf = [];
    function u0(W, Ge) {
      if (W === Ge) return 0;
      let An = W;
      W.length > Ge.length && ((W = Ge), (Ge = An));
      let Vi = W.length,
        qi = Ge.length;
      for (; Vi > 0 && W.charCodeAt(~-Vi) === Ge.charCodeAt(~-qi); ) Vi--, qi--;
      let el = 0;
      for (; el < Vi && W.charCodeAt(el) === Ge.charCodeAt(el); ) el++;
      if (((Vi -= el), (qi -= el), Vi === 0)) return qi;
      let Cl,
        Sl,
        Tl,
        Ml,
        $l = 0,
        Ql = 0;
      for (; $l < Vi; ) (uf[$l] = W.charCodeAt(el + $l)), (lf[$l] = ++$l);
      for (; Ql < qi; )
        for (Cl = Ge.charCodeAt(el + Ql), Tl = Ql++, Sl = Ql, $l = 0; $l < Vi; $l++)
          (Ml = Cl === uf[$l] ? Tl : Tl + 1),
            (Tl = lf[$l]),
            (Sl = lf[$l] = Tl > Sl ? (Ml > Sl ? Sl + 1 : Ml) : Ml > Tl ? Tl + 1 : Ml);
      return Sl;
    }
    var Of = (W, Ge, { descriptor: An, logger: Vi, schemas: qi }) => {
        let el = [`Ignored unknown option ${hh.default.yellow(An.pair({ key: W, value: Ge }))}.`],
          Cl = Object.keys(qi)
            .sort()
            .find((Sl) => u0(W, Sl) < 3);
        Cl && el.push(`Did you mean ${hh.default.blue(An.key(Cl))}?`), Vi.warn(el.join(' '));
      },
      cf = [
        'default',
        'expected',
        'validate',
        'deprecated',
        'forward',
        'redirect',
        'overlap',
        'preprocess',
        'postprocess',
      ];
    function c0(W, Ge) {
      let An = new W(Ge),
        Vi = Object.create(An);
      for (let qi of cf) qi in Ge && (Vi[qi] = od(Ge[qi], An, jh.prototype[qi].length));
      return Vi;
    }
    var jh = class {
      static create(W) {
        return c0(this, W);
      }
      constructor(W) {
        this.name = W.name;
      }
      default(W) {}
      expected(W) {
        return 'nothing';
      }
      validate(W, Ge) {
        return !1;
      }
      deprecated(W, Ge) {
        return !1;
      }
      forward(W, Ge) {}
      redirect(W, Ge) {}
      overlap(W, Ge, An) {
        return W;
      }
      preprocess(W, Ge) {
        return W;
      }
      postprocess(W, Ge) {
        return Dd;
      }
    };
    function od(W, Ge, An) {
      return typeof W == 'function' ? (...Vi) => W(...Vi.slice(0, An - 1), Ge, ...Vi.slice(An - 1)) : () => W;
    }
    var xd = class extends jh {
        constructor(W) {
          super(W), (this._sourceName = W.sourceName);
        }
        expected(W) {
          return W.schemas[this._sourceName].expected(W);
        }
        validate(W, Ge) {
          return Ge.schemas[this._sourceName].validate(W, Ge);
        }
        redirect(W, Ge) {
          return this._sourceName;
        }
      },
      h0 = class extends jh {
        expected() {
          return 'anything';
        }
        validate() {
          return !0;
        }
      },
      p0 = class extends jh {
        constructor({ valueSchema: W, name: Ge = W.name, ...An }) {
          super({ ...An, name: Ge }), (this._valueSchema = W);
        }
        expected(W) {
          let { text: Ge, list: An } = W.normalizeExpectedResult(this._valueSchema.expected(W));
          return {
            text: Ge && `an array of ${Ge}`,
            list: An && { title: 'an array of the following values', values: [{ list: An }] },
          };
        }
        validate(W, Ge) {
          if (!Array.isArray(W)) return !1;
          let An = [];
          for (let Vi of W) {
            let qi = Ge.normalizeValidateResult(this._valueSchema.validate(Vi, Ge), Vi);
            qi !== !0 && An.push(qi.value);
          }
          return An.length === 0 ? !0 : { value: An };
        }
        deprecated(W, Ge) {
          let An = [];
          for (let Vi of W) {
            let qi = Ge.normalizeDeprecatedResult(this._valueSchema.deprecated(Vi, Ge), Vi);
            qi !== !1 && An.push(...qi.map(({ value: el }) => ({ value: [el] })));
          }
          return An;
        }
        forward(W, Ge) {
          let An = [];
          for (let Vi of W) {
            let qi = Ge.normalizeForwardResult(this._valueSchema.forward(Vi, Ge), Vi);
            An.push(...qi.map(Bd));
          }
          return An;
        }
        redirect(W, Ge) {
          let An = [],
            Vi = [];
          for (let qi of W) {
            let el = Ge.normalizeRedirectResult(this._valueSchema.redirect(qi, Ge), qi);
            'remain' in el && An.push(el.remain), Vi.push(...el.redirect.map(Bd));
          }
          return An.length === 0 ? { redirect: Vi } : { redirect: Vi, remain: An };
        }
        overlap(W, Ge) {
          return W.concat(Ge);
        }
      };
    function Bd({ from: W, to: Ge }) {
      return { from: [W], to: Ge };
    }
    var Lf = class extends jh {
      expected() {
        return 'true or false';
      }
      validate(W) {
        return typeof W == 'boolean';
      }
    };
    function $f(W, Ge) {
      let An = Object.create(null);
      for (let Vi of W) {
        let qi = Vi[Ge];
        if (An[qi]) throw new Error(`Duplicate ${Ge} ${JSON.stringify(qi)}`);
        An[qi] = Vi;
      }
      return An;
    }
    function d0(W, Ge) {
      let An = new Map();
      for (let Vi of W) {
        let qi = Vi[Ge];
        if (An.has(qi)) throw new Error(`Duplicate ${Ge} ${JSON.stringify(qi)}`);
        An.set(qi, Vi);
      }
      return An;
    }
    function Rf() {
      let W = Object.create(null);
      return (Ge) => {
        let An = JSON.stringify(Ge);
        return W[An] ? !0 : ((W[An] = !0), !1);
      };
    }
    function f0(W, Ge) {
      let An = [],
        Vi = [];
      for (let qi of W) Ge(qi) ? An.push(qi) : Vi.push(qi);
      return [An, Vi];
    }
    function _f(W) {
      return W === Math.floor(W);
    }
    function sh(W, Ge) {
      if (W === Ge) return 0;
      let An = typeof W,
        Vi = typeof Ge,
        qi = ['undefined', 'object', 'boolean', 'number', 'string'];
      return An !== Vi
        ? qi.indexOf(An) - qi.indexOf(Vi)
        : An !== 'string'
        ? Number(W) - Number(Ge)
        : W.localeCompare(Ge);
    }
    function m0(W) {
      return (...Ge) => {
        let An = W(...Ge);
        return typeof An == 'string' ? new Error(An) : An;
      };
    }
    function hf(W) {
      return W === void 0 ? {} : W;
    }
    function pf(W) {
      if (typeof W == 'string') return { text: W };
      let { text: Ge, list: An } = W;
      return (
        ff((Ge || An) !== void 0, 'Unexpected `expected` result, there should be at least one field.'),
        An ? { text: Ge, list: { title: An.title, values: An.values.map(pf) } } : { text: Ge }
      );
    }
    function jf(W, Ge) {
      return W === !0 ? !0 : W === !1 ? { value: Ge } : W;
    }
    function Vf(W, Ge, An = !1) {
      return W === !1 ? !1 : W === !0 ? (An ? !0 : [{ value: Ge }]) : 'value' in W ? [W] : W.length === 0 ? !1 : W;
    }
    function df(W, Ge) {
      return typeof W == 'string' || 'key' in W
        ? { from: Ge, to: W }
        : 'from' in W
        ? { from: W.from, to: W.to }
        : { from: Ge, to: W.to };
    }
    function zd(W, Ge) {
      return W === void 0 ? [] : Array.isArray(W) ? W.map((An) => df(An, Ge)) : [df(W, Ge)];
    }
    function Hf(W, Ge) {
      let An = zd(typeof W == 'object' && 'redirect' in W ? W.redirect : W, Ge);
      return An.length === 0
        ? { remain: Ge, redirect: An }
        : typeof W == 'object' && 'remain' in W
        ? { remain: W.remain, redirect: An }
        : { redirect: An };
    }
    function ff(W, Ge) {
      if (!W) throw new Error(Ge);
    }
    var zf = class extends jh {
        constructor(W) {
          super(W),
            (this._choices = d0(
              W.choices.map((Ge) => (Ge && typeof Ge == 'object' ? Ge : { value: Ge })),
              'value',
            ));
        }
        expected({ descriptor: W }) {
          let Ge = Array.from(this._choices.keys())
              .map((qi) => this._choices.get(qi))
              .filter(({ hidden: qi }) => !qi)
              .map((qi) => qi.value)
              .sort(sh)
              .map(W.value),
            An = Ge.slice(0, -2),
            Vi = Ge.slice(-2);
          return {
            text: An.concat(Vi.join(' or ')).join(', '),
            list: { title: 'one of the following values', values: Ge },
          };
        }
        validate(W) {
          return this._choices.has(W);
        }
        deprecated(W) {
          let Ge = this._choices.get(W);
          return Ge && Ge.deprecated ? { value: W } : !1;
        }
        forward(W) {
          let Ge = this._choices.get(W);
          return Ge ? Ge.forward : void 0;
        }
        redirect(W) {
          let Ge = this._choices.get(W);
          return Ge ? Ge.redirect : void 0;
        }
      },
      g0 = class extends jh {
        expected() {
          return 'a number';
        }
        validate(W, Ge) {
          return typeof W == 'number';
        }
      },
      Wf = class extends g0 {
        expected() {
          return 'an integer';
        }
        validate(W, Ge) {
          return Ge.normalizeValidateResult(super.validate(W, Ge), W) === !0 && _f(W);
        }
      },
      Mh = class extends jh {
        expected() {
          return 'a string';
        }
        validate(W) {
          return typeof W == 'string';
        }
      },
      hd = cd,
      mf = Of,
      Uf = ed,
      qf = l0,
      Kf = class {
        constructor(W, Ge) {
          let {
            logger: An = console,
            loggerPrintWidth: Vi = 80,
            descriptor: qi = hd,
            unknown: el = mf,
            invalid: Cl = Uf,
            deprecated: Sl = qf,
            missing: Tl = () => !1,
            required: Ml = () => !1,
            preprocess: $l = (Ol) => Ol,
            postprocess: Ql = () => Dd,
          } = Ge || {};
          (this._utils = {
            descriptor: qi,
            logger: An || { warn: () => {} },
            loggerPrintWidth: Vi,
            schemas: $f(W, 'name'),
            normalizeDefaultResult: hf,
            normalizeExpectedResult: pf,
            normalizeDeprecatedResult: Vf,
            normalizeForwardResult: zd,
            normalizeRedirectResult: Hf,
            normalizeValidateResult: jf,
          }),
            (this._unknownHandler = el),
            (this._invalidHandler = m0(Cl)),
            (this._deprecatedHandler = Sl),
            (this._identifyMissing = (Ol, Xl) => !(Ol in Xl) || Tl(Ol, Xl)),
            (this._identifyRequired = Ml),
            (this._preprocess = $l),
            (this._postprocess = Ql),
            this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = Rf();
        }
        normalize(W) {
          let Ge = {},
            An = [this._preprocess(W, this._utils)],
            Vi = () => {
              for (; An.length !== 0; ) {
                let qi = An.shift(),
                  el = this._applyNormalization(qi, Ge);
                An.push(...el);
              }
            };
          Vi();
          for (let qi of Object.keys(this._utils.schemas)) {
            let el = this._utils.schemas[qi];
            if (!(qi in Ge)) {
              let Cl = hf(el.default(this._utils));
              'value' in Cl && An.push({ [qi]: Cl.value });
            }
          }
          Vi();
          for (let qi of Object.keys(this._utils.schemas)) {
            if (!(qi in Ge)) continue;
            let el = this._utils.schemas[qi],
              Cl = Ge[qi],
              Sl = el.postprocess(Cl, this._utils);
            Sl !== Dd && (this._applyValidation(Sl, qi, el), (Ge[qi] = Sl));
          }
          return this._applyPostprocess(Ge), this._applyRequiredCheck(Ge), Ge;
        }
        _applyNormalization(W, Ge) {
          let An = [],
            { knownKeys: Vi, unknownKeys: qi } = this._partitionOptionKeys(W);
          for (let el of Vi) {
            let Cl = this._utils.schemas[el],
              Sl = Cl.preprocess(W[el], this._utils);
            this._applyValidation(Sl, el, Cl);
            let Tl = ({ from: Ql, to: Ol }) => {
                An.push(typeof Ol == 'string' ? { [Ol]: Ql } : { [Ol.key]: Ol.value });
              },
              Ml = ({ value: Ql, redirectTo: Ol }) => {
                let Xl = Vf(Cl.deprecated(Ql, this._utils), Sl, !0);
                if (Xl !== !1)
                  if (Xl === !0)
                    this._hasDeprecationWarned(el) ||
                      this._utils.logger.warn(this._deprecatedHandler(el, Ol, this._utils));
                  else
                    for (let { value: Vl } of Xl) {
                      let nh = { key: el, value: Vl };
                      if (!this._hasDeprecationWarned(nh)) {
                        let fh = typeof Ol == 'string' ? { key: Ol, value: Vl } : Ol;
                        this._utils.logger.warn(this._deprecatedHandler(nh, fh, this._utils));
                      }
                    }
              };
            zd(Cl.forward(Sl, this._utils), Sl).forEach(Tl);
            let $l = Hf(Cl.redirect(Sl, this._utils), Sl);
            if (($l.redirect.forEach(Tl), 'remain' in $l)) {
              let Ql = $l.remain;
              (Ge[el] = el in Ge ? Cl.overlap(Ge[el], Ql, this._utils) : Ql), Ml({ value: Ql });
            }
            for (let { from: Ql, to: Ol } of $l.redirect) Ml({ value: Ql, redirectTo: Ol });
          }
          for (let el of qi) {
            let Cl = W[el];
            this._applyUnknownHandler(el, Cl, Ge, (Sl, Tl) => {
              An.push({ [Sl]: Tl });
            });
          }
          return An;
        }
        _applyRequiredCheck(W) {
          for (let Ge of Object.keys(this._utils.schemas))
            if (this._identifyMissing(Ge, W) && this._identifyRequired(Ge))
              throw this._invalidHandler(Ge, Pd, this._utils);
        }
        _partitionOptionKeys(W) {
          let [Ge, An] = f0(
            Object.keys(W).filter((Vi) => !this._identifyMissing(Vi, W)),
            (Vi) => Vi in this._utils.schemas,
          );
          return { knownKeys: Ge, unknownKeys: An };
        }
        _applyValidation(W, Ge, An) {
          let Vi = jf(An.validate(W, this._utils), W);
          if (Vi !== !0) throw this._invalidHandler(Ge, Vi.value, this._utils);
        }
        _applyUnknownHandler(W, Ge, An, Vi) {
          let qi = this._unknownHandler(W, Ge, this._utils);
          if (qi)
            for (let el of Object.keys(qi)) {
              if (this._identifyMissing(el, qi)) continue;
              let Cl = qi[el];
              el in this._utils.schemas ? Vi(el, Cl) : (An[el] = Cl);
            }
        }
        _applyPostprocess(W) {
          let Ge = this._postprocess(W, this._utils);
          if (Ge !== Dd) {
            if (Ge.delete) for (let An of Ge.delete) delete W[An];
            if (Ge.override) {
              let { knownKeys: An, unknownKeys: Vi } = this._partitionOptionKeys(Ge.override);
              for (let qi of An) {
                let el = Ge.override[qi];
                this._applyValidation(el, qi, this._utils.schemas[qi]), (W[qi] = el);
              }
              for (let qi of Vi) {
                let el = Ge.override[qi];
                this._applyUnknownHandler(qi, el, W, (Cl, Sl) => {
                  let Tl = this._utils.schemas[Cl];
                  this._applyValidation(Sl, Cl, Tl), (W[Cl] = Sl);
                });
              }
            }
          }
        }
      },
      Wd;
    function y0(W, Ge, { logger: An = !1, isCLI: Vi = !1, passThrough: qi = !1, FlagSchema: el, descriptor: Cl } = {}) {
      if (Vi) {
        if (!el) throw new Error("'FlagSchema' option is required.");
        if (!Cl) throw new Error("'descriptor' option is required.");
      } else Cl = cd;
      let Sl = qi
          ? Array.isArray(qi)
            ? (Ol, Xl) => (qi.includes(Ol) ? { [Ol]: Xl } : void 0)
            : (Ol, Xl) => ({ [Ol]: Xl })
          : (Ol, Xl, Vl) => {
              let { _: nh, ...fh } = Vl.schemas;
              return Of(Ol, Xl, { ...Vl, schemas: fh });
            },
        Tl = Ud(Ge, { isCLI: Vi, FlagSchema: el }),
        Ml = new Kf(Tl, { logger: An, unknown: Sl, descriptor: Cl }),
        $l = An !== !1;
      $l && Wd && (Ml._hasDeprecationWarned = Wd);
      let Ql = Ml.normalize(W);
      return $l && (Wd = Ml._hasDeprecationWarned), Ql;
    }
    function Ud(W, { isCLI: Ge, FlagSchema: An }) {
      let Vi = [];
      Ge && Vi.push(h0.create({ name: '_' }));
      for (let qi of W)
        Vi.push(D0(qi, { isCLI: Ge, optionInfos: W, FlagSchema: An })),
          qi.alias && Ge && Vi.push(xd.create({ name: qi.alias, sourceName: qi.name }));
      return Vi;
    }
    function D0(W, { isCLI: Ge, optionInfos: An, FlagSchema: Vi }) {
      let { name: qi } = W,
        el = { name: qi },
        Cl,
        Sl = {};
      switch (W.type) {
        case 'int':
          (Cl = Wf), Ge && (el.preprocess = Number);
          break;
        case 'string':
          Cl = Mh;
          break;
        case 'choice':
          (Cl = zf),
            (el.choices = W.choices.map((Tl) =>
              Tl != null && Tl.redirect ? { ...Tl, redirect: { to: { key: W.name, value: Tl.redirect } } } : Tl,
            ));
          break;
        case 'boolean':
          Cl = Lf;
          break;
        case 'flag':
          (Cl = Vi),
            (el.flags = An.flatMap((Tl) =>
              [Tl.alias, Tl.description && Tl.name, Tl.oppositeDescription && `no-${Tl.name}`].filter(Boolean),
            ));
          break;
        case 'path':
          Cl = Mh;
          break;
        default:
          throw new Error(`Unexpected type ${W.type}`);
      }
      if (
        (W.exception
          ? (el.validate = (Tl, Ml, $l) => W.exception(Tl) || Ml.validate(Tl, $l))
          : (el.validate = (Tl, Ml, $l) => Tl === void 0 || Ml.validate(Tl, $l)),
        W.redirect &&
          (Sl.redirect = (Tl) => (Tl ? { to: { key: W.redirect.option, value: W.redirect.value } } : void 0)),
        W.deprecated && (Sl.deprecated = !0),
        Ge && !W.array)
      ) {
        let Tl = el.preprocess || ((Ml) => Ml);
        el.preprocess = (Ml, $l, Ql) => $l.preprocess(Tl(Array.isArray(Ml) ? Ih(!1, Ml, -1) : Ml), Ql);
      }
      return W.array
        ? p0.create({
            ...(Ge ? { preprocess: (Tl) => (Array.isArray(Tl) ? Tl : [Tl]) } : {}),
            ...Sl,
            valueSchema: Cl.create(el),
          })
        : Cl.create({ ...el, ...Sl });
    }
    var x0 = y0;
    function Nd(W, Ge) {
      if (!Ge) throw new Error('parserName is required.');
      for (let Vi = W.length - 1; Vi >= 0; Vi--) {
        let qi = W[Vi];
        if (qi.parsers && Object.prototype.hasOwnProperty.call(qi.parsers, Ge)) return qi;
      }
      let An = `Couldn't resolve parser "${Ge}".`;
      throw ((An += ' Plugins must be explicitly added to the standalone bundle.'), new sf(An));
    }
    function C0(W, Ge) {
      if (!Ge) throw new Error('astFormat is required.');
      for (let Vi = W.length - 1; Vi >= 0; Vi--) {
        let qi = W[Vi];
        if (qi.printers && Object.prototype.hasOwnProperty.call(qi.printers, Ge)) return qi;
      }
      let An = `Couldn't find plugin for AST format "${Ge}".`;
      throw ((An += ' Plugins must be explicitly added to the standalone bundle.'), new sf(An));
    }
    function Jf({ plugins: W, parser: Ge }) {
      let An = Nd(W, Ge);
      return Id(An, Ge);
    }
    function Id(W, Ge) {
      let An = W.parsers[Ge];
      return typeof An == 'function' ? An() : An;
    }
    function E0(W, Ge) {
      let An = W.printers[Ge];
      return typeof An == 'function' ? An() : An;
    }
    var Gf = { astFormat: 'estree', printer: {}, originalText: void 0, locStart: null, locEnd: null };
    async function gf(W, Ge = {}) {
      var An;
      let Vi = { ...W };
      if (!Vi.parser)
        if (Vi.filepath) {
          if (((Vi.parser = yd(Vi, { physicalFile: Vi.filepath })), !Vi.parser))
            throw new Tf(`No parser could be inferred for file "${Vi.filepath}".`);
        } else throw new Tf("No parser and no file path given, couldn't infer a parser.");
      let qi = kf({ plugins: W.plugins, showDeprecated: !0 }).options,
        el = {
          ...Gf,
          ...Object.fromEntries(qi.filter((Ol) => Ol.default !== void 0).map((Ol) => [Ol.name, Ol.default])),
        },
        Cl = Nd(Vi.plugins, Vi.parser),
        Sl = await Id(Cl, Vi.parser);
      (Vi.astFormat = Sl.astFormat), (Vi.locEnd = Sl.locEnd), (Vi.locStart = Sl.locStart);
      let Tl = (An = Cl.printers) != null && An[Sl.astFormat] ? Cl : C0(Vi.plugins, Sl.astFormat),
        Ml = await E0(Tl, Sl.astFormat);
      Vi.printer = Ml;
      let $l = Tl.defaultOptions
          ? Object.fromEntries(Object.entries(Tl.defaultOptions).filter(([, Ol]) => Ol !== void 0))
          : {},
        Ql = { ...el, ...$l };
      for (let [Ol, Xl] of Object.entries(Ql)) (Vi[Ol] === null || Vi[Ol] === void 0) && (Vi[Ol] = Xl);
      return Vi.parser === 'json' && (Vi.trailingComma = 'none'), x0(Vi, qi, { passThrough: Object.keys(Gf), ...Ge });
    }
    var Cd = gf,
      Yf = new Set(['tokens', 'comments', 'parent', 'enclosingNode', 'precedingNode', 'followingNode']),
      Xf = (W) => Object.keys(W).filter((Ge) => !Yf.has(Ge));
    function b0(W) {
      return W ? (Ge) => W(Ge, Yf) : Xf;
    }
    var Md = b0;
    function Od(W, Ge) {
      let {
        printer: { massageAstNode: An, getVisitorKeys: Vi },
      } = Ge;
      if (!An) return W;
      let qi = Md(Vi),
        el = An.ignoredProperties ?? new Set();
      return Cl(W);
      function Cl(Sl, Tl) {
        if (!(Sl !== null && typeof Sl == 'object')) return Sl;
        if (Array.isArray(Sl)) return Sl.map((Ol) => Cl(Ol, Tl)).filter(Boolean);
        let Ml = {},
          $l = new Set(qi(Sl));
        for (let Ol in Sl)
          !Object.prototype.hasOwnProperty.call(Sl, Ol) ||
            el.has(Ol) ||
            ($l.has(Ol) ? (Ml[Ol] = Cl(Sl[Ol], Sl)) : (Ml[Ol] = Sl[Ol]));
        let Ql = An(Sl, Ml, Tl);
        if (Ql !== null) return Ql ?? Ml;
      }
    }
    var yf = Od,
      Qf = V(Fl(), 1);
    async function g(W, Ge) {
      let An = await Jf(Ge),
        Vi = An.preprocess ? An.preprocess(W, Ge) : W;
      Ge.originalText = Vi;
      let qi;
      try {
        qi = await An.parse(Vi, Ge, Ge);
      } catch (el) {
        u(el, W);
      }
      return { text: Vi, ast: qi };
    }
    function u(W, Ge) {
      let { loc: An } = W;
      if (An) {
        let Vi = (0, Qf.codeFrameColumns)(Ge, An, { highlightCode: !0 });
        throw (
          ((W.message +=
            `
` + Vi),
          (W.codeFrame = Vi),
          W)
        );
      }
      throw W;
    }
    var N = g,
      _,
      Be,
      Cn,
      Yi,
      nl = class {
        constructor(W) {
          ht(this, _), ht(this, Cn), (this.stack = [W]);
        }
        get key() {
          let { stack: W, siblings: Ge } = this;
          return Ih(!1, W, Ge === null ? -2 : -4) ?? null;
        }
        get index() {
          return this.siblings === null ? null : Ih(!1, this.stack, -2);
        }
        get node() {
          return Ih(!1, this.stack, -1);
        }
        get parent() {
          return this.getNode(1);
        }
        get grandparent() {
          return this.getNode(2);
        }
        get isInArray() {
          return this.siblings !== null;
        }
        get siblings() {
          let { stack: W } = this,
            Ge = Ih(!1, W, -3);
          return Array.isArray(Ge) ? Ge : null;
        }
        get next() {
          let { siblings: W } = this;
          return W === null ? null : W[this.index + 1];
        }
        get previous() {
          let { siblings: W } = this;
          return W === null ? null : W[this.index - 1];
        }
        get isFirst() {
          return this.index === 0;
        }
        get isLast() {
          let { siblings: W, index: Ge } = this;
          return W !== null && Ge === W.length - 1;
        }
        get isRoot() {
          return this.stack.length === 1;
        }
        get root() {
          return this.stack[0];
        }
        get ancestors() {
          return [...ar(this, Cn, Yi).call(this)];
        }
        getName() {
          let { stack: W } = this,
            { length: Ge } = W;
          return Ge > 1 ? Ih(!1, W, -2) : null;
        }
        getValue() {
          return Ih(!1, this.stack, -1);
        }
        getNode(W = 0) {
          let Ge = ar(this, _, Be).call(this, W);
          return Ge === -1 ? null : this.stack[Ge];
        }
        getParentNode(W = 0) {
          return this.getNode(W + 1);
        }
        call(W, ...Ge) {
          let { stack: An } = this,
            { length: Vi } = An,
            qi = Ih(!1, An, -1);
          for (let el of Ge) (qi = qi[el]), An.push(el, qi);
          try {
            return W(this);
          } finally {
            An.length = Vi;
          }
        }
        callParent(W, Ge = 0) {
          let An = ar(this, _, Be).call(this, Ge + 1),
            Vi = this.stack.splice(An + 1);
          try {
            return W(this);
          } finally {
            this.stack.push(...Vi);
          }
        }
        each(W, ...Ge) {
          let { stack: An } = this,
            { length: Vi } = An,
            qi = Ih(!1, An, -1);
          for (let el of Ge) (qi = qi[el]), An.push(el, qi);
          try {
            for (let el = 0; el < qi.length; ++el) An.push(el, qi[el]), W(this, el, qi), (An.length -= 2);
          } finally {
            An.length = Vi;
          }
        }
        map(W, ...Ge) {
          let An = [];
          return (
            this.each(
              (Vi, qi, el) => {
                An[qi] = W(Vi, qi, el);
              },
              ...Ge,
            ),
            An
          );
        }
        match(...W) {
          let Ge = this.stack.length - 1,
            An = null,
            Vi = this.stack[Ge--];
          for (let qi of W) {
            if (Vi === void 0) return !1;
            let el = null;
            if (
              (typeof An == 'number' && ((el = An), (An = this.stack[Ge--]), (Vi = this.stack[Ge--])),
              qi && !qi(Vi, An, el))
            )
              return !1;
            (An = this.stack[Ge--]), (Vi = this.stack[Ge--]);
          }
          return !0;
        }
        findAncestor(W) {
          for (let Ge of ar(this, Cn, Yi).call(this)) if (W(Ge)) return Ge;
        }
        hasAncestor(W) {
          for (let Ge of ar(this, Cn, Yi).call(this)) if (W(Ge)) return !0;
          return !1;
        }
      };
    (_ = new WeakSet()),
      (Be = function (W) {
        let { stack: Ge } = this;
        for (let An = Ge.length - 1; An >= 0; An -= 2) if (!Array.isArray(Ge[An]) && --W < 0) return An;
        return -1;
      }),
      (Cn = new WeakSet()),
      (Yi = function* () {
        let { stack: W } = this;
        for (let Ge = W.length - 3; Ge >= 0; Ge -= 2) {
          let An = W[Ge];
          Array.isArray(An) || (yield An);
        }
      });
    var xl = nl,
      Dl = new Proxy(() => {}, { get: () => Dl }),
      jl = Dl;
    function Zl(W) {
      return (Ge, An, Vi) => {
        let qi = !!(Vi != null && Vi.backwards);
        if (An === !1) return !1;
        let { length: el } = Ge,
          Cl = An;
        for (; Cl >= 0 && Cl < el; ) {
          let Sl = Ge.charAt(Cl);
          if (W instanceof RegExp) {
            if (!W.test(Sl)) return Cl;
          } else if (!W.includes(Sl)) return Cl;
          qi ? Cl-- : Cl++;
        }
        return Cl === -1 || Cl === el ? Cl : !1;
      };
    }
    var Zc = Zl(/\s/),
      rh = Zl(' 	'),
      Ph = Zl(',; 	'),
      Th = Zl(/[^\n\r]/);
    function Oh(W, Ge, An) {
      let Vi = !!(An != null && An.backwards);
      if (Ge === !1) return !1;
      let qi = W.charAt(Ge);
      if (Vi) {
        if (
          W.charAt(Ge - 1) === '\r' &&
          qi ===
            `
`
        )
          return Ge - 2;
        if (
          qi ===
            `
` ||
          qi === '\r' ||
          qi === '\u2028' ||
          qi === '\u2029'
        )
          return Ge - 1;
      } else {
        if (
          qi === '\r' &&
          W.charAt(Ge + 1) ===
            `
`
        )
          return Ge + 2;
        if (
          qi ===
            `
` ||
          qi === '\r' ||
          qi === '\u2028' ||
          qi === '\u2029'
        )
          return Ge + 1;
      }
      return Ge;
    }
    var rl = Oh;
    function oh(W, Ge, An = {}) {
      let Vi = rh(W, An.backwards ? Ge - 1 : Ge, An),
        qi = rl(W, Vi, An);
      return Vi !== qi;
    }
    var Vh = oh;
    function Ld(W) {
      return Array.isArray(W) && W.length > 0;
    }
    var Zf = Ld;
    function e0(W) {
      return W !== null && typeof W == 'object';
    }
    var eh = e0;
    function* dn(W, Ge) {
      let { getVisitorKeys: An, filter: Vi = () => !0 } = Ge,
        qi = (el) => eh(el) && Vi(el);
      for (let el of An(W)) {
        let Cl = W[el];
        if (Array.isArray(Cl)) for (let Sl of Cl) qi(Sl) && (yield Sl);
        else qi(Cl) && (yield Cl);
      }
    }
    function* Xi(W, Ge) {
      let An = [W];
      for (let Vi = 0; Vi < An.length; Vi++) {
        let qi = An[Vi];
        for (let el of dn(qi, Ge)) yield el, An.push(el);
      }
    }
    function _l(W) {
      let Ge = W.type || W.kind || '(unknown type)',
        An = String(
          W.name ||
            (W.id && (typeof W.id == 'object' ? W.id.name : W.id)) ||
            (W.key && (typeof W.key == 'object' ? W.key.name : W.key)) ||
            (W.value && (typeof W.value == 'object' ? '' : String(W.value))) ||
            W.operator ||
            '',
        );
      return An.length > 20 && (An = An.slice(0, 19) + '…'), Ge + (An ? ' ' + An : '');
    }
    function ah(W, Ge) {
      (W.comments ?? (W.comments = [])).push(Ge), (Ge.printed = !1), (Ge.nodeDescription = _l(W));
    }
    function Ch(W, Ge) {
      (Ge.leading = !0), (Ge.trailing = !1), ah(W, Ge);
    }
    function Uh(W, Ge, An) {
      (Ge.leading = !1), (Ge.trailing = !1), An && (Ge.marker = An), ah(W, Ge);
    }
    function ad(W, Ge) {
      (Ge.leading = !1), (Ge.trailing = !0), ah(W, Ge);
    }
    var S0 = new WeakMap();
    function w0(W, Ge) {
      if (S0.has(W)) return S0.get(W);
      let {
        printer: { getCommentChildNodes: An, canAttachComment: Vi, getVisitorKeys: qi },
        locStart: el,
        locEnd: Cl,
      } = Ge;
      if (!Vi) return [];
      let Sl = ((An == null ? void 0 : An(W, Ge)) ?? [...dn(W, { getVisitorKeys: Md(qi) })]).flatMap((Tl) =>
        Vi(Tl) ? [Tl] : w0(Tl, Ge),
      );
      return Sl.sort((Tl, Ml) => el(Tl) - el(Ml) || Cl(Tl) - Cl(Ml)), S0.set(W, Sl), Sl;
    }
    function $0(W, Ge, An, Vi) {
      let { locStart: qi, locEnd: el } = An,
        Cl = qi(Ge),
        Sl = el(Ge),
        Tl = w0(W, An),
        Ml,
        $l,
        Ql = 0,
        Ol = Tl.length;
      for (; Ql < Ol; ) {
        let Xl = (Ql + Ol) >> 1,
          Vl = Tl[Xl],
          nh = qi(Vl),
          fh = el(Vl);
        if (nh <= Cl && Sl <= fh) return $0(Vl, Ge, An, Vl);
        if (fh <= Cl) {
          (Ml = Vl), (Ql = Xl + 1);
          continue;
        }
        if (Sl <= nh) {
          ($l = Vl), (Ol = Xl);
          continue;
        }
        throw new Error('Comment location overlaps with node location');
      }
      if ((Vi == null ? void 0 : Vi.type) === 'TemplateLiteral') {
        let { quasis: Xl } = Vi,
          Vl = T0(Xl, Ge, An);
        Ml && T0(Xl, Ml, An) !== Vl && (Ml = null), $l && T0(Xl, $l, An) !== Vl && ($l = null);
      }
      return { enclosingNode: Vi, precedingNode: Ml, followingNode: $l };
    }
    var F0 = () => !1;
    function om(W, Ge) {
      let { comments: An } = W;
      if ((delete W.comments, !Zf(An) || !Ge.printer.canAttachComment)) return;
      let Vi = [],
        {
          locStart: qi,
          locEnd: el,
          printer: { experimentalFeatures: { avoidAstMutation: Cl = !1 } = {}, handleComments: Sl = {} },
          originalText: Tl,
        } = Ge,
        { ownLine: Ml = F0, endOfLine: $l = F0, remaining: Ql = F0 } = Sl,
        Ol = An.map((Xl, Vl) => ({
          ...$0(W, Xl, Ge),
          comment: Xl,
          text: Tl,
          options: Ge,
          ast: W,
          isLastComment: An.length - 1 === Vl,
        }));
      for (let [Xl, Vl] of Ol.entries()) {
        let {
          comment: nh,
          precedingNode: fh,
          enclosingNode: vh,
          followingNode: Eh,
          text: wh,
          options: Bh,
          ast: Nh,
          isLastComment: qh,
        } = Vl;
        if (
          Bh.parser === 'json' ||
          Bh.parser === 'json5' ||
          Bh.parser === '__js_expression' ||
          Bh.parser === '__ts_expression' ||
          Bh.parser === '__vue_expression' ||
          Bh.parser === '__vue_ts_expression'
        ) {
          if (qi(nh) - qi(Nh) <= 0) {
            Ch(Nh, nh);
            continue;
          }
          if (el(nh) - el(Nh) >= 0) {
            ad(Nh, nh);
            continue;
          }
        }
        let zh;
        if (
          (Cl
            ? (zh = [Vl])
            : ((nh.enclosingNode = vh), (nh.precedingNode = fh), (nh.followingNode = Eh), (zh = [nh, wh, Bh, Nh, qh])),
          am(wh, Bh, Ol, Xl))
        )
          (nh.placement = 'ownLine'), Ml(...zh) || (Eh ? Ch(Eh, nh) : fh ? ad(fh, nh) : Uh(vh || Nh, nh));
        else if (lm(wh, Bh, Ol, Xl))
          (nh.placement = 'endOfLine'), $l(...zh) || (fh ? ad(fh, nh) : Eh ? Ch(Eh, nh) : Uh(vh || Nh, nh));
        else if (((nh.placement = 'remaining'), !Ql(...zh)))
          if (fh && Eh) {
            let Gh = Vi.length;
            Gh > 0 && Vi[Gh - 1].followingNode !== Eh && _0(Vi, Bh), Vi.push(Vl);
          } else fh ? ad(fh, nh) : Eh ? Ch(Eh, nh) : Uh(vh || Nh, nh);
      }
      if ((_0(Vi, Ge), !Cl))
        for (let Xl of An) delete Xl.precedingNode, delete Xl.enclosingNode, delete Xl.followingNode;
    }
    var R0 = (W) => !/[\S\n\u2028\u2029]/.test(W);
    function am(W, Ge, An, Vi) {
      let { comment: qi, precedingNode: el } = An[Vi],
        { locStart: Cl, locEnd: Sl } = Ge,
        Tl = Cl(qi);
      if (el)
        for (let Ml = Vi - 1; Ml >= 0; Ml--) {
          let { comment: $l, precedingNode: Ql } = An[Ml];
          if (Ql !== el || !R0(W.slice(Sl($l), Tl))) break;
          Tl = Cl($l);
        }
      return Vh(W, Tl, { backwards: !0 });
    }
    function lm(W, Ge, An, Vi) {
      let { comment: qi, followingNode: el } = An[Vi],
        { locStart: Cl, locEnd: Sl } = Ge,
        Tl = Sl(qi);
      if (el)
        for (let Ml = Vi + 1; Ml < An.length; Ml++) {
          let { comment: $l, followingNode: Ql } = An[Ml];
          if (Ql !== el || !R0(W.slice(Tl, Cl($l)))) break;
          Tl = Sl($l);
        }
      return Vh(W, Tl);
    }
    function _0(W, Ge) {
      var An, Vi;
      let qi = W.length;
      if (qi === 0) return;
      let { precedingNode: el, followingNode: Cl } = W[0],
        Sl = Ge.locStart(Cl),
        Tl;
      for (Tl = qi; Tl > 0; --Tl) {
        let { comment: Ml, precedingNode: $l, followingNode: Ql } = W[Tl - 1];
        jl.strictEqual($l, el), jl.strictEqual(Ql, Cl);
        let Ol = Ge.originalText.slice(Ge.locEnd(Ml), Sl);
        if (((Vi = (An = Ge.printer).isGap) == null ? void 0 : Vi.call(An, Ol, Ge)) ?? /^[\s(]*$/.test(Ol))
          Sl = Ge.locStart(Ml);
        else break;
      }
      for (let [Ml, { comment: $l }] of W.entries()) Ml < Tl ? ad(el, $l) : Ch(Cl, $l);
      for (let Ml of [el, Cl])
        Ml.comments && Ml.comments.length > 1 && Ml.comments.sort(($l, Ql) => Ge.locStart($l) - Ge.locStart(Ql));
      W.length = 0;
    }
    function T0(W, Ge, An) {
      let Vi = An.locStart(Ge) - 1;
      for (let qi = 1; qi < W.length; ++qi) if (Vi < An.locStart(W[qi])) return qi - 1;
      return 0;
    }
    function um(W, Ge) {
      let An = Ge - 1;
      (An = rh(W, An, { backwards: !0 })), (An = rl(W, An, { backwards: !0 })), (An = rh(W, An, { backwards: !0 }));
      let Vi = rl(W, An, { backwards: !0 });
      return An !== Vi;
    }
    var k0 = um;
    function j0(W, Ge) {
      let An = W.node;
      return (An.printed = !0), Ge.printer.printComment(W, Ge);
    }
    function cm(W, Ge) {
      var An;
      let Vi = W.node,
        qi = [j0(W, Ge)],
        { printer: el, originalText: Cl, locStart: Sl, locEnd: Tl } = Ge;
      if ((An = el.isBlockComment) != null && An.call(el, Vi)) {
        let $l = Vh(Cl, Tl(Vi)) ? (Vh(Cl, Sl(Vi), { backwards: !0 }) ? Wh : Rh) : ' ';
        qi.push($l);
      } else qi.push(Wh);
      let Ml = rl(Cl, rh(Cl, Tl(Vi)));
      return Ml !== !1 && Vh(Cl, Ml) && qi.push(Wh), qi;
    }
    function hm(W, Ge, An) {
      var Vi;
      let qi = W.node,
        el = j0(W, Ge),
        { printer: Cl, originalText: Sl, locStart: Tl } = Ge,
        Ml = (Vi = Cl.isBlockComment) == null ? void 0 : Vi.call(Cl, qi);
      if ((An != null && An.hasLineSuffix && !(An != null && An.isBlock)) || Vh(Sl, Tl(qi), { backwards: !0 })) {
        let $l = k0(Sl, Tl(qi));
        return { doc: Lh([Wh, $l ? Wh : '', el]), isBlock: Ml, hasLineSuffix: !0 };
      }
      return !Ml || (An != null && An.hasLineSuffix)
        ? { doc: [Lh([' ', el]), td], isBlock: Ml, hasLineSuffix: !0 }
        : { doc: [' ', el], isBlock: Ml, hasLineSuffix: !1 };
    }
    function pm(W, Ge) {
      let An = W.node;
      if (!An) return {};
      let Vi = Ge[Symbol.for('printedComments')];
      if ((An.comments || []).filter((Sl) => !Vi.has(Sl)).length === 0) return { leading: '', trailing: '' };
      let qi = [],
        el = [],
        Cl;
      return (
        W.each(() => {
          let Sl = W.node;
          if (Vi != null && Vi.has(Sl)) return;
          let { leading: Tl, trailing: Ml } = Sl;
          Tl ? qi.push(cm(W, Ge)) : Ml && ((Cl = hm(W, Ge, Cl)), el.push(Cl.doc));
        }, 'comments'),
        { leading: qi, trailing: el }
      );
    }
    function dm(W, Ge, An) {
      let { leading: Vi, trailing: qi } = pm(W, An);
      return !Vi && !qi ? Ge : tf(Ge, (el) => [Vi, el, qi]);
    }
    function fm(W) {
      let { [Symbol.for('comments')]: Ge, [Symbol.for('printedComments')]: An } = W;
      for (let Vi of Ge) {
        if (!Vi.printed && !An.has(Vi))
          throw new Error('Comment "' + Vi.value.trim() + '" was not printed. Please report this error!');
        delete Vi.printed;
      }
    }
    async function mm(W, Ge, An, Vi, qi) {
      let {
        embeddedLanguageFormatting: el,
        printer: { embed: Cl, hasPrettierIgnore: Sl = () => !1, getVisitorKeys: Tl },
      } = An;
      if (!Cl || el !== 'auto') return;
      if (Cl.length > 2)
        throw new Error(
          'printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed',
        );
      let Ml = Md(Cl.getVisitorKeys ?? Tl),
        $l = [];
      Xl();
      let Ql = W.stack;
      for (let { print: Vl, node: nh, pathStack: fh } of $l)
        try {
          W.stack = fh;
          let vh = await Vl(Ol, Ge, W, An);
          vh && qi.set(nh, vh);
        } catch (vh) {
          if (globalThis.PRETTIER_DEBUG) throw vh;
        }
      W.stack = Ql;
      function Ol(Vl, nh) {
        return gm(Vl, nh, An, Vi);
      }
      function Xl() {
        let { node: Vl } = W;
        if (Vl === null || typeof Vl != 'object' || Sl(W)) return;
        for (let fh of Ml(Vl)) Array.isArray(Vl[fh]) ? W.each(Xl, fh) : W.call(Xl, fh);
        let nh = Cl(W, An);
        if (nh) {
          if (typeof nh == 'function') {
            $l.push({ print: nh, node: Vl, pathStack: [...W.stack] });
            return;
          }
          qi.set(Vl, nh);
        }
      }
    }
    async function gm(W, Ge, An, Vi) {
      let qi = await Cd({ ...An, ...Ge, parentParser: An.parser, originalText: W }, { passThrough: !0 }),
        { ast: el } = await N(W, qi),
        Cl = await Vi(el, qi);
      return Zd(Cl);
    }
    function ym(W, Ge) {
      let {
          originalText: An,
          [Symbol.for('comments')]: Vi,
          locStart: qi,
          locEnd: el,
          [Symbol.for('printedComments')]: Cl,
        } = Ge,
        { node: Sl } = W,
        Tl = qi(Sl),
        Ml = el(Sl);
      for (let $l of Vi) qi($l) >= Tl && el($l) <= Ml && Cl.add($l);
      return An.slice(Tl, Ml);
    }
    var Dm = ym;
    async function A0(W, Ge) {
      ({ ast: W } = await H0(W, Ge));
      let An = new Map(),
        Vi = new xl(W),
        qi = new Map();
      await mm(Vi, Cl, Ge, A0, qi);
      let el = await V0(Vi, Ge, Cl, void 0, qi);
      return fm(Ge), el;
      function Cl(Tl, Ml) {
        return Tl === void 0 || Tl === Vi
          ? Sl(Ml)
          : Array.isArray(Tl)
          ? Vi.call(() => Sl(Ml), ...Tl)
          : Vi.call(() => Sl(Ml), Tl);
      }
      function Sl(Tl) {
        let Ml = Vi.node;
        if (Ml == null) return '';
        let $l = Ml && typeof Ml == 'object' && Tl === void 0;
        if ($l && An.has(Ml)) return An.get(Ml);
        let Ql = V0(Vi, Ge, Cl, Tl, qi);
        return $l && An.set(Ml, Ql), Ql;
      }
    }
    function V0(W, Ge, An, Vi, qi) {
      var el;
      let { node: Cl } = W,
        { printer: Sl } = Ge,
        Tl;
      return (
        (el = Sl.hasPrettierIgnore) != null && el.call(Sl, W)
          ? (Tl = Dm(W, Ge))
          : qi.has(Cl)
          ? (Tl = qi.get(Cl))
          : (Tl = Sl.print(W, Ge, An, Vi)),
        Cl === Ge.cursorNode && (Tl = tf(Tl, (Ml) => [$d, Ml, $d])),
        Sl.printComment && (!Sl.willPrintOwnComments || !Sl.willPrintOwnComments(W, Ge)) && (Tl = dm(W, Tl, Ge)),
        Tl
      );
    }
    async function H0(W, Ge) {
      let An = W.comments ?? [];
      (Ge[Symbol.for('comments')] = An),
        (Ge[Symbol.for('tokens')] = W.tokens ?? []),
        (Ge[Symbol.for('printedComments')] = new Set()),
        om(W, Ge);
      let {
        printer: { preprocess: Vi },
      } = Ge;
      return (W = Vi ? await Vi(W, Ge) : W), { ast: W, comments: An };
    }
    var xm = ({ parser: W }) => W === 'json' || W === 'json5' || W === 'json-stringify';
    function Cm(W, Ge) {
      let An = [W.node, ...W.parentNodes],
        Vi = new Set([Ge.node, ...Ge.parentNodes]);
      return An.find((qi) => W0.has(qi.type) && Vi.has(qi));
    }
    function z0(W) {
      let Ge = W.length - 1;
      for (;;) {
        let An = W[Ge];
        if ((An == null ? void 0 : An.type) === 'Program' || (An == null ? void 0 : An.type) === 'File') Ge--;
        else break;
      }
      return W.slice(0, Ge + 1);
    }
    function Em(W, Ge, { locStart: An, locEnd: Vi }) {
      let qi = W.node,
        el = Ge.node;
      if (qi === el) return { startNode: qi, endNode: el };
      let Cl = An(W.node);
      for (let Tl of z0(Ge.parentNodes))
        if (An(Tl) >= Cl) el = Tl;
        else break;
      let Sl = Vi(Ge.node);
      for (let Tl of z0(W.parentNodes)) {
        if (Vi(Tl) <= Sl) qi = Tl;
        else break;
        if (qi === el) break;
      }
      return { startNode: qi, endNode: el };
    }
    function P0(W, Ge, An, Vi, qi = [], el) {
      let { locStart: Cl, locEnd: Sl } = An,
        Tl = Cl(W),
        Ml = Sl(W);
      if (!(Ge > Ml || Ge < Tl || (el === 'rangeEnd' && Ge === Tl) || (el === 'rangeStart' && Ge === Ml))) {
        for (let $l of w0(W, An)) {
          let Ql = P0($l, Ge, An, Vi, [W, ...qi], el);
          if (Ql) return Ql;
        }
        if (!Vi || Vi(W, qi[0])) return { node: W, parentNodes: qi };
      }
    }
    function bm(W, Ge) {
      return (
        Ge !== 'DeclareExportDeclaration' &&
        W !== 'TypeParameterDeclaration' &&
        (W === 'Directive' ||
          W === 'TypeAlias' ||
          W === 'TSExportAssignment' ||
          W.startsWith('Declare') ||
          W.startsWith('TSDeclare') ||
          W.endsWith('Statement') ||
          W.endsWith('Declaration'))
      );
    }
    var W0 = new Set([
        'JsonRoot',
        'ObjectExpression',
        'ArrayExpression',
        'StringLiteral',
        'NumericLiteral',
        'BooleanLiteral',
        'NullLiteral',
        'UnaryExpression',
        'TemplateLiteral',
      ]),
      Am = new Set([
        'OperationDefinition',
        'FragmentDefinition',
        'VariableDefinition',
        'TypeExtensionDefinition',
        'ObjectTypeDefinition',
        'FieldDefinition',
        'DirectiveDefinition',
        'EnumTypeDefinition',
        'EnumValueDefinition',
        'InputValueDefinition',
        'InputObjectTypeDefinition',
        'SchemaDefinition',
        'OperationTypeDefinition',
        'InterfaceTypeDefinition',
        'UnionTypeDefinition',
        'ScalarTypeDefinition',
      ]);
    function U0(W, Ge, An) {
      if (!Ge) return !1;
      switch (W.parser) {
        case 'flow':
        case 'babel':
        case 'babel-flow':
        case 'babel-ts':
        case 'typescript':
        case 'acorn':
        case 'espree':
        case 'meriyah':
        case '__babel_estree':
          return bm(Ge.type, An == null ? void 0 : An.type);
        case 'json':
        case 'json5':
        case 'json-stringify':
          return W0.has(Ge.type);
        case 'graphql':
          return Am.has(Ge.kind);
        case 'vue':
          return Ge.tag !== 'root';
      }
      return !1;
    }
    function vm(W, Ge, An) {
      let { rangeStart: Vi, rangeEnd: qi, locStart: el, locEnd: Cl } = Ge;
      jl.ok(qi > Vi);
      let Sl = W.slice(Vi, qi).search(/\S/),
        Tl = Sl === -1;
      if (!Tl) for (Vi += Sl; qi > Vi && !/\S/.test(W[qi - 1]); --qi);
      let Ml = P0(An, Vi, Ge, (Xl, Vl) => U0(Ge, Xl, Vl), [], 'rangeStart'),
        $l = Tl ? Ml : P0(An, qi, Ge, (Xl) => U0(Ge, Xl), [], 'rangeEnd');
      if (!Ml || !$l) return { rangeStart: 0, rangeEnd: 0 };
      let Ql, Ol;
      if (xm(Ge)) {
        let Xl = Cm(Ml, $l);
        (Ql = Xl), (Ol = Xl);
      } else ({ startNode: Ql, endNode: Ol } = Em(Ml, $l, Ge));
      return { rangeStart: Math.min(el(Ql), el(Ol)), rangeEnd: Math.max(Cl(Ql), Cl(Ol)) };
    }
    function Sm(W, Ge) {
      let { cursorOffset: An, locStart: Vi, locEnd: qi } = Ge,
        el = Md(Ge.printer.getVisitorKeys),
        Cl = (Tl) => Vi(Tl) <= An && qi(Tl) >= An,
        Sl = W;
      for (let Tl of Xi(W, { getVisitorKeys: el, filter: Cl })) Sl = Tl;
      return Sl;
    }
    var wm = Sm,
      q0 = '\uFEFF',
      K0 = Symbol('cursor');
    async function J0(W, Ge, An = 0) {
      if (!W || W.trim().length === 0) return { formatted: '', cursorOffset: -1, comments: [] };
      let { ast: Vi, text: qi } = await N(W, Ge);
      Ge.cursorOffset >= 0 && (Ge.cursorNode = wm(Vi, Ge));
      let el = await A0(Vi, Ge);
      An > 0 && (el = Kd([Wh, el], An, Ge.tabWidth));
      let Cl = Jh(el, Ge);
      if (An > 0) {
        let Tl = Cl.formatted.trim();
        Cl.cursorNodeStart !== void 0 && (Cl.cursorNodeStart -= Cl.formatted.indexOf(Tl)),
          (Cl.formatted = Tl + _d(Ge.endOfLine));
      }
      let Sl = Ge[Symbol.for('comments')];
      if (Ge.cursorOffset >= 0) {
        let Tl, Ml, $l, Ql, Ol;
        if (
          (Ge.cursorNode && Cl.cursorNodeText
            ? ((Tl = Ge.locStart(Ge.cursorNode)),
              (Ml = qi.slice(Tl, Ge.locEnd(Ge.cursorNode))),
              ($l = Ge.cursorOffset - Tl),
              (Ql = Cl.cursorNodeStart),
              (Ol = Cl.cursorNodeText))
            : ((Tl = 0), (Ml = qi), ($l = Ge.cursorOffset), (Ql = 0), (Ol = Cl.formatted)),
          Ml === Ol)
        )
          return { formatted: Cl.formatted, cursorOffset: Ql + $l, comments: Sl };
        let Xl = Ml.split('');
        Xl.splice($l, 0, K0);
        let Vl = Ol.split(''),
          nh = (0, Jl.diffArrays)(Xl, Vl),
          fh = Ql;
        for (let vh of nh)
          if (vh.removed) {
            if (vh.value.includes(K0)) break;
          } else fh += vh.count;
        return { formatted: Cl.formatted, cursorOffset: fh, comments: Sl };
      }
      return { formatted: Cl.formatted, cursorOffset: -1, comments: Sl };
    }
    async function Fm(W, Ge) {
      let { ast: An, text: Vi } = await N(W, Ge),
        { rangeStart: qi, rangeEnd: el } = vm(Vi, Ge, An),
        Cl = Vi.slice(qi, el),
        Sl = Math.min(
          qi,
          Vi.lastIndexOf(
            `
`,
            qi,
          ) + 1,
        ),
        Tl = Vi.slice(Sl, qi).match(/^\s*/)[0],
        Ml = md(Tl, Ge.tabWidth),
        $l = await J0(
          Cl,
          {
            ...Ge,
            rangeStart: 0,
            rangeEnd: Number.POSITIVE_INFINITY,
            cursorOffset: Ge.cursorOffset > qi && Ge.cursorOffset <= el ? Ge.cursorOffset - qi : -1,
            endOfLine: 'lf',
          },
          Ml,
        ),
        Ql = $l.formatted.trimEnd(),
        { cursorOffset: Ol } = Ge;
      Ol > el ? (Ol += Ql.length - Cl.length) : $l.cursorOffset >= 0 && (Ol = $l.cursorOffset + qi);
      let Xl = Vi.slice(0, qi) + Ql + Vi.slice(el);
      if (Ge.endOfLine !== 'lf') {
        let Vl = _d(Ge.endOfLine);
        Ol >= 0 &&
          Vl ===
            `\r
` &&
          (Ol += uh(
            Xl.slice(0, Ol),
            `
`,
          )),
          (Xl = El(
            !1,
            Xl,
            `
`,
            Vl,
          ));
      }
      return { formatted: Xl, cursorOffset: Ol, comments: $l.comments };
    }
    function B0(W, Ge, An) {
      return typeof Ge != 'number' || Number.isNaN(Ge) || Ge < 0 || Ge > W.length ? An : Ge;
    }
    function G0(W, Ge) {
      let { cursorOffset: An, rangeStart: Vi, rangeEnd: qi } = Ge;
      return (
        (An = B0(W, An, -1)),
        (Vi = B0(W, Vi, 0)),
        (qi = B0(W, qi, W.length)),
        { ...Ge, cursorOffset: An, rangeStart: Vi, rangeEnd: qi }
      );
    }
    function Y0(W, Ge) {
      let { cursorOffset: An, rangeStart: Vi, rangeEnd: qi, endOfLine: el } = G0(W, Ge),
        Cl = W.charAt(0) === q0;
      if ((Cl && ((W = W.slice(1)), An--, Vi--, qi--), el === 'auto' && (el = Gd(W)), W.includes('\r'))) {
        let Sl = (Tl) =>
          uh(
            W.slice(0, Math.max(Tl, 0)),
            `\r
`,
          );
        (An -= Sl(An)), (Vi -= Sl(Vi)), (qi -= Sl(qi)), (W = dd(W));
      }
      return {
        hasBOM: Cl,
        text: W,
        options: G0(W, { ...Ge, cursorOffset: An, rangeStart: Vi, rangeEnd: qi, endOfLine: el }),
      };
    }
    async function X0(W, Ge) {
      let An = await Jf(Ge);
      return !An.hasPragma || An.hasPragma(W);
    }
    async function Q0(W, Ge) {
      let { hasBOM: An, text: Vi, options: qi } = Y0(W, await Cd(Ge));
      if ((qi.rangeStart >= qi.rangeEnd && Vi !== '') || (qi.requirePragma && !(await X0(Vi, qi))))
        return { formatted: W, cursorOffset: Ge.cursorOffset, comments: [] };
      let el;
      return (
        qi.rangeStart > 0 || qi.rangeEnd < Vi.length
          ? (el = await Fm(Vi, qi))
          : (!qi.requirePragma &&
              qi.insertPragma &&
              qi.printer.insertPragma &&
              !(await X0(Vi, qi)) &&
              (Vi = qi.printer.insertPragma(Vi)),
            (el = await J0(Vi, qi))),
        An && ((el.formatted = q0 + el.formatted), el.cursorOffset >= 0 && el.cursorOffset++),
        el
      );
    }
    async function Tm(W, Ge, An) {
      let { text: Vi, options: qi } = Y0(W, await Cd(Ge)),
        el = await N(Vi, qi);
      return (
        An && (An.preprocessForPrint && (el.ast = await H0(el.ast, qi)), An.massage && (el.ast = yf(el.ast, qi))), el
      );
    }
    async function km(W, Ge) {
      Ge = await Cd(Ge);
      let An = await A0(W, Ge);
      return Jh(An, Ge);
    }
    async function Pm(W, Ge) {
      let An = Ff(W),
        { formatted: Vi } = await Q0(An, { ...Ge, parser: '__js_expression' });
      return Vi;
    }
    async function Bm(W, Ge) {
      Ge = await Cd(Ge);
      let { ast: An } = await N(W, Ge);
      return A0(An, Ge);
    }
    async function Nm(W, Ge) {
      return Jh(W, await Cd(Ge));
    }
    var Z0 = {};
    I(Z0, {
      addDanglingComment: () => Uh,
      addLeadingComment: () => Ch,
      addTrailingComment: () => ad,
      getAlignmentSize: () => md,
      getIndentSize: () => Vm,
      getMaxContinuousCount: () => _m,
      getNextNonSpaceNonCommentCharacter: () => Km,
      getNextNonSpaceNonCommentCharacterIndex: () => Xm,
      getStringWidth: () => jd,
      hasNewline: () => Vh,
      hasNewlineInRange: () => zm,
      hasSpaces: () => Um,
      isNextLineEmpty: () => t1,
      isNextLineEmptyAfterIndex: () => O0,
      isPreviousLineEmpty: () => Zm,
      makeString: () => Gm,
      skip: () => Zl,
      skipEverythingButNewLine: () => Th,
      skipInlineComment: () => N0,
      skipNewline: () => rl,
      skipSpaces: () => rh,
      skipToLineEnd: () => Ph,
      skipTrailingComment: () => I0,
      skipWhitespace: () => Zc,
    });
    function Im(W, Ge) {
      if (Ge === !1) return !1;
      if (W.charAt(Ge) === '/' && W.charAt(Ge + 1) === '*') {
        for (let An = Ge + 2; An < W.length; ++An) if (W.charAt(An) === '*' && W.charAt(An + 1) === '/') return An + 2;
      }
      return Ge;
    }
    var N0 = Im;
    function Mm(W, Ge) {
      return Ge === !1 ? !1 : W.charAt(Ge) === '/' && W.charAt(Ge + 1) === '/' ? Th(W, Ge) : Ge;
    }
    var I0 = Mm;
    function Om(W, Ge) {
      let An = null,
        Vi = Ge;
      for (; Vi !== An; ) (An = Vi), (Vi = rh(W, Vi)), (Vi = N0(W, Vi)), (Vi = I0(W, Vi)), (Vi = rl(W, Vi));
      return Vi;
    }
    var M0 = Om;
    function Lm(W, Ge) {
      let An = null,
        Vi = Ge;
      for (; Vi !== An; ) (An = Vi), (Vi = Ph(W, Vi)), (Vi = N0(W, Vi)), (Vi = rh(W, Vi));
      return (Vi = I0(W, Vi)), (Vi = rl(W, Vi)), Vi !== !1 && Vh(W, Vi);
    }
    var O0 = Lm;
    function $m(W) {
      if (typeof W != 'string') throw new TypeError('Expected a string');
      return W.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
    }
    function Rm(W, Ge) {
      let An = W.match(new RegExp(`(${$m(Ge)})+`, 'g'));
      return An === null ? 0 : An.reduce((Vi, qi) => Math.max(Vi, qi.length / Ge.length), 0);
    }
    var _m = Rm;
    function jm(W, Ge) {
      let An = W.lastIndexOf(`
`);
      return An === -1 ? 0 : md(W.slice(An + 1).match(/^[\t ]*/)[0], Ge);
    }
    var Vm = jm;
    function Hm(W, Ge, An) {
      for (let Vi = Ge; Vi < An; ++Vi)
        if (
          W.charAt(Vi) ===
          `
`
        )
          return !0;
      return !1;
    }
    var zm = Hm;
    function Wm(W, Ge, An = {}) {
      return rh(W, An.backwards ? Ge - 1 : Ge, An) !== Ge;
    }
    var Um = Wm;
    function qm(W, Ge) {
      let An = M0(W, Ge);
      return An === !1 ? '' : W.charAt(An);
    }
    var Km = qm;
    function Jm(W, Ge, An) {
      let Vi = Ge === '"' ? "'" : '"',
        qi = El(!1, W, /\\(.)|(["'])/gs, (el, Cl, Sl) =>
          Cl === Vi
            ? Cl
            : Sl === Ge
            ? '\\' + Sl
            : Sl || (An && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(Cl) ? Cl : '\\' + Cl),
        );
      return Ge + qi + Ge;
    }
    var Gm = Jm;
    function Ym(W, Ge, An) {
      return M0(W, An(Ge));
    }
    function Xm(W, Ge) {
      return arguments.length === 2 || typeof Ge == 'number' ? M0(W, Ge) : Ym(...arguments);
    }
    function Qm(W, Ge, An) {
      return k0(W, An(Ge));
    }
    function Zm(W, Ge) {
      return arguments.length === 2 || typeof Ge == 'number' ? k0(W, Ge) : Qm(...arguments);
    }
    function e1(W, Ge, An) {
      return O0(W, An(Ge));
    }
    function t1(W, Ge) {
      return arguments.length === 2 || typeof Ge == 'number' ? O0(W, Ge) : e1(...arguments);
    }
    var em = {};
    I(em, { builders: () => r1, printer: () => n1, utils: () => i1 });
    var r1 = {
        join: qd,
        line: Rh,
        softline: Hh,
        hardline: Wh,
        literalline: Ad,
        group: ch,
        conditionalGroup: yh,
        fill: kh,
        lineSuffix: Lh,
        lineSuffixBoundary: Yh,
        cursor: $d,
        breakParent: td,
        ifBreak: Sh,
        trim: rd,
        indent: Qc,
        indentIfBreak: Fh,
        align: Gl,
        addAlignmentToDoc: Kd,
        markAsRoot: dh,
        dedentToRoot: lh,
        dedent: mh,
        hardlineWithoutBreakParent: nd,
        literallineWithoutBreakParent: $h,
        label: Jd,
        concat: (W) => W,
      },
      n1 = { printDocToString: Jh },
      i1 = {
        willBreak: wd,
        traverseDoc: Kl,
        findInDoc: Qd,
        mapDoc: vd,
        removeLines: ld,
        stripTrailingHardline: Zd,
        replaceEndOfLine: n0,
        canBreak: Hd,
      },
      s1 = '3.0.2';
    function Df(W, Ge = 1) {
      return async (...An) => {
        let Vi = An[Ge] ?? {},
          qi = Vi.plugins ?? [];
        return (An[Ge] = { ...Vi, plugins: Array.isArray(qi) ? qi : Object.values(qi) }), W(...An);
      };
    }
    var tm = Df(Q0);
    async function nm(W, Ge) {
      let { formatted: An } = await tm(W, { ...Ge, cursorOffset: -1 });
      return An;
    }
    async function o1(W, Ge) {
      return (await nm(W, Ge)) === W;
    }
    var a1 = Df(kf, 0),
      l1 = { parse: Df(Tm), formatAST: Df(km), formatDoc: Df(Pm), printToDoc: Df(Bm), printDocToString: Df(Nm) };
    return se(vl);
  });
})(standalone);
var standaloneExports = standalone.exports,
  Ys$1 = Object.create,
  Ke$1 = Object.defineProperty,
  Qs$1 = Object.getOwnPropertyDescriptor,
  Zs$1 = Object.getOwnPropertyNames,
  ei$1 = Object.getPrototypeOf,
  ti$1 = Object.prototype.hasOwnProperty,
  Bt$1 = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports),
  si$1 = (r, e) => {
    for (var n in e) Ke$1(r, n, { get: e[n], enumerable: !0 });
  },
  ii$1 = (r, e, n, s) => {
    if ((e && typeof e == 'object') || typeof e == 'function')
      for (let o of Zs$1(e))
        !ti$1.call(r, o) && o !== n && Ke$1(r, o, { get: () => e[o], enumerable: !(s = Qs$1(e, o)) || s.enumerable });
    return r;
  },
  qe$1 = (r, e, n) => (
    (n = r != null ? Ys$1(ei$1(r)) : {}),
    ii$1(e || !r || !r.__esModule ? Ke$1(n, 'default', { value: r, enumerable: !0 }) : n, r)
  ),
  kt$1 = Bt$1((r) => {
    Object.defineProperty(r, '__esModule', { value: !0 });
    function e(g, u) {
      if (g == null) return {};
      var N = {},
        _ = Object.keys(g),
        Be,
        Cn;
      for (Cn = 0; Cn < _.length; Cn++) (Be = _[Cn]), !(u.indexOf(Be) >= 0) && (N[Be] = g[Be]);
      return N;
    }
    var n = class {
        constructor(g, u, N) {
          (this.line = void 0),
            (this.column = void 0),
            (this.index = void 0),
            (this.line = g),
            (this.column = u),
            (this.index = N);
        }
      },
      s = class {
        constructor(g, u) {
          (this.start = void 0),
            (this.end = void 0),
            (this.filename = void 0),
            (this.identifierName = void 0),
            (this.start = g),
            (this.end = u);
        }
      };
    function o(g, u) {
      let { line: N, column: _, index: Be } = g;
      return new n(N, _ + u, Be + u);
    }
    var a = {
        SyntaxError: 'BABEL_PARSER_SYNTAX_ERROR',
        SourceTypeModuleError: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
      },
      l = (g, u = g.length - 1) => ({
        get() {
          return g.reduce((N, _) => N[_], this);
        },
        set(N) {
          g.reduce((_, Be, Cn) => (Cn === u ? (_[Be] = N) : _[Be]), this);
        },
      }),
      f = (g, u, N) =>
        Object.keys(N)
          .map((_) => [_, N[_]])
          .filter(([, _]) => !!_)
          .map(([_, Be]) => [
            _,
            typeof Be == 'function'
              ? { value: Be, enumerable: !1 }
              : typeof Be.reflect == 'string'
              ? Object.assign({}, Be, l(Be.reflect.split('.')))
              : Be,
          ])
          .reduce(
            (_, [Be, Cn]) => Object.defineProperty(_, Be, Object.assign({ configurable: !0 }, Cn)),
            Object.assign(new g(), u),
          ),
      m = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: a.SourceTypeModuleError,
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: a.SourceTypeModuleError,
        },
      },
      v = {
        ArrayPattern: 'array destructuring pattern',
        AssignmentExpression: 'assignment expression',
        AssignmentPattern: 'assignment expression',
        ArrowFunctionExpression: 'arrow function expression',
        ConditionalExpression: 'conditional expression',
        CatchClause: 'catch clause',
        ForOfStatement: 'for-of statement',
        ForInStatement: 'for-in statement',
        ForStatement: 'for-loop',
        FormalParameters: 'function parameter list',
        Identifier: 'identifier',
        ImportSpecifier: 'import specifier',
        ImportDefaultSpecifier: 'import default specifier',
        ImportNamespaceSpecifier: 'import namespace specifier',
        ObjectPattern: 'object destructuring pattern',
        ParenthesizedExpression: 'parenthesized expression',
        RestElement: 'rest element',
        UpdateExpression: { true: 'prefix operation', false: 'postfix operation' },
        VariableDeclarator: 'variable declaration',
        YieldExpression: 'yield expression',
      },
      I = ({ type: g, prefix: u }) => (g === 'UpdateExpression' ? v.UpdateExpression[String(u)] : v[g]),
      L = {
        AccessorIsGenerator: ({ kind: g }) => `A ${g}ter cannot be a generator.`,
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext:
          'Async functions can only be declared at the top level or inside a block.',
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitUsingNotInAsyncContext:
          "'await using' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accessor must not have any formal parameters.",
        BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: 'Class constructor may not be an accessor.',
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({ kind: g }) => `Missing initializer in ${g} declaration.`,
        DecoratorArgumentsOutsideParentheses:
          "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
        DecoratorBeforeExport:
          "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
        DecoratorsBeforeAfterExport:
          "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass:
          "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
        DecoratorSemicolon: 'Decorators must not be followed by a semicolon.',
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: 'Deleting a private field is not allowed.',
        DestructureNamedImport:
          'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
        DuplicateConstructor: 'Duplicate constructor in the same class.',
        DuplicateDefaultExport: 'Only one default export allowed per module.',
        DuplicateExport: ({ exportName: g }) =>
          `\`${g}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: 'Redefinition of __proto__ property.',
        DuplicateRegExpFlags: 'Duplicate regular expression flag.',
        ElementAfterRest: 'Rest element must be last element.',
        EscapedCharNotAnIdentifier: 'Invalid Unicode escape.',
        ExportBindingIsString: ({
          localName: g,
          exportName: u,
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${g}' as '${u}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({ type: g }) =>
          `'${g === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`,
        ForInUsing: "For-in loop may not start with 'using' declaration.",
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.',
        IllegalBreakContinue: ({ type: g }) => `Unsyntactic ${g === 'BreakStatement' ? 'break' : 'continue'}.`,
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportAttributesUseAssert:
          'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.',
        ImportBindingIsString: ({ importName: g }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${g}" as foo }\`?`,
        ImportCallArgumentTrailingComma: 'Trailing comma is disallowed inside import(...) arguments.',
        ImportCallArity: ({ maxArgumentCount: g }) =>
          `\`import()\` requires exactly ${g === 1 ? 'one argument' : 'one or two arguments'}.`,
        ImportCallNotNewExpression: 'Cannot use new with import(...).',
        ImportCallSpreadArgument: '`...` is not allowed in `import()`.',
        ImportJSONBindingNotDefault: 'A JSON module can only be imported with `default`.',
        ImportReflectionHasAssertion: '`import module x` cannot have assertions.',
        ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
        IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: 'Invalid BigIntLiteral.',
        InvalidCodePoint: 'Code point out of bounds.',
        InvalidCoverInitializedName: 'Invalid shorthand property initializer.',
        InvalidDecimal: 'Invalid decimal.',
        InvalidDigit: ({ radix: g }) => `Expected number in radix ${g}.`,
        InvalidEscapeSequence: 'Bad character escape sequence.',
        InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.',
        InvalidEscapedReservedWord: ({ reservedWord: g }) => `Escape sequence in keyword ${g}.`,
        InvalidIdentifier: ({ identifierName: g }) => `Invalid identifier ${g}.`,
        InvalidLhs: ({ ancestor: g }) => `Invalid left-hand side in ${I(g)}.`,
        InvalidLhsBinding: ({ ancestor: g }) => `Binding invalid left-hand side in ${I(g)}.`,
        InvalidNumber: 'Invalid number.',
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({ unexpected: g }) => `Unexpected character '${g}'.`,
        InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.',
        InvalidPrivateFieldResolution: ({ identifierName: g }) => `Private name #${g} is not defined.`,
        InvalidPropertyBindingPattern: 'Binding member expression.',
        InvalidRecordProperty: 'Only properties and spread elements are allowed in record definitions.',
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({ labelName: g }) => `Label '${g}' is already declared.`,
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: 'Invalid regular expression flag.',
        MissingClassName: 'A class name is required.',
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: 'Missing semicolon.',
        MissingPlugin: ({ missingPlugin: g }) =>
          `This experimental syntax requires enabling the parser plugin: ${g
            .map((u) => JSON.stringify(u))
            .join(', ')}.`,
        MissingOneOfPlugins: ({ missingPlugin: g }) =>
          `This experimental syntax requires enabling one of the following parser plugin(s): ${g
            .map((u) => JSON.stringify(u))
            .join(', ')}.`,
        MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.',
        MixingCoalesceWithLogical:
          'Nullish coalescing operator(??) requires parens when mixing with logical operators.',
        ModuleAttributeDifferentFromType: 'The only accepted module attribute is `type`.',
        ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.',
        ModuleAttributesWithDuplicateKeys: ({ key: g }) => `Duplicate key "${g}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: g }) =>
          `An export name cannot include a lone surrogate, found '\\u${g.toString(16)}'.`,
        ModuleExportUndefined: ({ localName: g }) => `Export '${g}' is not defined.`,
        MultipleDefaultsInSwitch: 'Multiple default clauses.',
        NewlineAfterThrow: 'Illegal newline after throw.',
        NoCatchOrFinally: 'Missing catch or finally clause.',
        NumberIdentifier: 'Identifier directly after number.',
        NumericSeparatorInEscapeSequence:
          'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.',
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.',
        OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.',
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: 'Argument name clash.',
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({ identifierName: g }) =>
          `Private names are only allowed in property accesses (\`obj.#${g}\`) or in \`in\` expressions (\`#${g} in obj\`).`,
        PrivateNameRedeclaration: ({ identifierName: g }) => `Duplicate private name #${g}.`,
        RecordExpressionBarIncorrectEndSyntaxType:
          "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType:
          "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType:
          "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: 'Unexpected trailing comma after rest element.',
        SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.',
        SloppyFunctionAnnexB:
          'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.',
        StaticPrototype: 'Classes may not have static property named prototype.',
        SuperNotAllowed:
          "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: 'Decorators must be attached to a class element.',
        TupleExpressionBarIncorrectEndSyntaxType:
          "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType:
          "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType:
          "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.',
        UnexpectedAwaitAfterPipelineBody:
          'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: 'Unexpected digit after hash token.',
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({ keyword: g }) => `Unexpected keyword '${g}'.`,
        UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.',
        UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.',
        UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.',
        UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.',
        UnexpectedPrivateField: 'Unexpected private name.',
        UnexpectedReservedWord: ({ reservedWord: g }) => `Unexpected reserved word '${g}'.`,
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({ expected: g, unexpected: u }) =>
          `Unexpected token${u ? ` '${u}'.` : ''}${g ? `, expected "${g}"` : ''}`,
        UnexpectedTokenUnaryExponentiation:
          'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
        UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script`.',
        UnsupportedBind: 'Binding should be performed on object property.',
        UnsupportedDecoratorExport: 'A decorated export must export a class declaration.',
        UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.',
        UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.',
        UnsupportedMetaProperty: ({ target: g, onlyValidPropertyName: u }) =>
          `The only valid meta property for ${g} is ${g}.${u}.`,
        UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.',
        UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.',
        UnsupportedSuper:
          "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: 'Unterminated comment.',
        UnterminatedRegExp: 'Unterminated regular expression.',
        UnterminatedString: 'Unterminated string constant.',
        UnterminatedTemplate: 'Unterminated template.',
        UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.',
        VarRedeclaration: ({ identifierName: g }) => `Identifier '${g}' has already been declared.`,
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: 'Yield expression is not allowed in formal parameters.',
        ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.',
      },
      V = {
        StrictDelete: 'Deleting local variable in strict mode.',
        StrictEvalArguments: ({ referenceName: g }) => `Assigning to '${g}' in strict mode.`,
        StrictEvalArgumentsBinding: ({ bindingName: g }) => `Binding '${g}' in strict mode.`,
        StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.',
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.',
        StrictWith: "'with' in strict mode.",
      },
      se = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression']),
      Ee = {
        PipeBodyIsTighter:
          'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.',
        PipeTopicRequiresHackPipes:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.',
        PipeTopicUnconfiguredToken: ({ token: g }) =>
          `Invalid topic token ${g}. In order to use ${g} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${g}" }.`,
        PipeTopicUnused:
          'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.',
        PipeUnparenthesizedBody: ({ type: g }) =>
          `Hack-style pipe body cannot be an unparenthesized ${I({ type: g })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow:
          'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: 'Pipeline body may not be a comma-separated sequence expression.',
        PipelineHeadSequenceExpression: 'Pipeline head should not be a comma-separated sequence expression.',
        PipelineTopicUnused: 'Pipeline is in topic style but does not use topic reference.',
        PrimaryTopicNotAllowed: 'Topic reference was used in a lexical context without topic binding.',
        PrimaryTopicRequiresSmartPipeline:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      },
      ht = ['toMessage'],
      ar = ['message'];
    function $i(g) {
      let { toMessage: u } = g,
        N = e(g, ht);
      return function _({ loc: Be, details: Cn }) {
        return f(SyntaxError, Object.assign({}, N, { loc: Be }), {
          clone(Yi = {}) {
            let nl = Yi.loc || {};
            return _({
              loc: new n(
                'line' in nl ? nl.line : this.loc.line,
                'column' in nl ? nl.column : this.loc.column,
                'index' in nl ? nl.index : this.loc.index,
              ),
              details: Object.assign({}, this.details, Yi.details),
            });
          },
          details: { value: Cn, enumerable: !1 },
          message: {
            get() {
              return `${u(this.details)} (${this.loc.line}:${this.loc.column})`;
            },
            set(Yi) {
              Object.defineProperty(this, 'message', { value: Yi });
            },
          },
          pos: { reflect: 'loc.index', enumerable: !0 },
          missingPlugin: 'missingPlugin' in Cn && { reflect: 'details.missingPlugin', enumerable: !0 },
        });
      };
    }
    function tl(g, u) {
      if (Array.isArray(g)) return (_) => tl(_, g[0]);
      let N = {};
      for (let _ of Object.keys(g)) {
        let Be = g[_],
          Cn = typeof Be == 'string' ? { message: () => Be } : typeof Be == 'function' ? { message: Be } : Be,
          { message: Yi } = Cn,
          nl = e(Cn, ar),
          xl = typeof Yi == 'string' ? () => Yi : Yi;
        N[_] = $i(
          Object.assign({ code: a.SyntaxError, reasonCode: _, toMessage: xl }, u ? { syntaxPlugin: u } : {}, nl),
        );
      }
      return N;
    }
    var Wi = Object.assign({}, tl(m), tl(L), tl(V), tl`pipelineOperator`(Ee)),
      { defineProperty: hl } = Object,
      fl = (g, u) => hl(g, u, { enumerable: !1, value: g[u] });
    function dl(g) {
      return g.loc.start && fl(g.loc.start, 'index'), g.loc.end && fl(g.loc.end, 'index'), g;
    }
    var Al = (g) =>
        class extends g {
          parse() {
            let u = dl(super.parse());
            return this.options.tokens && (u.tokens = u.tokens.map(dl)), u;
          }
          parseRegExpLiteral({ pattern: u, flags: N }) {
            let _ = null;
            try {
              _ = new RegExp(u, N);
            } catch {}
            let Be = this.estreeParseLiteral(_);
            return (Be.regex = { pattern: u, flags: N }), Be;
          }
          parseBigIntLiteral(u) {
            let N;
            try {
              N = BigInt(u);
            } catch {
              N = null;
            }
            let _ = this.estreeParseLiteral(N);
            return (_.bigint = String(_.value || u)), _;
          }
          parseDecimalLiteral(u) {
            let N = this.estreeParseLiteral(null);
            return (N.decimal = String(N.value || u)), N;
          }
          estreeParseLiteral(u) {
            return this.parseLiteral(u, 'Literal');
          }
          parseStringLiteral(u) {
            return this.estreeParseLiteral(u);
          }
          parseNumericLiteral(u) {
            return this.estreeParseLiteral(u);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(u) {
            return this.estreeParseLiteral(u);
          }
          directiveToStmt(u) {
            let N = u.value;
            delete u.value, (N.type = 'Literal'), (N.raw = N.extra.raw), (N.value = N.extra.expressionValue);
            let _ = u;
            return (
              (_.type = 'ExpressionStatement'), (_.expression = N), (_.directive = N.extra.rawValue), delete N.extra, _
            );
          }
          initFunction(u, N) {
            super.initFunction(u, N), (u.expression = !1);
          }
          checkDeclaration(u) {
            u != null && this.isObjectProperty(u) ? this.checkDeclaration(u.value) : super.checkDeclaration(u);
          }
          getObjectOrClassMethodParams(u) {
            return u.value.params;
          }
          isValidDirective(u) {
            var N;
            return (
              u.type === 'ExpressionStatement' &&
              u.expression.type === 'Literal' &&
              typeof u.expression.value == 'string' &&
              !((N = u.expression.extra) != null && N.parenthesized)
            );
          }
          parseBlockBody(u, N, _, Be, Cn) {
            super.parseBlockBody(u, N, _, Be, Cn);
            let Yi = u.directives.map((nl) => this.directiveToStmt(nl));
            (u.body = Yi.concat(u.body)), delete u.directives;
          }
          pushClassMethod(u, N, _, Be, Cn, Yi) {
            this.parseMethod(N, _, Be, Cn, Yi, 'ClassMethod', !0),
              N.typeParameters && ((N.value.typeParameters = N.typeParameters), delete N.typeParameters),
              u.body.push(N);
          }
          parsePrivateName() {
            let u = super.parsePrivateName();
            return this.getPluginOption('estree', 'classFeatures') ? this.convertPrivateNameToPrivateIdentifier(u) : u;
          }
          convertPrivateNameToPrivateIdentifier(u) {
            let N = super.getPrivateNameSV(u);
            return (u = u), delete u.id, (u.name = N), (u.type = 'PrivateIdentifier'), u;
          }
          isPrivateName(u) {
            return this.getPluginOption('estree', 'classFeatures')
              ? u.type === 'PrivateIdentifier'
              : super.isPrivateName(u);
          }
          getPrivateNameSV(u) {
            return this.getPluginOption('estree', 'classFeatures') ? u.name : super.getPrivateNameSV(u);
          }
          parseLiteral(u, N) {
            let _ = super.parseLiteral(u, N);
            return (_.raw = _.extra.raw), delete _.extra, _;
          }
          parseFunctionBody(u, N, _ = !1) {
            super.parseFunctionBody(u, N, _), (u.expression = u.body.type !== 'BlockStatement');
          }
          parseMethod(u, N, _, Be, Cn, Yi, nl = !1) {
            let xl = this.startNode();
            return (
              (xl.kind = u.kind),
              (xl = super.parseMethod(xl, N, _, Be, Cn, Yi, nl)),
              (xl.type = 'FunctionExpression'),
              delete xl.kind,
              (u.value = xl),
              Yi === 'ClassPrivateMethod' && (u.computed = !1),
              this.finishNode(u, 'MethodDefinition')
            );
          }
          parseClassProperty(...u) {
            let N = super.parseClassProperty(...u);
            return this.getPluginOption('estree', 'classFeatures') && (N.type = 'PropertyDefinition'), N;
          }
          parseClassPrivateProperty(...u) {
            let N = super.parseClassPrivateProperty(...u);
            return (
              this.getPluginOption('estree', 'classFeatures') && ((N.type = 'PropertyDefinition'), (N.computed = !1)), N
            );
          }
          parseObjectMethod(u, N, _, Be, Cn) {
            let Yi = super.parseObjectMethod(u, N, _, Be, Cn);
            return Yi && ((Yi.type = 'Property'), Yi.kind === 'method' && (Yi.kind = 'init'), (Yi.shorthand = !1)), Yi;
          }
          parseObjectProperty(u, N, _, Be) {
            let Cn = super.parseObjectProperty(u, N, _, Be);
            return Cn && ((Cn.kind = 'init'), (Cn.type = 'Property')), Cn;
          }
          isValidLVal(u, N, _) {
            return u === 'Property' ? 'value' : super.isValidLVal(u, N, _);
          }
          isAssignable(u, N) {
            return u != null && this.isObjectProperty(u) ? this.isAssignable(u.value, N) : super.isAssignable(u, N);
          }
          toAssignable(u, N = !1) {
            if (u != null && this.isObjectProperty(u)) {
              let { key: _, value: Be } = u;
              this.isPrivateName(_) && this.classScope.usePrivateName(this.getPrivateNameSV(_), _.loc.start),
                this.toAssignable(Be, N);
            } else super.toAssignable(u, N);
          }
          toAssignableObjectExpressionProp(u, N, _) {
            u.kind === 'get' || u.kind === 'set'
              ? this.raise(Wi.PatternHasAccessor, { at: u.key })
              : u.method
              ? this.raise(Wi.PatternHasMethod, { at: u.key })
              : super.toAssignableObjectExpressionProp(u, N, _);
          }
          finishCallExpression(u, N) {
            let _ = super.finishCallExpression(u, N);
            if (_.callee.type === 'Import') {
              if (
                ((_.type = 'ImportExpression'),
                (_.source = _.arguments[0]),
                this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions'))
              ) {
                var Be;
                _.attributes = (Be = _.arguments[1]) != null ? Be : null;
              }
              delete _.arguments, delete _.callee;
            }
            return _;
          }
          toReferencedArguments(u) {
            u.type !== 'ImportExpression' && super.toReferencedArguments(u);
          }
          parseExport(u, N) {
            let _ = this.state.lastTokStartLoc,
              Be = super.parseExport(u, N);
            switch (Be.type) {
              case 'ExportAllDeclaration':
                Be.exported = null;
                break;
              case 'ExportNamedDeclaration':
                Be.specifiers.length === 1 &&
                  Be.specifiers[0].type === 'ExportNamespaceSpecifier' &&
                  ((Be.type = 'ExportAllDeclaration'), (Be.exported = Be.specifiers[0].exported), delete Be.specifiers);
              case 'ExportDefaultDeclaration':
                {
                  var Cn;
                  let { declaration: Yi } = Be;
                  (Yi == null ? void 0 : Yi.type) === 'ClassDeclaration' &&
                    ((Cn = Yi.decorators) == null ? void 0 : Cn.length) > 0 &&
                    Yi.start === Be.start &&
                    this.resetStartLocation(Be, _);
                }
                break;
            }
            return Be;
          }
          parseSubscript(u, N, _, Be) {
            let Cn = super.parseSubscript(u, N, _, Be);
            if (Be.optionalChainMember) {
              if (
                ((Cn.type === 'OptionalMemberExpression' || Cn.type === 'OptionalCallExpression') &&
                  (Cn.type = Cn.type.substring(8)),
                Be.stop)
              ) {
                let Yi = this.startNodeAtNode(Cn);
                return (Yi.expression = Cn), this.finishNode(Yi, 'ChainExpression');
              }
            } else (Cn.type === 'MemberExpression' || Cn.type === 'CallExpression') && (Cn.optional = !1);
            return Cn;
          }
          hasPropertyAsPrivateName(u) {
            return u.type === 'ChainExpression' && (u = u.expression), super.hasPropertyAsPrivateName(u);
          }
          isObjectProperty(u) {
            return u.type === 'Property' && u.kind === 'init' && !u.method;
          }
          isObjectMethod(u) {
            return u.method || u.kind === 'get' || u.kind === 'set';
          }
          finishNodeAt(u, N, _) {
            return dl(super.finishNodeAt(u, N, _));
          }
          resetStartLocation(u, N) {
            super.resetStartLocation(u, N), dl(u);
          }
          resetEndLocation(u, N = this.state.lastTokEndLoc) {
            super.resetEndLocation(u, N), dl(u);
          }
        },
      Fl = class {
        constructor(g, u) {
          (this.token = void 0), (this.preserveSpace = void 0), (this.token = g), (this.preserveSpace = !!u);
        }
      },
      vl = {
        brace: new Fl('{'),
        j_oTag: new Fl('<tag'),
        j_cTag: new Fl('</tag'),
        j_expr: new Fl('<tag>...</tag>', !0),
      };
    vl.template = new Fl('`', !0);
    var kl = !0,
      El = !0,
      Jl = !0,
      Kc = !0,
      Il = !0,
      Ll = !0,
      Nl = class {
        constructor(g, u = {}) {
          (this.label = void 0),
            (this.keyword = void 0),
            (this.beforeExpr = void 0),
            (this.startsExpr = void 0),
            (this.rightAssociative = void 0),
            (this.isLoop = void 0),
            (this.isAssign = void 0),
            (this.prefix = void 0),
            (this.postfix = void 0),
            (this.binop = void 0),
            (this.label = g),
            (this.keyword = u.keyword),
            (this.beforeExpr = !!u.beforeExpr),
            (this.startsExpr = !!u.startsExpr),
            (this.rightAssociative = !!u.rightAssociative),
            (this.isLoop = !!u.isLoop),
            (this.isAssign = !!u.isAssign),
            (this.prefix = !!u.prefix),
            (this.postfix = !!u.postfix),
            (this.binop = u.binop != null ? u.binop : null),
            (this.updateContext = null);
        }
      },
      Hl = new Map();
    function Bl(g, u = {}) {
      u.keyword = g;
      let N = wl(g, u);
      return Hl.set(g, N), N;
    }
    function ql(g, u) {
      return wl(g, { beforeExpr: kl, binop: u });
    }
    var Yl = -1,
      ih = [],
      ph = [],
      gh = [],
      xh = [],
      bh = [],
      Ah = [];
    function wl(g, u = {}) {
      var N, _, Be, Cn;
      return (
        ++Yl,
        ph.push(g),
        gh.push((N = u.binop) != null ? N : -1),
        xh.push((_ = u.beforeExpr) != null ? _ : !1),
        bh.push((Be = u.startsExpr) != null ? Be : !1),
        Ah.push((Cn = u.prefix) != null ? Cn : !1),
        ih.push(new Nl(g, u)),
        Yl
      );
    }
    function zl(g, u = {}) {
      var N, _, Be, Cn;
      return (
        ++Yl,
        Hl.set(g, Yl),
        ph.push(g),
        gh.push((N = u.binop) != null ? N : -1),
        xh.push((_ = u.beforeExpr) != null ? _ : !1),
        bh.push((Be = u.startsExpr) != null ? Be : !1),
        Ah.push((Cn = u.prefix) != null ? Cn : !1),
        ih.push(new Nl('name', u)),
        Yl
      );
    }
    var zc = {
      bracketL: wl('[', { beforeExpr: kl, startsExpr: El }),
      bracketHashL: wl('#[', { beforeExpr: kl, startsExpr: El }),
      bracketBarL: wl('[|', { beforeExpr: kl, startsExpr: El }),
      bracketR: wl(']'),
      bracketBarR: wl('|]'),
      braceL: wl('{', { beforeExpr: kl, startsExpr: El }),
      braceBarL: wl('{|', { beforeExpr: kl, startsExpr: El }),
      braceHashL: wl('#{', { beforeExpr: kl, startsExpr: El }),
      braceR: wl('}'),
      braceBarR: wl('|}'),
      parenL: wl('(', { beforeExpr: kl, startsExpr: El }),
      parenR: wl(')'),
      comma: wl(',', { beforeExpr: kl }),
      semi: wl(';', { beforeExpr: kl }),
      colon: wl(':', { beforeExpr: kl }),
      doubleColon: wl('::', { beforeExpr: kl }),
      dot: wl('.'),
      question: wl('?', { beforeExpr: kl }),
      questionDot: wl('?.'),
      arrow: wl('=>', { beforeExpr: kl }),
      template: wl('template'),
      ellipsis: wl('...', { beforeExpr: kl }),
      backQuote: wl('`', { startsExpr: El }),
      dollarBraceL: wl('${', { beforeExpr: kl, startsExpr: El }),
      templateTail: wl('...`', { startsExpr: El }),
      templateNonTail: wl('...${', { beforeExpr: kl, startsExpr: El }),
      at: wl('@'),
      hash: wl('#', { startsExpr: El }),
      interpreterDirective: wl('#!...'),
      eq: wl('=', { beforeExpr: kl, isAssign: Kc }),
      assign: wl('_=', { beforeExpr: kl, isAssign: Kc }),
      slashAssign: wl('_=', { beforeExpr: kl, isAssign: Kc }),
      xorAssign: wl('_=', { beforeExpr: kl, isAssign: Kc }),
      moduloAssign: wl('_=', { beforeExpr: kl, isAssign: Kc }),
      incDec: wl('++/--', { prefix: Il, postfix: Ll, startsExpr: El }),
      bang: wl('!', { beforeExpr: kl, prefix: Il, startsExpr: El }),
      tilde: wl('~', { beforeExpr: kl, prefix: Il, startsExpr: El }),
      doubleCaret: wl('^^', { startsExpr: El }),
      doubleAt: wl('@@', { startsExpr: El }),
      pipeline: ql('|>', 0),
      nullishCoalescing: ql('??', 1),
      logicalOR: ql('||', 1),
      logicalAND: ql('&&', 2),
      bitwiseOR: ql('|', 3),
      bitwiseXOR: ql('^', 4),
      bitwiseAND: ql('&', 5),
      equality: ql('==/!=/===/!==', 6),
      lt: ql('</>/<=/>=', 7),
      gt: ql('</>/<=/>=', 7),
      relational: ql('</>/<=/>=', 7),
      bitShift: ql('<</>>/>>>', 8),
      bitShiftL: ql('<</>>/>>>', 8),
      bitShiftR: ql('<</>>/>>>', 8),
      plusMin: wl('+/-', { beforeExpr: kl, binop: 9, prefix: Il, startsExpr: El }),
      modulo: wl('%', { binop: 10, startsExpr: El }),
      star: wl('*', { binop: 10 }),
      slash: ql('/', 10),
      exponent: wl('**', { beforeExpr: kl, binop: 11, rightAssociative: !0 }),
      _in: Bl('in', { beforeExpr: kl, binop: 7 }),
      _instanceof: Bl('instanceof', { beforeExpr: kl, binop: 7 }),
      _break: Bl('break'),
      _case: Bl('case', { beforeExpr: kl }),
      _catch: Bl('catch'),
      _continue: Bl('continue'),
      _debugger: Bl('debugger'),
      _default: Bl('default', { beforeExpr: kl }),
      _else: Bl('else', { beforeExpr: kl }),
      _finally: Bl('finally'),
      _function: Bl('function', { startsExpr: El }),
      _if: Bl('if'),
      _return: Bl('return', { beforeExpr: kl }),
      _switch: Bl('switch'),
      _throw: Bl('throw', { beforeExpr: kl, prefix: Il, startsExpr: El }),
      _try: Bl('try'),
      _var: Bl('var'),
      _const: Bl('const'),
      _with: Bl('with'),
      _new: Bl('new', { beforeExpr: kl, startsExpr: El }),
      _this: Bl('this', { startsExpr: El }),
      _super: Bl('super', { startsExpr: El }),
      _class: Bl('class', { startsExpr: El }),
      _extends: Bl('extends', { beforeExpr: kl }),
      _export: Bl('export'),
      _import: Bl('import', { startsExpr: El }),
      _null: Bl('null', { startsExpr: El }),
      _true: Bl('true', { startsExpr: El }),
      _false: Bl('false', { startsExpr: El }),
      _typeof: Bl('typeof', { beforeExpr: kl, prefix: Il, startsExpr: El }),
      _void: Bl('void', { beforeExpr: kl, prefix: Il, startsExpr: El }),
      _delete: Bl('delete', { beforeExpr: kl, prefix: Il, startsExpr: El }),
      _do: Bl('do', { isLoop: Jl, beforeExpr: kl }),
      _for: Bl('for', { isLoop: Jl }),
      _while: Bl('while', { isLoop: Jl }),
      _as: zl('as', { startsExpr: El }),
      _assert: zl('assert', { startsExpr: El }),
      _async: zl('async', { startsExpr: El }),
      _await: zl('await', { startsExpr: El }),
      _from: zl('from', { startsExpr: El }),
      _get: zl('get', { startsExpr: El }),
      _let: zl('let', { startsExpr: El }),
      _meta: zl('meta', { startsExpr: El }),
      _of: zl('of', { startsExpr: El }),
      _sent: zl('sent', { startsExpr: El }),
      _set: zl('set', { startsExpr: El }),
      _static: zl('static', { startsExpr: El }),
      _using: zl('using', { startsExpr: El }),
      _yield: zl('yield', { startsExpr: El }),
      _asserts: zl('asserts', { startsExpr: El }),
      _checks: zl('checks', { startsExpr: El }),
      _exports: zl('exports', { startsExpr: El }),
      _global: zl('global', { startsExpr: El }),
      _implements: zl('implements', { startsExpr: El }),
      _intrinsic: zl('intrinsic', { startsExpr: El }),
      _infer: zl('infer', { startsExpr: El }),
      _is: zl('is', { startsExpr: El }),
      _mixins: zl('mixins', { startsExpr: El }),
      _proto: zl('proto', { startsExpr: El }),
      _require: zl('require', { startsExpr: El }),
      _satisfies: zl('satisfies', { startsExpr: El }),
      _keyof: zl('keyof', { startsExpr: El }),
      _readonly: zl('readonly', { startsExpr: El }),
      _unique: zl('unique', { startsExpr: El }),
      _abstract: zl('abstract', { startsExpr: El }),
      _declare: zl('declare', { startsExpr: El }),
      _enum: zl('enum', { startsExpr: El }),
      _module: zl('module', { startsExpr: El }),
      _namespace: zl('namespace', { startsExpr: El }),
      _interface: zl('interface', { startsExpr: El }),
      _type: zl('type', { startsExpr: El }),
      _opaque: zl('opaque', { startsExpr: El }),
      name: wl('name', { startsExpr: El }),
      string: wl('string', { startsExpr: El }),
      num: wl('num', { startsExpr: El }),
      bigint: wl('bigint', { startsExpr: El }),
      decimal: wl('decimal', { startsExpr: El }),
      regexp: wl('regexp', { startsExpr: El }),
      privateName: wl('#name', { startsExpr: El }),
      eof: wl('eof'),
      jsxName: wl('jsxName'),
      jsxText: wl('jsxText', { beforeExpr: !0 }),
      jsxTagStart: wl('jsxTagStart', { startsExpr: !0 }),
      jsxTagEnd: wl('jsxTagEnd'),
      placeholder: wl('%%', { startsExpr: !0 }),
    };
    function Ul(g) {
      return g >= 93 && g <= 130;
    }
    function Dh(g) {
      return g <= 92;
    }
    function gl(g) {
      return g >= 58 && g <= 130;
    }
    function bl(g) {
      return g >= 58 && g <= 134;
    }
    function Pl(g) {
      return xh[g];
    }
    function Rl(g) {
      return bh[g];
    }
    function Wl(g) {
      return g >= 29 && g <= 33;
    }
    function Kl(g) {
      return g >= 127 && g <= 129;
    }
    function th(g) {
      return g >= 90 && g <= 92;
    }
    function Hc(g) {
      return g >= 58 && g <= 92;
    }
    function Qc(g) {
      return g >= 39 && g <= 59;
    }
    function Gl(g) {
      return g === 34;
    }
    function ch(g) {
      return Ah[g];
    }
    function lh(g) {
      return g >= 119 && g <= 121;
    }
    function dh(g) {
      return g >= 122 && g <= 128;
    }
    function mh(g) {
      return ph[g];
    }
    function yh(g) {
      return gh[g];
    }
    function kh(g) {
      return g === 57;
    }
    function Sh(g) {
      return g >= 24 && g <= 25;
    }
    function Fh(g) {
      return ih[g];
    }
    (ih[8].updateContext = (g) => {
      g.pop();
    }),
      (ih[5].updateContext =
        ih[7].updateContext =
        ih[23].updateContext =
          (g) => {
            g.push(vl.brace);
          }),
      (ih[22].updateContext = (g) => {
        g[g.length - 1] === vl.template ? g.pop() : g.push(vl.template);
      }),
      (ih[140].updateContext = (g) => {
        g.push(vl.j_expr, vl.j_oTag);
      });
    var Lh =
        'ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ',
      Yh =
        '‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿',
      td = new RegExp('[' + Lh + ']'),
      rd = new RegExp('[' + Lh + Yh + ']');
    Lh = Yh = null;
    var nd = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35,
        5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310,
        10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21,
        11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17,
        111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3,
        0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2,
        0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2,
        31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0,
        3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
        264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2,
        33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29,
        19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2,
        6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0,
        3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2,
        30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
        29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2,
        3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6,
        2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541,
        1507, 4938, 6, 4191,
      ],
      $h = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10,
        50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13,
        9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193,
        17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9,
        71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2,
        7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49,
        6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
        1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2,
        14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9,
        4759, 9, 787719, 239,
      ];
    function Rh(g, u) {
      let N = 65536;
      for (let _ = 0, Be = u.length; _ < Be; _ += 2) {
        if (((N += u[_]), N > g)) return !1;
        if (((N += u[_ + 1]), N >= g)) return !0;
      }
      return !1;
    }
    function Hh(g) {
      return g < 65
        ? g === 36
        : g <= 90
        ? !0
        : g < 97
        ? g === 95
        : g <= 122
        ? !0
        : g <= 65535
        ? g >= 170 && td.test(String.fromCharCode(g))
        : Rh(g, nd);
    }
    function Wh(g) {
      return g < 48
        ? g === 36
        : g < 58
        ? !0
        : g < 65
        ? !1
        : g <= 90
        ? !0
        : g < 97
        ? g === 95
        : g <= 122
        ? !0
        : g <= 65535
        ? g >= 170 && rd.test(String.fromCharCode(g))
        : Rh(g, nd) || Rh(g, $h);
    }
    var Ad = {
        keyword: [
          'break',
          'case',
          'catch',
          'continue',
          'debugger',
          'default',
          'do',
          'else',
          'finally',
          'for',
          'function',
          'if',
          'return',
          'switch',
          'throw',
          'try',
          'var',
          'const',
          'while',
          'with',
          'new',
          'this',
          'super',
          'class',
          'extends',
          'export',
          'import',
          'null',
          'true',
          'false',
          'in',
          'instanceof',
          'typeof',
          'void',
          'delete',
        ],
        strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
        strictBind: ['eval', 'arguments'],
      },
      $d = new Set(Ad.keyword),
      qd = new Set(Ad.strict),
      Kd = new Set(Ad.strictBind);
    function Jd(g, u) {
      return (u && g === 'await') || g === 'enum';
    }
    function Rd(g, u) {
      return Jd(g, u) || qd.has(g);
    }
    function Ih(g) {
      return Kd.has(g);
    }
    function Gd(g, u) {
      return Rd(g, u) || Ih(g);
    }
    function _d(g) {
      return $d.has(g);
    }
    function uh(g, u, N) {
      return g === 64 && u === 64 && Hh(N);
    }
    var dd = new Set([
      'break',
      'case',
      'catch',
      'continue',
      'debugger',
      'default',
      'do',
      'else',
      'finally',
      'for',
      'function',
      'if',
      'return',
      'switch',
      'throw',
      'try',
      'var',
      'const',
      'while',
      'with',
      'new',
      'this',
      'super',
      'class',
      'extends',
      'export',
      'import',
      'null',
      'true',
      'false',
      'in',
      'instanceof',
      'typeof',
      'void',
      'delete',
      'implements',
      'interface',
      'let',
      'package',
      'private',
      'protected',
      'public',
      'static',
      'yield',
      'eval',
      'arguments',
      'enum',
      'await',
    ]);
    function t0(g) {
      return dd.has(g);
    }
    var Yd = class {
        constructor(g) {
          (this.var = new Set()), (this.lexical = new Set()), (this.functions = new Set()), (this.flags = g);
        }
      },
      Xd = class {
        constructor(g, u) {
          (this.parser = void 0),
            (this.scopeStack = []),
            (this.inModule = void 0),
            (this.undefinedExports = new Map()),
            (this.parser = g),
            (this.inModule = u);
        }
        get inTopLevel() {
          return (this.currentScope().flags & 1) > 0;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & 2) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & 16) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & 32) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & 64) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          let g = this.currentThisScopeFlags();
          return (g & 64) > 0 && (g & 2) === 0;
        }
        get inStaticBlock() {
          for (let g = this.scopeStack.length - 1; ; g--) {
            let { flags: u } = this.scopeStack[g];
            if (u & 128) return !0;
            if (u & 451) return !1;
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & 2) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(g) {
          return new Yd(g);
        }
        enter(g) {
          this.scopeStack.push(this.createScope(g));
        }
        exit() {
          return this.scopeStack.pop().flags;
        }
        treatFunctionsAsVarInScope(g) {
          return !!(g.flags & 130 || (!this.parser.inModule && g.flags & 1));
        }
        declareName(g, u, N) {
          let _ = this.currentScope();
          if (u & 8 || u & 16)
            this.checkRedeclarationInScope(_, g, u, N),
              u & 16 ? _.functions.add(g) : _.lexical.add(g),
              u & 8 && this.maybeExportDefined(_, g);
          else if (u & 4)
            for (
              let Be = this.scopeStack.length - 1;
              Be >= 0 &&
              ((_ = this.scopeStack[Be]),
              this.checkRedeclarationInScope(_, g, u, N),
              _.var.add(g),
              this.maybeExportDefined(_, g),
              !(_.flags & 387));
              --Be
            );
          this.parser.inModule && _.flags & 1 && this.undefinedExports.delete(g);
        }
        maybeExportDefined(g, u) {
          this.parser.inModule && g.flags & 1 && this.undefinedExports.delete(u);
        }
        checkRedeclarationInScope(g, u, N, _) {
          this.isRedeclaredInScope(g, u, N) && this.parser.raise(Wi.VarRedeclaration, { at: _, identifierName: u });
        }
        isRedeclaredInScope(g, u, N) {
          return N & 1
            ? N & 8
              ? g.lexical.has(u) || g.functions.has(u) || g.var.has(u)
              : N & 16
              ? g.lexical.has(u) || (!this.treatFunctionsAsVarInScope(g) && g.var.has(u))
              : (g.lexical.has(u) && !(g.flags & 8 && g.lexical.values().next().value === u)) ||
                (!this.treatFunctionsAsVarInScope(g) && g.functions.has(u))
            : !1;
        }
        checkLocalExport(g) {
          let { name: u } = g,
            N = this.scopeStack[0];
          !N.lexical.has(u) && !N.var.has(u) && !N.functions.has(u) && this.undefinedExports.set(u, g.loc.start);
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let g = this.scopeStack.length - 1; ; g--) {
            let { flags: u } = this.scopeStack[g];
            if (u & 387) return u;
          }
        }
        currentThisScopeFlags() {
          for (let g = this.scopeStack.length - 1; ; g--) {
            let { flags: u } = this.scopeStack[g];
            if (u & 451 && !(u & 4)) return u;
          }
        }
      },
      r0 = class extends Yd {
        constructor(...g) {
          super(...g), (this.declareFunctions = new Set());
        }
      },
      jd = class extends Xd {
        createScope(g) {
          return new r0(g);
        }
        declareName(g, u, N) {
          let _ = this.currentScope();
          if (u & 2048) {
            this.checkRedeclarationInScope(_, g, u, N), this.maybeExportDefined(_, g), _.declareFunctions.add(g);
            return;
          }
          super.declareName(g, u, N);
        }
        isRedeclaredInScope(g, u, N) {
          return super.isRedeclaredInScope(g, u, N)
            ? !0
            : N & 2048
            ? !g.declareFunctions.has(u) && (g.lexical.has(u) || g.functions.has(u))
            : !1;
        }
        checkLocalExport(g) {
          this.scopeStack[0].declareFunctions.has(g.name) || super.checkLocalExport(g);
        }
      },
      Ef = class {
        constructor() {
          (this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1);
        }
        hasPlugin(g) {
          if (typeof g == 'string') return this.plugins.has(g);
          {
            let [u, N] = g;
            if (!this.hasPlugin(u)) return !1;
            let _ = this.plugins.get(u);
            for (let Be of Object.keys(N)) if ((_ == null ? void 0 : _[Be]) !== N[Be]) return !1;
            return !0;
          }
        }
        getPluginOption(g, u) {
          var N;
          return (N = this.plugins.get(g)) == null ? void 0 : N[u];
        }
      };
    function vd(g, u) {
      g.trailingComments === void 0 ? (g.trailingComments = u) : g.trailingComments.unshift(...u);
    }
    function Qd(g, u) {
      g.leadingComments === void 0 ? (g.leadingComments = u) : g.leadingComments.unshift(...u);
    }
    function Sd(g, u) {
      g.innerComments === void 0 ? (g.innerComments = u) : g.innerComments.unshift(...u);
    }
    function wd(g, u, N) {
      let _ = null,
        Be = u.length;
      for (; _ === null && Be > 0; ) _ = u[--Be];
      _ === null || _.start > N.start ? Sd(g, N.comments) : vd(_, N.comments);
    }
    var bf = class extends Ef {
        addComment(g) {
          this.filename && (g.loc.filename = this.filename), this.state.comments.push(g);
        }
        processComment(g) {
          let { commentStack: u } = this.state,
            N = u.length;
          if (N === 0) return;
          let _ = N - 1,
            Be = u[_];
          Be.start === g.end && ((Be.leadingNode = g), _--);
          let { start: Cn } = g;
          for (; _ >= 0; _--) {
            let Yi = u[_],
              nl = Yi.end;
            if (nl > Cn) (Yi.containingNode = g), this.finalizeComment(Yi), u.splice(_, 1);
            else {
              nl === Cn && (Yi.trailingNode = g);
              break;
            }
          }
        }
        finalizeComment(g) {
          let { comments: u } = g;
          if (g.leadingNode !== null || g.trailingNode !== null)
            g.leadingNode !== null && vd(g.leadingNode, u), g.trailingNode !== null && Qd(g.trailingNode, u);
          else {
            let { containingNode: N, start: _ } = g;
            if (this.input.charCodeAt(_ - 1) === 44)
              switch (N.type) {
                case 'ObjectExpression':
                case 'ObjectPattern':
                case 'RecordExpression':
                  wd(N, N.properties, g);
                  break;
                case 'CallExpression':
                case 'OptionalCallExpression':
                  wd(N, N.arguments, g);
                  break;
                case 'FunctionDeclaration':
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                case 'ObjectMethod':
                case 'ClassMethod':
                case 'ClassPrivateMethod':
                  wd(N, N.params, g);
                  break;
                case 'ArrayExpression':
                case 'ArrayPattern':
                case 'TupleExpression':
                  wd(N, N.elements, g);
                  break;
                case 'ExportNamedDeclaration':
                case 'ImportDeclaration':
                  wd(N, N.specifiers, g);
                  break;
                default:
                  Sd(N, u);
              }
            else Sd(N, u);
          }
        }
        finalizeRemainingComments() {
          let { commentStack: g } = this.state;
          for (let u = g.length - 1; u >= 0; u--) this.finalizeComment(g[u]);
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(g) {
          let { commentStack: u } = this.state,
            { length: N } = u;
          if (N === 0) return;
          let _ = u[N - 1];
          _.leadingNode === g && (_.leadingNode = null);
        }
        resetPreviousIdentifierLeadingComments(g) {
          let { commentStack: u } = this.state,
            { length: N } = u;
          N !== 0 &&
            (u[N - 1].trailingNode === g
              ? (u[N - 1].trailingNode = null)
              : N >= 2 && u[N - 2].trailingNode === g && (u[N - 2].trailingNode = null));
        }
        takeSurroundingComments(g, u, N) {
          let { commentStack: _ } = this.state,
            Be = _.length;
          if (Be === 0) return;
          let Cn = Be - 1;
          for (; Cn >= 0; Cn--) {
            let Yi = _[Cn],
              nl = Yi.end;
            if (Yi.start === N) Yi.leadingNode = g;
            else if (nl === u) Yi.trailingNode = g;
            else if (nl < u) break;
          }
        }
      },
      Af = /\r\n?|[\n\u2028\u2029]/,
      Vd = new RegExp(Af.source, 'g');
    function ld(g) {
      switch (g) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return !0;
        default:
          return !1;
      }
    }
    var fd = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
      id = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g,
      Zd = new RegExp('(?=(' + id.source + '))\\1' + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, 'y');
    function vf(g) {
      switch (g) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return !0;
        default:
          return !1;
      }
    }
    var Sf = class sm {
        constructor() {
          (this.strict = void 0),
            (this.curLine = void 0),
            (this.lineStart = void 0),
            (this.startLoc = void 0),
            (this.endLoc = void 0),
            (this.errors = []),
            (this.potentialArrowAt = -1),
            (this.noArrowAt = []),
            (this.noArrowParamsConversionAt = []),
            (this.maybeInArrowParameters = !1),
            (this.inType = !1),
            (this.noAnonFunctionType = !1),
            (this.hasFlowComment = !1),
            (this.isAmbientContext = !1),
            (this.inAbstractClass = !1),
            (this.inDisallowConditionalTypesContext = !1),
            (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }),
            (this.soloAwait = !1),
            (this.inFSharpPipelineDirectBody = !1),
            (this.labels = []),
            (this.comments = []),
            (this.commentStack = []),
            (this.pos = 0),
            (this.type = 137),
            (this.value = null),
            (this.start = 0),
            (this.end = 0),
            (this.lastTokEndLoc = null),
            (this.lastTokStartLoc = null),
            (this.lastTokStart = 0),
            (this.context = [vl.brace]),
            (this.canStartJSXElement = !0),
            (this.containsEsc = !1),
            (this.firstInvalidTemplateEscapePos = null),
            (this.strictErrors = new Map()),
            (this.tokensLength = 0);
        }
        init({ strictMode: u, sourceType: N, startLine: _, startColumn: Be }) {
          (this.strict = u === !1 ? !1 : u === !0 ? !0 : N === 'module'),
            (this.curLine = _),
            (this.lineStart = -Be),
            (this.startLoc = this.endLoc = new n(_, Be, 0));
        }
        curPosition() {
          return new n(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(u) {
          let N = new sm(),
            _ = Object.keys(this);
          for (let Be = 0, Cn = _.length; Be < Cn; Be++) {
            let Yi = _[Be],
              nl = this[Yi];
            !u && Array.isArray(nl) && (nl = nl.slice()), (N[Yi] = nl);
          }
          return N;
        }
      },
      n0 = function (g) {
        return g >= 48 && g <= 57;
      },
      ef = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
      Hd = {
        bin: (g) => g === 48 || g === 49,
        oct: (g) => g >= 48 && g <= 55,
        dec: (g) => g >= 48 && g <= 57,
        hex: (g) => (g >= 48 && g <= 57) || (g >= 65 && g <= 70) || (g >= 97 && g <= 102),
      };
    function tf(g, u, N, _, Be, Cn) {
      let Yi = N,
        nl = _,
        xl = Be,
        Dl = '',
        jl = null,
        Zl = N,
        { length: Zc } = u;
      for (;;) {
        if (N >= Zc) {
          Cn.unterminated(Yi, nl, xl), (Dl += u.slice(Zl, N));
          break;
        }
        let rh = u.charCodeAt(N);
        if (_h(g, rh, u, N)) {
          Dl += u.slice(Zl, N);
          break;
        }
        if (rh === 92) {
          Dl += u.slice(Zl, N);
          let Ph = Xh(u, N, _, Be, g === 'template', Cn);
          Ph.ch === null && !jl ? (jl = { pos: N, lineStart: _, curLine: Be }) : (Dl += Ph.ch),
            ({ pos: N, lineStart: _, curLine: Be } = Ph),
            (Zl = N);
        } else
          rh === 8232 || rh === 8233
            ? (++N, ++Be, (_ = N))
            : rh === 10 || rh === 13
            ? g === 'template'
              ? ((Dl +=
                  u.slice(Zl, N) +
                  `
`),
                ++N,
                rh === 13 && u.charCodeAt(N) === 10 && ++N,
                ++Be,
                (Zl = _ = N))
              : Cn.unterminated(Yi, nl, xl)
            : ++N;
      }
      return { pos: N, str: Dl, firstInvalidLoc: jl, lineStart: _, curLine: Be, containsInvalid: !!jl };
    }
    function _h(g, u, N, _) {
      return g === 'template'
        ? u === 96 || (u === 36 && N.charCodeAt(_ + 1) === 123)
        : u === (g === 'double' ? 34 : 39);
    }
    function Xh(g, u, N, _, Be, Cn) {
      let Yi = !Be;
      u++;
      let nl = (Dl) => ({ pos: u, ch: Dl, lineStart: N, curLine: _ }),
        xl = g.charCodeAt(u++);
      switch (xl) {
        case 110:
          return nl(`
`);
        case 114:
          return nl('\r');
        case 120: {
          let Dl;
          return (
            ({ code: Dl, pos: u } = ud(g, u, N, _, 2, !1, Yi, Cn)), nl(Dl === null ? null : String.fromCharCode(Dl))
          );
        }
        case 117: {
          let Dl;
          return ({ code: Dl, pos: u } = wf(g, u, N, _, Yi, Cn)), nl(Dl === null ? null : String.fromCodePoint(Dl));
        }
        case 116:
          return nl('	');
        case 98:
          return nl('\b');
        case 118:
          return nl('\v');
        case 102:
          return nl('\f');
        case 13:
          g.charCodeAt(u) === 10 && ++u;
        case 10:
          (N = u), ++_;
        case 8232:
        case 8233:
          return nl('');
        case 56:
        case 57:
          if (Be) return nl(null);
          Cn.strictNumericEscape(u - 1, N, _);
        default:
          if (xl >= 48 && xl <= 55) {
            let Dl = u - 1,
              jl = g.slice(Dl, u + 2).match(/^[0-7]+/)[0],
              Zl = parseInt(jl, 8);
            Zl > 255 && ((jl = jl.slice(0, -1)), (Zl = parseInt(jl, 8))), (u += jl.length - 1);
            let Zc = g.charCodeAt(u);
            if (jl !== '0' || Zc === 56 || Zc === 57) {
              if (Be) return nl(null);
              Cn.strictNumericEscape(Dl, N, _);
            }
            return nl(String.fromCharCode(Zl));
          }
          return nl(String.fromCharCode(xl));
      }
    }
    function ud(g, u, N, _, Be, Cn, Yi, nl) {
      let xl = u,
        Dl;
      return (
        ({ n: Dl, pos: u } = rf(g, u, N, _, 16, Be, Cn, !1, nl, !Yi)),
        Dl === null && (Yi ? nl.invalidEscapeSequence(xl, N, _) : (u = xl - 1)),
        { code: Dl, pos: u }
      );
    }
    function rf(g, u, N, _, Be, Cn, Yi, nl, xl, Dl) {
      let jl = u,
        Zl = Be === 16 ? ef.hex : ef.decBinOct,
        Zc = Be === 16 ? Hd.hex : Be === 10 ? Hd.dec : Be === 8 ? Hd.oct : Hd.bin,
        rh = !1,
        Ph = 0;
      for (let Th = 0, Oh = Cn ?? 1 / 0; Th < Oh; ++Th) {
        let rl = g.charCodeAt(u),
          oh;
        if (rl === 95 && nl !== 'bail') {
          let Vh = g.charCodeAt(u - 1),
            Ld = g.charCodeAt(u + 1);
          if (nl) {
            if (Number.isNaN(Ld) || !Zc(Ld) || Zl.has(Vh) || Zl.has(Ld)) {
              if (Dl) return { n: null, pos: u };
              xl.unexpectedNumericSeparator(u, N, _);
            }
          } else {
            if (Dl) return { n: null, pos: u };
            xl.numericSeparatorInEscapeSequence(u, N, _);
          }
          ++u;
          continue;
        }
        if (
          (rl >= 97 ? (oh = rl - 97 + 10) : rl >= 65 ? (oh = rl - 65 + 10) : n0(rl) ? (oh = rl - 48) : (oh = 1 / 0),
          oh >= Be)
        ) {
          if (oh <= 9 && Dl) return { n: null, pos: u };
          if (oh <= 9 && xl.invalidDigit(u, N, _, Be)) oh = 0;
          else if (Yi) (oh = 0), (rh = !0);
          else break;
        }
        ++u, (Ph = Ph * Be + oh);
      }
      return u === jl || (Cn != null && u - jl !== Cn) || rh ? { n: null, pos: u } : { n: Ph, pos: u };
    }
    function wf(g, u, N, _, Be, Cn) {
      let Yi = g.charCodeAt(u),
        nl;
      if (Yi === 123) {
        if (
          (++u,
          ({ code: nl, pos: u } = ud(g, u, N, _, g.indexOf('}', u) - u, !0, Be, Cn)),
          ++u,
          nl !== null && nl > 1114111)
        )
          if (Be) Cn.invalidCodePoint(u, N, _);
          else return { code: null, pos: u };
      } else ({ code: nl, pos: u } = ud(g, u, N, _, 4, !1, Be, Cn));
      return { code: nl, pos: u };
    }
    var i0 = ['at'],
      nf = ['at'];
    function sd(g, u, N) {
      return new n(N, g - u, g);
    }
    var Fd = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
      Jh = class {
        constructor(g) {
          (this.type = g.type),
            (this.value = g.value),
            (this.start = g.start),
            (this.end = g.end),
            (this.loc = new s(g.startLoc, g.endLoc));
        }
      },
      Qh = class extends bf {
        constructor(g, u) {
          super(),
            (this.isLookahead = void 0),
            (this.tokens = []),
            (this.errorHandlers_readInt = {
              invalidDigit: (N, _, Be, Cn) =>
                this.options.errorRecovery ? (this.raise(Wi.InvalidDigit, { at: sd(N, _, Be), radix: Cn }), !0) : !1,
              numericSeparatorInEscapeSequence: this.errorBuilder(Wi.NumericSeparatorInEscapeSequence),
              unexpectedNumericSeparator: this.errorBuilder(Wi.UnexpectedNumericSeparator),
            }),
            (this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
              invalidEscapeSequence: this.errorBuilder(Wi.InvalidEscapeSequence),
              invalidCodePoint: this.errorBuilder(Wi.InvalidCodePoint),
            })),
            (this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
              strictNumericEscape: (N, _, Be) => {
                this.recordStrictModeErrors(Wi.StrictNumericEscape, { at: sd(N, _, Be) });
              },
              unterminated: (N, _, Be) => {
                throw this.raise(Wi.UnterminatedString, { at: sd(N - 1, _, Be) });
              },
            })),
            (this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
              strictNumericEscape: this.errorBuilder(Wi.StrictNumericEscape),
              unterminated: (N, _, Be) => {
                throw this.raise(Wi.UnterminatedTemplate, { at: sd(N, _, Be) });
              },
            })),
            (this.state = new Sf()),
            this.state.init(g),
            (this.input = u),
            (this.length = u.length),
            (this.isLookahead = !1);
        }
        pushToken(g) {
          (this.tokens.length = this.state.tokensLength), this.tokens.push(g), ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes(),
            this.options.tokens && this.pushToken(new Jh(this.state)),
            (this.state.lastTokStart = this.state.start),
            (this.state.lastTokEndLoc = this.state.endLoc),
            (this.state.lastTokStartLoc = this.state.startLoc),
            this.nextToken();
        }
        eat(g) {
          return this.match(g) ? (this.next(), !0) : !1;
        }
        match(g) {
          return this.state.type === g;
        }
        createLookaheadState(g) {
          return {
            pos: g.pos,
            value: null,
            type: g.type,
            start: g.start,
            end: g.end,
            context: [this.curContext()],
            inType: g.inType,
            startLoc: g.startLoc,
            lastTokEndLoc: g.lastTokEndLoc,
            curLine: g.curLine,
            lineStart: g.lineStart,
            curPosition: g.curPosition,
          };
        }
        lookahead() {
          let g = this.state;
          (this.state = this.createLookaheadState(g)),
            (this.isLookahead = !0),
            this.nextToken(),
            (this.isLookahead = !1);
          let u = this.state;
          return (this.state = g), u;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(g) {
          return (fd.lastIndex = g), fd.test(this.input) ? fd.lastIndex : g;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        nextTokenInLineStart() {
          return this.nextTokenInLineStartSince(this.state.pos);
        }
        nextTokenInLineStartSince(g) {
          return (id.lastIndex = g), id.test(this.input) ? id.lastIndex : g;
        }
        lookaheadInLineCharCode() {
          return this.input.charCodeAt(this.nextTokenInLineStart());
        }
        codePointAtPos(g) {
          let u = this.input.charCodeAt(g);
          if ((u & 64512) === 55296 && ++g < this.input.length) {
            let N = this.input.charCodeAt(g);
            (N & 64512) === 56320 && (u = 65536 + ((u & 1023) << 10) + (N & 1023));
          }
          return u;
        }
        setStrict(g) {
          (this.state.strict = g),
            g &&
              (this.state.strictErrors.forEach(([u, N]) => this.raise(u, { at: N })), this.state.strictErrors.clear());
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          if (
            (this.skipSpace(),
            (this.state.start = this.state.pos),
            this.isLookahead || (this.state.startLoc = this.state.curPosition()),
            this.state.pos >= this.length)
          ) {
            this.finishToken(137);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment(g) {
          let u;
          this.isLookahead || (u = this.state.curPosition());
          let N = this.state.pos,
            _ = this.input.indexOf(g, N + 2);
          if (_ === -1) throw this.raise(Wi.UnterminatedComment, { at: this.state.curPosition() });
          for (this.state.pos = _ + g.length, Vd.lastIndex = N + 2; Vd.test(this.input) && Vd.lastIndex <= _; )
            ++this.state.curLine, (this.state.lineStart = Vd.lastIndex);
          if (this.isLookahead) return;
          let Be = {
            type: 'CommentBlock',
            value: this.input.slice(N + 2, _),
            start: N,
            end: _ + g.length,
            loc: new s(u, this.state.curPosition()),
          };
          return this.options.tokens && this.pushToken(Be), Be;
        }
        skipLineComment(g) {
          let u = this.state.pos,
            N;
          this.isLookahead || (N = this.state.curPosition());
          let _ = this.input.charCodeAt((this.state.pos += g));
          if (this.state.pos < this.length)
            for (; !ld(_) && ++this.state.pos < this.length; ) _ = this.input.charCodeAt(this.state.pos);
          if (this.isLookahead) return;
          let Be = this.state.pos,
            Cn = {
              type: 'CommentLine',
              value: this.input.slice(u + g, Be),
              start: u,
              end: Be,
              loc: new s(N, this.state.curPosition()),
            };
          return this.options.tokens && this.pushToken(Cn), Cn;
        }
        skipSpace() {
          let g = this.state.pos,
            u = [];
          e: for (; this.state.pos < this.length; ) {
            let N = this.input.charCodeAt(this.state.pos);
            switch (N) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    let _ = this.skipBlockComment('*/');
                    _ !== void 0 && (this.addComment(_), this.options.attachComment && u.push(_));
                    break;
                  }
                  case 47: {
                    let _ = this.skipLineComment(2);
                    _ !== void 0 && (this.addComment(_), this.options.attachComment && u.push(_));
                    break;
                  }
                  default:
                    break e;
                }
                break;
              default:
                if (vf(N)) ++this.state.pos;
                else if (N === 45 && !this.inModule && this.options.annexB) {
                  let _ = this.state.pos;
                  if (
                    this.input.charCodeAt(_ + 1) === 45 &&
                    this.input.charCodeAt(_ + 2) === 62 &&
                    (g === 0 || this.state.lineStart > g)
                  ) {
                    let Be = this.skipLineComment(3);
                    Be !== void 0 && (this.addComment(Be), this.options.attachComment && u.push(Be));
                  } else break e;
                } else if (N === 60 && !this.inModule && this.options.annexB) {
                  let _ = this.state.pos;
                  if (
                    this.input.charCodeAt(_ + 1) === 33 &&
                    this.input.charCodeAt(_ + 2) === 45 &&
                    this.input.charCodeAt(_ + 3) === 45
                  ) {
                    let Be = this.skipLineComment(4);
                    Be !== void 0 && (this.addComment(Be), this.options.attachComment && u.push(Be));
                  } else break e;
                } else break e;
            }
          }
          if (u.length > 0) {
            let N = this.state.pos,
              _ = { start: g, end: N, comments: u, leadingNode: null, trailingNode: null, containingNode: null };
            this.state.commentStack.push(_);
          }
        }
        finishToken(g, u) {
          (this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition());
          let N = this.state.type;
          (this.state.type = g), (this.state.value = u), this.isLookahead || this.updateContext(N);
        }
        replaceToken(g) {
          (this.state.type = g), this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) return;
          let g = this.state.pos + 1,
            u = this.codePointAtPos(g);
          if (u >= 48 && u <= 57) throw this.raise(Wi.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
          if (u === 123 || (u === 91 && this.hasPlugin('recordAndTuple'))) {
            if ((this.expectPlugin('recordAndTuple'), this.getPluginOption('recordAndTuple', 'syntaxType') === 'bar'))
              throw this.raise(
                u === 123
                  ? Wi.RecordExpressionHashIncorrectStartSyntaxType
                  : Wi.TupleExpressionHashIncorrectStartSyntaxType,
                { at: this.state.curPosition() },
              );
            (this.state.pos += 2), u === 123 ? this.finishToken(7) : this.finishToken(1);
          } else
            Hh(u)
              ? (++this.state.pos, this.finishToken(136, this.readWord1(u)))
              : u === 92
              ? (++this.state.pos, this.finishToken(136, this.readWord1()))
              : this.finishOp(27, 1);
        }
        readToken_dot() {
          let g = this.input.charCodeAt(this.state.pos + 1);
          if (g >= 48 && g <= 57) {
            this.readNumber(!0);
            return;
          }
          g === 46 && this.input.charCodeAt(this.state.pos + 2) === 46
            ? ((this.state.pos += 3), this.finishToken(21))
            : (++this.state.pos, this.finishToken(16));
        }
        readToken_slash() {
          this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2) return !1;
          let g = this.input.charCodeAt(this.state.pos + 1);
          if (g !== 33) return !1;
          let u = this.state.pos;
          for (this.state.pos += 1; !ld(g) && ++this.state.pos < this.length; )
            g = this.input.charCodeAt(this.state.pos);
          let N = this.input.slice(u + 2, this.state.pos);
          return this.finishToken(28, N), !0;
        }
        readToken_mult_modulo(g) {
          let u = g === 42 ? 55 : 54,
            N = 1,
            _ = this.input.charCodeAt(this.state.pos + 1);
          g === 42 && _ === 42 && (N++, (_ = this.input.charCodeAt(this.state.pos + 2)), (u = 57)),
            _ === 61 && !this.state.inType && (N++, (u = g === 37 ? 33 : 30)),
            this.finishOp(u, N);
        }
        readToken_pipe_amp(g) {
          let u = this.input.charCodeAt(this.state.pos + 1);
          if (u === g) {
            this.input.charCodeAt(this.state.pos + 2) === 61
              ? this.finishOp(30, 3)
              : this.finishOp(g === 124 ? 41 : 42, 2);
            return;
          }
          if (g === 124) {
            if (u === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin('recordAndTuple') && u === 125) {
              if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                throw this.raise(Wi.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
              (this.state.pos += 2), this.finishToken(9);
              return;
            }
            if (this.hasPlugin('recordAndTuple') && u === 93) {
              if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                throw this.raise(Wi.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
              (this.state.pos += 2), this.finishToken(4);
              return;
            }
          }
          if (u === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(g === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          let g = this.input.charCodeAt(this.state.pos + 1);
          g === 61 && !this.state.inType
            ? this.finishOp(32, 2)
            : g === 94 && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }])
            ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected())
            : this.finishOp(44, 1);
        }
        readToken_atSign() {
          this.input.charCodeAt(this.state.pos + 1) === 64 &&
          this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }])
            ? this.finishOp(38, 2)
            : this.finishOp(26, 1);
        }
        readToken_plus_min(g) {
          let u = this.input.charCodeAt(this.state.pos + 1);
          if (u === g) {
            this.finishOp(34, 2);
            return;
          }
          u === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
        }
        readToken_lt() {
          let { pos: g } = this.state,
            u = this.input.charCodeAt(g + 1);
          if (u === 60) {
            if (this.input.charCodeAt(g + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (u === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          let { pos: g } = this.state,
            u = this.input.charCodeAt(g + 1);
          if (u === 62) {
            let N = this.input.charCodeAt(g + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(g + N) === 61) {
              this.finishOp(30, N + 1);
              return;
            }
            this.finishOp(52, N);
            return;
          }
          if (u === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(g) {
          let u = this.input.charCodeAt(this.state.pos + 1);
          if (u === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (g === 61 && u === 62) {
            (this.state.pos += 2), this.finishToken(19);
            return;
          }
          this.finishOp(g === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          let g = this.input.charCodeAt(this.state.pos + 1),
            u = this.input.charCodeAt(this.state.pos + 2);
          g === 63
            ? u === 61
              ? this.finishOp(30, 3)
              : this.finishOp(40, 2)
            : g === 46 && !(u >= 48 && u <= 57)
            ? ((this.state.pos += 2), this.finishToken(18))
            : (++this.state.pos, this.finishToken(17));
        }
        getTokenFromCode(g) {
          switch (g) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos, this.finishToken(10);
              return;
            case 41:
              ++this.state.pos, this.finishToken(11);
              return;
            case 59:
              ++this.state.pos, this.finishToken(13);
              return;
            case 44:
              ++this.state.pos, this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                  throw this.raise(Wi.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                (this.state.pos += 2), this.finishToken(2);
              } else ++this.state.pos, this.finishToken(0);
              return;
            case 93:
              ++this.state.pos, this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
                  throw this.raise(Wi.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                (this.state.pos += 2), this.finishToken(6);
              } else ++this.state.pos, this.finishToken(5);
              return;
            case 125:
              ++this.state.pos, this.finishToken(8);
              return;
            case 58:
              this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58
                ? this.finishOp(15, 2)
                : (++this.state.pos, this.finishToken(14));
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              let u = this.input.charCodeAt(this.state.pos + 1);
              if (u === 120 || u === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (u === 111 || u === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (u === 98 || u === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(!1);
              return;
            case 34:
            case 39:
              this.readString(g);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(g);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(g);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(g);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(g);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (Hh(g)) {
                this.readWord(g);
                return;
              }
          }
          throw this.raise(Wi.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(g),
          });
        }
        finishOp(g, u) {
          let N = this.input.slice(this.state.pos, this.state.pos + u);
          (this.state.pos += u), this.finishToken(g, N);
        }
        readRegexp() {
          let g = this.state.startLoc,
            u = this.state.start + 1,
            N,
            _,
            { pos: Be } = this.state;
          for (; ; ++Be) {
            if (Be >= this.length) throw this.raise(Wi.UnterminatedRegExp, { at: o(g, 1) });
            let xl = this.input.charCodeAt(Be);
            if (ld(xl)) throw this.raise(Wi.UnterminatedRegExp, { at: o(g, 1) });
            if (N) N = !1;
            else {
              if (xl === 91) _ = !0;
              else if (xl === 93 && _) _ = !1;
              else if (xl === 47 && !_) break;
              N = xl === 92;
            }
          }
          let Cn = this.input.slice(u, Be);
          ++Be;
          let Yi = '',
            nl = () => o(g, Be + 2 - u);
          for (; Be < this.length; ) {
            let xl = this.codePointAtPos(Be),
              Dl = String.fromCharCode(xl);
            if (Fd.has(xl))
              xl === 118
                ? Yi.includes('u') && this.raise(Wi.IncompatibleRegExpUVFlags, { at: nl() })
                : xl === 117 && Yi.includes('v') && this.raise(Wi.IncompatibleRegExpUVFlags, { at: nl() }),
                Yi.includes(Dl) && this.raise(Wi.DuplicateRegExpFlags, { at: nl() });
            else if (Wh(xl) || xl === 92) this.raise(Wi.MalformedRegExpFlags, { at: nl() });
            else break;
            ++Be, (Yi += Dl);
          }
          (this.state.pos = Be), this.finishToken(135, { pattern: Cn, flags: Yi });
        }
        readInt(g, u, N = !1, _ = !0) {
          let { n: Be, pos: Cn } = rf(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            g,
            u,
            N,
            _,
            this.errorHandlers_readInt,
            !1,
          );
          return (this.state.pos = Cn), Be;
        }
        readRadixNumber(g) {
          let u = this.state.curPosition(),
            N = !1;
          this.state.pos += 2;
          let _ = this.readInt(g);
          _ == null && this.raise(Wi.InvalidDigit, { at: o(u, 2), radix: g });
          let Be = this.input.charCodeAt(this.state.pos);
          if (Be === 110) ++this.state.pos, (N = !0);
          else if (Be === 109) throw this.raise(Wi.InvalidDecimal, { at: u });
          if (Hh(this.codePointAtPos(this.state.pos)))
            throw this.raise(Wi.NumberIdentifier, { at: this.state.curPosition() });
          if (N) {
            let Cn = this.input.slice(u.index, this.state.pos).replace(/[_n]/g, '');
            this.finishToken(133, Cn);
            return;
          }
          this.finishToken(132, _);
        }
        readNumber(g) {
          let u = this.state.pos,
            N = this.state.curPosition(),
            _ = !1,
            Be = !1,
            Cn = !1,
            Yi = !1,
            nl = !1;
          !g && this.readInt(10) === null && this.raise(Wi.InvalidNumber, { at: this.state.curPosition() });
          let xl = this.state.pos - u >= 2 && this.input.charCodeAt(u) === 48;
          if (xl) {
            let Zc = this.input.slice(u, this.state.pos);
            if ((this.recordStrictModeErrors(Wi.StrictOctalLiteral, { at: N }), !this.state.strict)) {
              let rh = Zc.indexOf('_');
              rh > 0 && this.raise(Wi.ZeroDigitNumericSeparator, { at: o(N, rh) });
            }
            nl = xl && !/[89]/.test(Zc);
          }
          let Dl = this.input.charCodeAt(this.state.pos);
          if (
            (Dl === 46 &&
              !nl &&
              (++this.state.pos, this.readInt(10), (_ = !0), (Dl = this.input.charCodeAt(this.state.pos))),
            (Dl === 69 || Dl === 101) &&
              !nl &&
              ((Dl = this.input.charCodeAt(++this.state.pos)),
              (Dl === 43 || Dl === 45) && ++this.state.pos,
              this.readInt(10) === null && this.raise(Wi.InvalidOrMissingExponent, { at: N }),
              (_ = !0),
              (Yi = !0),
              (Dl = this.input.charCodeAt(this.state.pos))),
            Dl === 110 && ((_ || xl) && this.raise(Wi.InvalidBigIntLiteral, { at: N }), ++this.state.pos, (Be = !0)),
            Dl === 109 &&
              (this.expectPlugin('decimal', this.state.curPosition()),
              (Yi || xl) && this.raise(Wi.InvalidDecimal, { at: N }),
              ++this.state.pos,
              (Cn = !0)),
            Hh(this.codePointAtPos(this.state.pos)))
          )
            throw this.raise(Wi.NumberIdentifier, { at: this.state.curPosition() });
          let jl = this.input.slice(u, this.state.pos).replace(/[_mn]/g, '');
          if (Be) {
            this.finishToken(133, jl);
            return;
          }
          if (Cn) {
            this.finishToken(134, jl);
            return;
          }
          let Zl = nl ? parseInt(jl, 8) : parseFloat(jl);
          this.finishToken(132, Zl);
        }
        readCodePoint(g) {
          let { code: u, pos: N } = wf(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            g,
            this.errorHandlers_readCodePoint,
          );
          return (this.state.pos = N), u;
        }
        readString(g) {
          let {
            str: u,
            pos: N,
            curLine: _,
            lineStart: Be,
          } = tf(
            g === 34 ? 'double' : 'single',
            this.input,
            this.state.pos + 1,
            this.state.lineStart,
            this.state.curLine,
            this.errorHandlers_readStringContents_string,
          );
          (this.state.pos = N + 1), (this.state.lineStart = Be), (this.state.curLine = _), this.finishToken(131, u);
        }
        readTemplateContinuation() {
          this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
        }
        readTemplateToken() {
          let g = this.input[this.state.pos],
            {
              str: u,
              firstInvalidLoc: N,
              pos: _,
              curLine: Be,
              lineStart: Cn,
            } = tf(
              'template',
              this.input,
              this.state.pos + 1,
              this.state.lineStart,
              this.state.curLine,
              this.errorHandlers_readStringContents_template,
            );
          (this.state.pos = _ + 1),
            (this.state.lineStart = Cn),
            (this.state.curLine = Be),
            N && (this.state.firstInvalidTemplateEscapePos = new n(N.curLine, N.pos - N.lineStart, N.pos)),
            this.input.codePointAt(_) === 96
              ? this.finishToken(24, N ? null : g + u + '`')
              : (this.state.pos++, this.finishToken(25, N ? null : g + u + '${'));
        }
        recordStrictModeErrors(g, { at: u }) {
          let N = u.index;
          this.state.strict && !this.state.strictErrors.has(N)
            ? this.raise(g, { at: u })
            : this.state.strictErrors.set(N, [g, u]);
        }
        readWord1(g) {
          this.state.containsEsc = !1;
          let u = '',
            N = this.state.pos,
            _ = this.state.pos;
          for (g !== void 0 && (this.state.pos += g <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
            let Be = this.codePointAtPos(this.state.pos);
            if (Wh(Be)) this.state.pos += Be <= 65535 ? 1 : 2;
            else if (Be === 92) {
              (this.state.containsEsc = !0), (u += this.input.slice(_, this.state.pos));
              let Cn = this.state.curPosition(),
                Yi = this.state.pos === N ? Hh : Wh;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(Wi.MissingUnicodeEscape, { at: this.state.curPosition() }), (_ = this.state.pos - 1);
                continue;
              }
              ++this.state.pos;
              let nl = this.readCodePoint(!0);
              nl !== null &&
                (Yi(nl) || this.raise(Wi.EscapedCharNotAnIdentifier, { at: Cn }), (u += String.fromCodePoint(nl))),
                (_ = this.state.pos);
            } else break;
          }
          return u + this.input.slice(_, this.state.pos);
        }
        readWord(g) {
          let u = this.readWord1(g),
            N = Hl.get(u);
          N !== void 0 ? this.finishToken(N, mh(N)) : this.finishToken(130, u);
        }
        checkKeywordEscapes() {
          let { type: g } = this.state;
          Hc(g) &&
            this.state.containsEsc &&
            this.raise(Wi.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: mh(g) });
        }
        raise(g, u) {
          let { at: N } = u,
            _ = e(u, i0),
            Be = N instanceof n ? N : N.loc.start,
            Cn = g({ loc: Be, details: _ });
          if (!this.options.errorRecovery) throw Cn;
          return this.isLookahead || this.state.errors.push(Cn), Cn;
        }
        raiseOverwrite(g, u) {
          let { at: N } = u,
            _ = e(u, nf),
            Be = N instanceof n ? N : N.loc.start,
            Cn = Be.index,
            Yi = this.state.errors;
          for (let nl = Yi.length - 1; nl >= 0; nl--) {
            let xl = Yi[nl];
            if (xl.loc.index === Cn) return (Yi[nl] = g({ loc: Be, details: _ }));
            if (xl.loc.index < Cn) break;
          }
          return this.raise(g, u);
        }
        updateContext(g) {}
        unexpected(g, u) {
          throw this.raise(Wi.UnexpectedToken, { expected: u ? mh(u) : null, at: g ?? this.state.startLoc });
        }
        expectPlugin(g, u) {
          if (this.hasPlugin(g)) return !0;
          throw this.raise(Wi.MissingPlugin, { at: u ?? this.state.startLoc, missingPlugin: [g] });
        }
        expectOnePlugin(g) {
          if (!g.some((u) => this.hasPlugin(u)))
            throw this.raise(Wi.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: g });
        }
        errorBuilder(g) {
          return (u, N, _) => {
            this.raise(g, { at: sd(u, N, _) });
          };
        }
      },
      Ff = class {
        constructor() {
          (this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map());
        }
      },
      s0 = class {
        constructor(g) {
          (this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = g);
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new Ff());
        }
        exit() {
          let g = this.stack.pop(),
            u = this.current();
          for (let [N, _] of Array.from(g.undefinedPrivateNames))
            u
              ? u.undefinedPrivateNames.has(N) || u.undefinedPrivateNames.set(N, _)
              : this.parser.raise(Wi.InvalidPrivateFieldResolution, { at: _, identifierName: N });
        }
        declarePrivateName(g, u, N) {
          let { privateNames: _, loneAccessors: Be, undefinedPrivateNames: Cn } = this.current(),
            Yi = _.has(g);
          if (u & 3) {
            let nl = Yi && Be.get(g);
            if (nl) {
              let xl = nl & 4,
                Dl = u & 4,
                jl = nl & 3,
                Zl = u & 3;
              (Yi = jl === Zl || xl !== Dl), Yi || Be.delete(g);
            } else Yi || Be.set(g, u);
          }
          Yi && this.parser.raise(Wi.PrivateNameRedeclaration, { at: N, identifierName: g }), _.add(g), Cn.delete(g);
        }
        usePrivateName(g, u) {
          let N;
          for (N of this.stack) if (N.privateNames.has(g)) return;
          N
            ? N.undefinedPrivateNames.set(g, u)
            : this.parser.raise(Wi.InvalidPrivateFieldResolution, { at: u, identifierName: g });
        }
      },
      md = class {
        constructor(g = 0) {
          this.type = g;
        }
        canBeArrowParameterDeclaration() {
          return this.type === 2 || this.type === 1;
        }
        isCertainlyParameterDeclaration() {
          return this.type === 3;
        }
      },
      sf = class extends md {
        constructor(g) {
          super(g), (this.declarationErrors = new Map());
        }
        recordDeclarationError(g, { at: u }) {
          let N = u.index;
          this.declarationErrors.set(N, [g, u]);
        }
        clearDeclarationError(g) {
          this.declarationErrors.delete(g);
        }
        iterateErrors(g) {
          this.declarationErrors.forEach(g);
        }
      },
      Tf = class {
        constructor(g) {
          (this.parser = void 0), (this.stack = [new md()]), (this.parser = g);
        }
        enter(g) {
          this.stack.push(g);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(g, { at: u }) {
          let N = { at: u.loc.start },
            { stack: _ } = this,
            Be = _.length - 1,
            Cn = _[Be];
          for (; !Cn.isCertainlyParameterDeclaration(); ) {
            if (Cn.canBeArrowParameterDeclaration()) Cn.recordDeclarationError(g, N);
            else return;
            Cn = _[--Be];
          }
          this.parser.raise(g, N);
        }
        recordArrowParameterBindingError(g, { at: u }) {
          let { stack: N } = this,
            _ = N[N.length - 1],
            Be = { at: u.loc.start };
          if (_.isCertainlyParameterDeclaration()) this.parser.raise(g, Be);
          else if (_.canBeArrowParameterDeclaration()) _.recordDeclarationError(g, Be);
          else return;
        }
        recordAsyncArrowParametersError({ at: g }) {
          let { stack: u } = this,
            N = u.length - 1,
            _ = u[N];
          for (; _.canBeArrowParameterDeclaration(); )
            _.type === 2 && _.recordDeclarationError(Wi.AwaitBindingIdentifier, { at: g }), (_ = u[--N]);
        }
        validateAsPattern() {
          let { stack: g } = this,
            u = g[g.length - 1];
          u.canBeArrowParameterDeclaration() &&
            u.iterateErrors(([N, _]) => {
              this.parser.raise(N, { at: _ });
              let Be = g.length - 2,
                Cn = g[Be];
              for (; Cn.canBeArrowParameterDeclaration(); ) Cn.clearDeclarationError(_.index), (Cn = g[--Be]);
            });
        }
      };
    function o0() {
      return new md(3);
    }
    function kf() {
      return new sf(1);
    }
    function a0() {
      return new sf(2);
    }
    function of() {
      return new md();
    }
    var gd = 0,
      af = 1,
      Td = 2,
      Pf = 4,
      yd = 8,
      cd = class {
        constructor() {
          this.stacks = [];
        }
        enter(g) {
          this.stacks.push(g);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & Td) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & af) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & Pf) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & yd) > 0;
        }
      };
    function kd(g, u) {
      return (g ? Td : 0) | (u ? af : 0);
    }
    var l0 = class extends Qh {
        addExtra(g, u, N, _ = !0) {
          if (!g) return;
          let Be = (g.extra = g.extra || {});
          _ ? (Be[u] = N) : Object.defineProperty(Be, u, { enumerable: _, value: N });
        }
        isContextual(g) {
          return this.state.type === g && !this.state.containsEsc;
        }
        isUnparsedContextual(g, u) {
          let N = g + u.length;
          if (this.input.slice(g, N) === u) {
            let _ = this.input.charCodeAt(N);
            return !(Wh(_) || (_ & 64512) === 55296);
          }
          return !1;
        }
        isLookaheadContextual(g) {
          let u = this.nextTokenStart();
          return this.isUnparsedContextual(u, g);
        }
        eatContextual(g) {
          return this.isContextual(g) ? (this.next(), !0) : !1;
        }
        expectContextual(g, u) {
          if (!this.eatContextual(g)) {
            if (u != null) throw this.raise(u, { at: this.state.startLoc });
            this.unexpected(null, g);
          }
        }
        canInsertSemicolon() {
          return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return Af.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          return (Zd.lastIndex = this.state.end), Zd.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(g = !0) {
          (g ? this.isLineTerminator() : this.eat(13)) ||
            this.raise(Wi.MissingSemicolon, { at: this.state.lastTokEndLoc });
        }
        expect(g, u) {
          this.eat(g) || this.unexpected(u, g);
        }
        tryParse(g, u = this.state.clone()) {
          let N = { node: null };
          try {
            let _ = g((Be = null) => {
              throw ((N.node = Be), N);
            });
            if (this.state.errors.length > u.errors.length) {
              let Be = this.state;
              return (
                (this.state = u),
                (this.state.tokensLength = Be.tokensLength),
                { node: _, error: Be.errors[u.errors.length], thrown: !1, aborted: !1, failState: Be }
              );
            }
            return { node: _, error: null, thrown: !1, aborted: !1, failState: null };
          } catch (_) {
            let Be = this.state;
            if (((this.state = u), _ instanceof SyntaxError))
              return { node: null, error: _, thrown: !0, aborted: !1, failState: Be };
            if (_ === N) return { node: N.node, error: null, thrown: !1, aborted: !0, failState: Be };
            throw _;
          }
        }
        checkExpressionErrors(g, u) {
          if (!g) return !1;
          let { shorthandAssignLoc: N, doubleProtoLoc: _, privateKeyLoc: Be, optionalParametersLoc: Cn } = g,
            Yi = !!N || !!_ || !!Cn || !!Be;
          if (!u) return Yi;
          N != null && this.raise(Wi.InvalidCoverInitializedName, { at: N }),
            _ != null && this.raise(Wi.DuplicateProto, { at: _ }),
            Be != null && this.raise(Wi.UnexpectedPrivateField, { at: Be }),
            Cn != null && this.unexpected(Cn);
        }
        isLiteralPropertyName() {
          return bl(this.state.type);
        }
        isPrivateName(g) {
          return g.type === 'PrivateName';
        }
        getPrivateNameSV(g) {
          return g.id.name;
        }
        hasPropertyAsPrivateName(g) {
          return (
            (g.type === 'MemberExpression' || g.type === 'OptionalMemberExpression') && this.isPrivateName(g.property)
          );
        }
        isObjectProperty(g) {
          return g.type === 'ObjectProperty';
        }
        isObjectMethod(g) {
          return g.type === 'ObjectMethod';
        }
        initializeScopes(g = this.options.sourceType === 'module') {
          let u = this.state.labels;
          this.state.labels = [];
          let N = this.exportedIdentifiers;
          this.exportedIdentifiers = new Set();
          let _ = this.inModule;
          this.inModule = g;
          let Be = this.scope,
            Cn = this.getScopeHandler();
          this.scope = new Cn(this, g);
          let Yi = this.prodParam;
          this.prodParam = new cd();
          let nl = this.classScope;
          this.classScope = new s0(this);
          let xl = this.expressionScope;
          return (
            (this.expressionScope = new Tf(this)),
            () => {
              (this.state.labels = u),
                (this.exportedIdentifiers = N),
                (this.inModule = _),
                (this.scope = Be),
                (this.prodParam = Yi),
                (this.classScope = nl),
                (this.expressionScope = xl);
            }
          );
        }
        enterInitialScopes() {
          let g = gd;
          this.inModule && (g |= Td), this.scope.enter(1), this.prodParam.enter(g);
        }
        checkDestructuringPrivate(g) {
          let { privateKeyLoc: u } = g;
          u !== null && this.expectPlugin('destructuringPrivate', u);
        }
      },
      Zh = class {
        constructor() {
          (this.shorthandAssignLoc = null),
            (this.doubleProtoLoc = null),
            (this.privateKeyLoc = null),
            (this.optionalParametersLoc = null);
        }
      },
      Pd = class {
        constructor(g, u, N) {
          (this.type = ''),
            (this.start = u),
            (this.end = 0),
            (this.loc = new s(N)),
            g != null && g.options.ranges && (this.range = [u, 0]),
            g != null && g.filename && (this.loc.filename = g.filename);
        }
      },
      Dd = Pd.prototype;
    Dd.__clone = function () {
      let g = new Pd(void 0, this.start, this.loc.start),
        u = Object.keys(this);
      for (let N = 0, _ = u.length; N < _; N++) {
        let Be = u[N];
        Be !== 'leadingComments' && Be !== 'trailingComments' && Be !== 'innerComments' && (g[Be] = this[Be]);
      }
      return g;
    };
    function Bf(g) {
      return ed(g);
    }
    function ed(g) {
      let { type: u, start: N, end: _, loc: Be, range: Cn, extra: Yi, name: nl } = g,
        xl = Object.create(Dd);
      return (
        (xl.type = u),
        (xl.start = N),
        (xl.end = _),
        (xl.loc = Be),
        (xl.range = Cn),
        (xl.extra = Yi),
        (xl.name = nl),
        u === 'Placeholder' && (xl.expectedNode = g.expectedNode),
        xl
      );
    }
    function Nf(g) {
      let { type: u, start: N, end: _, loc: Be, range: Cn, extra: Yi } = g;
      if (u === 'Placeholder') return Bf(g);
      let nl = Object.create(Dd);
      return (
        (nl.type = u),
        (nl.start = N),
        (nl.end = _),
        (nl.loc = Be),
        (nl.range = Cn),
        g.raw !== void 0 ? (nl.raw = g.raw) : (nl.extra = Yi),
        (nl.value = g.value),
        nl
      );
    }
    var If = class extends l0 {
        startNode() {
          return new Pd(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(g) {
          return new Pd(this, g.index, g);
        }
        startNodeAtNode(g) {
          return this.startNodeAt(g.loc.start);
        }
        finishNode(g, u) {
          return this.finishNodeAt(g, u, this.state.lastTokEndLoc);
        }
        finishNodeAt(g, u, N) {
          return (
            (g.type = u),
            (g.end = N.index),
            (g.loc.end = N),
            this.options.ranges && (g.range[1] = N.index),
            this.options.attachComment && this.processComment(g),
            g
          );
        }
        resetStartLocation(g, u) {
          (g.start = u.index), (g.loc.start = u), this.options.ranges && (g.range[0] = u.index);
        }
        resetEndLocation(g, u = this.state.lastTokEndLoc) {
          (g.end = u.index), (g.loc.end = u), this.options.ranges && (g.range[1] = u.index);
        }
        resetStartLocationFromNode(g, u) {
          this.resetStartLocation(g, u.loc.start);
        }
      },
      Mf = new Set([
        '_',
        'any',
        'bool',
        'boolean',
        'empty',
        'extends',
        'false',
        'interface',
        'mixed',
        'null',
        'number',
        'static',
        'string',
        'true',
        'typeof',
        'void',
      ]),
      hh = tl`flow`({
        AmbiguousConditionalArrow: 'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.',
        AmbiguousDeclareModuleKind:
          'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.',
        AssignReservedType: ({ reservedType: g }) => `Cannot overwrite reserved type ${g}.`,
        DeclareClassElement: 'The `declare` modifier can only appear on class fields.',
        DeclareClassFieldInitializer: 'Initializers are not allowed in fields with the `declare` modifier.',
        DuplicateDeclareModuleExports: 'Duplicate `declare module.exports` statement.',
        EnumBooleanMemberNotInitialized: ({ memberName: g, enumName: u }) =>
          `Boolean enum members need to be initialized. Use either \`${g} = true,\` or \`${g} = false,\` in enum \`${u}\`.`,
        EnumDuplicateMemberName: ({ memberName: g, enumName: u }) =>
          `Enum member names need to be unique, but the name \`${g}\` has already been used before in enum \`${u}\`.`,
        EnumInconsistentMemberValues: ({ enumName: g }) =>
          `Enum \`${g}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({ invalidEnumType: g, enumName: u }) =>
          `Enum type \`${g}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${u}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: g }) =>
          `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${g}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({ enumName: g, memberName: u, explicitType: N }) =>
          `Enum \`${g}\` has type \`${N}\`, so the initializer of \`${u}\` needs to be a ${N} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({ enumName: g, memberName: u }) =>
          `Symbol enum members cannot be initialized. Use \`${u},\` in enum \`${g}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({ enumName: g, memberName: u }) =>
          `The enum member initializer for \`${u}\` needs to be a literal (either a boolean, number, or string) in enum \`${g}\`.`,
        EnumInvalidMemberName: ({ enumName: g, memberName: u, suggestion: N }) =>
          `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${u}\`, consider using \`${N}\`, in enum \`${g}\`.`,
        EnumNumberMemberNotInitialized: ({ enumName: g, memberName: u }) =>
          `Number enum members need to be initialized, e.g. \`${u} = 1\` in enum \`${g}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({ enumName: g }) =>
          `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${g}\`.`,
        GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.',
        ImportReflectionHasImportType: 'An `import module` declaration can not use `type` or `typeof` keyword.',
        ImportTypeShorthandOnlyInPureImport:
          'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.',
        InexactInsideExact: 'Explicit inexact syntax cannot appear inside an explicit exact object type.',
        InexactInsideNonObject: 'Explicit inexact syntax cannot appear in class or interface definitions.',
        InexactVariance: 'Explicit inexact syntax cannot have variance.',
        InvalidNonTypeImportInDeclareModule:
          'Imports within a `declare module` body must always be `import type` or `import typeof`.',
        MissingTypeParamDefault:
          'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.',
        NestedDeclareModule: '`declare module` cannot be used inside another `declare module`.',
        NestedFlowComment: 'Cannot have a flow comment inside another flow comment.',
        PatternIsOptional: Object.assign(
          { message: 'A binding pattern parameter cannot be optional in an implementation signature.' },
          { reasonCode: 'OptionalBindingPattern' },
        ),
        SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.',
        SpreadVariance: 'Spread properties cannot have variance.',
        ThisParamAnnotationRequired: 'A type annotation is required for the `this` parameter.',
        ThisParamBannedInConstructor:
          "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.',
        ThisParamMustBeFirst: 'The `this` parameter must be the first function parameter.',
        ThisParamNoDefault: 'The `this` parameter may not have a default value.',
        TypeBeforeInitializer:
          'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
        TypeCastInPattern: 'The type cast expression is expected to be wrapped with parenthesis.',
        UnexpectedExplicitInexactInObject: 'Explicit inexact syntax must appear at the end of an inexact object.',
        UnexpectedReservedType: ({ reservedType: g }) => `Unexpected reserved type ${g}.`,
        UnexpectedReservedUnderscore: '`_` is only allowed as a type argument to call or new.',
        UnexpectedSpaceBetweenModuloChecks: 'Spaces between `%` and `checks` are not allowed here.',
        UnexpectedSpreadType: 'Spread operator cannot appear in class or interface definitions.',
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: 'Expected an arrow function after this type parameter declaration.',
        UnexpectedTypeParameterBeforeAsyncArrowFunction:
          'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.',
        UnsupportedDeclareExportKind: ({ unsupportedExportKind: g, suggestion: u }) =>
          `\`declare export ${g}\` is not supported. Use \`${u}\` instead.`,
        UnsupportedStatementInDeclareModule: 'Only declares and type imports are allowed inside declare module.',
        UnterminatedFlowComment: 'Unterminated flow-comment.',
      });
    function lf(g) {
      return (
        g.type === 'DeclareExportAllDeclaration' ||
        (g.type === 'DeclareExportDeclaration' &&
          (!g.declaration || (g.declaration.type !== 'TypeAlias' && g.declaration.type !== 'InterfaceDeclaration')))
      );
    }
    function uf(g) {
      return g.importKind === 'type' || g.importKind === 'typeof';
    }
    var u0 = {
      const: 'declare export var',
      let: 'declare export var',
      type: 'export type',
      interface: 'export interface',
    };
    function Of(g, u) {
      let N = [],
        _ = [];
      for (let Be = 0; Be < g.length; Be++) (u(g[Be], Be, g) ? N : _).push(g[Be]);
      return [N, _];
    }
    var cf = /\*?\s*@((?:no)?flow)\b/,
      c0 = (g) =>
        class extends g {
          constructor(...u) {
            super(...u), (this.flowPragma = void 0);
          }
          getScopeHandler() {
            return jd;
          }
          shouldParseTypes() {
            return this.getPluginOption('flow', 'all') || this.flowPragma === 'flow';
          }
          shouldParseEnums() {
            return !!this.getPluginOption('flow', 'enums');
          }
          finishToken(u, N) {
            u !== 131 && u !== 13 && u !== 28 && this.flowPragma === void 0 && (this.flowPragma = null),
              super.finishToken(u, N);
          }
          addComment(u) {
            if (this.flowPragma === void 0) {
              let N = cf.exec(u.value);
              if (N)
                if (N[1] === 'flow') this.flowPragma = 'flow';
                else if (N[1] === 'noflow') this.flowPragma = 'noflow';
                else throw new Error('Unexpected flow pragma');
            }
            super.addComment(u);
          }
          flowParseTypeInitialiser(u) {
            let N = this.state.inType;
            (this.state.inType = !0), this.expect(u || 14);
            let _ = this.flowParseType();
            return (this.state.inType = N), _;
          }
          flowParsePredicate() {
            let u = this.startNode(),
              N = this.state.startLoc;
            return (
              this.next(),
              this.expectContextual(108),
              this.state.lastTokStart > N.index + 1 && this.raise(hh.UnexpectedSpaceBetweenModuloChecks, { at: N }),
              this.eat(10)
                ? ((u.value = super.parseExpression()), this.expect(11), this.finishNode(u, 'DeclaredPredicate'))
                : this.finishNode(u, 'InferredPredicate')
            );
          }
          flowParseTypeAndPredicateInitialiser() {
            let u = this.state.inType;
            (this.state.inType = !0), this.expect(14);
            let N = null,
              _ = null;
            return (
              this.match(54)
                ? ((this.state.inType = u), (_ = this.flowParsePredicate()))
                : ((N = this.flowParseType()),
                  (this.state.inType = u),
                  this.match(54) && (_ = this.flowParsePredicate())),
              [N, _]
            );
          }
          flowParseDeclareClass(u) {
            return this.next(), this.flowParseInterfaceish(u, !0), this.finishNode(u, 'DeclareClass');
          }
          flowParseDeclareFunction(u) {
            this.next();
            let N = (u.id = this.parseIdentifier()),
              _ = this.startNode(),
              Be = this.startNode();
            this.match(47) ? (_.typeParameters = this.flowParseTypeParameterDeclaration()) : (_.typeParameters = null),
              this.expect(10);
            let Cn = this.flowParseFunctionTypeParams();
            return (
              (_.params = Cn.params),
              (_.rest = Cn.rest),
              (_.this = Cn._this),
              this.expect(11),
              ([_.returnType, u.predicate] = this.flowParseTypeAndPredicateInitialiser()),
              (Be.typeAnnotation = this.finishNode(_, 'FunctionTypeAnnotation')),
              (N.typeAnnotation = this.finishNode(Be, 'TypeAnnotation')),
              this.resetEndLocation(N),
              this.semicolon(),
              this.scope.declareName(u.id.name, 2048, u.id.loc.start),
              this.finishNode(u, 'DeclareFunction')
            );
          }
          flowParseDeclare(u, N) {
            if (this.match(80)) return this.flowParseDeclareClass(u);
            if (this.match(68)) return this.flowParseDeclareFunction(u);
            if (this.match(74)) return this.flowParseDeclareVariable(u);
            if (this.eatContextual(125))
              return this.match(16)
                ? this.flowParseDeclareModuleExports(u)
                : (N && this.raise(hh.NestedDeclareModule, { at: this.state.lastTokStartLoc }),
                  this.flowParseDeclareModule(u));
            if (this.isContextual(128)) return this.flowParseDeclareTypeAlias(u);
            if (this.isContextual(129)) return this.flowParseDeclareOpaqueType(u);
            if (this.isContextual(127)) return this.flowParseDeclareInterface(u);
            if (this.match(82)) return this.flowParseDeclareExportDeclaration(u, N);
            this.unexpected();
          }
          flowParseDeclareVariable(u) {
            return (
              this.next(),
              (u.id = this.flowParseTypeAnnotatableIdentifier(!0)),
              this.scope.declareName(u.id.name, 5, u.id.loc.start),
              this.semicolon(),
              this.finishNode(u, 'DeclareVariable')
            );
          }
          flowParseDeclareModule(u) {
            this.scope.enter(0), this.match(131) ? (u.id = super.parseExprAtom()) : (u.id = this.parseIdentifier());
            let N = (u.body = this.startNode()),
              _ = (N.body = []);
            for (this.expect(5); !this.match(8); ) {
              let Yi = this.startNode();
              this.match(83)
                ? (this.next(),
                  !this.isContextual(128) &&
                    !this.match(87) &&
                    this.raise(hh.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }),
                  super.parseImport(Yi))
                : (this.expectContextual(123, hh.UnsupportedStatementInDeclareModule),
                  (Yi = this.flowParseDeclare(Yi, !0))),
                _.push(Yi);
            }
            this.scope.exit(), this.expect(8), this.finishNode(N, 'BlockStatement');
            let Be = null,
              Cn = !1;
            return (
              _.forEach((Yi) => {
                lf(Yi)
                  ? (Be === 'CommonJS' && this.raise(hh.AmbiguousDeclareModuleKind, { at: Yi }), (Be = 'ES'))
                  : Yi.type === 'DeclareModuleExports' &&
                    (Cn && this.raise(hh.DuplicateDeclareModuleExports, { at: Yi }),
                    Be === 'ES' && this.raise(hh.AmbiguousDeclareModuleKind, { at: Yi }),
                    (Be = 'CommonJS'),
                    (Cn = !0));
              }),
              (u.kind = Be || 'CommonJS'),
              this.finishNode(u, 'DeclareModule')
            );
          }
          flowParseDeclareExportDeclaration(u, N) {
            if ((this.expect(82), this.eat(65)))
              return (
                this.match(68) || this.match(80)
                  ? (u.declaration = this.flowParseDeclare(this.startNode()))
                  : ((u.declaration = this.flowParseType()), this.semicolon()),
                (u.default = !0),
                this.finishNode(u, 'DeclareExportDeclaration')
              );
            if (this.match(75) || this.isLet() || ((this.isContextual(128) || this.isContextual(127)) && !N)) {
              let _ = this.state.value;
              throw this.raise(hh.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: _,
                suggestion: u0[_],
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129))
              return (
                (u.declaration = this.flowParseDeclare(this.startNode())),
                (u.default = !1),
                this.finishNode(u, 'DeclareExportDeclaration')
              );
            if (
              this.match(55) ||
              this.match(5) ||
              this.isContextual(127) ||
              this.isContextual(128) ||
              this.isContextual(129)
            )
              return (
                (u = this.parseExport(u, null)),
                u.type === 'ExportNamedDeclaration' &&
                  ((u.type = 'ExportDeclaration'), (u.default = !1), delete u.exportKind),
                (u.type = 'Declare' + u.type),
                u
              );
            this.unexpected();
          }
          flowParseDeclareModuleExports(u) {
            return (
              this.next(),
              this.expectContextual(109),
              (u.typeAnnotation = this.flowParseTypeAnnotation()),
              this.semicolon(),
              this.finishNode(u, 'DeclareModuleExports')
            );
          }
          flowParseDeclareTypeAlias(u) {
            this.next();
            let N = this.flowParseTypeAlias(u);
            return (N.type = 'DeclareTypeAlias'), N;
          }
          flowParseDeclareOpaqueType(u) {
            this.next();
            let N = this.flowParseOpaqueType(u, !0);
            return (N.type = 'DeclareOpaqueType'), N;
          }
          flowParseDeclareInterface(u) {
            return this.next(), this.flowParseInterfaceish(u, !1), this.finishNode(u, 'DeclareInterface');
          }
          flowParseInterfaceish(u, N) {
            if (
              ((u.id = this.flowParseRestrictedIdentifier(!N, !0)),
              this.scope.declareName(u.id.name, N ? 17 : 8201, u.id.loc.start),
              this.match(47)
                ? (u.typeParameters = this.flowParseTypeParameterDeclaration())
                : (u.typeParameters = null),
              (u.extends = []),
              this.eat(81))
            )
              do u.extends.push(this.flowParseInterfaceExtends());
              while (!N && this.eat(12));
            if (N) {
              if (((u.implements = []), (u.mixins = []), this.eatContextual(115)))
                do u.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              if (this.eatContextual(111))
                do u.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
            }
            u.body = this.flowParseObjectType({
              allowStatic: N,
              allowExact: !1,
              allowSpread: !1,
              allowProto: N,
              allowInexact: !1,
            });
          }
          flowParseInterfaceExtends() {
            let u = this.startNode();
            return (
              (u.id = this.flowParseQualifiedTypeIdentifier()),
              this.match(47)
                ? (u.typeParameters = this.flowParseTypeParameterInstantiation())
                : (u.typeParameters = null),
              this.finishNode(u, 'InterfaceExtends')
            );
          }
          flowParseInterface(u) {
            return this.flowParseInterfaceish(u, !1), this.finishNode(u, 'InterfaceDeclaration');
          }
          checkNotUnderscore(u) {
            u === '_' && this.raise(hh.UnexpectedReservedUnderscore, { at: this.state.startLoc });
          }
          checkReservedType(u, N, _) {
            Mf.has(u) && this.raise(_ ? hh.AssignReservedType : hh.UnexpectedReservedType, { at: N, reservedType: u });
          }
          flowParseRestrictedIdentifier(u, N) {
            return this.checkReservedType(this.state.value, this.state.startLoc, N), this.parseIdentifier(u);
          }
          flowParseTypeAlias(u) {
            return (
              (u.id = this.flowParseRestrictedIdentifier(!1, !0)),
              this.scope.declareName(u.id.name, 8201, u.id.loc.start),
              this.match(47)
                ? (u.typeParameters = this.flowParseTypeParameterDeclaration())
                : (u.typeParameters = null),
              (u.right = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(u, 'TypeAlias')
            );
          }
          flowParseOpaqueType(u, N) {
            return (
              this.expectContextual(128),
              (u.id = this.flowParseRestrictedIdentifier(!0, !0)),
              this.scope.declareName(u.id.name, 8201, u.id.loc.start),
              this.match(47)
                ? (u.typeParameters = this.flowParseTypeParameterDeclaration())
                : (u.typeParameters = null),
              (u.supertype = null),
              this.match(14) && (u.supertype = this.flowParseTypeInitialiser(14)),
              (u.impltype = null),
              N || (u.impltype = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(u, 'OpaqueType')
            );
          }
          flowParseTypeParameter(u = !1) {
            let N = this.state.startLoc,
              _ = this.startNode(),
              Be = this.flowParseVariance(),
              Cn = this.flowParseTypeAnnotatableIdentifier();
            return (
              (_.name = Cn.name),
              (_.variance = Be),
              (_.bound = Cn.typeAnnotation),
              this.match(29)
                ? (this.eat(29), (_.default = this.flowParseType()))
                : u && this.raise(hh.MissingTypeParamDefault, { at: N }),
              this.finishNode(_, 'TypeParameter')
            );
          }
          flowParseTypeParameterDeclaration() {
            let u = this.state.inType,
              N = this.startNode();
            (N.params = []),
              (this.state.inType = !0),
              this.match(47) || this.match(140) ? this.next() : this.unexpected();
            let _ = !1;
            do {
              let Be = this.flowParseTypeParameter(_);
              N.params.push(Be), Be.default && (_ = !0), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), (this.state.inType = u), this.finishNode(N, 'TypeParameterDeclaration');
          }
          flowParseTypeParameterInstantiation() {
            let u = this.startNode(),
              N = this.state.inType;
            (u.params = []), (this.state.inType = !0), this.expect(47);
            let _ = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = !1; !this.match(48); )
              u.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return (
              (this.state.noAnonFunctionType = _),
              this.expect(48),
              (this.state.inType = N),
              this.finishNode(u, 'TypeParameterInstantiation')
            );
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let u = this.startNode(),
              N = this.state.inType;
            for (u.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
              u.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), (this.state.inType = N), this.finishNode(u, 'TypeParameterInstantiation');
          }
          flowParseInterfaceType() {
            let u = this.startNode();
            if ((this.expectContextual(127), (u.extends = []), this.eat(81)))
              do u.extends.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            return (
              (u.body = this.flowParseObjectType({
                allowStatic: !1,
                allowExact: !1,
                allowSpread: !1,
                allowProto: !1,
                allowInexact: !1,
              })),
              this.finishNode(u, 'InterfaceTypeAnnotation')
            );
          }
          flowParseObjectPropertyKey() {
            return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(u, N, _) {
            return (
              (u.static = N),
              this.lookahead().type === 14
                ? ((u.id = this.flowParseObjectPropertyKey()), (u.key = this.flowParseTypeInitialiser()))
                : ((u.id = null), (u.key = this.flowParseType())),
              this.expect(3),
              (u.value = this.flowParseTypeInitialiser()),
              (u.variance = _),
              this.finishNode(u, 'ObjectTypeIndexer')
            );
          }
          flowParseObjectTypeInternalSlot(u, N) {
            return (
              (u.static = N),
              (u.id = this.flowParseObjectPropertyKey()),
              this.expect(3),
              this.expect(3),
              this.match(47) || this.match(10)
                ? ((u.method = !0),
                  (u.optional = !1),
                  (u.value = this.flowParseObjectTypeMethodish(this.startNodeAt(u.loc.start))))
                : ((u.method = !1), this.eat(17) && (u.optional = !0), (u.value = this.flowParseTypeInitialiser())),
              this.finishNode(u, 'ObjectTypeInternalSlot')
            );
          }
          flowParseObjectTypeMethodish(u) {
            for (
              u.params = [],
                u.rest = null,
                u.typeParameters = null,
                u.this = null,
                this.match(47) && (u.typeParameters = this.flowParseTypeParameterDeclaration()),
                this.expect(10),
                this.match(78) &&
                  ((u.this = this.flowParseFunctionTypeParam(!0)),
                  (u.this.name = null),
                  this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              u.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return (
              this.eat(21) && (u.rest = this.flowParseFunctionTypeParam(!1)),
              this.expect(11),
              (u.returnType = this.flowParseTypeInitialiser()),
              this.finishNode(u, 'FunctionTypeAnnotation')
            );
          }
          flowParseObjectTypeCallProperty(u, N) {
            let _ = this.startNode();
            return (
              (u.static = N),
              (u.value = this.flowParseObjectTypeMethodish(_)),
              this.finishNode(u, 'ObjectTypeCallProperty')
            );
          }
          flowParseObjectType({ allowStatic: u, allowExact: N, allowSpread: _, allowProto: Be, allowInexact: Cn }) {
            let Yi = this.state.inType;
            this.state.inType = !0;
            let nl = this.startNode();
            (nl.callProperties = []), (nl.properties = []), (nl.indexers = []), (nl.internalSlots = []);
            let xl,
              Dl,
              jl = !1;
            for (
              N && this.match(6) ? (this.expect(6), (xl = 9), (Dl = !0)) : (this.expect(5), (xl = 8), (Dl = !1)),
                nl.exact = Dl;
              !this.match(xl);

            ) {
              let Zc = !1,
                rh = null,
                Ph = null,
                Th = this.startNode();
              if (Be && this.isContextual(116)) {
                let rl = this.lookahead();
                rl.type !== 14 && rl.type !== 17 && (this.next(), (rh = this.state.startLoc), (u = !1));
              }
              if (u && this.isContextual(104)) {
                let rl = this.lookahead();
                rl.type !== 14 && rl.type !== 17 && (this.next(), (Zc = !0));
              }
              let Oh = this.flowParseVariance();
              if (this.eat(0))
                rh != null && this.unexpected(rh),
                  this.eat(0)
                    ? (Oh && this.unexpected(Oh.loc.start),
                      nl.internalSlots.push(this.flowParseObjectTypeInternalSlot(Th, Zc)))
                    : nl.indexers.push(this.flowParseObjectTypeIndexer(Th, Zc, Oh));
              else if (this.match(10) || this.match(47))
                rh != null && this.unexpected(rh),
                  Oh && this.unexpected(Oh.loc.start),
                  nl.callProperties.push(this.flowParseObjectTypeCallProperty(Th, Zc));
              else {
                let rl = 'init';
                if (this.isContextual(98) || this.isContextual(103)) {
                  let Vh = this.lookahead();
                  bl(Vh.type) && ((rl = this.state.value), this.next());
                }
                let oh = this.flowParseObjectTypeProperty(Th, Zc, rh, Oh, rl, _, Cn ?? !Dl);
                oh === null ? ((jl = !0), (Ph = this.state.lastTokStartLoc)) : nl.properties.push(oh);
              }
              this.flowObjectTypeSemicolon(),
                Ph && !this.match(8) && !this.match(9) && this.raise(hh.UnexpectedExplicitInexactInObject, { at: Ph });
            }
            this.expect(xl), _ && (nl.inexact = jl);
            let Zl = this.finishNode(nl, 'ObjectTypeAnnotation');
            return (this.state.inType = Yi), Zl;
          }
          flowParseObjectTypeProperty(u, N, _, Be, Cn, Yi, nl) {
            if (this.eat(21))
              return this.match(12) || this.match(13) || this.match(8) || this.match(9)
                ? (Yi
                    ? nl || this.raise(hh.InexactInsideExact, { at: this.state.lastTokStartLoc })
                    : this.raise(hh.InexactInsideNonObject, { at: this.state.lastTokStartLoc }),
                  Be && this.raise(hh.InexactVariance, { at: Be }),
                  null)
                : (Yi || this.raise(hh.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }),
                  _ != null && this.unexpected(_),
                  Be && this.raise(hh.SpreadVariance, { at: Be }),
                  (u.argument = this.flowParseType()),
                  this.finishNode(u, 'ObjectTypeSpreadProperty'));
            {
              (u.key = this.flowParseObjectPropertyKey()), (u.static = N), (u.proto = _ != null), (u.kind = Cn);
              let xl = !1;
              return (
                this.match(47) || this.match(10)
                  ? ((u.method = !0),
                    _ != null && this.unexpected(_),
                    Be && this.unexpected(Be.loc.start),
                    (u.value = this.flowParseObjectTypeMethodish(this.startNodeAt(u.loc.start))),
                    (Cn === 'get' || Cn === 'set') && this.flowCheckGetterSetterParams(u),
                    !Yi &&
                      u.key.name === 'constructor' &&
                      u.value.this &&
                      this.raise(hh.ThisParamBannedInConstructor, { at: u.value.this }))
                  : (Cn !== 'init' && this.unexpected(),
                    (u.method = !1),
                    this.eat(17) && (xl = !0),
                    (u.value = this.flowParseTypeInitialiser()),
                    (u.variance = Be)),
                (u.optional = xl),
                this.finishNode(u, 'ObjectTypeProperty')
              );
            }
          }
          flowCheckGetterSetterParams(u) {
            let N = u.kind === 'get' ? 0 : 1,
              _ = u.value.params.length + (u.value.rest ? 1 : 0);
            u.value.this &&
              this.raise(u.kind === 'get' ? hh.GetterMayNotHaveThisParam : hh.SetterMayNotHaveThisParam, {
                at: u.value.this,
              }),
              _ !== N && this.raise(u.kind === 'get' ? Wi.BadGetterArity : Wi.BadSetterArity, { at: u }),
              u.kind === 'set' && u.value.rest && this.raise(Wi.BadSetterRestParameter, { at: u });
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(u, N) {
            u != null || (u = this.state.startLoc);
            let _ = N || this.flowParseRestrictedIdentifier(!0);
            for (; this.eat(16); ) {
              let Be = this.startNodeAt(u);
              (Be.qualification = _),
                (Be.id = this.flowParseRestrictedIdentifier(!0)),
                (_ = this.finishNode(Be, 'QualifiedTypeIdentifier'));
            }
            return _;
          }
          flowParseGenericType(u, N) {
            let _ = this.startNodeAt(u);
            return (
              (_.typeParameters = null),
              (_.id = this.flowParseQualifiedTypeIdentifier(u, N)),
              this.match(47) && (_.typeParameters = this.flowParseTypeParameterInstantiation()),
              this.finishNode(_, 'GenericTypeAnnotation')
            );
          }
          flowParseTypeofType() {
            let u = this.startNode();
            return (
              this.expect(87), (u.argument = this.flowParsePrimaryType()), this.finishNode(u, 'TypeofTypeAnnotation')
            );
          }
          flowParseTupleType() {
            let u = this.startNode();
            for (
              u.types = [], this.expect(0);
              this.state.pos < this.length && !this.match(3) && (u.types.push(this.flowParseType()), !this.match(3));

            )
              this.expect(12);
            return this.expect(3), this.finishNode(u, 'TupleTypeAnnotation');
          }
          flowParseFunctionTypeParam(u) {
            let N = null,
              _ = !1,
              Be = null,
              Cn = this.startNode(),
              Yi = this.lookahead(),
              nl = this.state.type === 78;
            return (
              Yi.type === 14 || Yi.type === 17
                ? (nl && !u && this.raise(hh.ThisParamMustBeFirst, { at: Cn }),
                  (N = this.parseIdentifier(nl)),
                  this.eat(17) && ((_ = !0), nl && this.raise(hh.ThisParamMayNotBeOptional, { at: Cn })),
                  (Be = this.flowParseTypeInitialiser()))
                : (Be = this.flowParseType()),
              (Cn.name = N),
              (Cn.optional = _),
              (Cn.typeAnnotation = Be),
              this.finishNode(Cn, 'FunctionTypeParam')
            );
          }
          reinterpretTypeAsFunctionTypeParam(u) {
            let N = this.startNodeAt(u.loc.start);
            return (N.name = null), (N.optional = !1), (N.typeAnnotation = u), this.finishNode(N, 'FunctionTypeParam');
          }
          flowParseFunctionTypeParams(u = []) {
            let N = null,
              _ = null;
            for (
              this.match(78) &&
              ((_ = this.flowParseFunctionTypeParam(!0)), (_.name = null), this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              u.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (N = this.flowParseFunctionTypeParam(!1)), { params: u, rest: N, _this: _ };
          }
          flowIdentToTypeAnnotation(u, N, _) {
            switch (_.name) {
              case 'any':
                return this.finishNode(N, 'AnyTypeAnnotation');
              case 'bool':
              case 'boolean':
                return this.finishNode(N, 'BooleanTypeAnnotation');
              case 'mixed':
                return this.finishNode(N, 'MixedTypeAnnotation');
              case 'empty':
                return this.finishNode(N, 'EmptyTypeAnnotation');
              case 'number':
                return this.finishNode(N, 'NumberTypeAnnotation');
              case 'string':
                return this.finishNode(N, 'StringTypeAnnotation');
              case 'symbol':
                return this.finishNode(N, 'SymbolTypeAnnotation');
              default:
                return this.checkNotUnderscore(_.name), this.flowParseGenericType(u, _);
            }
          }
          flowParsePrimaryType() {
            let u = this.state.startLoc,
              N = this.startNode(),
              _,
              Be,
              Cn = !1,
              Yi = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !1,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !0,
                });
              case 6:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !0,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !1,
                });
              case 0:
                return (
                  (this.state.noAnonFunctionType = !1),
                  (Be = this.flowParseTupleType()),
                  (this.state.noAnonFunctionType = Yi),
                  Be
                );
              case 47:
                return (
                  (N.typeParameters = this.flowParseTypeParameterDeclaration()),
                  this.expect(10),
                  (_ = this.flowParseFunctionTypeParams()),
                  (N.params = _.params),
                  (N.rest = _.rest),
                  (N.this = _._this),
                  this.expect(11),
                  this.expect(19),
                  (N.returnType = this.flowParseType()),
                  this.finishNode(N, 'FunctionTypeAnnotation')
                );
              case 10:
                if ((this.next(), !this.match(11) && !this.match(21)))
                  if (Ul(this.state.type) || this.match(78)) {
                    let nl = this.lookahead().type;
                    Cn = nl !== 17 && nl !== 14;
                  } else Cn = !0;
                if (Cn) {
                  if (
                    ((this.state.noAnonFunctionType = !1),
                    (Be = this.flowParseType()),
                    (this.state.noAnonFunctionType = Yi),
                    this.state.noAnonFunctionType ||
                      !(this.match(12) || (this.match(11) && this.lookahead().type === 19)))
                  )
                    return this.expect(11), Be;
                  this.eat(12);
                }
                return (
                  Be
                    ? (_ = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(Be)]))
                    : (_ = this.flowParseFunctionTypeParams()),
                  (N.params = _.params),
                  (N.rest = _.rest),
                  (N.this = _._this),
                  this.expect(11),
                  this.expect(19),
                  (N.returnType = this.flowParseType()),
                  (N.typeParameters = null),
                  this.finishNode(N, 'FunctionTypeAnnotation')
                );
              case 131:
                return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation');
              case 85:
              case 86:
                return (N.value = this.match(85)), this.next(), this.finishNode(N, 'BooleanLiteralTypeAnnotation');
              case 53:
                if (this.state.value === '-') {
                  if ((this.next(), this.match(132)))
                    return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', N);
                  if (this.match(133))
                    return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', N);
                  throw this.raise(hh.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                }
                this.unexpected();
                return;
              case 132:
                return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation');
              case 133:
                return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation');
              case 88:
                return this.next(), this.finishNode(N, 'VoidTypeAnnotation');
              case 84:
                return this.next(), this.finishNode(N, 'NullLiteralTypeAnnotation');
              case 78:
                return this.next(), this.finishNode(N, 'ThisTypeAnnotation');
              case 55:
                return this.next(), this.finishNode(N, 'ExistsTypeAnnotation');
              case 87:
                return this.flowParseTypeofType();
              default:
                if (Hc(this.state.type)) {
                  let nl = mh(this.state.type);
                  return this.next(), super.createIdentifier(N, nl);
                } else if (Ul(this.state.type))
                  return this.isContextual(127)
                    ? this.flowParseInterfaceType()
                    : this.flowIdentToTypeAnnotation(u, N, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            let u = this.state.startLoc,
              N = this.flowParsePrimaryType(),
              _ = !1;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              let Be = this.startNodeAt(u),
                Cn = this.eat(18);
              (_ = _ || Cn),
                this.expect(0),
                !Cn && this.match(3)
                  ? ((Be.elementType = N), this.next(), (N = this.finishNode(Be, 'ArrayTypeAnnotation')))
                  : ((Be.objectType = N),
                    (Be.indexType = this.flowParseType()),
                    this.expect(3),
                    _
                      ? ((Be.optional = Cn), (N = this.finishNode(Be, 'OptionalIndexedAccessType')))
                      : (N = this.finishNode(Be, 'IndexedAccessType')));
            }
            return N;
          }
          flowParsePrefixType() {
            let u = this.startNode();
            return this.eat(17)
              ? ((u.typeAnnotation = this.flowParsePrefixType()), this.finishNode(u, 'NullableTypeAnnotation'))
              : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            let u = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let N = this.startNodeAt(u.loc.start);
              return (
                (N.params = [this.reinterpretTypeAsFunctionTypeParam(u)]),
                (N.rest = null),
                (N.this = null),
                (N.returnType = this.flowParseType()),
                (N.typeParameters = null),
                this.finishNode(N, 'FunctionTypeAnnotation')
              );
            }
            return u;
          }
          flowParseIntersectionType() {
            let u = this.startNode();
            this.eat(45);
            let N = this.flowParseAnonFunctionWithoutParens();
            for (u.types = [N]; this.eat(45); ) u.types.push(this.flowParseAnonFunctionWithoutParens());
            return u.types.length === 1 ? N : this.finishNode(u, 'IntersectionTypeAnnotation');
          }
          flowParseUnionType() {
            let u = this.startNode();
            this.eat(43);
            let N = this.flowParseIntersectionType();
            for (u.types = [N]; this.eat(43); ) u.types.push(this.flowParseIntersectionType());
            return u.types.length === 1 ? N : this.finishNode(u, 'UnionTypeAnnotation');
          }
          flowParseType() {
            let u = this.state.inType;
            this.state.inType = !0;
            let N = this.flowParseUnionType();
            return (this.state.inType = u), N;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 130 && this.state.value === '_') {
              let u = this.state.startLoc,
                N = this.parseIdentifier();
              return this.flowParseGenericType(u, N);
            } else return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            let u = this.startNode();
            return (u.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(u, 'TypeAnnotation');
          }
          flowParseTypeAnnotatableIdentifier(u) {
            let N = u ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && ((N.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(N)), N;
          }
          typeCastToParameter(u) {
            return (
              (u.expression.typeAnnotation = u.typeAnnotation),
              this.resetEndLocation(u.expression, u.typeAnnotation.loc.end),
              u.expression
            );
          }
          flowParseVariance() {
            let u = null;
            return this.match(53)
              ? ((u = this.startNode()),
                this.state.value === '+' ? (u.kind = 'plus') : (u.kind = 'minus'),
                this.next(),
                this.finishNode(u, 'Variance'))
              : u;
          }
          parseFunctionBody(u, N, _ = !1) {
            if (N) {
              this.forwardNoArrowParamsConversionAt(u, () => super.parseFunctionBody(u, !0, _));
              return;
            }
            super.parseFunctionBody(u, !1, _);
          }
          parseFunctionBodyAndFinish(u, N, _ = !1) {
            if (this.match(14)) {
              let Be = this.startNode();
              ([Be.typeAnnotation, u.predicate] = this.flowParseTypeAndPredicateInitialiser()),
                (u.returnType = Be.typeAnnotation ? this.finishNode(Be, 'TypeAnnotation') : null);
            }
            return super.parseFunctionBodyAndFinish(u, N, _);
          }
          parseStatementLike(u) {
            if (this.state.strict && this.isContextual(127)) {
              let _ = this.lookahead();
              if (gl(_.type)) {
                let Be = this.startNode();
                return this.next(), this.flowParseInterface(Be);
              }
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
              let _ = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(_);
            }
            let N = super.parseStatementLike(u);
            return this.flowPragma === void 0 && !this.isValidDirective(N) && (this.flowPragma = null), N;
          }
          parseExpressionStatement(u, N, _) {
            if (N.type === 'Identifier') {
              if (N.name === 'declare') {
                if (this.match(80) || Ul(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                  return this.flowParseDeclare(u);
              } else if (Ul(this.state.type)) {
                if (N.name === 'interface') return this.flowParseInterface(u);
                if (N.name === 'type') return this.flowParseTypeAlias(u);
                if (N.name === 'opaque') return this.flowParseOpaqueType(u, !1);
              }
            }
            return super.parseExpressionStatement(u, N, _);
          }
          shouldParseExportDeclaration() {
            let { type: u } = this.state;
            return Kl(u) || (this.shouldParseEnums() && u === 124)
              ? !this.state.containsEsc
              : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            let { type: u } = this.state;
            return Kl(u) || (this.shouldParseEnums() && u === 124)
              ? this.state.containsEsc
              : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(124)) {
              let u = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(u);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(u, N, _) {
            if (!this.match(17)) return u;
            if (this.state.maybeInArrowParameters) {
              let Zl = this.lookaheadCharCode();
              if (Zl === 44 || Zl === 61 || Zl === 58 || Zl === 41) return this.setOptionalParametersError(_), u;
            }
            this.expect(17);
            let Be = this.state.clone(),
              Cn = this.state.noArrowAt,
              Yi = this.startNodeAt(N),
              { consequent: nl, failed: xl } = this.tryParseConditionalConsequent(),
              [Dl, jl] = this.getArrowLikeExpressions(nl);
            if (xl || jl.length > 0) {
              let Zl = [...Cn];
              if (jl.length > 0) {
                (this.state = Be), (this.state.noArrowAt = Zl);
                for (let Zc = 0; Zc < jl.length; Zc++) Zl.push(jl[Zc].start);
                ({ consequent: nl, failed: xl } = this.tryParseConditionalConsequent()),
                  ([Dl, jl] = this.getArrowLikeExpressions(nl));
              }
              xl && Dl.length > 1 && this.raise(hh.AmbiguousConditionalArrow, { at: Be.startLoc }),
                xl &&
                  Dl.length === 1 &&
                  ((this.state = Be),
                  Zl.push(Dl[0].start),
                  (this.state.noArrowAt = Zl),
                  ({ consequent: nl, failed: xl } = this.tryParseConditionalConsequent()));
            }
            return (
              this.getArrowLikeExpressions(nl, !0),
              (this.state.noArrowAt = Cn),
              this.expect(14),
              (Yi.test = u),
              (Yi.consequent = nl),
              (Yi.alternate = this.forwardNoArrowParamsConversionAt(Yi, () => this.parseMaybeAssign(void 0, void 0))),
              this.finishNode(Yi, 'ConditionalExpression')
            );
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let u = this.parseMaybeAssignAllowIn(),
              N = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: u, failed: N };
          }
          getArrowLikeExpressions(u, N) {
            let _ = [u],
              Be = [];
            for (; _.length !== 0; ) {
              let Cn = _.pop();
              Cn.type === 'ArrowFunctionExpression'
                ? (Cn.typeParameters || !Cn.returnType ? this.finishArrowValidation(Cn) : Be.push(Cn), _.push(Cn.body))
                : Cn.type === 'ConditionalExpression' && (_.push(Cn.consequent), _.push(Cn.alternate));
            }
            return N
              ? (Be.forEach((Cn) => this.finishArrowValidation(Cn)), [Be, []])
              : Of(Be, (Cn) => Cn.params.every((Yi) => this.isAssignable(Yi, !0)));
          }
          finishArrowValidation(u) {
            var N;
            this.toAssignableList(u.params, (N = u.extra) == null ? void 0 : N.trailingCommaLoc, !1),
              this.scope.enter(6),
              super.checkParams(u, !1, !0),
              this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(u, N) {
            let _;
            return (
              this.state.noArrowParamsConversionAt.indexOf(u.start) !== -1
                ? (this.state.noArrowParamsConversionAt.push(this.state.start),
                  (_ = N()),
                  this.state.noArrowParamsConversionAt.pop())
                : (_ = N()),
              _
            );
          }
          parseParenItem(u, N) {
            if (
              ((u = super.parseParenItem(u, N)),
              this.eat(17) && ((u.optional = !0), this.resetEndLocation(u)),
              this.match(14))
            ) {
              let _ = this.startNodeAt(N);
              return (
                (_.expression = u),
                (_.typeAnnotation = this.flowParseTypeAnnotation()),
                this.finishNode(_, 'TypeCastExpression')
              );
            }
            return u;
          }
          assertModuleNodeAllowed(u) {
            (u.type === 'ImportDeclaration' && (u.importKind === 'type' || u.importKind === 'typeof')) ||
              (u.type === 'ExportNamedDeclaration' && u.exportKind === 'type') ||
              (u.type === 'ExportAllDeclaration' && u.exportKind === 'type') ||
              super.assertModuleNodeAllowed(u);
          }
          parseExportDeclaration(u) {
            if (this.isContextual(128)) {
              u.exportKind = 'type';
              let N = this.startNode();
              return (
                this.next(),
                this.match(5)
                  ? ((u.specifiers = this.parseExportSpecifiers(!0)), super.parseExportFrom(u), null)
                  : this.flowParseTypeAlias(N)
              );
            } else if (this.isContextual(129)) {
              u.exportKind = 'type';
              let N = this.startNode();
              return this.next(), this.flowParseOpaqueType(N, !1);
            } else if (this.isContextual(127)) {
              u.exportKind = 'type';
              let N = this.startNode();
              return this.next(), this.flowParseInterface(N);
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
              u.exportKind = 'value';
              let N = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(N);
            } else return super.parseExportDeclaration(u);
          }
          eatExportStar(u) {
            return super.eatExportStar(u)
              ? !0
              : this.isContextual(128) && this.lookahead().type === 55
              ? ((u.exportKind = 'type'), this.next(), this.next(), !0)
              : !1;
          }
          maybeParseExportNamespaceSpecifier(u) {
            let { startLoc: N } = this.state,
              _ = super.maybeParseExportNamespaceSpecifier(u);
            return _ && u.exportKind === 'type' && this.unexpected(N), _;
          }
          parseClassId(u, N, _) {
            super.parseClassId(u, N, _),
              this.match(47) && (u.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(u, N, _) {
            let { startLoc: Be } = this.state;
            if (this.isContextual(123)) {
              if (super.parseClassMemberFromModifier(u, N)) return;
              N.declare = !0;
            }
            super.parseClassMember(u, N, _),
              N.declare &&
                (N.type !== 'ClassProperty' && N.type !== 'ClassPrivateProperty' && N.type !== 'PropertyDefinition'
                  ? this.raise(hh.DeclareClassElement, { at: Be })
                  : N.value && this.raise(hh.DeclareClassFieldInitializer, { at: N.value }));
          }
          isIterator(u) {
            return u === 'iterator' || u === 'asyncIterator';
          }
          readIterator() {
            let u = super.readWord1(),
              N = '@@' + u;
            (!this.isIterator(u) || !this.state.inType) &&
              this.raise(Wi.InvalidIdentifier, { at: this.state.curPosition(), identifierName: N }),
              this.finishToken(130, N);
          }
          getTokenFromCode(u) {
            let N = this.input.charCodeAt(this.state.pos + 1);
            u === 123 && N === 124
              ? this.finishOp(6, 2)
              : this.state.inType && (u === 62 || u === 60)
              ? this.finishOp(u === 62 ? 48 : 47, 1)
              : this.state.inType && u === 63
              ? N === 46
                ? this.finishOp(18, 2)
                : this.finishOp(17, 1)
              : uh(u, N, this.input.charCodeAt(this.state.pos + 2))
              ? ((this.state.pos += 2), this.readIterator())
              : super.getTokenFromCode(u);
          }
          isAssignable(u, N) {
            return u.type === 'TypeCastExpression' ? this.isAssignable(u.expression, N) : super.isAssignable(u, N);
          }
          toAssignable(u, N = !1) {
            !N &&
              u.type === 'AssignmentExpression' &&
              u.left.type === 'TypeCastExpression' &&
              (u.left = this.typeCastToParameter(u.left)),
              super.toAssignable(u, N);
          }
          toAssignableList(u, N, _) {
            for (let Be = 0; Be < u.length; Be++) {
              let Cn = u[Be];
              (Cn == null ? void 0 : Cn.type) === 'TypeCastExpression' && (u[Be] = this.typeCastToParameter(Cn));
            }
            super.toAssignableList(u, N, _);
          }
          toReferencedList(u, N) {
            for (let Be = 0; Be < u.length; Be++) {
              var _;
              let Cn = u[Be];
              Cn &&
                Cn.type === 'TypeCastExpression' &&
                !((_ = Cn.extra) != null && _.parenthesized) &&
                (u.length > 1 || !N) &&
                this.raise(hh.TypeCastInPattern, { at: Cn.typeAnnotation });
            }
            return u;
          }
          parseArrayLike(u, N, _, Be) {
            let Cn = super.parseArrayLike(u, N, _, Be);
            return N && !this.state.maybeInArrowParameters && this.toReferencedList(Cn.elements), Cn;
          }
          isValidLVal(u, N, _) {
            return u === 'TypeCastExpression' || super.isValidLVal(u, N, _);
          }
          parseClassProperty(u) {
            return this.match(14) && (u.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(u);
          }
          parseClassPrivateProperty(u) {
            return (
              this.match(14) && (u.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(u)
            );
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(u) {
            return !this.match(14) && super.isNonstaticConstructor(u);
          }
          pushClassMethod(u, N, _, Be, Cn, Yi) {
            if (
              (N.variance && this.unexpected(N.variance.loc.start),
              delete N.variance,
              this.match(47) && (N.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassMethod(u, N, _, Be, Cn, Yi),
              N.params && Cn)
            ) {
              let nl = N.params;
              nl.length > 0 && this.isThisParam(nl[0]) && this.raise(hh.ThisParamBannedInConstructor, { at: N });
            } else if (N.type === 'MethodDefinition' && Cn && N.value.params) {
              let nl = N.value.params;
              nl.length > 0 && this.isThisParam(nl[0]) && this.raise(hh.ThisParamBannedInConstructor, { at: N });
            }
          }
          pushClassPrivateMethod(u, N, _, Be) {
            N.variance && this.unexpected(N.variance.loc.start),
              delete N.variance,
              this.match(47) && (N.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassPrivateMethod(u, N, _, Be);
          }
          parseClassSuper(u) {
            if (
              (super.parseClassSuper(u),
              u.superClass && this.match(47) && (u.superTypeParameters = this.flowParseTypeParameterInstantiation()),
              this.isContextual(111))
            ) {
              this.next();
              let N = (u.implements = []);
              do {
                let _ = this.startNode();
                (_.id = this.flowParseRestrictedIdentifier(!0)),
                  this.match(47)
                    ? (_.typeParameters = this.flowParseTypeParameterInstantiation())
                    : (_.typeParameters = null),
                  N.push(this.finishNode(_, 'ClassImplements'));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(u) {
            super.checkGetterSetterParams(u);
            let N = this.getObjectOrClassMethodParams(u);
            if (N.length > 0) {
              let _ = N[0];
              this.isThisParam(_) && u.kind === 'get'
                ? this.raise(hh.GetterMayNotHaveThisParam, { at: _ })
                : this.isThisParam(_) && this.raise(hh.SetterMayNotHaveThisParam, { at: _ });
            }
          }
          parsePropertyNamePrefixOperator(u) {
            u.variance = this.flowParseVariance();
          }
          parseObjPropValue(u, N, _, Be, Cn, Yi, nl) {
            u.variance && this.unexpected(u.variance.loc.start), delete u.variance;
            let xl;
            this.match(47) &&
              !Yi &&
              ((xl = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected());
            let Dl = super.parseObjPropValue(u, N, _, Be, Cn, Yi, nl);
            return xl && ((Dl.value || Dl).typeParameters = xl), Dl;
          }
          parseAssignableListItemTypes(u) {
            return (
              this.eat(17) &&
                (u.type !== 'Identifier' && this.raise(hh.PatternIsOptional, { at: u }),
                this.isThisParam(u) && this.raise(hh.ThisParamMayNotBeOptional, { at: u }),
                (u.optional = !0)),
              this.match(14)
                ? (u.typeAnnotation = this.flowParseTypeAnnotation())
                : this.isThisParam(u) && this.raise(hh.ThisParamAnnotationRequired, { at: u }),
              this.match(29) && this.isThisParam(u) && this.raise(hh.ThisParamNoDefault, { at: u }),
              this.resetEndLocation(u),
              u
            );
          }
          parseMaybeDefault(u, N) {
            let _ = super.parseMaybeDefault(u, N);
            return (
              _.type === 'AssignmentPattern' &&
                _.typeAnnotation &&
                _.right.start < _.typeAnnotation.start &&
                this.raise(hh.TypeBeforeInitializer, { at: _.typeAnnotation }),
              _
            );
          }
          checkImportReflection(u) {
            super.checkImportReflection(u),
              u.module &&
                u.importKind !== 'value' &&
                this.raise(hh.ImportReflectionHasImportType, { at: u.specifiers[0].loc.start });
          }
          parseImportSpecifierLocal(u, N, _) {
            (N.local = uf(u) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()),
              u.specifiers.push(this.finishImportSpecifier(N, _));
          }
          isPotentialImportPhase(u) {
            if (super.isPotentialImportPhase(u)) return !0;
            if (this.isContextual(128)) {
              if (!u) return !0;
              let N = this.lookaheadCharCode();
              return N === 123 || N === 42;
            }
            return !u && this.isContextual(87);
          }
          applyImportPhase(u, N, _, Be) {
            if ((super.applyImportPhase(u, N, _, Be), N)) {
              if (!_ && this.match(65)) return;
              u.exportKind = _ === 'type' ? _ : 'value';
            } else
              _ === 'type' && this.match(55) && this.unexpected(),
                (u.importKind = _ === 'type' || _ === 'typeof' ? _ : 'value');
          }
          parseImportSpecifier(u, N, _, Be, Cn) {
            let Yi = u.imported,
              nl = null;
            Yi.type === 'Identifier' && (Yi.name === 'type' ? (nl = 'type') : Yi.name === 'typeof' && (nl = 'typeof'));
            let xl = !1;
            if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
              let jl = this.parseIdentifier(!0);
              nl !== null && !gl(this.state.type)
                ? ((u.imported = jl), (u.importKind = nl), (u.local = ed(jl)))
                : ((u.imported = Yi), (u.importKind = null), (u.local = this.parseIdentifier()));
            } else {
              if (nl !== null && gl(this.state.type)) (u.imported = this.parseIdentifier(!0)), (u.importKind = nl);
              else {
                if (N) throw this.raise(Wi.ImportBindingIsString, { at: u, importName: Yi.value });
                (u.imported = Yi), (u.importKind = null);
              }
              this.eatContextual(93) ? (u.local = this.parseIdentifier()) : ((xl = !0), (u.local = ed(u.imported)));
            }
            let Dl = uf(u);
            return (
              _ && Dl && this.raise(hh.ImportTypeShorthandOnlyInPureImport, { at: u }),
              (_ || Dl) && this.checkReservedType(u.local.name, u.local.loc.start, !0),
              xl && !_ && !Dl && this.checkReservedWord(u.local.name, u.loc.start, !0, !0),
              this.finishImportSpecifier(u, 'ImportSpecifier')
            );
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(!0);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(u, N) {
            let _ = u.kind;
            _ !== 'get' &&
              _ !== 'set' &&
              this.match(47) &&
              (u.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.parseFunctionParams(u, N);
          }
          parseVarId(u, N) {
            super.parseVarId(u, N),
              this.match(14) && ((u.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(u.id));
          }
          parseAsyncArrowFromCallExpression(u, N) {
            if (this.match(14)) {
              let _ = this.state.noAnonFunctionType;
              (this.state.noAnonFunctionType = !0),
                (u.returnType = this.flowParseTypeAnnotation()),
                (this.state.noAnonFunctionType = _);
            }
            return super.parseAsyncArrowFromCallExpression(u, N);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(u, N) {
            var _;
            let Be = null,
              Cn;
            if (this.hasPlugin('jsx') && (this.match(140) || this.match(47))) {
              if (((Be = this.state.clone()), (Cn = this.tryParse(() => super.parseMaybeAssign(u, N), Be)), !Cn.error))
                return Cn.node;
              let { context: xl } = this.state,
                Dl = xl[xl.length - 1];
              (Dl === vl.j_oTag || Dl === vl.j_expr) && xl.pop();
            }
            if (((_ = Cn) != null && _.error) || this.match(47)) {
              var Yi, nl;
              Be = Be || this.state.clone();
              let xl,
                Dl = this.tryParse((Zl) => {
                  var Zc;
                  xl = this.flowParseTypeParameterDeclaration();
                  let rh = this.forwardNoArrowParamsConversionAt(xl, () => {
                    let Th = super.parseMaybeAssign(u, N);
                    return this.resetStartLocationFromNode(Th, xl), Th;
                  });
                  (Zc = rh.extra) != null && Zc.parenthesized && Zl();
                  let Ph = this.maybeUnwrapTypeCastExpression(rh);
                  return (
                    Ph.type !== 'ArrowFunctionExpression' && Zl(),
                    (Ph.typeParameters = xl),
                    this.resetStartLocationFromNode(Ph, xl),
                    rh
                  );
                }, Be),
                jl = null;
              if (Dl.node && this.maybeUnwrapTypeCastExpression(Dl.node).type === 'ArrowFunctionExpression') {
                if (!Dl.error && !Dl.aborted)
                  return (
                    Dl.node.async && this.raise(hh.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: xl }), Dl.node
                  );
                jl = Dl.node;
              }
              if ((Yi = Cn) != null && Yi.node) return (this.state = Cn.failState), Cn.node;
              if (jl) return (this.state = Dl.failState), jl;
              throw (nl = Cn) != null && nl.thrown
                ? Cn.error
                : Dl.thrown
                ? Dl.error
                : this.raise(hh.UnexpectedTokenAfterTypeParameter, { at: xl });
            }
            return super.parseMaybeAssign(u, N);
          }
          parseArrow(u) {
            if (this.match(14)) {
              let N = this.tryParse(() => {
                let _ = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = !0;
                let Be = this.startNode();
                return (
                  ([Be.typeAnnotation, u.predicate] = this.flowParseTypeAndPredicateInitialiser()),
                  (this.state.noAnonFunctionType = _),
                  this.canInsertSemicolon() && this.unexpected(),
                  this.match(19) || this.unexpected(),
                  Be
                );
              });
              if (N.thrown) return null;
              N.error && (this.state = N.failState),
                (u.returnType = N.node.typeAnnotation ? this.finishNode(N.node, 'TypeAnnotation') : null);
            }
            return super.parseArrow(u);
          }
          shouldParseArrow(u) {
            return this.match(14) || super.shouldParseArrow(u);
          }
          setArrowFunctionParameters(u, N) {
            this.state.noArrowParamsConversionAt.indexOf(u.start) !== -1
              ? (u.params = N)
              : super.setArrowFunctionParameters(u, N);
          }
          checkParams(u, N, _, Be = !0) {
            if (!(_ && this.state.noArrowParamsConversionAt.indexOf(u.start) !== -1)) {
              for (let Cn = 0; Cn < u.params.length; Cn++)
                this.isThisParam(u.params[Cn]) && Cn > 0 && this.raise(hh.ThisParamMustBeFirst, { at: u.params[Cn] });
              super.checkParams(u, N, _, Be);
            }
          }
          parseParenAndDistinguishExpression(u) {
            return super.parseParenAndDistinguishExpression(u && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(u, N, _) {
            if (u.type === 'Identifier' && u.name === 'async' && this.state.noArrowAt.indexOf(N.index) !== -1) {
              this.next();
              let Be = this.startNodeAt(N);
              (Be.callee = u),
                (Be.arguments = super.parseCallExpressionArguments(11, !1)),
                (u = this.finishNode(Be, 'CallExpression'));
            } else if (u.type === 'Identifier' && u.name === 'async' && this.match(47)) {
              let Be = this.state.clone(),
                Cn = this.tryParse((nl) => this.parseAsyncArrowWithTypeParameters(N) || nl(), Be);
              if (!Cn.error && !Cn.aborted) return Cn.node;
              let Yi = this.tryParse(() => super.parseSubscripts(u, N, _), Be);
              if (Yi.node && !Yi.error) return Yi.node;
              if (Cn.node) return (this.state = Cn.failState), Cn.node;
              if (Yi.node) return (this.state = Yi.failState), Yi.node;
              throw Cn.error || Yi.error;
            }
            return super.parseSubscripts(u, N, _);
          }
          parseSubscript(u, N, _, Be) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (((Be.optionalChainMember = !0), _)) return (Be.stop = !0), u;
              this.next();
              let Cn = this.startNodeAt(N);
              return (
                (Cn.callee = u),
                (Cn.typeArguments = this.flowParseTypeParameterInstantiation()),
                this.expect(10),
                (Cn.arguments = this.parseCallExpressionArguments(11, !1)),
                (Cn.optional = !0),
                this.finishCallExpression(Cn, !0)
              );
            } else if (!_ && this.shouldParseTypes() && this.match(47)) {
              let Cn = this.startNodeAt(N);
              Cn.callee = u;
              let Yi = this.tryParse(
                () => (
                  (Cn.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()),
                  this.expect(10),
                  (Cn.arguments = super.parseCallExpressionArguments(11, !1)),
                  Be.optionalChainMember && (Cn.optional = !1),
                  this.finishCallExpression(Cn, Be.optionalChainMember)
                ),
              );
              if (Yi.node) return Yi.error && (this.state = Yi.failState), Yi.node;
            }
            return super.parseSubscript(u, N, _, Be);
          }
          parseNewCallee(u) {
            super.parseNewCallee(u);
            let N = null;
            this.shouldParseTypes() &&
              this.match(47) &&
              (N = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node),
              (u.typeArguments = N);
          }
          parseAsyncArrowWithTypeParameters(u) {
            let N = this.startNodeAt(u);
            if ((this.parseFunctionParams(N, !1), !!this.parseArrow(N)))
              return super.parseArrowExpression(N, void 0, !0);
          }
          readToken_mult_modulo(u) {
            let N = this.input.charCodeAt(this.state.pos + 1);
            if (u === 42 && N === 47 && this.state.hasFlowComment) {
              (this.state.hasFlowComment = !1), (this.state.pos += 2), this.nextToken();
              return;
            }
            super.readToken_mult_modulo(u);
          }
          readToken_pipe_amp(u) {
            let N = this.input.charCodeAt(this.state.pos + 1);
            if (u === 124 && N === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(u);
          }
          parseTopLevel(u, N) {
            let _ = super.parseTopLevel(u, N);
            return (
              this.state.hasFlowComment && this.raise(hh.UnterminatedFlowComment, { at: this.state.curPosition() }), _
            );
          }
          skipBlockComment() {
            if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
              if (this.state.hasFlowComment) throw this.raise(hh.NestedFlowComment, { at: this.state.startLoc });
              this.hasFlowCommentCompletion();
              let u = this.skipFlowComment();
              u && ((this.state.pos += u), (this.state.hasFlowComment = !0));
              return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? '*-/' : '*/');
          }
          skipFlowComment() {
            let { pos: u } = this.state,
              N = 2;
            for (; [32, 9].includes(this.input.charCodeAt(u + N)); ) N++;
            let _ = this.input.charCodeAt(N + u),
              Be = this.input.charCodeAt(N + u + 1);
            return _ === 58 && Be === 58
              ? N + 2
              : this.input.slice(N + u, N + u + 12) === 'flow-include'
              ? N + 12
              : _ === 58 && Be !== 58
              ? N
              : !1;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf('*/', this.state.pos) === -1)
              throw this.raise(Wi.UnterminatedComment, { at: this.state.curPosition() });
          }
          flowEnumErrorBooleanMemberNotInitialized(u, { enumName: N, memberName: _ }) {
            this.raise(hh.EnumBooleanMemberNotInitialized, { at: u, memberName: _, enumName: N });
          }
          flowEnumErrorInvalidMemberInitializer(u, N) {
            return this.raise(
              N.explicitType
                ? N.explicitType === 'symbol'
                  ? hh.EnumInvalidMemberInitializerSymbolType
                  : hh.EnumInvalidMemberInitializerPrimaryType
                : hh.EnumInvalidMemberInitializerUnknownType,
              Object.assign({ at: u }, N),
            );
          }
          flowEnumErrorNumberMemberNotInitialized(u, { enumName: N, memberName: _ }) {
            this.raise(hh.EnumNumberMemberNotInitialized, { at: u, enumName: N, memberName: _ });
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(u, { enumName: N }) {
            this.raise(hh.EnumStringMemberInconsistentlyInitailized, { at: u, enumName: N });
          }
          flowEnumMemberInit() {
            let u = this.state.startLoc,
              N = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 132: {
                let _ = this.parseNumericLiteral(this.state.value);
                return N() ? { type: 'number', loc: _.loc.start, value: _ } : { type: 'invalid', loc: u };
              }
              case 131: {
                let _ = this.parseStringLiteral(this.state.value);
                return N() ? { type: 'string', loc: _.loc.start, value: _ } : { type: 'invalid', loc: u };
              }
              case 85:
              case 86: {
                let _ = this.parseBooleanLiteral(this.match(85));
                return N() ? { type: 'boolean', loc: _.loc.start, value: _ } : { type: 'invalid', loc: u };
              }
              default:
                return { type: 'invalid', loc: u };
            }
          }
          flowEnumMemberRaw() {
            let u = this.state.startLoc,
              N = this.parseIdentifier(!0),
              _ = this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: u };
            return { id: N, init: _ };
          }
          flowEnumCheckExplicitTypeMismatch(u, N, _) {
            let { explicitType: Be } = N;
            Be !== null && Be !== _ && this.flowEnumErrorInvalidMemberInitializer(u, N);
          }
          flowEnumMembers({ enumName: u, explicitType: N }) {
            let _ = new Set(),
              Be = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] },
              Cn = !1;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                Cn = !0;
                break;
              }
              let Yi = this.startNode(),
                { id: nl, init: xl } = this.flowEnumMemberRaw(),
                Dl = nl.name;
              if (Dl === '') continue;
              /^[a-z]/.test(Dl) &&
                this.raise(hh.EnumInvalidMemberName, {
                  at: nl,
                  memberName: Dl,
                  suggestion: Dl[0].toUpperCase() + Dl.slice(1),
                  enumName: u,
                }),
                _.has(Dl) && this.raise(hh.EnumDuplicateMemberName, { at: nl, memberName: Dl, enumName: u }),
                _.add(Dl);
              let jl = { enumName: u, explicitType: N, memberName: Dl };
              switch (((Yi.id = nl), xl.type)) {
                case 'boolean': {
                  this.flowEnumCheckExplicitTypeMismatch(xl.loc, jl, 'boolean'),
                    (Yi.init = xl.value),
                    Be.booleanMembers.push(this.finishNode(Yi, 'EnumBooleanMember'));
                  break;
                }
                case 'number': {
                  this.flowEnumCheckExplicitTypeMismatch(xl.loc, jl, 'number'),
                    (Yi.init = xl.value),
                    Be.numberMembers.push(this.finishNode(Yi, 'EnumNumberMember'));
                  break;
                }
                case 'string': {
                  this.flowEnumCheckExplicitTypeMismatch(xl.loc, jl, 'string'),
                    (Yi.init = xl.value),
                    Be.stringMembers.push(this.finishNode(Yi, 'EnumStringMember'));
                  break;
                }
                case 'invalid':
                  throw this.flowEnumErrorInvalidMemberInitializer(xl.loc, jl);
                case 'none':
                  switch (N) {
                    case 'boolean':
                      this.flowEnumErrorBooleanMemberNotInitialized(xl.loc, jl);
                      break;
                    case 'number':
                      this.flowEnumErrorNumberMemberNotInitialized(xl.loc, jl);
                      break;
                    default:
                      Be.defaultedMembers.push(this.finishNode(Yi, 'EnumDefaultedMember'));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: Be, hasUnknownMembers: Cn };
          }
          flowEnumStringMembers(u, N, { enumName: _ }) {
            if (u.length === 0) return N;
            if (N.length === 0) return u;
            if (N.length > u.length) {
              for (let Be of u) this.flowEnumErrorStringMemberInconsistentlyInitailized(Be, { enumName: _ });
              return N;
            } else {
              for (let Be of N) this.flowEnumErrorStringMemberInconsistentlyInitailized(Be, { enumName: _ });
              return u;
            }
          }
          flowEnumParseExplicitType({ enumName: u }) {
            if (!this.eatContextual(101)) return null;
            if (!Ul(this.state.type))
              throw this.raise(hh.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: u });
            let { value: N } = this.state;
            return (
              this.next(),
              N !== 'boolean' &&
                N !== 'number' &&
                N !== 'string' &&
                N !== 'symbol' &&
                this.raise(hh.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: u, invalidEnumType: N }),
              N
            );
          }
          flowEnumBody(u, N) {
            let _ = N.name,
              Be = N.loc.start,
              Cn = this.flowEnumParseExplicitType({ enumName: _ });
            this.expect(5);
            let { members: Yi, hasUnknownMembers: nl } = this.flowEnumMembers({ enumName: _, explicitType: Cn });
            switch (((u.hasUnknownMembers = nl), Cn)) {
              case 'boolean':
                return (
                  (u.explicitType = !0),
                  (u.members = Yi.booleanMembers),
                  this.expect(8),
                  this.finishNode(u, 'EnumBooleanBody')
                );
              case 'number':
                return (
                  (u.explicitType = !0),
                  (u.members = Yi.numberMembers),
                  this.expect(8),
                  this.finishNode(u, 'EnumNumberBody')
                );
              case 'string':
                return (
                  (u.explicitType = !0),
                  (u.members = this.flowEnumStringMembers(Yi.stringMembers, Yi.defaultedMembers, { enumName: _ })),
                  this.expect(8),
                  this.finishNode(u, 'EnumStringBody')
                );
              case 'symbol':
                return (u.members = Yi.defaultedMembers), this.expect(8), this.finishNode(u, 'EnumSymbolBody');
              default: {
                let xl = () => ((u.members = []), this.expect(8), this.finishNode(u, 'EnumStringBody'));
                u.explicitType = !1;
                let Dl = Yi.booleanMembers.length,
                  jl = Yi.numberMembers.length,
                  Zl = Yi.stringMembers.length,
                  Zc = Yi.defaultedMembers.length;
                if (!Dl && !jl && !Zl && !Zc) return xl();
                if (!Dl && !jl)
                  return (
                    (u.members = this.flowEnumStringMembers(Yi.stringMembers, Yi.defaultedMembers, { enumName: _ })),
                    this.expect(8),
                    this.finishNode(u, 'EnumStringBody')
                  );
                if (!jl && !Zl && Dl >= Zc) {
                  for (let rh of Yi.defaultedMembers)
                    this.flowEnumErrorBooleanMemberNotInitialized(rh.loc.start, {
                      enumName: _,
                      memberName: rh.id.name,
                    });
                  return (u.members = Yi.booleanMembers), this.expect(8), this.finishNode(u, 'EnumBooleanBody');
                } else if (!Dl && !Zl && jl >= Zc) {
                  for (let rh of Yi.defaultedMembers)
                    this.flowEnumErrorNumberMemberNotInitialized(rh.loc.start, { enumName: _, memberName: rh.id.name });
                  return (u.members = Yi.numberMembers), this.expect(8), this.finishNode(u, 'EnumNumberBody');
                } else return this.raise(hh.EnumInconsistentMemberValues, { at: Be, enumName: _ }), xl();
              }
            }
          }
          flowParseEnumDeclaration(u) {
            let N = this.parseIdentifier();
            return (u.id = N), (u.body = this.flowEnumBody(this.startNode(), N)), this.finishNode(u, 'EnumDeclaration');
          }
          isLookaheadToken_lt() {
            let u = this.nextTokenStart();
            if (this.input.charCodeAt(u) === 60) {
              let N = this.input.charCodeAt(u + 1);
              return N !== 60 && N !== 61;
            }
            return !1;
          }
          maybeUnwrapTypeCastExpression(u) {
            return u.type === 'TypeCastExpression' ? u.expression : u;
          }
        },
      jh = tl`jsx`({
        AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.',
        MissingClosingTagElement: ({ openingTagName: g }) => `Expected corresponding JSX closing tag for <${g}>.`,
        MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.',
        UnexpectedSequenceExpression:
          'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
        UnexpectedToken: ({ unexpected: g, HTMLEntity: u }) =>
          `Unexpected token \`${g}\`. Did you mean \`${u}\` or \`{'${g}'}\`?`,
        UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.',
        UnterminatedJsxContent: 'Unterminated JSX contents.',
        UnwrappedAdjacentJSXElements:
          'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
      });
    function od(g) {
      return g ? g.type === 'JSXOpeningFragment' || g.type === 'JSXClosingFragment' : !1;
    }
    function xd(g) {
      if (g.type === 'JSXIdentifier') return g.name;
      if (g.type === 'JSXNamespacedName') return g.namespace.name + ':' + g.name.name;
      if (g.type === 'JSXMemberExpression') return xd(g.object) + '.' + xd(g.property);
      throw new Error('Node had unexpected type: ' + g.type);
    }
    var h0 = (g) =>
        class extends g {
          jsxReadToken() {
            let u = '',
              N = this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length)
                throw this.raise(jh.UnterminatedJsxContent, { at: this.state.startLoc });
              let _ = this.input.charCodeAt(this.state.pos);
              switch (_) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    _ === 60 && this.state.canStartJSXElement
                      ? (++this.state.pos, this.finishToken(140))
                      : super.getTokenFromCode(_);
                    return;
                  }
                  (u += this.input.slice(N, this.state.pos)), this.finishToken(139, u);
                  return;
                case 38:
                  (u += this.input.slice(N, this.state.pos)), (u += this.jsxReadEntity()), (N = this.state.pos);
                  break;
                case 62:
                case 125:
                default:
                  ld(_)
                    ? ((u += this.input.slice(N, this.state.pos)), (u += this.jsxReadNewLine(!0)), (N = this.state.pos))
                    : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(u) {
            let N = this.input.charCodeAt(this.state.pos),
              _;
            return (
              ++this.state.pos,
              N === 13 && this.input.charCodeAt(this.state.pos) === 10
                ? (++this.state.pos,
                  (_ = u
                    ? `
`
                    : `\r
`))
                : (_ = String.fromCharCode(N)),
              ++this.state.curLine,
              (this.state.lineStart = this.state.pos),
              _
            );
          }
          jsxReadString(u) {
            let N = '',
              _ = ++this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length) throw this.raise(Wi.UnterminatedString, { at: this.state.startLoc });
              let Be = this.input.charCodeAt(this.state.pos);
              if (Be === u) break;
              Be === 38
                ? ((N += this.input.slice(_, this.state.pos)), (N += this.jsxReadEntity()), (_ = this.state.pos))
                : ld(Be)
                ? ((N += this.input.slice(_, this.state.pos)), (N += this.jsxReadNewLine(!1)), (_ = this.state.pos))
                : ++this.state.pos;
            }
            (N += this.input.slice(_, this.state.pos++)), this.finishToken(131, N);
          }
          jsxReadEntity() {
            let u = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let N = 10;
              this.codePointAtPos(this.state.pos) === 120 && ((N = 16), ++this.state.pos);
              let _ = this.readInt(N, void 0, !1, 'bail');
              if (_ !== null && this.codePointAtPos(this.state.pos) === 59)
                return ++this.state.pos, String.fromCodePoint(_);
            } else {
              let N = 0,
                _ = !1;
              for (; N++ < 10 && this.state.pos < this.length && !(_ = this.codePointAtPos(this.state.pos) == 59); )
                ++this.state.pos;
              if (_) {
                this.input.slice(u, this.state.pos);
                let Be;
                ++this.state.pos;
              }
            }
            return (this.state.pos = u), '&';
          }
          jsxReadWord() {
            let u,
              N = this.state.pos;
            do u = this.input.charCodeAt(++this.state.pos);
            while (Wh(u) || u === 45);
            this.finishToken(138, this.input.slice(N, this.state.pos));
          }
          jsxParseIdentifier() {
            let u = this.startNode();
            return (
              this.match(138)
                ? (u.name = this.state.value)
                : Hc(this.state.type)
                ? (u.name = mh(this.state.type))
                : this.unexpected(),
              this.next(),
              this.finishNode(u, 'JSXIdentifier')
            );
          }
          jsxParseNamespacedName() {
            let u = this.state.startLoc,
              N = this.jsxParseIdentifier();
            if (!this.eat(14)) return N;
            let _ = this.startNodeAt(u);
            return (_.namespace = N), (_.name = this.jsxParseIdentifier()), this.finishNode(_, 'JSXNamespacedName');
          }
          jsxParseElementName() {
            let u = this.state.startLoc,
              N = this.jsxParseNamespacedName();
            if (N.type === 'JSXNamespacedName') return N;
            for (; this.eat(16); ) {
              let _ = this.startNodeAt(u);
              (_.object = N), (_.property = this.jsxParseIdentifier()), (N = this.finishNode(_, 'JSXMemberExpression'));
            }
            return N;
          }
          jsxParseAttributeValue() {
            let u;
            switch (this.state.type) {
              case 5:
                return (
                  (u = this.startNode()),
                  this.setContext(vl.brace),
                  this.next(),
                  (u = this.jsxParseExpressionContainer(u, vl.j_oTag)),
                  u.expression.type === 'JSXEmptyExpression' && this.raise(jh.AttributeIsEmpty, { at: u }),
                  u
                );
              case 140:
              case 131:
                return this.parseExprAtom();
              default:
                throw this.raise(jh.UnsupportedJsxValue, { at: this.state.startLoc });
            }
          }
          jsxParseEmptyExpression() {
            let u = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(u, 'JSXEmptyExpression', this.state.startLoc);
          }
          jsxParseSpreadChild(u) {
            return (
              this.next(),
              (u.expression = this.parseExpression()),
              this.setContext(vl.j_expr),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(u, 'JSXSpreadChild')
            );
          }
          jsxParseExpressionContainer(u, N) {
            if (this.match(8)) u.expression = this.jsxParseEmptyExpression();
            else {
              let _ = this.parseExpression();
              u.expression = _;
            }
            return (
              this.setContext(N),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(u, 'JSXExpressionContainer')
            );
          }
          jsxParseAttribute() {
            let u = this.startNode();
            return this.match(5)
              ? (this.setContext(vl.brace),
                this.next(),
                this.expect(21),
                (u.argument = this.parseMaybeAssignAllowIn()),
                this.setContext(vl.j_oTag),
                (this.state.canStartJSXElement = !0),
                this.expect(8),
                this.finishNode(u, 'JSXSpreadAttribute'))
              : ((u.name = this.jsxParseNamespacedName()),
                (u.value = this.eat(29) ? this.jsxParseAttributeValue() : null),
                this.finishNode(u, 'JSXAttribute'));
          }
          jsxParseOpeningElementAt(u) {
            let N = this.startNodeAt(u);
            return this.eat(141)
              ? this.finishNode(N, 'JSXOpeningFragment')
              : ((N.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(N));
          }
          jsxParseOpeningElementAfterName(u) {
            let N = [];
            for (; !this.match(56) && !this.match(141); ) N.push(this.jsxParseAttribute());
            return (
              (u.attributes = N),
              (u.selfClosing = this.eat(56)),
              this.expect(141),
              this.finishNode(u, 'JSXOpeningElement')
            );
          }
          jsxParseClosingElementAt(u) {
            let N = this.startNodeAt(u);
            return this.eat(141)
              ? this.finishNode(N, 'JSXClosingFragment')
              : ((N.name = this.jsxParseElementName()), this.expect(141), this.finishNode(N, 'JSXClosingElement'));
          }
          jsxParseElementAt(u) {
            let N = this.startNodeAt(u),
              _ = [],
              Be = this.jsxParseOpeningElementAt(u),
              Cn = null;
            if (!Be.selfClosing) {
              e: for (;;)
                switch (this.state.type) {
                  case 140:
                    if (((u = this.state.startLoc), this.next(), this.eat(56))) {
                      Cn = this.jsxParseClosingElementAt(u);
                      break e;
                    }
                    _.push(this.jsxParseElementAt(u));
                    break;
                  case 139:
                    _.push(this.parseExprAtom());
                    break;
                  case 5: {
                    let Yi = this.startNode();
                    this.setContext(vl.brace),
                      this.next(),
                      this.match(21)
                        ? _.push(this.jsxParseSpreadChild(Yi))
                        : _.push(this.jsxParseExpressionContainer(Yi, vl.j_expr));
                    break;
                  }
                  default:
                    this.unexpected();
                }
              od(Be) && !od(Cn) && Cn !== null
                ? this.raise(jh.MissingClosingTagFragment, { at: Cn })
                : !od(Be) && od(Cn)
                ? this.raise(jh.MissingClosingTagElement, { at: Cn, openingTagName: xd(Be.name) })
                : !od(Be) &&
                  !od(Cn) &&
                  xd(Cn.name) !== xd(Be.name) &&
                  this.raise(jh.MissingClosingTagElement, { at: Cn, openingTagName: xd(Be.name) });
            }
            if (
              (od(Be)
                ? ((N.openingFragment = Be), (N.closingFragment = Cn))
                : ((N.openingElement = Be), (N.closingElement = Cn)),
              (N.children = _),
              this.match(47))
            )
              throw this.raise(jh.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
            return od(Be) ? this.finishNode(N, 'JSXFragment') : this.finishNode(N, 'JSXElement');
          }
          jsxParseElement() {
            let u = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(u);
          }
          setContext(u) {
            let { context: N } = this.state;
            N[N.length - 1] = u;
          }
          parseExprAtom(u) {
            return this.match(139)
              ? this.parseLiteral(this.state.value, 'JSXText')
              : this.match(140)
              ? this.jsxParseElement()
              : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33
              ? (this.replaceToken(140), this.jsxParseElement())
              : super.parseExprAtom(u);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(u) {
            let N = this.curContext();
            if (N === vl.j_expr) {
              this.jsxReadToken();
              return;
            }
            if (N === vl.j_oTag || N === vl.j_cTag) {
              if (Hh(u)) {
                this.jsxReadWord();
                return;
              }
              if (u === 62) {
                ++this.state.pos, this.finishToken(141);
                return;
              }
              if ((u === 34 || u === 39) && N === vl.j_oTag) {
                this.jsxReadString(u);
                return;
              }
            }
            if (u === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
              ++this.state.pos, this.finishToken(140);
              return;
            }
            super.getTokenFromCode(u);
          }
          updateContext(u) {
            let { context: N, type: _ } = this.state;
            if (_ === 56 && u === 140) N.splice(-2, 2, vl.j_cTag), (this.state.canStartJSXElement = !1);
            else if (_ === 140) N.push(vl.j_oTag);
            else if (_ === 141) {
              let Be = N[N.length - 1];
              (Be === vl.j_oTag && u === 56) || Be === vl.j_cTag
                ? (N.pop(), (this.state.canStartJSXElement = N[N.length - 1] === vl.j_expr))
                : (this.setContext(vl.j_expr), (this.state.canStartJSXElement = !0));
            } else this.state.canStartJSXElement = Pl(_);
          }
        },
      p0 = class extends Yd {
        constructor(...g) {
          super(...g),
            (this.types = new Set()),
            (this.enums = new Set()),
            (this.constEnums = new Set()),
            (this.classes = new Set()),
            (this.exportOnlyBindings = new Set());
        }
      },
      Bd = class extends Xd {
        constructor(...g) {
          super(...g), (this.importsStack = []);
        }
        createScope(g) {
          return this.importsStack.push(new Set()), new p0(g);
        }
        enter(g) {
          g == 256 && this.importsStack.push(new Set()), super.enter(g);
        }
        exit() {
          let g = super.exit();
          return g == 256 && this.importsStack.pop(), g;
        }
        hasImport(g, u) {
          let N = this.importsStack.length;
          if (this.importsStack[N - 1].has(g)) return !0;
          if (!u && N > 1) {
            for (let _ = 0; _ < N - 1; _++) if (this.importsStack[_].has(g)) return !0;
          }
          return !1;
        }
        declareName(g, u, N) {
          if (u & 4096) {
            this.hasImport(g, !0) && this.parser.raise(Wi.VarRedeclaration, { at: N, identifierName: g }),
              this.importsStack[this.importsStack.length - 1].add(g);
            return;
          }
          let _ = this.currentScope();
          if (u & 1024) {
            this.maybeExportDefined(_, g), _.exportOnlyBindings.add(g);
            return;
          }
          super.declareName(g, u, N),
            u & 2 &&
              (u & 1 || (this.checkRedeclarationInScope(_, g, u, N), this.maybeExportDefined(_, g)), _.types.add(g)),
            u & 256 && _.enums.add(g),
            u & 512 && _.constEnums.add(g),
            u & 128 && _.classes.add(g);
        }
        isRedeclaredInScope(g, u, N) {
          if (g.enums.has(u)) {
            if (N & 256) {
              let _ = !!(N & 512),
                Be = g.constEnums.has(u);
              return _ !== Be;
            }
            return !0;
          }
          return N & 128 && g.classes.has(u)
            ? g.lexical.has(u)
              ? !!(N & 1)
              : !1
            : N & 2 && g.types.has(u)
            ? !0
            : super.isRedeclaredInScope(g, u, N);
        }
        checkLocalExport(g) {
          let { name: u } = g;
          if (this.hasImport(u)) return;
          let N = this.scopeStack.length;
          for (let _ = N - 1; _ >= 0; _--) {
            let Be = this.scopeStack[_];
            if (Be.types.has(u) || Be.exportOnlyBindings.has(u)) return;
          }
          super.checkLocalExport(g);
        }
      },
      Lf = (g, u) => Object.hasOwnProperty.call(g, u) && g[u],
      $f = (g) => (g.type === 'ParenthesizedExpression' ? $f(g.expression) : g),
      d0 = class extends If {
        toAssignable(g, u = !1) {
          var N, _;
          let Be;
          switch (
            ((g.type === 'ParenthesizedExpression' || ((N = g.extra) != null && N.parenthesized)) &&
              ((Be = $f(g)),
              u
                ? Be.type === 'Identifier'
                  ? this.expressionScope.recordArrowParameterBindingError(Wi.InvalidParenthesizedAssignment, { at: g })
                  : Be.type !== 'MemberExpression' && this.raise(Wi.InvalidParenthesizedAssignment, { at: g })
                : this.raise(Wi.InvalidParenthesizedAssignment, { at: g })),
            g.type)
          ) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              break;
            case 'ObjectExpression':
              g.type = 'ObjectPattern';
              for (let Yi = 0, nl = g.properties.length, xl = nl - 1; Yi < nl; Yi++) {
                var Cn;
                let Dl = g.properties[Yi],
                  jl = Yi === xl;
                this.toAssignableObjectExpressionProp(Dl, jl, u),
                  jl &&
                    Dl.type === 'RestElement' &&
                    (Cn = g.extra) != null &&
                    Cn.trailingCommaLoc &&
                    this.raise(Wi.RestTrailingComma, { at: g.extra.trailingCommaLoc });
              }
              break;
            case 'ObjectProperty': {
              let { key: Yi, value: nl } = g;
              this.isPrivateName(Yi) && this.classScope.usePrivateName(this.getPrivateNameSV(Yi), Yi.loc.start),
                this.toAssignable(nl, u);
              break;
            }
            case 'SpreadElement':
              throw new Error(
                "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.",
              );
            case 'ArrayExpression':
              (g.type = 'ArrayPattern'),
                this.toAssignableList(g.elements, (_ = g.extra) == null ? void 0 : _.trailingCommaLoc, u);
              break;
            case 'AssignmentExpression':
              g.operator !== '=' && this.raise(Wi.MissingEqInAssignment, { at: g.left.loc.end }),
                (g.type = 'AssignmentPattern'),
                delete g.operator,
                this.toAssignable(g.left, u);
              break;
            case 'ParenthesizedExpression':
              this.toAssignable(Be, u);
              break;
          }
        }
        toAssignableObjectExpressionProp(g, u, N) {
          if (g.type === 'ObjectMethod')
            this.raise(g.kind === 'get' || g.kind === 'set' ? Wi.PatternHasAccessor : Wi.PatternHasMethod, {
              at: g.key,
            });
          else if (g.type === 'SpreadElement') {
            g.type = 'RestElement';
            let _ = g.argument;
            this.checkToRestConversion(_, !1),
              this.toAssignable(_, N),
              u || this.raise(Wi.RestTrailingComma, { at: g });
          } else this.toAssignable(g, N);
        }
        toAssignableList(g, u, N) {
          let _ = g.length - 1;
          for (let Be = 0; Be <= _; Be++) {
            let Cn = g[Be];
            if (Cn) {
              if (Cn.type === 'SpreadElement') {
                Cn.type = 'RestElement';
                let Yi = Cn.argument;
                this.checkToRestConversion(Yi, !0), this.toAssignable(Yi, N);
              } else this.toAssignable(Cn, N);
              Cn.type === 'RestElement' &&
                (Be < _
                  ? this.raise(Wi.RestTrailingComma, { at: Cn })
                  : u && this.raise(Wi.RestTrailingComma, { at: u }));
            }
          }
        }
        isAssignable(g, u) {
          switch (g.type) {
            case 'Identifier':
            case 'ObjectPattern':
            case 'ArrayPattern':
            case 'AssignmentPattern':
            case 'RestElement':
              return !0;
            case 'ObjectExpression': {
              let N = g.properties.length - 1;
              return g.properties.every(
                (_, Be) =>
                  _.type !== 'ObjectMethod' && (Be === N || _.type !== 'SpreadElement') && this.isAssignable(_),
              );
            }
            case 'ObjectProperty':
              return this.isAssignable(g.value);
            case 'SpreadElement':
              return this.isAssignable(g.argument);
            case 'ArrayExpression':
              return g.elements.every((N) => N === null || this.isAssignable(N));
            case 'AssignmentExpression':
              return g.operator === '=';
            case 'ParenthesizedExpression':
              return this.isAssignable(g.expression);
            case 'MemberExpression':
            case 'OptionalMemberExpression':
              return !u;
            default:
              return !1;
          }
        }
        toReferencedList(g, u) {
          return g;
        }
        toReferencedListDeep(g, u) {
          this.toReferencedList(g, u);
          for (let N of g) (N == null ? void 0 : N.type) === 'ArrayExpression' && this.toReferencedListDeep(N.elements);
        }
        parseSpread(g) {
          let u = this.startNode();
          return (
            this.next(), (u.argument = this.parseMaybeAssignAllowIn(g, void 0)), this.finishNode(u, 'SpreadElement')
          );
        }
        parseRestBinding() {
          let g = this.startNode();
          return this.next(), (g.argument = this.parseBindingAtom()), this.finishNode(g, 'RestElement');
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              let g = this.startNode();
              return this.next(), (g.elements = this.parseBindingList(3, 93, 1)), this.finishNode(g, 'ArrayPattern');
            }
            case 5:
              return this.parseObjectLike(8, !0);
          }
          return this.parseIdentifier();
        }
        parseBindingList(g, u, N) {
          let _ = N & 1,
            Be = [],
            Cn = !0;
          for (; !this.eat(g); )
            if ((Cn ? (Cn = !1) : this.expect(12), _ && this.match(12))) Be.push(null);
            else {
              if (this.eat(g)) break;
              if (this.match(21)) {
                if (
                  (Be.push(this.parseAssignableListItemTypes(this.parseRestBinding(), N)), !this.checkCommaAfterRest(u))
                ) {
                  this.expect(g);
                  break;
                }
              } else {
                let Yi = [];
                for (
                  this.match(26) &&
                  this.hasPlugin('decorators') &&
                  this.raise(Wi.UnsupportedParameterDecorator, { at: this.state.startLoc });
                  this.match(26);

                )
                  Yi.push(this.parseDecorator());
                Be.push(this.parseAssignableListItem(N, Yi));
              }
            }
          return Be;
        }
        parseBindingRestProperty(g) {
          return (
            this.next(),
            (g.argument = this.parseIdentifier()),
            this.checkCommaAfterRest(125),
            this.finishNode(g, 'RestElement')
          );
        }
        parseBindingProperty() {
          let g = this.startNode(),
            { type: u, startLoc: N } = this.state;
          return u === 21
            ? this.parseBindingRestProperty(g)
            : (u === 136
                ? (this.expectPlugin('destructuringPrivate', N),
                  this.classScope.usePrivateName(this.state.value, N),
                  (g.key = this.parsePrivateName()))
                : this.parsePropertyName(g),
              (g.method = !1),
              this.parseObjPropValue(g, N, !1, !1, !0, !1));
        }
        parseAssignableListItem(g, u) {
          let N = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(N, g);
          let _ = this.parseMaybeDefault(N.loc.start, N);
          return u.length && (N.decorators = u), _;
        }
        parseAssignableListItemTypes(g, u) {
          return g;
        }
        parseMaybeDefault(g, u) {
          var N;
          if (
            (g != null || (g = this.state.startLoc), (u = (N = u) != null ? N : this.parseBindingAtom()), !this.eat(29))
          )
            return u;
          let _ = this.startNodeAt(g);
          return (_.left = u), (_.right = this.parseMaybeAssignAllowIn()), this.finishNode(_, 'AssignmentPattern');
        }
        isValidLVal(g, u, N) {
          return Lf(
            {
              AssignmentPattern: 'left',
              RestElement: 'argument',
              ObjectProperty: 'value',
              ParenthesizedExpression: 'expression',
              ArrayPattern: 'elements',
              ObjectPattern: 'properties',
            },
            g,
          );
        }
        checkLVal(
          g,
          {
            in: u,
            binding: N = 64,
            checkClashes: _ = !1,
            strictModeChanged: Be = !1,
            hasParenthesizedAncestor: Cn = !1,
          },
        ) {
          var Yi;
          let nl = g.type;
          if (this.isObjectMethod(g)) return;
          if (nl === 'MemberExpression') {
            N !== 64 && this.raise(Wi.InvalidPropertyBindingPattern, { at: g });
            return;
          }
          if (nl === 'Identifier') {
            this.checkIdentifier(g, N, Be);
            let { name: Zc } = g;
            _ && (_.has(Zc) ? this.raise(Wi.ParamDupe, { at: g }) : _.add(Zc));
            return;
          }
          let xl = this.isValidLVal(
            nl,
            !(Cn || ((Yi = g.extra) != null && Yi.parenthesized)) && u.type === 'AssignmentExpression',
            N,
          );
          if (xl === !0) return;
          if (xl === !1) {
            let Zc = N === 64 ? Wi.InvalidLhs : Wi.InvalidLhsBinding;
            this.raise(Zc, { at: g, ancestor: u });
            return;
          }
          let [Dl, jl] = Array.isArray(xl) ? xl : [xl, nl === 'ParenthesizedExpression'],
            Zl = nl === 'ArrayPattern' || nl === 'ObjectPattern' || nl === 'ParenthesizedExpression' ? { type: nl } : u;
          for (let Zc of [].concat(g[Dl]))
            Zc &&
              this.checkLVal(Zc, {
                in: Zl,
                binding: N,
                checkClashes: _,
                strictModeChanged: Be,
                hasParenthesizedAncestor: jl,
              });
        }
        checkIdentifier(g, u, N = !1) {
          this.state.strict &&
            (N ? Gd(g.name, this.inModule) : Ih(g.name)) &&
            (u === 64
              ? this.raise(Wi.StrictEvalArguments, { at: g, referenceName: g.name })
              : this.raise(Wi.StrictEvalArgumentsBinding, { at: g, bindingName: g.name })),
            u & 8192 && g.name === 'let' && this.raise(Wi.LetInLexicalBinding, { at: g }),
            u & 64 || this.declareNameFromIdentifier(g, u);
        }
        declareNameFromIdentifier(g, u) {
          this.scope.declareName(g.name, u, g.loc.start);
        }
        checkToRestConversion(g, u) {
          switch (g.type) {
            case 'ParenthesizedExpression':
              this.checkToRestConversion(g.expression, u);
              break;
            case 'Identifier':
            case 'MemberExpression':
              break;
            case 'ArrayExpression':
            case 'ObjectExpression':
              if (u) break;
            default:
              this.raise(Wi.InvalidRestAssignmentPattern, { at: g });
          }
        }
        checkCommaAfterRest(g) {
          return this.match(12)
            ? (this.raise(this.lookaheadCharCode() === g ? Wi.RestTrailingComma : Wi.ElementAfterRest, {
                at: this.state.startLoc,
              }),
              !0)
            : !1;
        }
      },
      Rf = (g, u) => Object.hasOwnProperty.call(g, u) && g[u];
    function f0(g) {
      if (g == null) throw new Error(`Unexpected ${g} value.`);
      return g;
    }
    function _f(g) {
      if (!g) throw new Error('Assert fail');
    }
    var sh = tl`typescript`({
      AbstractMethodHasImplementation: ({ methodName: g }) =>
        `Method '${g}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({ propertyName: g }) =>
        `Property '${g}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: 'An accessor cannot have type parameters.',
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:
        "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.',
      DeclareAccessor: ({ kind: g }) => `'declare' is not allowed in ${g}ters.`,
      DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.',
      DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.',
      DuplicateAccessibilityModifier: ({ modifier: g }) => 'Accessibility modifier already seen.',
      DuplicateModifier: ({ modifier: g }) => `Duplicate modifier: '${g}'.`,
      EmptyHeritageClauseType: ({ token: g }) => `'${g}' list cannot be empty.`,
      EmptyTypeArguments: 'Type argument list cannot be empty.',
      EmptyTypeParameters: 'Type parameter list cannot be empty.',
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: 'An `import module` declaration can not use `type` modifier',
      IncompatibleModifiers: ({ modifiers: g }) => `'${g[0]}' modifier cannot be used with '${g[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({ modifier: g }) =>
        `Index signatures cannot have an accessibility modifier ('${g}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.',
      InvalidModifierOnTypeMember: ({ modifier: g }) => `'${g}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({ modifier: g }) => `'${g}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({ modifier: g }) =>
        `'${g}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({ orderedModifiers: g }) => `'${g[0]}' modifier must precede '${g[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression:
        'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.',
      InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.',
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      MixedLabeledAndUnlabeledElements: 'Tuple members must all have names or all not have names.',
      NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.',
      NonClassMethodPropertyHasAbstractModifer:
        "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.',
      OverrideNotInSubClass:
        "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.',
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({ modifier: g }) =>
        `Private elements cannot have an accessibility modifier ('${g}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam:
        'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.',
      ReservedTypeAssertion:
        'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.',
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: g }) =>
        `Single type parameter ${g} should have a trailing comma. Example usage: <${g},>.`,
      StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.',
      TupleOptionalAfterType:
        'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).',
      TypeAnnotationAfterAssign:
        'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
      TypeImportCannotSpecifyDefaultAndNamed:
        'A type-only import can specify a default import or named bindings, but not both.',
      TypeModifierIsUsedInTypeExports:
        "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports:
        "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.',
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
      UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.',
      UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.',
      UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.',
      UnsupportedSignatureParameterKind: ({ type: g }) =>
        `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${g}.`,
    });
    function m0(g) {
      switch (g) {
        case 'any':
          return 'TSAnyKeyword';
        case 'boolean':
          return 'TSBooleanKeyword';
        case 'bigint':
          return 'TSBigIntKeyword';
        case 'never':
          return 'TSNeverKeyword';
        case 'number':
          return 'TSNumberKeyword';
        case 'object':
          return 'TSObjectKeyword';
        case 'string':
          return 'TSStringKeyword';
        case 'symbol':
          return 'TSSymbolKeyword';
        case 'undefined':
          return 'TSUndefinedKeyword';
        case 'unknown':
          return 'TSUnknownKeyword';
        default:
          return;
      }
    }
    function hf(g) {
      return g === 'private' || g === 'public' || g === 'protected';
    }
    function pf(g) {
      return g === 'in' || g === 'out';
    }
    var jf = (g) =>
      class extends g {
        constructor(...u) {
          super(...u),
            (this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['in', 'out'],
              disallowedModifiers: [
                'const',
                'public',
                'private',
                'protected',
                'readonly',
                'declare',
                'abstract',
                'override',
              ],
              errorTemplate: sh.InvalidModifierOnTypeParameter,
            })),
            (this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['const'],
              disallowedModifiers: ['in', 'out'],
              errorTemplate: sh.InvalidModifierOnTypeParameterPositions,
            })),
            (this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
              allowedModifiers: ['in', 'out', 'const'],
              disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'],
              errorTemplate: sh.InvalidModifierOnTypeParameter,
            }));
        }
        getScopeHandler() {
          return Bd;
        }
        tsIsIdentifier() {
          return Ul(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (
            (this.match(0) ||
              this.match(5) ||
              this.match(55) ||
              this.match(21) ||
              this.match(136) ||
              this.isLiteralPropertyName()) &&
            !this.hasPrecedingLineBreak()
          );
        }
        tsNextTokenCanFollowModifier() {
          return this.next(), this.tsTokenCanFollowModifier();
        }
        tsParseModifier(u, N) {
          if (!Ul(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
          let _ = this.state.value;
          if (u.indexOf(_) !== -1) {
            if (N && this.tsIsStartOfStaticBlocks()) return;
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return _;
          }
        }
        tsParseModifiers(
          {
            allowedModifiers: u,
            disallowedModifiers: N,
            stopOnStartOfClassStaticBlock: _,
            errorTemplate: Be = sh.InvalidModifierOnTypeMember,
          },
          Cn,
        ) {
          let Yi = (xl, Dl, jl, Zl) => {
              Dl === jl && Cn[Zl] && this.raise(sh.InvalidModifiersOrder, { at: xl, orderedModifiers: [jl, Zl] });
            },
            nl = (xl, Dl, jl, Zl) => {
              ((Cn[jl] && Dl === Zl) || (Cn[Zl] && Dl === jl)) &&
                this.raise(sh.IncompatibleModifiers, { at: xl, modifiers: [jl, Zl] });
            };
          for (;;) {
            let { startLoc: xl } = this.state,
              Dl = this.tsParseModifier(u.concat(N ?? []), _);
            if (!Dl) break;
            hf(Dl)
              ? Cn.accessibility
                ? this.raise(sh.DuplicateAccessibilityModifier, { at: xl, modifier: Dl })
                : (Yi(xl, Dl, Dl, 'override'),
                  Yi(xl, Dl, Dl, 'static'),
                  Yi(xl, Dl, Dl, 'readonly'),
                  (Cn.accessibility = Dl))
              : pf(Dl)
              ? (Cn[Dl] && this.raise(sh.DuplicateModifier, { at: xl, modifier: Dl }),
                (Cn[Dl] = !0),
                Yi(xl, Dl, 'in', 'out'))
              : (Object.hasOwnProperty.call(Cn, Dl)
                  ? this.raise(sh.DuplicateModifier, { at: xl, modifier: Dl })
                  : (Yi(xl, Dl, 'static', 'readonly'),
                    Yi(xl, Dl, 'static', 'override'),
                    Yi(xl, Dl, 'override', 'readonly'),
                    Yi(xl, Dl, 'abstract', 'override'),
                    nl(xl, Dl, 'declare', 'override'),
                    nl(xl, Dl, 'static', 'abstract')),
                (Cn[Dl] = !0)),
              N != null && N.includes(Dl) && this.raise(Be, { at: xl, modifier: Dl });
          }
        }
        tsIsListTerminator(u) {
          switch (u) {
            case 'EnumMembers':
            case 'TypeMembers':
              return this.match(8);
            case 'HeritageClauseElement':
              return this.match(5);
            case 'TupleElementTypes':
              return this.match(3);
            case 'TypeParametersOrArguments':
              return this.match(48);
          }
        }
        tsParseList(u, N) {
          let _ = [];
          for (; !this.tsIsListTerminator(u); ) _.push(N());
          return _;
        }
        tsParseDelimitedList(u, N, _) {
          return f0(this.tsParseDelimitedListWorker(u, N, !0, _));
        }
        tsParseDelimitedListWorker(u, N, _, Be) {
          let Cn = [],
            Yi = -1;
          for (; !this.tsIsListTerminator(u); ) {
            Yi = -1;
            let nl = N();
            if (nl == null) return;
            if ((Cn.push(nl), this.eat(12))) {
              Yi = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(u)) break;
            _ && this.expect(12);
            return;
          }
          return Be && (Be.value = Yi), Cn;
        }
        tsParseBracketedList(u, N, _, Be, Cn) {
          Be || (_ ? this.expect(0) : this.expect(47));
          let Yi = this.tsParseDelimitedList(u, N, Cn);
          return _ ? this.expect(3) : this.expect(48), Yi;
        }
        tsParseImportType() {
          let u = this.startNode();
          return (
            this.expect(83),
            this.expect(10),
            this.match(131) || this.raise(sh.UnsupportedImportTypeArgument, { at: this.state.startLoc }),
            (u.argument = super.parseExprAtom()),
            this.expect(11),
            this.eat(16) && (u.qualifier = this.tsParseEntityName()),
            this.match(47) && (u.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(u, 'TSImportType')
          );
        }
        tsParseEntityName(u = !0) {
          let N = this.parseIdentifier(u);
          for (; this.eat(16); ) {
            let _ = this.startNodeAtNode(N);
            (_.left = N), (_.right = this.parseIdentifier(u)), (N = this.finishNode(_, 'TSQualifiedName'));
          }
          return N;
        }
        tsParseTypeReference() {
          let u = this.startNode();
          return (
            (u.typeName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() && this.match(47) && (u.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(u, 'TSTypeReference')
          );
        }
        tsParseThisTypePredicate(u) {
          this.next();
          let N = this.startNodeAtNode(u);
          return (
            (N.parameterName = u),
            (N.typeAnnotation = this.tsParseTypeAnnotation(!1)),
            (N.asserts = !1),
            this.finishNode(N, 'TSTypePredicate')
          );
        }
        tsParseThisTypeNode() {
          let u = this.startNode();
          return this.next(), this.finishNode(u, 'TSThisType');
        }
        tsParseTypeQuery() {
          let u = this.startNode();
          return (
            this.expect(87),
            this.match(83) ? (u.exprName = this.tsParseImportType()) : (u.exprName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() && this.match(47) && (u.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(u, 'TSTypeQuery')
          );
        }
        tsParseTypeParameter(u) {
          let N = this.startNode();
          return (
            u(N),
            (N.name = this.tsParseTypeParameterName()),
            (N.constraint = this.tsEatThenParseType(81)),
            (N.default = this.tsEatThenParseType(29)),
            this.finishNode(N, 'TSTypeParameter')
          );
        }
        tsTryParseTypeParameters(u) {
          if (this.match(47)) return this.tsParseTypeParameters(u);
        }
        tsParseTypeParameters(u) {
          let N = this.startNode();
          this.match(47) || this.match(140) ? this.next() : this.unexpected();
          let _ = { value: -1 };
          return (
            (N.params = this.tsParseBracketedList(
              'TypeParametersOrArguments',
              this.tsParseTypeParameter.bind(this, u),
              !1,
              !0,
              _,
            )),
            N.params.length === 0 && this.raise(sh.EmptyTypeParameters, { at: N }),
            _.value !== -1 && this.addExtra(N, 'trailingComma', _.value),
            this.finishNode(N, 'TSTypeParameterDeclaration')
          );
        }
        tsFillSignature(u, N) {
          let _ = u === 19,
            Be = 'parameters',
            Cn = 'typeAnnotation';
          (N.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier)),
            this.expect(10),
            (N[Be] = this.tsParseBindingListForSignature()),
            _
              ? (N[Cn] = this.tsParseTypeOrTypePredicateAnnotation(u))
              : this.match(u) && (N[Cn] = this.tsParseTypeOrTypePredicateAnnotation(u));
        }
        tsParseBindingListForSignature() {
          let u = super.parseBindingList(11, 41, 2);
          for (let N of u) {
            let { type: _ } = N;
            (_ === 'AssignmentPattern' || _ === 'TSParameterProperty') &&
              this.raise(sh.UnsupportedSignatureParameterKind, { at: N, type: _ });
          }
          return u;
        }
        tsParseTypeMemberSemicolon() {
          !this.eat(12) && !this.isLineTerminator() && this.expect(13);
        }
        tsParseSignatureMember(u, N) {
          return this.tsFillSignature(14, N), this.tsParseTypeMemberSemicolon(), this.finishNode(N, u);
        }
        tsIsUnambiguouslyIndexSignature() {
          return this.next(), Ul(this.state.type) ? (this.next(), this.match(14)) : !1;
        }
        tsTryParseIndexSignature(u) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
          this.expect(0);
          let N = this.parseIdentifier();
          (N.typeAnnotation = this.tsParseTypeAnnotation()),
            this.resetEndLocation(N),
            this.expect(3),
            (u.parameters = [N]);
          let _ = this.tsTryParseTypeAnnotation();
          return _ && (u.typeAnnotation = _), this.tsParseTypeMemberSemicolon(), this.finishNode(u, 'TSIndexSignature');
        }
        tsParsePropertyOrMethodSignature(u, N) {
          this.eat(17) && (u.optional = !0);
          let _ = u;
          if (this.match(10) || this.match(47)) {
            N && this.raise(sh.ReadonlyForMethodSignature, { at: u });
            let Be = _;
            Be.kind &&
              this.match(47) &&
              this.raise(sh.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }),
              this.tsFillSignature(14, Be),
              this.tsParseTypeMemberSemicolon();
            let Cn = 'parameters',
              Yi = 'typeAnnotation';
            if (Be.kind === 'get')
              Be[Cn].length > 0 &&
                (this.raise(Wi.BadGetterArity, { at: this.state.curPosition() }),
                this.isThisParam(Be[Cn][0]) &&
                  this.raise(sh.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
            else if (Be.kind === 'set') {
              if (Be[Cn].length !== 1) this.raise(Wi.BadSetterArity, { at: this.state.curPosition() });
              else {
                let nl = Be[Cn][0];
                this.isThisParam(nl) &&
                  this.raise(sh.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }),
                  nl.type === 'Identifier' &&
                    nl.optional &&
                    this.raise(sh.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }),
                  nl.type === 'RestElement' &&
                    this.raise(sh.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
              }
              Be[Yi] && this.raise(sh.SetAccesorCannotHaveReturnType, { at: Be[Yi] });
            } else Be.kind = 'method';
            return this.finishNode(Be, 'TSMethodSignature');
          } else {
            let Be = _;
            N && (Be.readonly = !0);
            let Cn = this.tsTryParseTypeAnnotation();
            return (
              Cn && (Be.typeAnnotation = Cn),
              this.tsParseTypeMemberSemicolon(),
              this.finishNode(Be, 'TSPropertySignature')
            );
          }
        }
        tsParseTypeMember() {
          let u = this.startNode();
          if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', u);
          if (this.match(77)) {
            let _ = this.startNode();
            return (
              this.next(),
              this.match(10) || this.match(47)
                ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', u)
                : ((u.key = this.createIdentifier(_, 'new')), this.tsParsePropertyOrMethodSignature(u, !1))
            );
          }
          return (
            this.tsParseModifiers(
              {
                allowedModifiers: ['readonly'],
                disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'],
              },
              u,
            ),
            this.tsTryParseIndexSignature(u) ||
              (super.parsePropertyName(u),
              !u.computed &&
                u.key.type === 'Identifier' &&
                (u.key.name === 'get' || u.key.name === 'set') &&
                this.tsTokenCanFollowModifier() &&
                ((u.kind = u.key.name), super.parsePropertyName(u)),
              this.tsParsePropertyOrMethodSignature(u, !!u.readonly))
          );
        }
        tsParseTypeLiteral() {
          let u = this.startNode();
          return (u.members = this.tsParseObjectTypeMembers()), this.finishNode(u, 'TSTypeLiteral');
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          let u = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
          return this.expect(8), u;
        }
        tsIsStartOfMappedType() {
          return (
            this.next(),
            this.eat(53)
              ? this.isContextual(120)
              : (this.isContextual(120) && this.next(),
                !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)))
          );
        }
        tsParseMappedTypeParameter() {
          let u = this.startNode();
          return (
            (u.name = this.tsParseTypeParameterName()),
            (u.constraint = this.tsExpectThenParseType(58)),
            this.finishNode(u, 'TSTypeParameter')
          );
        }
        tsParseMappedType() {
          let u = this.startNode();
          return (
            this.expect(5),
            this.match(53)
              ? ((u.readonly = this.state.value), this.next(), this.expectContextual(120))
              : this.eatContextual(120) && (u.readonly = !0),
            this.expect(0),
            (u.typeParameter = this.tsParseMappedTypeParameter()),
            (u.nameType = this.eatContextual(93) ? this.tsParseType() : null),
            this.expect(3),
            this.match(53)
              ? ((u.optional = this.state.value), this.next(), this.expect(17))
              : this.eat(17) && (u.optional = !0),
            (u.typeAnnotation = this.tsTryParseType()),
            this.semicolon(),
            this.expect(8),
            this.finishNode(u, 'TSMappedType')
          );
        }
        tsParseTupleType() {
          let u = this.startNode();
          u.elementTypes = this.tsParseBracketedList(
            'TupleElementTypes',
            this.tsParseTupleElementType.bind(this),
            !0,
            !1,
          );
          let N = !1,
            _ = null;
          return (
            u.elementTypes.forEach((Be) => {
              let { type: Cn } = Be;
              N &&
                Cn !== 'TSRestType' &&
                Cn !== 'TSOptionalType' &&
                !(Cn === 'TSNamedTupleMember' && Be.optional) &&
                this.raise(sh.OptionalTypeBeforeRequired, { at: Be }),
                N || (N = (Cn === 'TSNamedTupleMember' && Be.optional) || Cn === 'TSOptionalType');
              let Yi = Cn;
              Cn === 'TSRestType' && ((Be = Be.typeAnnotation), (Yi = Be.type));
              let nl = Yi === 'TSNamedTupleMember';
              _ != null || (_ = nl), _ !== nl && this.raise(sh.MixedLabeledAndUnlabeledElements, { at: Be });
            }),
            this.finishNode(u, 'TSTupleType')
          );
        }
        tsParseTupleElementType() {
          let { startLoc: u } = this.state,
            N = this.eat(21),
            _,
            Be,
            Cn,
            Yi,
            nl = gl(this.state.type) ? this.lookaheadCharCode() : null;
          if (nl === 58)
            (_ = !0), (Cn = !1), (Be = this.parseIdentifier(!0)), this.expect(14), (Yi = this.tsParseType());
          else if (nl === 63) {
            Cn = !0;
            let xl = this.state.startLoc,
              Dl = this.state.value,
              jl = this.tsParseNonArrayType();
            this.lookaheadCharCode() === 58
              ? ((_ = !0),
                (Be = this.createIdentifier(this.startNodeAt(xl), Dl)),
                this.expect(17),
                this.expect(14),
                (Yi = this.tsParseType()))
              : ((_ = !1), (Yi = jl), this.expect(17));
          } else (Yi = this.tsParseType()), (Cn = this.eat(17)), (_ = this.eat(14));
          if (_) {
            let xl;
            Be
              ? ((xl = this.startNodeAtNode(Be)),
                (xl.optional = Cn),
                (xl.label = Be),
                (xl.elementType = Yi),
                this.eat(17) &&
                  ((xl.optional = !0), this.raise(sh.TupleOptionalAfterType, { at: this.state.lastTokStartLoc })))
              : ((xl = this.startNodeAtNode(Yi)),
                (xl.optional = Cn),
                this.raise(sh.InvalidTupleMemberLabel, { at: Yi }),
                (xl.label = Yi),
                (xl.elementType = this.tsParseType())),
              (Yi = this.finishNode(xl, 'TSNamedTupleMember'));
          } else if (Cn) {
            let xl = this.startNodeAtNode(Yi);
            (xl.typeAnnotation = Yi), (Yi = this.finishNode(xl, 'TSOptionalType'));
          }
          if (N) {
            let xl = this.startNodeAt(u);
            (xl.typeAnnotation = Yi), (Yi = this.finishNode(xl, 'TSRestType'));
          }
          return Yi;
        }
        tsParseParenthesizedType() {
          let u = this.startNode();
          return (
            this.expect(10),
            (u.typeAnnotation = this.tsParseType()),
            this.expect(11),
            this.finishNode(u, 'TSParenthesizedType')
          );
        }
        tsParseFunctionOrConstructorType(u, N) {
          let _ = this.startNode();
          return (
            u === 'TSConstructorType' && ((_.abstract = !!N), N && this.next(), this.next()),
            this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, _)),
            this.finishNode(_, u)
          );
        }
        tsParseLiteralTypeNode() {
          let u = this.startNode();
          switch (this.state.type) {
            case 132:
            case 133:
            case 131:
            case 85:
            case 86:
              u.literal = super.parseExprAtom();
              break;
            default:
              this.unexpected();
          }
          return this.finishNode(u, 'TSLiteralType');
        }
        tsParseTemplateLiteralType() {
          let u = this.startNode();
          return (u.literal = super.parseTemplate(!1)), this.finishNode(u, 'TSLiteralType');
        }
        parseTemplateSubstitution() {
          return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          let u = this.tsParseThisTypeNode();
          return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(u) : u;
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 131:
            case 132:
            case 133:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === '-') {
                let u = this.startNode(),
                  N = this.lookahead();
                return (
                  N.type !== 132 && N.type !== 133 && this.unexpected(),
                  (u.literal = this.parseMaybeUnary()),
                  this.finishNode(u, 'TSLiteralType')
                );
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
                ? this.tsParseMappedType()
                : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              let { type: u } = this.state;
              if (Ul(u) || u === 88 || u === 84) {
                let N = u === 88 ? 'TSVoidKeyword' : u === 84 ? 'TSNullKeyword' : m0(this.state.value);
                if (N !== void 0 && this.lookaheadCharCode() !== 46) {
                  let _ = this.startNode();
                  return this.next(), this.finishNode(_, N);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let u = this.tsParseNonArrayType();
          for (; !this.hasPrecedingLineBreak() && this.eat(0); )
            if (this.match(3)) {
              let N = this.startNodeAtNode(u);
              (N.elementType = u), this.expect(3), (u = this.finishNode(N, 'TSArrayType'));
            } else {
              let N = this.startNodeAtNode(u);
              (N.objectType = u),
                (N.indexType = this.tsParseType()),
                this.expect(3),
                (u = this.finishNode(N, 'TSIndexedAccessType'));
            }
          return u;
        }
        tsParseTypeOperator() {
          let u = this.startNode(),
            N = this.state.value;
          return (
            this.next(),
            (u.operator = N),
            (u.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
            N === 'readonly' && this.tsCheckTypeAnnotationForReadOnly(u),
            this.finishNode(u, 'TSTypeOperator')
          );
        }
        tsCheckTypeAnnotationForReadOnly(u) {
          switch (u.typeAnnotation.type) {
            case 'TSTupleType':
            case 'TSArrayType':
              return;
            default:
              this.raise(sh.UnexpectedReadonly, { at: u });
          }
        }
        tsParseInferType() {
          let u = this.startNode();
          this.expectContextual(113);
          let N = this.startNode();
          return (
            (N.name = this.tsParseTypeParameterName()),
            (N.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())),
            (u.typeParameter = this.finishNode(N, 'TSTypeParameter')),
            this.finishNode(u, 'TSInferType')
          );
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            let u = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return u;
          }
        }
        tsParseTypeOperatorOrHigher() {
          return lh(this.state.type) && !this.state.containsEsc
            ? this.tsParseTypeOperator()
            : this.isContextual(113)
            ? this.tsParseInferType()
            : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(u, N, _) {
          let Be = this.startNode(),
            Cn = this.eat(_),
            Yi = [];
          do Yi.push(N());
          while (this.eat(_));
          return Yi.length === 1 && !Cn ? Yi[0] : ((Be.types = Yi), this.finishNode(Be, u));
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            'TSIntersectionType',
            this.tsParseTypeOperatorOrHigher.bind(this),
            45,
          );
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            'TSUnionType',
            this.tsParseIntersectionTypeOrHigher.bind(this),
            43,
          );
        }
        tsIsStartOfFunctionType() {
          return this.match(47)
            ? !0
            : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (Ul(this.state.type) || this.match(78)) return this.next(), !0;
          if (this.match(5)) {
            let { errors: u } = this.state,
              N = u.length;
            try {
              return this.parseObjectLike(8, !0), u.length === N;
            } catch {
              return !1;
            }
          }
          if (this.match(0)) {
            this.next();
            let { errors: u } = this.state,
              N = u.length;
            try {
              return super.parseBindingList(3, 93, 1), u.length === N;
            } catch {
              return !1;
            }
          }
          return !1;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          return (
            this.next(),
            !!(
              this.match(11) ||
              this.match(21) ||
              (this.tsSkipParameterStart() &&
                (this.match(14) ||
                  this.match(12) ||
                  this.match(17) ||
                  this.match(29) ||
                  (this.match(11) && (this.next(), this.match(19)))))
            )
          );
        }
        tsParseTypeOrTypePredicateAnnotation(u) {
          return this.tsInType(() => {
            let N = this.startNode();
            this.expect(u);
            let _ = this.startNode(),
              Be = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (Be && this.match(78)) {
              let nl = this.tsParseThisTypeOrThisTypePredicate();
              return (
                nl.type === 'TSThisType'
                  ? ((_.parameterName = nl),
                    (_.asserts = !0),
                    (_.typeAnnotation = null),
                    (nl = this.finishNode(_, 'TSTypePredicate')))
                  : (this.resetStartLocationFromNode(nl, _), (nl.asserts = !0)),
                (N.typeAnnotation = nl),
                this.finishNode(N, 'TSTypeAnnotation')
              );
            }
            let Cn = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!Cn)
              return Be
                ? ((_.parameterName = this.parseIdentifier()),
                  (_.asserts = Be),
                  (_.typeAnnotation = null),
                  (N.typeAnnotation = this.finishNode(_, 'TSTypePredicate')),
                  this.finishNode(N, 'TSTypeAnnotation'))
                : this.tsParseTypeAnnotation(!1, N);
            let Yi = this.tsParseTypeAnnotation(!1);
            return (
              (_.parameterName = Cn),
              (_.typeAnnotation = Yi),
              (_.asserts = Be),
              (N.typeAnnotation = this.finishNode(_, 'TSTypePredicate')),
              this.finishNode(N, 'TSTypeAnnotation')
            );
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        tsTryParseTypeAnnotation() {
          if (this.match(14)) return this.tsParseTypeAnnotation();
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          let u = this.parseIdentifier();
          if (this.isContextual(114) && !this.hasPrecedingLineBreak()) return this.next(), u;
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 107) return !1;
          let u = this.state.containsEsc;
          return (
            this.next(),
            !Ul(this.state.type) && !this.match(78)
              ? !1
              : (u &&
                  this.raise(Wi.InvalidEscapedReservedWord, {
                    at: this.state.lastTokStartLoc,
                    reservedWord: 'asserts',
                  }),
                !0)
          );
        }
        tsParseTypeAnnotation(u = !0, N = this.startNode()) {
          return (
            this.tsInType(() => {
              u && this.expect(14), (N.typeAnnotation = this.tsParseType());
            }),
            this.finishNode(N, 'TSTypeAnnotation')
          );
        }
        tsParseType() {
          _f(this.state.inType);
          let u = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return u;
          let N = this.startNodeAtNode(u);
          return (
            (N.checkType = u),
            (N.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())),
            this.expect(17),
            (N.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
            this.expect(14),
            (N.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
            this.finishNode(N, 'TSConditionalType')
          );
        }
        isAbstractConstructorSignature() {
          return this.isContextual(122) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          return this.tsIsStartOfFunctionType()
            ? this.tsParseFunctionOrConstructorType('TSFunctionType')
            : this.match(77)
            ? this.tsParseFunctionOrConstructorType('TSConstructorType')
            : this.isAbstractConstructorSignature()
            ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0)
            : this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
            this.raise(sh.ReservedTypeAssertion, { at: this.state.startLoc });
          let u = this.startNode();
          return (
            (u.typeAnnotation = this.tsInType(
              () => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType()),
            )),
            this.expect(48),
            (u.expression = this.parseMaybeUnary()),
            this.finishNode(u, 'TSTypeAssertion')
          );
        }
        tsParseHeritageClause(u) {
          let N = this.state.startLoc,
            _ = this.tsParseDelimitedList('HeritageClauseElement', () => {
              let Be = this.startNode();
              return (
                (Be.expression = this.tsParseEntityName()),
                this.match(47) && (Be.typeParameters = this.tsParseTypeArguments()),
                this.finishNode(Be, 'TSExpressionWithTypeArguments')
              );
            });
          return _.length || this.raise(sh.EmptyHeritageClauseType, { at: N, token: u }), _;
        }
        tsParseInterfaceDeclaration(u, N = {}) {
          if (this.hasFollowingLineBreak()) return null;
          this.expectContextual(127),
            N.declare && (u.declare = !0),
            Ul(this.state.type)
              ? ((u.id = this.parseIdentifier()), this.checkIdentifier(u.id, 130))
              : ((u.id = null), this.raise(sh.MissingInterfaceName, { at: this.state.startLoc })),
            (u.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)),
            this.eat(81) && (u.extends = this.tsParseHeritageClause('extends'));
          let _ = this.startNode();
          return (
            (_.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))),
            (u.body = this.finishNode(_, 'TSInterfaceBody')),
            this.finishNode(u, 'TSInterfaceDeclaration')
          );
        }
        tsParseTypeAliasDeclaration(u) {
          return (
            (u.id = this.parseIdentifier()),
            this.checkIdentifier(u.id, 2),
            (u.typeAnnotation = this.tsInType(() => {
              if (
                ((u.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers)),
                this.expect(29),
                this.isContextual(112) && this.lookahead().type !== 16)
              ) {
                let N = this.startNode();
                return this.next(), this.finishNode(N, 'TSIntrinsicKeyword');
              }
              return this.tsParseType();
            })),
            this.semicolon(),
            this.finishNode(u, 'TSTypeAliasDeclaration')
          );
        }
        tsInNoContext(u) {
          let N = this.state.context;
          this.state.context = [N[0]];
          try {
            return u();
          } finally {
            this.state.context = N;
          }
        }
        tsInType(u) {
          let N = this.state.inType;
          this.state.inType = !0;
          try {
            return u();
          } finally {
            this.state.inType = N;
          }
        }
        tsInDisallowConditionalTypesContext(u) {
          let N = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !0;
          try {
            return u();
          } finally {
            this.state.inDisallowConditionalTypesContext = N;
          }
        }
        tsInAllowConditionalTypesContext(u) {
          let N = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !1;
          try {
            return u();
          } finally {
            this.state.inDisallowConditionalTypesContext = N;
          }
        }
        tsEatThenParseType(u) {
          if (this.match(u)) return this.tsNextThenParseType();
        }
        tsExpectThenParseType(u) {
          return this.tsInType(() => (this.expect(u), this.tsParseType()));
        }
        tsNextThenParseType() {
          return this.tsInType(() => (this.next(), this.tsParseType()));
        }
        tsParseEnumMember() {
          let u = this.startNode();
          return (
            (u.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0)),
            this.eat(29) && (u.initializer = super.parseMaybeAssignAllowIn()),
            this.finishNode(u, 'TSEnumMember')
          );
        }
        tsParseEnumDeclaration(u, N = {}) {
          return (
            N.const && (u.const = !0),
            N.declare && (u.declare = !0),
            this.expectContextual(124),
            (u.id = this.parseIdentifier()),
            this.checkIdentifier(u.id, u.const ? 8971 : 8459),
            this.expect(5),
            (u.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))),
            this.expect(8),
            this.finishNode(u, 'TSEnumDeclaration')
          );
        }
        tsParseModuleBlock() {
          let u = this.startNode();
          return (
            this.scope.enter(0),
            this.expect(5),
            super.parseBlockOrModuleBlockBody((u.body = []), void 0, !0, 8),
            this.scope.exit(),
            this.finishNode(u, 'TSModuleBlock')
          );
        }
        tsParseModuleOrNamespaceDeclaration(u, N = !1) {
          if (((u.id = this.parseIdentifier()), N || this.checkIdentifier(u.id, 1024), this.eat(16))) {
            let _ = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(_, !0), (u.body = _);
          } else
            this.scope.enter(256),
              this.prodParam.enter(gd),
              (u.body = this.tsParseModuleBlock()),
              this.prodParam.exit(),
              this.scope.exit();
          return this.finishNode(u, 'TSModuleDeclaration');
        }
        tsParseAmbientExternalModuleDeclaration(u) {
          return (
            this.isContextual(110)
              ? ((u.global = !0), (u.id = this.parseIdentifier()))
              : this.match(131)
              ? (u.id = super.parseStringLiteral(this.state.value))
              : this.unexpected(),
            this.match(5)
              ? (this.scope.enter(256),
                this.prodParam.enter(gd),
                (u.body = this.tsParseModuleBlock()),
                this.prodParam.exit(),
                this.scope.exit())
              : this.semicolon(),
            this.finishNode(u, 'TSModuleDeclaration')
          );
        }
        tsParseImportEqualsDeclaration(u, N, _) {
          (u.isExport = _ || !1),
            (u.id = N || this.parseIdentifier()),
            this.checkIdentifier(u.id, 4096),
            this.expect(29);
          let Be = this.tsParseModuleReference();
          return (
            u.importKind === 'type' &&
              Be.type !== 'TSExternalModuleReference' &&
              this.raise(sh.ImportAliasHasImportType, { at: Be }),
            (u.moduleReference = Be),
            this.semicolon(),
            this.finishNode(u, 'TSImportEqualsDeclaration')
          );
        }
        tsIsExternalModuleReference() {
          return this.isContextual(117) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference()
            ? this.tsParseExternalModuleReference()
            : this.tsParseEntityName(!1);
        }
        tsParseExternalModuleReference() {
          let u = this.startNode();
          return (
            this.expectContextual(117),
            this.expect(10),
            this.match(131) || this.unexpected(),
            (u.expression = super.parseExprAtom()),
            this.expect(11),
            (this.sawUnambiguousESM = !0),
            this.finishNode(u, 'TSExternalModuleReference')
          );
        }
        tsLookAhead(u) {
          let N = this.state.clone(),
            _ = u();
          return (this.state = N), _;
        }
        tsTryParseAndCatch(u) {
          let N = this.tryParse((_) => u() || _());
          if (!(N.aborted || !N.node)) return N.error && (this.state = N.failState), N.node;
        }
        tsTryParse(u) {
          let N = this.state.clone(),
            _ = u();
          if (_ !== void 0 && _ !== !1) return _;
          this.state = N;
        }
        tsTryParseDeclare(u) {
          if (this.isLineTerminator()) return;
          let N = this.state.type,
            _;
          return (
            this.isContextual(99) && ((N = 74), (_ = 'let')),
            this.tsInAmbientContext(() => {
              switch (N) {
                case 68:
                  return (u.declare = !0), super.parseFunctionStatement(u, !1, !1);
                case 80:
                  return (u.declare = !0), this.parseClass(u, !0, !1);
                case 124:
                  return this.tsParseEnumDeclaration(u, { declare: !0 });
                case 110:
                  return this.tsParseAmbientExternalModuleDeclaration(u);
                case 75:
                case 74:
                  return !this.match(75) || !this.isLookaheadContextual('enum')
                    ? ((u.declare = !0), this.parseVarStatement(u, _ || this.state.value, !0))
                    : (this.expect(75), this.tsParseEnumDeclaration(u, { const: !0, declare: !0 }));
                case 127: {
                  let Be = this.tsParseInterfaceDeclaration(u, { declare: !0 });
                  if (Be) return Be;
                }
                default:
                  if (Ul(N)) return this.tsParseDeclaration(u, this.state.value, !0, null);
              }
            })
          );
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
        }
        tsParseExpressionStatement(u, N, _) {
          switch (N.name) {
            case 'declare': {
              let Be = this.tsTryParseDeclare(u);
              return Be && (Be.declare = !0), Be;
            }
            case 'global':
              if (this.match(5)) {
                this.scope.enter(256), this.prodParam.enter(gd);
                let Be = u;
                return (
                  (Be.global = !0),
                  (Be.id = N),
                  (Be.body = this.tsParseModuleBlock()),
                  this.scope.exit(),
                  this.prodParam.exit(),
                  this.finishNode(Be, 'TSModuleDeclaration')
                );
              }
              break;
            default:
              return this.tsParseDeclaration(u, N.name, !1, _);
          }
        }
        tsParseDeclaration(u, N, _, Be) {
          switch (N) {
            case 'abstract':
              if (this.tsCheckLineTerminator(_) && (this.match(80) || Ul(this.state.type)))
                return this.tsParseAbstractDeclaration(u, Be);
              break;
            case 'module':
              if (this.tsCheckLineTerminator(_)) {
                if (this.match(131)) return this.tsParseAmbientExternalModuleDeclaration(u);
                if (Ul(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(u);
              }
              break;
            case 'namespace':
              if (this.tsCheckLineTerminator(_) && Ul(this.state.type))
                return this.tsParseModuleOrNamespaceDeclaration(u);
              break;
            case 'type':
              if (this.tsCheckLineTerminator(_) && Ul(this.state.type)) return this.tsParseTypeAliasDeclaration(u);
              break;
          }
        }
        tsCheckLineTerminator(u) {
          return u ? (this.hasFollowingLineBreak() ? !1 : (this.next(), !0)) : !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(u) {
          if (!this.match(47)) return;
          let N = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = !0;
          let _ = this.tsTryParseAndCatch(() => {
            let Be = this.startNodeAt(u);
            return (
              (Be.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier)),
              super.parseFunctionParams(Be),
              (Be.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()),
              this.expect(19),
              Be
            );
          });
          if (((this.state.maybeInArrowParameters = N), !!_)) return super.parseArrowExpression(_, null, !0);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          let u = this.startNode();
          return (
            (u.params = this.tsInType(() =>
              this.tsInNoContext(
                () => (
                  this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this))
                ),
              ),
            )),
            u.params.length === 0
              ? this.raise(sh.EmptyTypeArguments, { at: u })
              : !this.state.inType && this.curContext() === vl.brace && this.reScan_lt_gt(),
            this.expect(48),
            this.finishNode(u, 'TSTypeParameterInstantiation')
          );
        }
        tsIsDeclarationStart() {
          return dh(this.state.type);
        }
        isExportDefaultSpecifier() {
          return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(u, N) {
          let _ = this.state.startLoc,
            Be = {};
          this.tsParseModifiers({ allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'] }, Be);
          let Cn = Be.accessibility,
            Yi = Be.override,
            nl = Be.readonly;
          !(u & 4) && (Cn || nl || Yi) && this.raise(sh.UnexpectedParameterModifier, { at: _ });
          let xl = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(xl, u);
          let Dl = this.parseMaybeDefault(xl.loc.start, xl);
          if (Cn || nl || Yi) {
            let jl = this.startNodeAt(_);
            return (
              N.length && (jl.decorators = N),
              Cn && (jl.accessibility = Cn),
              nl && (jl.readonly = nl),
              Yi && (jl.override = Yi),
              Dl.type !== 'Identifier' &&
                Dl.type !== 'AssignmentPattern' &&
                this.raise(sh.UnsupportedParameterPropertyKind, { at: jl }),
              (jl.parameter = Dl),
              this.finishNode(jl, 'TSParameterProperty')
            );
          }
          return N.length && (xl.decorators = N), Dl;
        }
        isSimpleParameter(u) {
          return (
            (u.type === 'TSParameterProperty' && super.isSimpleParameter(u.parameter)) || super.isSimpleParameter(u)
          );
        }
        tsDisallowOptionalPattern(u) {
          for (let N of u.params)
            N.type !== 'Identifier' &&
              N.optional &&
              !this.state.isAmbientContext &&
              this.raise(sh.PatternIsOptional, { at: N });
        }
        setArrowFunctionParameters(u, N, _) {
          super.setArrowFunctionParameters(u, N, _), this.tsDisallowOptionalPattern(u);
        }
        parseFunctionBodyAndFinish(u, N, _ = !1) {
          this.match(14) && (u.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
          let Be =
            N === 'FunctionDeclaration'
              ? 'TSDeclareFunction'
              : N === 'ClassMethod' || N === 'ClassPrivateMethod'
              ? 'TSDeclareMethod'
              : void 0;
          return Be && !this.match(5) && this.isLineTerminator()
            ? this.finishNode(u, Be)
            : Be === 'TSDeclareFunction' &&
              this.state.isAmbientContext &&
              (this.raise(sh.DeclareFunctionHasImplementation, { at: u }), u.declare)
            ? super.parseFunctionBodyAndFinish(u, Be, _)
            : (this.tsDisallowOptionalPattern(u), super.parseFunctionBodyAndFinish(u, N, _));
        }
        registerFunctionStatementId(u) {
          !u.body && u.id ? this.checkIdentifier(u.id, 1024) : super.registerFunctionStatementId(u);
        }
        tsCheckForInvalidTypeCasts(u) {
          u.forEach((N) => {
            (N == null ? void 0 : N.type) === 'TSTypeCastExpression' &&
              this.raise(sh.UnexpectedTypeAnnotation, { at: N.typeAnnotation });
          });
        }
        toReferencedList(u, N) {
          return this.tsCheckForInvalidTypeCasts(u), u;
        }
        parseArrayLike(u, N, _, Be) {
          let Cn = super.parseArrayLike(u, N, _, Be);
          return Cn.type === 'ArrayExpression' && this.tsCheckForInvalidTypeCasts(Cn.elements), Cn;
        }
        parseSubscript(u, N, _, Be) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            (this.state.canStartJSXElement = !1), this.next();
            let Yi = this.startNodeAt(N);
            return (Yi.expression = u), this.finishNode(Yi, 'TSNonNullExpression');
          }
          let Cn = !1;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (_) return (Be.stop = !0), u;
            (Be.optionalChainMember = Cn = !0), this.next();
          }
          if (this.match(47) || this.match(51)) {
            let Yi,
              nl = this.tsTryParseAndCatch(() => {
                if (!_ && this.atPossibleAsyncArrow(u)) {
                  let Zl = this.tsTryParseGenericAsyncArrowFunction(N);
                  if (Zl) return Zl;
                }
                let xl = this.tsParseTypeArgumentsInExpression();
                if (!xl) return;
                if (Cn && !this.match(10)) {
                  Yi = this.state.curPosition();
                  return;
                }
                if (Sh(this.state.type)) {
                  let Zl = super.parseTaggedTemplateExpression(u, N, Be);
                  return (Zl.typeParameters = xl), Zl;
                }
                if (!_ && this.eat(10)) {
                  let Zl = this.startNodeAt(N);
                  return (
                    (Zl.callee = u),
                    (Zl.arguments = this.parseCallExpressionArguments(11, !1)),
                    this.tsCheckForInvalidTypeCasts(Zl.arguments),
                    (Zl.typeParameters = xl),
                    Be.optionalChainMember && (Zl.optional = Cn),
                    this.finishCallExpression(Zl, Be.optionalChainMember)
                  );
                }
                let Dl = this.state.type;
                if (Dl === 48 || Dl === 52 || (Dl !== 10 && Rl(Dl) && !this.hasPrecedingLineBreak())) return;
                let jl = this.startNodeAt(N);
                return (jl.expression = u), (jl.typeParameters = xl), this.finishNode(jl, 'TSInstantiationExpression');
              });
            if ((Yi && this.unexpected(Yi, 10), nl))
              return (
                nl.type === 'TSInstantiationExpression' &&
                  (this.match(16) || (this.match(18) && this.lookaheadCharCode() !== 40)) &&
                  this.raise(sh.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }),
                nl
              );
          }
          return super.parseSubscript(u, N, _, Be);
        }
        parseNewCallee(u) {
          var N;
          super.parseNewCallee(u);
          let { callee: _ } = u;
          _.type === 'TSInstantiationExpression' &&
            !((N = _.extra) != null && N.parenthesized) &&
            ((u.typeParameters = _.typeParameters), (u.callee = _.expression));
        }
        parseExprOp(u, N, _) {
          let Be;
          if (yh(58) > _ && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (Be = this.isContextual(118)))) {
            let Cn = this.startNodeAt(N);
            return (
              (Cn.expression = u),
              (Cn.typeAnnotation = this.tsInType(
                () => (
                  this.next(),
                  this.match(75)
                    ? (Be && this.raise(Wi.UnexpectedKeyword, { at: this.state.startLoc, keyword: 'const' }),
                      this.tsParseTypeReference())
                    : this.tsParseType()
                ),
              )),
              this.finishNode(Cn, Be ? 'TSSatisfiesExpression' : 'TSAsExpression'),
              this.reScan_lt_gt(),
              this.parseExprOp(Cn, N, _)
            );
          }
          return super.parseExprOp(u, N, _);
        }
        checkReservedWord(u, N, _, Be) {
          this.state.isAmbientContext || super.checkReservedWord(u, N, _, Be);
        }
        checkImportReflection(u) {
          super.checkImportReflection(u),
            u.module &&
              u.importKind !== 'value' &&
              this.raise(sh.ImportReflectionHasImportType, { at: u.specifiers[0].loc.start });
        }
        checkDuplicateExports() {}
        isPotentialImportPhase(u) {
          if (super.isPotentialImportPhase(u)) return !0;
          if (this.isContextual(128)) {
            let N = this.lookaheadCharCode();
            return u ? N === 123 || N === 42 : N !== 61;
          }
          return !u && this.isContextual(87);
        }
        applyImportPhase(u, N, _, Be) {
          super.applyImportPhase(u, N, _, Be),
            N
              ? (u.exportKind = _ === 'type' ? 'type' : 'value')
              : (u.importKind = _ === 'type' || _ === 'typeof' ? _ : 'value');
        }
        parseImport(u) {
          if (this.match(131)) return (u.importKind = 'value'), super.parseImport(u);
          let N;
          if (Ul(this.state.type) && this.lookaheadCharCode() === 61)
            return (u.importKind = 'value'), this.tsParseImportEqualsDeclaration(u);
          if (this.isContextual(128)) {
            let _ = this.parseMaybeImportPhase(u, !1);
            if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(u, _);
            N = super.parseImportSpecifiersAndAfter(u, _);
          } else N = super.parseImport(u);
          return (
            N.importKind === 'type' &&
              N.specifiers.length > 1 &&
              N.specifiers[0].type === 'ImportDefaultSpecifier' &&
              this.raise(sh.TypeImportCannotSpecifyDefaultAndNamed, { at: N }),
            N
          );
        }
        parseExport(u, N) {
          if (this.match(83)) {
            this.next();
            let _ = null;
            return (
              this.isContextual(128) && this.isPotentialImportPhase(!1)
                ? (_ = this.parseMaybeImportPhase(u, !1))
                : (u.importKind = 'value'),
              this.tsParseImportEqualsDeclaration(u, _, !0)
            );
          } else if (this.eat(29)) {
            let _ = u;
            return (
              (_.expression = super.parseExpression()),
              this.semicolon(),
              (this.sawUnambiguousESM = !0),
              this.finishNode(_, 'TSExportAssignment')
            );
          } else if (this.eatContextual(93)) {
            let _ = u;
            return (
              this.expectContextual(126),
              (_.id = this.parseIdentifier()),
              this.semicolon(),
              this.finishNode(_, 'TSNamespaceExportDeclaration')
            );
          } else return super.parseExport(u, N);
        }
        isAbstractClass() {
          return this.isContextual(122) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            let u = this.startNode();
            return this.next(), (u.abstract = !0), this.parseClass(u, !0, !0);
          }
          if (this.match(127)) {
            let u = this.tsParseInterfaceDeclaration(this.startNode());
            if (u) return u;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(u, N, _ = !1) {
          let { isAmbientContext: Be } = this.state,
            Cn = super.parseVarStatement(u, N, _ || Be);
          if (!Be) return Cn;
          for (let { id: Yi, init: nl } of Cn.declarations)
            nl &&
              (N !== 'const' || Yi.typeAnnotation
                ? this.raise(sh.InitializerNotAllowedInAmbientContext, { at: nl })
                : df(nl, this.hasPlugin('estree')) ||
                  this.raise(sh.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: nl }));
          return Cn;
        }
        parseStatementContent(u, N) {
          if (this.match(75) && this.isLookaheadContextual('enum')) {
            let _ = this.startNode();
            return this.expect(75), this.tsParseEnumDeclaration(_, { const: !0 });
          }
          if (this.isContextual(124)) return this.tsParseEnumDeclaration(this.startNode());
          if (this.isContextual(127)) {
            let _ = this.tsParseInterfaceDeclaration(this.startNode());
            if (_) return _;
          }
          return super.parseStatementContent(u, N);
        }
        parseAccessModifier() {
          return this.tsParseModifier(['public', 'protected', 'private']);
        }
        tsHasSomeModifiers(u, N) {
          return N.some((_) => (hf(_) ? u.accessibility === _ : !!u[_]));
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(u, N, _) {
          let Be = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static'];
          this.tsParseModifiers(
            {
              allowedModifiers: Be,
              disallowedModifiers: ['in', 'out'],
              stopOnStartOfClassStaticBlock: !0,
              errorTemplate: sh.InvalidModifierOnTypeParameterPositions,
            },
            N,
          );
          let Cn = () => {
            this.tsIsStartOfStaticBlocks()
              ? (this.next(),
                this.next(),
                this.tsHasSomeModifiers(N, Be) &&
                  this.raise(sh.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }),
                super.parseClassStaticBlock(u, N))
              : this.parseClassMemberWithIsStatic(u, N, _, !!N.static);
          };
          N.declare ? this.tsInAmbientContext(Cn) : Cn();
        }
        parseClassMemberWithIsStatic(u, N, _, Be) {
          let Cn = this.tsTryParseIndexSignature(N);
          if (Cn) {
            u.body.push(Cn),
              N.abstract && this.raise(sh.IndexSignatureHasAbstract, { at: N }),
              N.accessibility && this.raise(sh.IndexSignatureHasAccessibility, { at: N, modifier: N.accessibility }),
              N.declare && this.raise(sh.IndexSignatureHasDeclare, { at: N }),
              N.override && this.raise(sh.IndexSignatureHasOverride, { at: N });
            return;
          }
          !this.state.inAbstractClass && N.abstract && this.raise(sh.NonAbstractClassHasAbstractMethod, { at: N }),
            N.override && (_.hadSuperClass || this.raise(sh.OverrideNotInSubClass, { at: N })),
            super.parseClassMemberWithIsStatic(u, N, _, Be);
        }
        parsePostMemberNameModifiers(u) {
          this.eat(17) && (u.optional = !0),
            u.readonly && this.match(10) && this.raise(sh.ClassMethodHasReadonly, { at: u }),
            u.declare && this.match(10) && this.raise(sh.ClassMethodHasDeclare, { at: u });
        }
        parseExpressionStatement(u, N, _) {
          return (
            (N.type === 'Identifier' ? this.tsParseExpressionStatement(u, N, _) : void 0) ||
            super.parseExpressionStatement(u, N, _)
          );
        }
        shouldParseExportDeclaration() {
          return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
        }
        parseConditional(u, N, _) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(u, N, _);
          let Be = this.tryParse(() => super.parseConditional(u, N));
          return Be.node
            ? (Be.error && (this.state = Be.failState), Be.node)
            : (Be.error && super.setOptionalParametersError(_, Be.error), u);
        }
        parseParenItem(u, N) {
          if (
            ((u = super.parseParenItem(u, N)),
            this.eat(17) && ((u.optional = !0), this.resetEndLocation(u)),
            this.match(14))
          ) {
            let _ = this.startNodeAt(N);
            return (
              (_.expression = u),
              (_.typeAnnotation = this.tsParseTypeAnnotation()),
              this.finishNode(_, 'TSTypeCastExpression')
            );
          }
          return u;
        }
        parseExportDeclaration(u) {
          if (!this.state.isAmbientContext && this.isContextual(123))
            return this.tsInAmbientContext(() => this.parseExportDeclaration(u));
          let N = this.state.startLoc,
            _ = this.eatContextual(123);
          if (_ && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
            throw this.raise(sh.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
          let Be = (Ul(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(u);
          return Be
            ? ((Be.type === 'TSInterfaceDeclaration' || Be.type === 'TSTypeAliasDeclaration' || _) &&
                (u.exportKind = 'type'),
              _ && (this.resetStartLocation(Be, N), (Be.declare = !0)),
              Be)
            : null;
        }
        parseClassId(u, N, _, Be) {
          if ((!N || _) && this.isContextual(111)) return;
          super.parseClassId(u, N, _, u.declare ? 1024 : 8331);
          let Cn = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
          Cn && (u.typeParameters = Cn);
        }
        parseClassPropertyAnnotation(u) {
          u.optional || (this.eat(35) ? (u.definite = !0) : this.eat(17) && (u.optional = !0));
          let N = this.tsTryParseTypeAnnotation();
          N && (u.typeAnnotation = N);
        }
        parseClassProperty(u) {
          if (
            (this.parseClassPropertyAnnotation(u),
            this.state.isAmbientContext &&
              !(u.readonly && !u.typeAnnotation) &&
              this.match(29) &&
              this.raise(sh.DeclareClassFieldHasInitializer, { at: this.state.startLoc }),
            u.abstract && this.match(29))
          ) {
            let { key: N } = u;
            this.raise(sh.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: N.type === 'Identifier' && !u.computed ? N.name : `[${this.input.slice(N.start, N.end)}]`,
            });
          }
          return super.parseClassProperty(u);
        }
        parseClassPrivateProperty(u) {
          return (
            u.abstract && this.raise(sh.PrivateElementHasAbstract, { at: u }),
            u.accessibility && this.raise(sh.PrivateElementHasAccessibility, { at: u, modifier: u.accessibility }),
            this.parseClassPropertyAnnotation(u),
            super.parseClassPrivateProperty(u)
          );
        }
        parseClassAccessorProperty(u) {
          return (
            this.parseClassPropertyAnnotation(u),
            u.optional && this.raise(sh.AccessorCannotBeOptional, { at: u }),
            super.parseClassAccessorProperty(u)
          );
        }
        pushClassMethod(u, N, _, Be, Cn, Yi) {
          let nl = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          nl && Cn && this.raise(sh.ConstructorHasTypeParameters, { at: nl });
          let { declare: xl = !1, kind: Dl } = N;
          xl && (Dl === 'get' || Dl === 'set') && this.raise(sh.DeclareAccessor, { at: N, kind: Dl }),
            nl && (N.typeParameters = nl),
            super.pushClassMethod(u, N, _, Be, Cn, Yi);
        }
        pushClassPrivateMethod(u, N, _, Be) {
          let Cn = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          Cn && (N.typeParameters = Cn), super.pushClassPrivateMethod(u, N, _, Be);
        }
        declareClassPrivateMethodInScope(u, N) {
          u.type !== 'TSDeclareMethod' &&
            ((u.type === 'MethodDefinition' && !u.value.body) || super.declareClassPrivateMethodInScope(u, N));
        }
        parseClassSuper(u) {
          super.parseClassSuper(u),
            u.superClass &&
              (this.match(47) || this.match(51)) &&
              (u.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
            this.eatContextual(111) && (u.implements = this.tsParseHeritageClause('implements'));
        }
        parseObjPropValue(u, N, _, Be, Cn, Yi, nl) {
          let xl = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          return xl && (u.typeParameters = xl), super.parseObjPropValue(u, N, _, Be, Cn, Yi, nl);
        }
        parseFunctionParams(u, N) {
          let _ = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          _ && (u.typeParameters = _), super.parseFunctionParams(u, N);
        }
        parseVarId(u, N) {
          super.parseVarId(u, N),
            u.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(35) && (u.definite = !0);
          let _ = this.tsTryParseTypeAnnotation();
          _ && ((u.id.typeAnnotation = _), this.resetEndLocation(u.id));
        }
        parseAsyncArrowFromCallExpression(u, N) {
          return (
            this.match(14) && (u.returnType = this.tsParseTypeAnnotation()),
            super.parseAsyncArrowFromCallExpression(u, N)
          );
        }
        parseMaybeAssign(u, N) {
          var _, Be, Cn, Yi, nl;
          let xl, Dl, jl;
          if (this.hasPlugin('jsx') && (this.match(140) || this.match(47))) {
            if (((xl = this.state.clone()), (Dl = this.tryParse(() => super.parseMaybeAssign(u, N), xl)), !Dl.error))
              return Dl.node;
            let { context: rh } = this.state,
              Ph = rh[rh.length - 1];
            (Ph === vl.j_oTag || Ph === vl.j_expr) && rh.pop();
          }
          if (!((_ = Dl) != null && _.error) && !this.match(47)) return super.parseMaybeAssign(u, N);
          (!xl || xl === this.state) && (xl = this.state.clone());
          let Zl,
            Zc = this.tryParse((rh) => {
              var Ph, Th;
              Zl = this.tsParseTypeParameters(this.tsParseConstModifier);
              let Oh = super.parseMaybeAssign(u, N);
              return (
                (Oh.type !== 'ArrowFunctionExpression' || ((Ph = Oh.extra) != null && Ph.parenthesized)) && rh(),
                ((Th = Zl) == null ? void 0 : Th.params.length) !== 0 && this.resetStartLocationFromNode(Oh, Zl),
                (Oh.typeParameters = Zl),
                Oh
              );
            }, xl);
          if (!Zc.error && !Zc.aborted) return Zl && this.reportReservedArrowTypeParam(Zl), Zc.node;
          if (
            !Dl &&
            (_f(!this.hasPlugin('jsx')), (jl = this.tryParse(() => super.parseMaybeAssign(u, N), xl)), !jl.error)
          )
            return jl.node;
          if ((Be = Dl) != null && Be.node) return (this.state = Dl.failState), Dl.node;
          if (Zc.node) return (this.state = Zc.failState), Zl && this.reportReservedArrowTypeParam(Zl), Zc.node;
          if ((Cn = jl) != null && Cn.node) return (this.state = jl.failState), jl.node;
          throw ((Yi = Dl) == null ? void 0 : Yi.error) || Zc.error || ((nl = jl) == null ? void 0 : nl.error);
        }
        reportReservedArrowTypeParam(u) {
          var N;
          u.params.length === 1 &&
            !u.params[0].constraint &&
            !((N = u.extra) != null && N.trailingComma) &&
            this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
            this.raise(sh.ReservedArrowTypeParam, { at: u });
        }
        parseMaybeUnary(u, N) {
          return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(u, N);
        }
        parseArrow(u) {
          if (this.match(14)) {
            let N = this.tryParse((_) => {
              let Be = this.tsParseTypeOrTypePredicateAnnotation(14);
              return (this.canInsertSemicolon() || !this.match(19)) && _(), Be;
            });
            if (N.aborted) return;
            N.thrown || (N.error && (this.state = N.failState), (u.returnType = N.node));
          }
          return super.parseArrow(u);
        }
        parseAssignableListItemTypes(u, N) {
          if (!(N & 2)) return u;
          this.eat(17) && (u.optional = !0);
          let _ = this.tsTryParseTypeAnnotation();
          return _ && (u.typeAnnotation = _), this.resetEndLocation(u), u;
        }
        isAssignable(u, N) {
          switch (u.type) {
            case 'TSTypeCastExpression':
              return this.isAssignable(u.expression, N);
            case 'TSParameterProperty':
              return !0;
            default:
              return super.isAssignable(u, N);
          }
        }
        toAssignable(u, N = !1) {
          switch (u.type) {
            case 'ParenthesizedExpression':
              this.toAssignableParenthesizedExpression(u, N);
              break;
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
              N
                ? this.expressionScope.recordArrowParameterBindingError(sh.UnexpectedTypeCastInParameter, { at: u })
                : this.raise(sh.UnexpectedTypeCastInParameter, { at: u }),
                this.toAssignable(u.expression, N);
              break;
            case 'AssignmentExpression':
              !N && u.left.type === 'TSTypeCastExpression' && (u.left = this.typeCastToParameter(u.left));
            default:
              super.toAssignable(u, N);
          }
        }
        toAssignableParenthesizedExpression(u, N) {
          switch (u.expression.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
            case 'ParenthesizedExpression':
              this.toAssignable(u.expression, N);
              break;
            default:
              super.toAssignable(u, N);
          }
        }
        checkToRestConversion(u, N) {
          switch (u.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSTypeAssertion':
            case 'TSNonNullExpression':
              this.checkToRestConversion(u.expression, !1);
              break;
            default:
              super.checkToRestConversion(u, N);
          }
        }
        isValidLVal(u, N, _) {
          return (
            Rf(
              {
                TSTypeCastExpression: !0,
                TSParameterProperty: 'parameter',
                TSNonNullExpression: 'expression',
                TSAsExpression: (_ !== 64 || !N) && ['expression', !0],
                TSSatisfiesExpression: (_ !== 64 || !N) && ['expression', !0],
                TSTypeAssertion: (_ !== 64 || !N) && ['expression', !0],
              },
              u,
            ) || super.isValidLVal(u, N, _)
          );
        }
        parseBindingAtom() {
          return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
        }
        parseMaybeDecoratorArguments(u) {
          if (this.match(47) || this.match(51)) {
            let N = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              let _ = super.parseMaybeDecoratorArguments(u);
              return (_.typeParameters = N), _;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(u);
        }
        checkCommaAfterRest(u) {
          return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === u
            ? (this.next(), !1)
            : super.checkCommaAfterRest(u);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(u, N) {
          let _ = super.parseMaybeDefault(u, N);
          return (
            _.type === 'AssignmentPattern' &&
              _.typeAnnotation &&
              _.right.start < _.typeAnnotation.start &&
              this.raise(sh.TypeAnnotationAfterAssign, { at: _.typeAnnotation }),
            _
          );
        }
        getTokenFromCode(u) {
          if (this.state.inType) {
            if (u === 62) {
              this.finishOp(48, 1);
              return;
            }
            if (u === 60) {
              this.finishOp(47, 1);
              return;
            }
          }
          super.getTokenFromCode(u);
        }
        reScan_lt_gt() {
          let { type: u } = this.state;
          u === 47
            ? ((this.state.pos -= 1), this.readToken_lt())
            : u === 48 && ((this.state.pos -= 1), this.readToken_gt());
        }
        reScan_lt() {
          let { type: u } = this.state;
          return u === 51 ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : u;
        }
        toAssignableList(u, N, _) {
          for (let Be = 0; Be < u.length; Be++) {
            let Cn = u[Be];
            (Cn == null ? void 0 : Cn.type) === 'TSTypeCastExpression' && (u[Be] = this.typeCastToParameter(Cn));
          }
          super.toAssignableList(u, N, _);
        }
        typeCastToParameter(u) {
          return (
            (u.expression.typeAnnotation = u.typeAnnotation),
            this.resetEndLocation(u.expression, u.typeAnnotation.loc.end),
            u.expression
          );
        }
        shouldParseArrow(u) {
          return this.match(14) ? u.every((N) => this.isAssignable(N, !0)) : super.shouldParseArrow(u);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(u) {
          if (this.match(47) || this.match(51)) {
            let N = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            N && (u.typeParameters = N);
          }
          return super.jsxParseOpeningElementAfterName(u);
        }
        getGetterSetterExpectedParamCount(u) {
          let N = super.getGetterSetterExpectedParamCount(u),
            _ = this.getObjectOrClassMethodParams(u)[0];
          return _ && this.isThisParam(_) ? N + 1 : N;
        }
        parseCatchClauseParam() {
          let u = super.parseCatchClauseParam(),
            N = this.tsTryParseTypeAnnotation();
          return N && ((u.typeAnnotation = N), this.resetEndLocation(u)), u;
        }
        tsInAmbientContext(u) {
          let N = this.state.isAmbientContext;
          this.state.isAmbientContext = !0;
          try {
            return u();
          } finally {
            this.state.isAmbientContext = N;
          }
        }
        parseClass(u, N, _) {
          let Be = this.state.inAbstractClass;
          this.state.inAbstractClass = !!u.abstract;
          try {
            return super.parseClass(u, N, _);
          } finally {
            this.state.inAbstractClass = Be;
          }
        }
        tsParseAbstractDeclaration(u, N) {
          if (this.match(80)) return (u.abstract = !0), this.maybeTakeDecorators(N, this.parseClass(u, !0, !1));
          if (this.isContextual(127)) {
            if (!this.hasFollowingLineBreak())
              return (
                (u.abstract = !0),
                this.raise(sh.NonClassMethodPropertyHasAbstractModifer, { at: u }),
                this.tsParseInterfaceDeclaration(u)
              );
          } else this.unexpected(null, 80);
        }
        parseMethod(u, N, _, Be, Cn, Yi, nl) {
          let xl = super.parseMethod(u, N, _, Be, Cn, Yi, nl);
          if (xl.abstract && (this.hasPlugin('estree') ? xl.value.body : xl.body)) {
            let { key: Dl } = xl;
            this.raise(sh.AbstractMethodHasImplementation, {
              at: xl,
              methodName:
                Dl.type === 'Identifier' && !xl.computed ? Dl.name : `[${this.input.slice(Dl.start, Dl.end)}]`,
            });
          }
          return xl;
        }
        tsParseTypeParameterName() {
          return this.parseIdentifier().name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption('typescript', 'dts');
        }
        parse() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
        }
        getExpression() {
          return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
        }
        parseExportSpecifier(u, N, _, Be) {
          return !N && Be
            ? (this.parseTypeOnlyImportExportSpecifier(u, !1, _), this.finishNode(u, 'ExportSpecifier'))
            : ((u.exportKind = 'value'), super.parseExportSpecifier(u, N, _, Be));
        }
        parseImportSpecifier(u, N, _, Be, Cn) {
          return !N && Be
            ? (this.parseTypeOnlyImportExportSpecifier(u, !0, _), this.finishNode(u, 'ImportSpecifier'))
            : ((u.importKind = 'value'), super.parseImportSpecifier(u, N, _, Be, _ ? 4098 : 4096));
        }
        parseTypeOnlyImportExportSpecifier(u, N, _) {
          let Be = N ? 'imported' : 'local',
            Cn = N ? 'local' : 'exported',
            Yi = u[Be],
            nl,
            xl = !1,
            Dl = !0,
            jl = Yi.loc.start;
          if (this.isContextual(93)) {
            let Zc = this.parseIdentifier();
            if (this.isContextual(93)) {
              let rh = this.parseIdentifier();
              gl(this.state.type)
                ? ((xl = !0), (Yi = Zc), (nl = N ? this.parseIdentifier() : this.parseModuleExportName()), (Dl = !1))
                : ((nl = rh), (Dl = !1));
            } else
              gl(this.state.type)
                ? ((Dl = !1), (nl = N ? this.parseIdentifier() : this.parseModuleExportName()))
                : ((xl = !0), (Yi = Zc));
          } else
            gl(this.state.type) &&
              ((xl = !0),
              N
                ? ((Yi = this.parseIdentifier(!0)),
                  this.isContextual(93) || this.checkReservedWord(Yi.name, Yi.loc.start, !0, !0))
                : (Yi = this.parseModuleExportName()));
          xl &&
            _ &&
            this.raise(N ? sh.TypeModifierIsUsedInTypeImports : sh.TypeModifierIsUsedInTypeExports, { at: jl }),
            (u[Be] = Yi),
            (u[Cn] = nl);
          let Zl = N ? 'importKind' : 'exportKind';
          (u[Zl] = xl ? 'type' : 'value'),
            Dl && this.eatContextual(93) && (u[Cn] = N ? this.parseIdentifier() : this.parseModuleExportName()),
            u[Cn] || (u[Cn] = ed(u[Be])),
            N && this.checkIdentifier(u[Cn], xl ? 4098 : 4096);
        }
      };
    function Vf(g) {
      if (g.type !== 'MemberExpression') return !1;
      let { computed: u, property: N } = g;
      return u && N.type !== 'StringLiteral' && (N.type !== 'TemplateLiteral' || N.expressions.length > 0)
        ? !1
        : ff(g.object);
    }
    function df(g, u) {
      var N;
      let { type: _ } = g;
      if ((N = g.extra) != null && N.parenthesized) return !1;
      if (u) {
        if (_ === 'Literal') {
          let { value: Be } = g;
          if (typeof Be == 'string' || typeof Be == 'boolean') return !0;
        }
      } else if (_ === 'StringLiteral' || _ === 'BooleanLiteral') return !0;
      return !!(zd(g, u) || Hf(g, u) || (_ === 'TemplateLiteral' && g.expressions.length === 0) || Vf(g));
    }
    function zd(g, u) {
      return u
        ? g.type === 'Literal' && (typeof g.value == 'number' || 'bigint' in g)
        : g.type === 'NumericLiteral' || g.type === 'BigIntLiteral';
    }
    function Hf(g, u) {
      if (g.type === 'UnaryExpression') {
        let { operator: N, argument: _ } = g;
        if (N === '-' && zd(_, u)) return !0;
      }
      return !1;
    }
    function ff(g) {
      return g.type === 'Identifier' ? !0 : g.type !== 'MemberExpression' || g.computed ? !1 : ff(g.object);
    }
    var zf = tl`placeholders`({
        ClassNameIsRequired: 'A class name is required.',
        UnexpectedSpace: 'Unexpected space in placeholder.',
      }),
      g0 = (g) =>
        class extends g {
          parsePlaceholder(u) {
            if (this.match(142)) {
              let N = this.startNode();
              return (
                this.next(),
                this.assertNoSpace(),
                (N.name = super.parseIdentifier(!0)),
                this.assertNoSpace(),
                this.expect(142),
                this.finishPlaceholder(N, u)
              );
            }
          }
          finishPlaceholder(u, N) {
            let _ = !!(u.expectedNode && u.type === 'Placeholder');
            return (u.expectedNode = N), _ ? u : this.finishNode(u, 'Placeholder');
          }
          getTokenFromCode(u) {
            u === 37 && this.input.charCodeAt(this.state.pos + 1) === 37
              ? this.finishOp(142, 2)
              : super.getTokenFromCode(u);
          }
          parseExprAtom(u) {
            return this.parsePlaceholder('Expression') || super.parseExprAtom(u);
          }
          parseIdentifier(u) {
            return this.parsePlaceholder('Identifier') || super.parseIdentifier(u);
          }
          checkReservedWord(u, N, _, Be) {
            u !== void 0 && super.checkReservedWord(u, N, _, Be);
          }
          parseBindingAtom() {
            return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
          }
          isValidLVal(u, N, _) {
            return u === 'Placeholder' || super.isValidLVal(u, N, _);
          }
          toAssignable(u, N) {
            u && u.type === 'Placeholder' && u.expectedNode === 'Expression'
              ? (u.expectedNode = 'Pattern')
              : super.toAssignable(u, N);
          }
          chStartsBindingIdentifier(u, N) {
            return !!(super.chStartsBindingIdentifier(u, N) || this.lookahead().type === 142);
          }
          verifyBreakContinue(u, N) {
            (u.label && u.label.type === 'Placeholder') || super.verifyBreakContinue(u, N);
          }
          parseExpressionStatement(u, N) {
            var _;
            if (N.type !== 'Placeholder' || ((_ = N.extra) != null && _.parenthesized))
              return super.parseExpressionStatement(u, N);
            if (this.match(14)) {
              let Be = u;
              return (
                (Be.label = this.finishPlaceholder(N, 'Identifier')),
                this.next(),
                (Be.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration()),
                this.finishNode(Be, 'LabeledStatement')
              );
            }
            return this.semicolon(), (u.name = N.name), this.finishPlaceholder(u, 'Statement');
          }
          parseBlock(u, N, _) {
            return this.parsePlaceholder('BlockStatement') || super.parseBlock(u, N, _);
          }
          parseFunctionId(u) {
            return this.parsePlaceholder('Identifier') || super.parseFunctionId(u);
          }
          parseClass(u, N, _) {
            let Be = N ? 'ClassDeclaration' : 'ClassExpression';
            this.next();
            let Cn = this.state.strict,
              Yi = this.parsePlaceholder('Identifier');
            if (Yi)
              if (this.match(81) || this.match(142) || this.match(5)) u.id = Yi;
              else {
                if (_ || !N)
                  return (u.id = null), (u.body = this.finishPlaceholder(Yi, 'ClassBody')), this.finishNode(u, Be);
                throw this.raise(zf.ClassNameIsRequired, { at: this.state.startLoc });
              }
            else this.parseClassId(u, N, _);
            return (
              super.parseClassSuper(u),
              (u.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!u.superClass, Cn)),
              this.finishNode(u, Be)
            );
          }
          parseExport(u, N) {
            let _ = this.parsePlaceholder('Identifier');
            if (!_) return super.parseExport(u, N);
            if (!this.isContextual(97) && !this.match(12))
              return (
                (u.specifiers = []),
                (u.source = null),
                (u.declaration = this.finishPlaceholder(_, 'Declaration')),
                this.finishNode(u, 'ExportNamedDeclaration')
              );
            this.expectPlugin('exportDefaultFrom');
            let Be = this.startNode();
            return (
              (Be.exported = _),
              (u.specifiers = [this.finishNode(Be, 'ExportDefaultSpecifier')]),
              super.parseExport(u, N)
            );
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let u = this.nextTokenStart();
              if (
                this.isUnparsedContextual(u, 'from') &&
                this.input.startsWith(mh(142), this.nextTokenStartSince(u + 4))
              )
                return !0;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(u, N) {
            var _;
            return (_ = u.specifiers) != null && _.length ? !0 : super.maybeParseExportDefaultSpecifier(u, N);
          }
          checkExport(u) {
            let { specifiers: N } = u;
            N != null && N.length && (u.specifiers = N.filter((_) => _.exported.type === 'Placeholder')),
              super.checkExport(u),
              (u.specifiers = N);
          }
          parseImport(u) {
            let N = this.parsePlaceholder('Identifier');
            if (!N) return super.parseImport(u);
            if (((u.specifiers = []), !this.isContextual(97) && !this.match(12)))
              return (
                (u.source = this.finishPlaceholder(N, 'StringLiteral')),
                this.semicolon(),
                this.finishNode(u, 'ImportDeclaration')
              );
            let _ = this.startNodeAtNode(N);
            return (
              (_.local = N),
              u.specifiers.push(this.finishNode(_, 'ImportDefaultSpecifier')),
              this.eat(12) && (this.maybeParseStarImportSpecifier(u) || this.parseNamedImportSpecifiers(u)),
              this.expectContextual(97),
              (u.source = this.parseImportSource()),
              this.semicolon(),
              this.finishNode(u, 'ImportDeclaration')
            );
          }
          parseImportSource() {
            return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index &&
              this.raise(zf.UnexpectedSpace, { at: this.state.lastTokEndLoc });
          }
        },
      Wf = (g) =>
        class extends g {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let u = this.state.startLoc,
                N = this.startNode();
              if ((this.next(), Ul(this.state.type))) {
                let _ = this.parseIdentifierName(),
                  Be = this.createIdentifier(N, _);
                if (((Be.type = 'V8IntrinsicIdentifier'), this.match(10))) return Be;
              }
              this.unexpected(u);
            }
          }
          parseExprAtom(u) {
            return this.parseV8Intrinsic() || super.parseExprAtom(u);
          }
        };
    function Mh(g, u) {
      let [N, _] = typeof u == 'string' ? [u, {}] : u,
        Be = Object.keys(_),
        Cn = Be.length === 0;
      return g.some((Yi) => {
        if (typeof Yi == 'string') return Cn && Yi === N;
        {
          let [nl, xl] = Yi;
          if (nl !== N) return !1;
          for (let Dl of Be) if (xl[Dl] !== _[Dl]) return !1;
          return !0;
        }
      });
    }
    function hd(g, u, N) {
      let _ = g.find((Be) => (Array.isArray(Be) ? Be[0] === u : Be === u));
      return _ && Array.isArray(_) && _.length > 1 ? _[1][N] : null;
    }
    var mf = ['minimal', 'fsharp', 'hack', 'smart'],
      Uf = ['^^', '@@', '^', '%', '#'],
      qf = ['hash', 'bar'];
    function Kf(g) {
      if (Mh(g, 'decorators')) {
        if (Mh(g, 'decorators-legacy'))
          throw new Error('Cannot use the decorators and decorators-legacy plugin together');
        let u = hd(g, 'decorators', 'decoratorsBeforeExport');
        if (u != null && typeof u != 'boolean')
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        let N = hd(g, 'decorators', 'allowCallParenthesized');
        if (N != null && typeof N != 'boolean') throw new Error("'allowCallParenthesized' must be a boolean.");
      }
      if (Mh(g, 'flow') && Mh(g, 'typescript')) throw new Error('Cannot combine flow and typescript plugins.');
      if (Mh(g, 'placeholders') && Mh(g, 'v8intrinsic'))
        throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
      if (Mh(g, 'pipelineOperator')) {
        let u = hd(g, 'pipelineOperator', 'proposal');
        if (!mf.includes(u)) {
          let _ = mf.map((Be) => `"${Be}"`).join(', ');
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${_}.`);
        }
        let N = Mh(g, ['recordAndTuple', { syntaxType: 'hash' }]);
        if (u === 'hack') {
          if (Mh(g, 'placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
          if (Mh(g, 'v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
          let _ = hd(g, 'pipelineOperator', 'topicToken');
          if (!Uf.includes(_)) {
            let Be = Uf.map((Cn) => `"${Cn}"`).join(', ');
            throw new Error(
              `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${Be}.`,
            );
          }
          if (_ === '#' && N)
            throw new Error(
              'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.',
            );
        } else if (u === 'smart' && N)
          throw new Error(
            'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.',
          );
      }
      if (Mh(g, 'moduleAttributes')) {
        if (Mh(g, 'importAssertions') || Mh(g, 'importAttributes'))
          throw new Error('Cannot combine importAssertions, importAttributes and moduleAttributes plugins.');
        if (hd(g, 'moduleAttributes', 'version') !== 'may-2020')
          throw new Error(
            "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.",
          );
      }
      if (Mh(g, 'importAssertions') && Mh(g, 'importAttributes'))
        throw new Error('Cannot combine importAssertions and importAttributes plugins.');
      if (
        Mh(g, 'recordAndTuple') &&
        hd(g, 'recordAndTuple', 'syntaxType') != null &&
        !qf.includes(hd(g, 'recordAndTuple', 'syntaxType'))
      )
        throw new Error(
          "The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " +
            qf.map((u) => `'${u}'`).join(', '),
        );
      if (Mh(g, 'asyncDoExpressions') && !Mh(g, 'doExpressions')) {
        let u = new Error(
          "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.",
        );
        throw ((u.missingPlugins = 'doExpressions'), u);
      }
    }
    var Wd = { estree: Al, jsx: h0, flow: c0, typescript: jf, v8intrinsic: Wf, placeholders: g0 },
      y0 = Object.keys(Wd),
      Ud = {
        sourceType: 'script',
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowNewTargetOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        plugins: [],
        strictMode: null,
        ranges: !1,
        tokens: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1,
        attachComment: !0,
        annexB: !0,
      };
    function D0(g) {
      if (g == null) return Object.assign({}, Ud);
      if (g.annexB != null && g.annexB !== !1) throw new Error('The `annexB` option can only be set to `false`.');
      let u = {};
      for (let _ of Object.keys(Ud)) {
        var N;
        u[_] = (N = g[_]) != null ? N : Ud[_];
      }
      return u;
    }
    var x0 = class extends d0 {
        checkProto(g, u, N, _) {
          if (g.type === 'SpreadElement' || this.isObjectMethod(g) || g.computed || g.shorthand) return;
          let Be = g.key;
          if ((Be.type === 'Identifier' ? Be.name : Be.value) === '__proto__') {
            if (u) {
              this.raise(Wi.RecordNoProto, { at: Be });
              return;
            }
            N.used &&
              (_
                ? _.doubleProtoLoc === null && (_.doubleProtoLoc = Be.loc.start)
                : this.raise(Wi.DuplicateProto, { at: Be })),
              (N.used = !0);
          }
        }
        shouldExitDescending(g, u) {
          return g.type === 'ArrowFunctionExpression' && g.start === u;
        }
        getExpression() {
          this.enterInitialScopes(), this.nextToken();
          let g = this.parseExpression();
          return (
            this.match(137) || this.unexpected(),
            this.finalizeRemainingComments(),
            (g.comments = this.state.comments),
            (g.errors = this.state.errors),
            this.options.tokens && (g.tokens = this.tokens),
            g
          );
        }
        parseExpression(g, u) {
          return g
            ? this.disallowInAnd(() => this.parseExpressionBase(u))
            : this.allowInAnd(() => this.parseExpressionBase(u));
        }
        parseExpressionBase(g) {
          let u = this.state.startLoc,
            N = this.parseMaybeAssign(g);
          if (this.match(12)) {
            let _ = this.startNodeAt(u);
            for (_.expressions = [N]; this.eat(12); ) _.expressions.push(this.parseMaybeAssign(g));
            return this.toReferencedList(_.expressions), this.finishNode(_, 'SequenceExpression');
          }
          return N;
        }
        parseMaybeAssignDisallowIn(g, u) {
          return this.disallowInAnd(() => this.parseMaybeAssign(g, u));
        }
        parseMaybeAssignAllowIn(g, u) {
          return this.allowInAnd(() => this.parseMaybeAssign(g, u));
        }
        setOptionalParametersError(g, u) {
          var N;
          g.optionalParametersLoc = (N = u == null ? void 0 : u.loc) != null ? N : this.state.startLoc;
        }
        parseMaybeAssign(g, u) {
          let N = this.state.startLoc;
          if (this.isContextual(106) && this.prodParam.hasYield) {
            let Yi = this.parseYield();
            return u && (Yi = u.call(this, Yi, N)), Yi;
          }
          let _;
          g ? (_ = !1) : ((g = new Zh()), (_ = !0));
          let { type: Be } = this.state;
          (Be === 10 || Ul(Be)) && (this.state.potentialArrowAt = this.state.start);
          let Cn = this.parseMaybeConditional(g);
          if ((u && (Cn = u.call(this, Cn, N)), Wl(this.state.type))) {
            let Yi = this.startNodeAt(N),
              nl = this.state.value;
            if (((Yi.operator = nl), this.match(29))) {
              this.toAssignable(Cn, !0), (Yi.left = Cn);
              let xl = N.index;
              g.doubleProtoLoc != null && g.doubleProtoLoc.index >= xl && (g.doubleProtoLoc = null),
                g.shorthandAssignLoc != null && g.shorthandAssignLoc.index >= xl && (g.shorthandAssignLoc = null),
                g.privateKeyLoc != null &&
                  g.privateKeyLoc.index >= xl &&
                  (this.checkDestructuringPrivate(g), (g.privateKeyLoc = null));
            } else Yi.left = Cn;
            return (
              this.next(),
              (Yi.right = this.parseMaybeAssign()),
              this.checkLVal(Cn, { in: this.finishNode(Yi, 'AssignmentExpression') }),
              Yi
            );
          } else _ && this.checkExpressionErrors(g, !0);
          return Cn;
        }
        parseMaybeConditional(g) {
          let u = this.state.startLoc,
            N = this.state.potentialArrowAt,
            _ = this.parseExprOps(g);
          return this.shouldExitDescending(_, N) ? _ : this.parseConditional(_, u, g);
        }
        parseConditional(g, u, N) {
          if (this.eat(17)) {
            let _ = this.startNodeAt(u);
            return (
              (_.test = g),
              (_.consequent = this.parseMaybeAssignAllowIn()),
              this.expect(14),
              (_.alternate = this.parseMaybeAssign()),
              this.finishNode(_, 'ConditionalExpression')
            );
          }
          return g;
        }
        parseMaybeUnaryOrPrivate(g) {
          return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(g);
        }
        parseExprOps(g) {
          let u = this.state.startLoc,
            N = this.state.potentialArrowAt,
            _ = this.parseMaybeUnaryOrPrivate(g);
          return this.shouldExitDescending(_, N) ? _ : this.parseExprOp(_, u, -1);
        }
        parseExprOp(g, u, N) {
          if (this.isPrivateName(g)) {
            let Be = this.getPrivateNameSV(g);
            (N >= yh(58) || !this.prodParam.hasIn || !this.match(58)) &&
              this.raise(Wi.PrivateInExpectedIn, { at: g, identifierName: Be }),
              this.classScope.usePrivateName(Be, g.loc.start);
          }
          let _ = this.state.type;
          if (Qc(_) && (this.prodParam.hasIn || !this.match(58))) {
            let Be = yh(_);
            if (Be > N) {
              if (_ === 39) {
                if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return g;
                this.checkPipelineAtInfixOperator(g, u);
              }
              let Cn = this.startNodeAt(u);
              (Cn.left = g), (Cn.operator = this.state.value);
              let Yi = _ === 41 || _ === 42,
                nl = _ === 40;
              if (
                (nl && (Be = yh(42)),
                this.next(),
                _ === 39 &&
                  this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }]) &&
                  this.state.type === 96 &&
                  this.prodParam.hasAwait)
              )
                throw this.raise(Wi.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
              Cn.right = this.parseExprOpRightExpr(_, Be);
              let xl = this.finishNode(Cn, Yi || nl ? 'LogicalExpression' : 'BinaryExpression'),
                Dl = this.state.type;
              if ((nl && (Dl === 41 || Dl === 42)) || (Yi && Dl === 40))
                throw this.raise(Wi.MixingCoalesceWithLogical, { at: this.state.startLoc });
              return this.parseExprOp(xl, u, N);
            }
          }
          return g;
        }
        parseExprOpRightExpr(g, u) {
          let N = this.state.startLoc;
          switch (g) {
            case 39:
              switch (this.getPluginOption('pipelineOperator', 'proposal')) {
                case 'hack':
                  return this.withTopicBindingContext(() => this.parseHackPipeBody());
                case 'smart':
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(106))
                      throw this.raise(Wi.PipeBodyIsTighter, { at: this.state.startLoc });
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(g, u), N);
                  });
                case 'fsharp':
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(u));
              }
            default:
              return this.parseExprOpBaseRightExpr(g, u);
          }
        }
        parseExprOpBaseRightExpr(g, u) {
          let N = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), N, kh(g) ? u - 1 : u);
        }
        parseHackPipeBody() {
          var g;
          let { startLoc: u } = this.state,
            N = this.parseMaybeAssign();
          return (
            se.has(N.type) &&
              !((g = N.extra) != null && g.parenthesized) &&
              this.raise(Wi.PipeUnparenthesizedBody, { at: u, type: N.type }),
            this.topicReferenceWasUsedInCurrentContext() || this.raise(Wi.PipeTopicUnused, { at: u }),
            N
          );
        }
        checkExponentialAfterUnary(g) {
          this.match(57) && this.raise(Wi.UnexpectedTokenUnaryExponentiation, { at: g.argument });
        }
        parseMaybeUnary(g, u) {
          let N = this.state.startLoc,
            _ = this.isContextual(96);
          if (_ && this.isAwaitAllowed()) {
            this.next();
            let nl = this.parseAwait(N);
            return u || this.checkExponentialAfterUnary(nl), nl;
          }
          let Be = this.match(34),
            Cn = this.startNode();
          if (ch(this.state.type)) {
            (Cn.operator = this.state.value), (Cn.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions');
            let nl = this.match(89);
            if (
              (this.next(),
              (Cn.argument = this.parseMaybeUnary(null, !0)),
              this.checkExpressionErrors(g, !0),
              this.state.strict && nl)
            ) {
              let xl = Cn.argument;
              xl.type === 'Identifier'
                ? this.raise(Wi.StrictDelete, { at: Cn })
                : this.hasPropertyAsPrivateName(xl) && this.raise(Wi.DeletePrivateField, { at: Cn });
            }
            if (!Be) return u || this.checkExponentialAfterUnary(Cn), this.finishNode(Cn, 'UnaryExpression');
          }
          let Yi = this.parseUpdate(Cn, Be, g);
          if (_) {
            let { type: nl } = this.state;
            if ((this.hasPlugin('v8intrinsic') ? Rl(nl) : Rl(nl) && !this.match(54)) && !this.isAmbiguousAwait())
              return this.raiseOverwrite(Wi.AwaitNotInAsyncContext, { at: N }), this.parseAwait(N);
          }
          return Yi;
        }
        parseUpdate(g, u, N) {
          if (u) {
            let Cn = g;
            return this.checkLVal(Cn.argument, { in: this.finishNode(Cn, 'UpdateExpression') }), g;
          }
          let _ = this.state.startLoc,
            Be = this.parseExprSubscripts(N);
          if (this.checkExpressionErrors(N, !1)) return Be;
          for (; Gl(this.state.type) && !this.canInsertSemicolon(); ) {
            let Cn = this.startNodeAt(_);
            (Cn.operator = this.state.value),
              (Cn.prefix = !1),
              (Cn.argument = Be),
              this.next(),
              this.checkLVal(Be, { in: (Be = this.finishNode(Cn, 'UpdateExpression')) });
          }
          return Be;
        }
        parseExprSubscripts(g) {
          let u = this.state.startLoc,
            N = this.state.potentialArrowAt,
            _ = this.parseExprAtom(g);
          return this.shouldExitDescending(_, N) ? _ : this.parseSubscripts(_, u);
        }
        parseSubscripts(g, u, N) {
          let _ = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(g), stop: !1 };
          do (g = this.parseSubscript(g, u, N, _)), (_.maybeAsyncArrow = !1);
          while (!_.stop);
          return g;
        }
        parseSubscript(g, u, N, _) {
          let { type: Be } = this.state;
          if (!N && Be === 15) return this.parseBind(g, u, N, _);
          if (Sh(Be)) return this.parseTaggedTemplateExpression(g, u, _);
          let Cn = !1;
          if (Be === 18) {
            if (
              N &&
              (this.raise(Wi.OptionalChainingNoNew, { at: this.state.startLoc }), this.lookaheadCharCode() === 40)
            )
              return (_.stop = !0), g;
            (_.optionalChainMember = Cn = !0), this.next();
          }
          if (!N && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(g, u, _, Cn);
          {
            let Yi = this.eat(0);
            return Yi || Cn || this.eat(16) ? this.parseMember(g, u, _, Yi, Cn) : ((_.stop = !0), g);
          }
        }
        parseMember(g, u, N, _, Be) {
          let Cn = this.startNodeAt(u);
          return (
            (Cn.object = g),
            (Cn.computed = _),
            _
              ? ((Cn.property = this.parseExpression()), this.expect(3))
              : this.match(136)
              ? (g.type === 'Super' && this.raise(Wi.SuperPrivateField, { at: u }),
                this.classScope.usePrivateName(this.state.value, this.state.startLoc),
                (Cn.property = this.parsePrivateName()))
              : (Cn.property = this.parseIdentifier(!0)),
            N.optionalChainMember
              ? ((Cn.optional = Be), this.finishNode(Cn, 'OptionalMemberExpression'))
              : this.finishNode(Cn, 'MemberExpression')
          );
        }
        parseBind(g, u, N, _) {
          let Be = this.startNodeAt(u);
          return (
            (Be.object = g),
            this.next(),
            (Be.callee = this.parseNoCallExpr()),
            (_.stop = !0),
            this.parseSubscripts(this.finishNode(Be, 'BindExpression'), u, N)
          );
        }
        parseCoverCallAndAsyncArrowHead(g, u, N, _) {
          let Be = this.state.maybeInArrowParameters,
            Cn = null;
          (this.state.maybeInArrowParameters = !0), this.next();
          let Yi = this.startNodeAt(u);
          Yi.callee = g;
          let { maybeAsyncArrow: nl, optionalChainMember: xl } = N;
          nl && (this.expressionScope.enter(a0()), (Cn = new Zh())),
            xl && (Yi.optional = _),
            _
              ? (Yi.arguments = this.parseCallExpressionArguments(11))
              : (Yi.arguments = this.parseCallExpressionArguments(11, g.type === 'Import', g.type !== 'Super', Yi, Cn));
          let Dl = this.finishCallExpression(Yi, xl);
          return (
            nl && this.shouldParseAsyncArrow() && !_
              ? ((N.stop = !0),
                this.checkDestructuringPrivate(Cn),
                this.expressionScope.validateAsPattern(),
                this.expressionScope.exit(),
                (Dl = this.parseAsyncArrowFromCallExpression(this.startNodeAt(u), Dl)))
              : (nl && (this.checkExpressionErrors(Cn, !0), this.expressionScope.exit()),
                this.toReferencedArguments(Dl)),
            (this.state.maybeInArrowParameters = Be),
            Dl
          );
        }
        toReferencedArguments(g, u) {
          this.toReferencedListDeep(g.arguments, u);
        }
        parseTaggedTemplateExpression(g, u, N) {
          let _ = this.startNodeAt(u);
          return (
            (_.tag = g),
            (_.quasi = this.parseTemplate(!0)),
            N.optionalChainMember && this.raise(Wi.OptionalChainingNoTemplate, { at: u }),
            this.finishNode(_, 'TaggedTemplateExpression')
          );
        }
        atPossibleAsyncArrow(g) {
          return (
            g.type === 'Identifier' &&
            g.name === 'async' &&
            this.state.lastTokEndLoc.index === g.end &&
            !this.canInsertSemicolon() &&
            g.end - g.start === 5 &&
            g.start === this.state.potentialArrowAt
          );
        }
        expectImportAttributesPlugin() {
          this.hasPlugin('importAssertions') || this.expectPlugin('importAttributes');
        }
        finishCallExpression(g, u) {
          if (g.callee.type === 'Import')
            if (
              (g.arguments.length === 2 && (this.hasPlugin('moduleAttributes') || this.expectImportAttributesPlugin()),
              g.arguments.length === 0 || g.arguments.length > 2)
            )
              this.raise(Wi.ImportCallArity, {
                at: g,
                maxArgumentCount:
                  this.hasPlugin('importAttributes') ||
                  this.hasPlugin('importAssertions') ||
                  this.hasPlugin('moduleAttributes')
                    ? 2
                    : 1,
              });
            else
              for (let N of g.arguments)
                N.type === 'SpreadElement' && this.raise(Wi.ImportCallSpreadArgument, { at: N });
          return this.finishNode(g, u ? 'OptionalCallExpression' : 'CallExpression');
        }
        parseCallExpressionArguments(g, u, N, _, Be) {
          let Cn = [],
            Yi = !0,
            nl = this.state.inFSharpPipelineDirectBody;
          for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(g); ) {
            if (Yi) Yi = !1;
            else if ((this.expect(12), this.match(g))) {
              u &&
                !this.hasPlugin('importAttributes') &&
                !this.hasPlugin('importAssertions') &&
                !this.hasPlugin('moduleAttributes') &&
                this.raise(Wi.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }),
                _ && this.addTrailingCommaExtraToNode(_),
                this.next();
              break;
            }
            Cn.push(this.parseExprListItem(!1, Be, N));
          }
          return (this.state.inFSharpPipelineDirectBody = nl), Cn;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(g, u) {
          var N;
          return (
            this.resetPreviousNodeTrailingComments(u),
            this.expect(19),
            this.parseArrowExpression(g, u.arguments, !0, (N = u.extra) == null ? void 0 : N.trailingCommaLoc),
            u.innerComments && Sd(g, u.innerComments),
            u.callee.trailingComments && Sd(g, u.callee.trailingComments),
            g
          );
        }
        parseNoCallExpr() {
          let g = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), g, !0);
        }
        parseExprAtom(g) {
          let u,
            N = null,
            { type: _ } = this.state;
          switch (_) {
            case 79:
              return this.parseSuper();
            case 83:
              return (
                (u = this.startNode()),
                this.next(),
                this.match(16)
                  ? this.parseImportMetaProperty(u)
                  : (this.match(10) || this.raise(Wi.UnsupportedImport, { at: this.state.lastTokStartLoc }),
                    this.finishNode(u, 'Import'))
              );
            case 78:
              return (u = this.startNode()), this.next(), this.finishNode(u, 'ThisExpression');
            case 90:
              return this.parseDo(this.startNode(), !1);
            case 56:
            case 31:
              return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
            case 132:
              return this.parseNumericLiteral(this.state.value);
            case 133:
              return this.parseBigIntLiteral(this.state.value);
            case 134:
              return this.parseDecimalLiteral(this.state.value);
            case 131:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(!0);
            case 86:
              return this.parseBooleanLiteral(!1);
            case 10: {
              let Be = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(Be);
            }
            case 2:
            case 1:
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
            case 0:
              return this.parseArrayLike(3, !0, !1, g);
            case 6:
            case 7:
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
            case 5:
              return this.parseObjectLike(8, !1, !1, g);
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              N = this.parseDecorators();
            case 80:
              return this.parseClass(this.maybeTakeDecorators(N, this.startNode()), !1);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(!1);
            case 15: {
              (u = this.startNode()), this.next(), (u.object = null);
              let Be = (u.callee = this.parseNoCallExpr());
              if (Be.type === 'MemberExpression') return this.finishNode(u, 'BindExpression');
              throw this.raise(Wi.UnsupportedBind, { at: Be });
            }
            case 136:
              return (
                this.raise(Wi.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }),
                this.parsePrivateName()
              );
            case 33:
              return this.parseTopicReferenceThenEqualsSign(54, '%');
            case 32:
              return this.parseTopicReferenceThenEqualsSign(44, '^');
            case 37:
            case 38:
              return this.parseTopicReference('hack');
            case 44:
            case 54:
            case 27: {
              let Be = this.getPluginOption('pipelineOperator', 'proposal');
              if (Be) return this.parseTopicReference(Be);
              this.unexpected();
              break;
            }
            case 47: {
              let Be = this.input.codePointAt(this.nextTokenStart());
              Hh(Be) || Be === 62 ? this.expectOnePlugin(['jsx', 'flow', 'typescript']) : this.unexpected();
              break;
            }
            default:
              if (Ul(_)) {
                if (this.isContextual(125) && this.lookaheadInLineCharCode() === 123)
                  return this.parseModuleExpression();
                let Be = this.state.potentialArrowAt === this.state.start,
                  Cn = this.state.containsEsc,
                  Yi = this.parseIdentifier();
                if (!Cn && Yi.name === 'async' && !this.canInsertSemicolon()) {
                  let { type: nl } = this.state;
                  if (nl === 68)
                    return (
                      this.resetPreviousNodeTrailingComments(Yi),
                      this.next(),
                      this.parseAsyncFunctionExpression(this.startNodeAtNode(Yi))
                    );
                  if (Ul(nl))
                    return this.lookaheadCharCode() === 61
                      ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(Yi))
                      : Yi;
                  if (nl === 90)
                    return this.resetPreviousNodeTrailingComments(Yi), this.parseDo(this.startNodeAtNode(Yi), !0);
                }
                return Be && this.match(19) && !this.canInsertSemicolon()
                  ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(Yi), [Yi], !1))
                  : Yi;
              } else this.unexpected();
          }
        }
        parseTopicReferenceThenEqualsSign(g, u) {
          let N = this.getPluginOption('pipelineOperator', 'proposal');
          if (N)
            return (
              (this.state.type = g),
              (this.state.value = u),
              this.state.pos--,
              this.state.end--,
              (this.state.endLoc = o(this.state.endLoc, -1)),
              this.parseTopicReference(N)
            );
          this.unexpected();
        }
        parseTopicReference(g) {
          let u = this.startNode(),
            N = this.state.startLoc,
            _ = this.state.type;
          return this.next(), this.finishTopicReference(u, N, g, _);
        }
        finishTopicReference(g, u, N, _) {
          if (this.testTopicReferenceConfiguration(N, u, _)) {
            let Be = N === 'smart' ? 'PipelinePrimaryTopicReference' : 'TopicReference';
            return (
              this.topicReferenceIsAllowedInCurrentContext() ||
                this.raise(N === 'smart' ? Wi.PrimaryTopicNotAllowed : Wi.PipeTopicUnbound, { at: u }),
              this.registerTopicReference(),
              this.finishNode(g, Be)
            );
          } else throw this.raise(Wi.PipeTopicUnconfiguredToken, { at: u, token: mh(_) });
        }
        testTopicReferenceConfiguration(g, u, N) {
          switch (g) {
            case 'hack':
              return this.hasPlugin(['pipelineOperator', { topicToken: mh(N) }]);
            case 'smart':
              return N === 27;
            default:
              throw this.raise(Wi.PipeTopicRequiresHackPipes, { at: u });
          }
        }
        parseAsyncArrowUnaryFunction(g) {
          this.prodParam.enter(kd(!0, this.prodParam.hasYield));
          let u = [this.parseIdentifier()];
          return (
            this.prodParam.exit(),
            this.hasPrecedingLineBreak() && this.raise(Wi.LineTerminatorBeforeArrow, { at: this.state.curPosition() }),
            this.expect(19),
            this.parseArrowExpression(g, u, !0)
          );
        }
        parseDo(g, u) {
          this.expectPlugin('doExpressions'), u && this.expectPlugin('asyncDoExpressions'), (g.async = u), this.next();
          let N = this.state.labels;
          return (
            (this.state.labels = []),
            u
              ? (this.prodParam.enter(Td), (g.body = this.parseBlock()), this.prodParam.exit())
              : (g.body = this.parseBlock()),
            (this.state.labels = N),
            this.finishNode(g, 'DoExpression')
          );
        }
        parseSuper() {
          let g = this.startNode();
          return (
            this.next(),
            this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod
              ? this.raise(Wi.SuperNotAllowed, { at: g })
              : !this.scope.allowSuper &&
                !this.options.allowSuperOutsideMethod &&
                this.raise(Wi.UnexpectedSuper, { at: g }),
            !this.match(10) && !this.match(0) && !this.match(16) && this.raise(Wi.UnsupportedSuper, { at: g }),
            this.finishNode(g, 'Super')
          );
        }
        parsePrivateName() {
          let g = this.startNode(),
            u = this.startNodeAt(o(this.state.startLoc, 1)),
            N = this.state.value;
          return this.next(), (g.id = this.createIdentifier(u, N)), this.finishNode(g, 'PrivateName');
        }
        parseFunctionOrFunctionSent() {
          let g = this.startNode();
          if ((this.next(), this.prodParam.hasYield && this.match(16))) {
            let u = this.createIdentifier(this.startNodeAtNode(g), 'function');
            return (
              this.next(),
              this.match(102) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(),
              this.parseMetaProperty(g, u, 'sent')
            );
          }
          return this.parseFunction(g);
        }
        parseMetaProperty(g, u, N) {
          g.meta = u;
          let _ = this.state.containsEsc;
          return (
            (g.property = this.parseIdentifier(!0)),
            (g.property.name !== N || _) &&
              this.raise(Wi.UnsupportedMetaProperty, { at: g.property, target: u.name, onlyValidPropertyName: N }),
            this.finishNode(g, 'MetaProperty')
          );
        }
        parseImportMetaProperty(g) {
          let u = this.createIdentifier(this.startNodeAtNode(g), 'import');
          return (
            this.next(),
            this.isContextual(100) &&
              (this.inModule || this.raise(Wi.ImportMetaOutsideModule, { at: u }), (this.sawUnambiguousESM = !0)),
            this.parseMetaProperty(g, u, 'meta')
          );
        }
        parseLiteralAtNode(g, u, N) {
          return (
            this.addExtra(N, 'rawValue', g),
            this.addExtra(N, 'raw', this.input.slice(N.start, this.state.end)),
            (N.value = g),
            this.next(),
            this.finishNode(N, u)
          );
        }
        parseLiteral(g, u) {
          let N = this.startNode();
          return this.parseLiteralAtNode(g, u, N);
        }
        parseStringLiteral(g) {
          return this.parseLiteral(g, 'StringLiteral');
        }
        parseNumericLiteral(g) {
          return this.parseLiteral(g, 'NumericLiteral');
        }
        parseBigIntLiteral(g) {
          return this.parseLiteral(g, 'BigIntLiteral');
        }
        parseDecimalLiteral(g) {
          return this.parseLiteral(g, 'DecimalLiteral');
        }
        parseRegExpLiteral(g) {
          let u = this.parseLiteral(g.value, 'RegExpLiteral');
          return (u.pattern = g.pattern), (u.flags = g.flags), u;
        }
        parseBooleanLiteral(g) {
          let u = this.startNode();
          return (u.value = g), this.next(), this.finishNode(u, 'BooleanLiteral');
        }
        parseNullLiteral() {
          let g = this.startNode();
          return this.next(), this.finishNode(g, 'NullLiteral');
        }
        parseParenAndDistinguishExpression(g) {
          let u = this.state.startLoc,
            N;
          this.next(), this.expressionScope.enter(kf());
          let _ = this.state.maybeInArrowParameters,
            Be = this.state.inFSharpPipelineDirectBody;
          (this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1);
          let Cn = this.state.startLoc,
            Yi = [],
            nl = new Zh(),
            xl = !0,
            Dl,
            jl;
          for (; !this.match(11); ) {
            if (xl) xl = !1;
            else if (
              (this.expect(12, nl.optionalParametersLoc === null ? null : nl.optionalParametersLoc), this.match(11))
            ) {
              jl = this.state.startLoc;
              break;
            }
            if (this.match(21)) {
              let rh = this.state.startLoc;
              if (
                ((Dl = this.state.startLoc),
                Yi.push(this.parseParenItem(this.parseRestBinding(), rh)),
                !this.checkCommaAfterRest(41))
              )
                break;
            } else Yi.push(this.parseMaybeAssignAllowIn(nl, this.parseParenItem));
          }
          let Zl = this.state.lastTokEndLoc;
          this.expect(11), (this.state.maybeInArrowParameters = _), (this.state.inFSharpPipelineDirectBody = Be);
          let Zc = this.startNodeAt(u);
          return g && this.shouldParseArrow(Yi) && (Zc = this.parseArrow(Zc))
            ? (this.checkDestructuringPrivate(nl),
              this.expressionScope.validateAsPattern(),
              this.expressionScope.exit(),
              this.parseArrowExpression(Zc, Yi, !1),
              Zc)
            : (this.expressionScope.exit(),
              Yi.length || this.unexpected(this.state.lastTokStartLoc),
              jl && this.unexpected(jl),
              Dl && this.unexpected(Dl),
              this.checkExpressionErrors(nl, !0),
              this.toReferencedListDeep(Yi, !0),
              Yi.length > 1
                ? ((N = this.startNodeAt(Cn)),
                  (N.expressions = Yi),
                  this.finishNode(N, 'SequenceExpression'),
                  this.resetEndLocation(N, Zl))
                : (N = Yi[0]),
              this.wrapParenthesis(u, N));
        }
        wrapParenthesis(g, u) {
          if (!this.options.createParenthesizedExpressions)
            return (
              this.addExtra(u, 'parenthesized', !0),
              this.addExtra(u, 'parenStart', g.index),
              this.takeSurroundingComments(u, g.index, this.state.lastTokEndLoc.index),
              u
            );
          let N = this.startNodeAt(g);
          return (N.expression = u), this.finishNode(N, 'ParenthesizedExpression');
        }
        shouldParseArrow(g) {
          return !this.canInsertSemicolon();
        }
        parseArrow(g) {
          if (this.eat(19)) return g;
        }
        parseParenItem(g, u) {
          return g;
        }
        parseNewOrNewTarget() {
          let g = this.startNode();
          if ((this.next(), this.match(16))) {
            let u = this.createIdentifier(this.startNodeAtNode(g), 'new');
            this.next();
            let N = this.parseMetaProperty(g, u, 'target');
            return (
              !this.scope.inNonArrowFunction &&
                !this.scope.inClass &&
                !this.options.allowNewTargetOutsideFunction &&
                this.raise(Wi.UnexpectedNewTarget, { at: N }),
              N
            );
          }
          return this.parseNew(g);
        }
        parseNew(g) {
          if ((this.parseNewCallee(g), this.eat(10))) {
            let u = this.parseExprList(11);
            this.toReferencedList(u), (g.arguments = u);
          } else g.arguments = [];
          return this.finishNode(g, 'NewExpression');
        }
        parseNewCallee(g) {
          (g.callee = this.parseNoCallExpr()),
            g.callee.type === 'Import' && this.raise(Wi.ImportCallNotNewExpression, { at: g.callee });
        }
        parseTemplateElement(g) {
          let { start: u, startLoc: N, end: _, value: Be } = this.state,
            Cn = u + 1,
            Yi = this.startNodeAt(o(N, 1));
          Be === null &&
            (g || this.raise(Wi.InvalidEscapeSequenceTemplate, { at: o(this.state.firstInvalidTemplateEscapePos, 1) }));
          let nl = this.match(24),
            xl = nl ? -1 : -2,
            Dl = _ + xl;
          (Yi.value = {
            raw: this.input.slice(Cn, Dl).replace(
              /\r\n?/g,
              `
`,
            ),
            cooked: Be === null ? null : Be.slice(1, xl),
          }),
            (Yi.tail = nl),
            this.next();
          let jl = this.finishNode(Yi, 'TemplateElement');
          return this.resetEndLocation(jl, o(this.state.lastTokEndLoc, xl)), jl;
        }
        parseTemplate(g) {
          let u = this.startNode();
          u.expressions = [];
          let N = this.parseTemplateElement(g);
          for (u.quasis = [N]; !N.tail; )
            u.expressions.push(this.parseTemplateSubstitution()),
              this.readTemplateContinuation(),
              u.quasis.push((N = this.parseTemplateElement(g)));
          return this.finishNode(u, 'TemplateLiteral');
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(g, u, N, _) {
          N && this.expectPlugin('recordAndTuple');
          let Be = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          let Cn = Object.create(null),
            Yi = !0,
            nl = this.startNode();
          for (nl.properties = [], this.next(); !this.match(g); ) {
            if (Yi) Yi = !1;
            else if ((this.expect(12), this.match(g))) {
              this.addTrailingCommaExtraToNode(nl);
              break;
            }
            let Dl;
            u
              ? (Dl = this.parseBindingProperty())
              : ((Dl = this.parsePropertyDefinition(_)), this.checkProto(Dl, N, Cn, _)),
              N &&
                !this.isObjectProperty(Dl) &&
                Dl.type !== 'SpreadElement' &&
                this.raise(Wi.InvalidRecordProperty, { at: Dl }),
              Dl.shorthand && this.addExtra(Dl, 'shorthand', !0),
              nl.properties.push(Dl);
          }
          this.next(), (this.state.inFSharpPipelineDirectBody = Be);
          let xl = 'ObjectExpression';
          return u ? (xl = 'ObjectPattern') : N && (xl = 'RecordExpression'), this.finishNode(nl, xl);
        }
        addTrailingCommaExtraToNode(g) {
          this.addExtra(g, 'trailingComma', this.state.lastTokStart),
            this.addExtra(g, 'trailingCommaLoc', this.state.lastTokStartLoc, !1);
        }
        maybeAsyncOrAccessorProp(g) {
          return (
            !g.computed &&
            g.key.type === 'Identifier' &&
            (this.isLiteralPropertyName() || this.match(0) || this.match(55))
          );
        }
        parsePropertyDefinition(g) {
          let u = [];
          if (this.match(26))
            for (
              this.hasPlugin('decorators') && this.raise(Wi.UnsupportedPropertyDecorator, { at: this.state.startLoc });
              this.match(26);

            )
              u.push(this.parseDecorator());
          let N = this.startNode(),
            _ = !1,
            Be = !1,
            Cn;
          if (this.match(21)) return u.length && this.unexpected(), this.parseSpread();
          u.length && ((N.decorators = u), (u = [])), (N.method = !1), g && (Cn = this.state.startLoc);
          let Yi = this.eat(55);
          this.parsePropertyNamePrefixOperator(N);
          let nl = this.state.containsEsc,
            xl = this.parsePropertyName(N, g);
          if (!Yi && !nl && this.maybeAsyncOrAccessorProp(N)) {
            let Dl = xl.name;
            Dl === 'async' &&
              !this.hasPrecedingLineBreak() &&
              ((_ = !0), this.resetPreviousNodeTrailingComments(xl), (Yi = this.eat(55)), this.parsePropertyName(N)),
              (Dl === 'get' || Dl === 'set') &&
                ((Be = !0),
                this.resetPreviousNodeTrailingComments(xl),
                (N.kind = Dl),
                this.match(55) &&
                  ((Yi = !0),
                  this.raise(Wi.AccessorIsGenerator, { at: this.state.curPosition(), kind: Dl }),
                  this.next()),
                this.parsePropertyName(N));
          }
          return this.parseObjPropValue(N, Cn, Yi, _, !1, Be, g);
        }
        getGetterSetterExpectedParamCount(g) {
          return g.kind === 'get' ? 0 : 1;
        }
        getObjectOrClassMethodParams(g) {
          return g.params;
        }
        checkGetterSetterParams(g) {
          var u;
          let N = this.getGetterSetterExpectedParamCount(g),
            _ = this.getObjectOrClassMethodParams(g);
          _.length !== N && this.raise(g.kind === 'get' ? Wi.BadGetterArity : Wi.BadSetterArity, { at: g }),
            g.kind === 'set' &&
              ((u = _[_.length - 1]) == null ? void 0 : u.type) === 'RestElement' &&
              this.raise(Wi.BadSetterRestParameter, { at: g });
        }
        parseObjectMethod(g, u, N, _, Be) {
          if (Be) {
            let Cn = this.parseMethod(g, u, !1, !1, !1, 'ObjectMethod');
            return this.checkGetterSetterParams(Cn), Cn;
          }
          if (N || u || this.match(10))
            return (
              _ && this.unexpected(),
              (g.kind = 'method'),
              (g.method = !0),
              this.parseMethod(g, u, N, !1, !1, 'ObjectMethod')
            );
        }
        parseObjectProperty(g, u, N, _) {
          if (((g.shorthand = !1), this.eat(14)))
            return (
              (g.value = N ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(_)),
              this.finishNode(g, 'ObjectProperty')
            );
          if (!g.computed && g.key.type === 'Identifier') {
            if ((this.checkReservedWord(g.key.name, g.key.loc.start, !0, !1), N))
              g.value = this.parseMaybeDefault(u, ed(g.key));
            else if (this.match(29)) {
              let Be = this.state.startLoc;
              _ != null
                ? _.shorthandAssignLoc === null && (_.shorthandAssignLoc = Be)
                : this.raise(Wi.InvalidCoverInitializedName, { at: Be }),
                (g.value = this.parseMaybeDefault(u, ed(g.key)));
            } else g.value = ed(g.key);
            return (g.shorthand = !0), this.finishNode(g, 'ObjectProperty');
          }
        }
        parseObjPropValue(g, u, N, _, Be, Cn, Yi) {
          let nl = this.parseObjectMethod(g, N, _, Be, Cn) || this.parseObjectProperty(g, u, Be, Yi);
          return nl || this.unexpected(), nl;
        }
        parsePropertyName(g, u) {
          if (this.eat(0)) (g.computed = !0), (g.key = this.parseMaybeAssignAllowIn()), this.expect(3);
          else {
            let { type: N, value: _ } = this.state,
              Be;
            if (gl(N)) Be = this.parseIdentifier(!0);
            else
              switch (N) {
                case 132:
                  Be = this.parseNumericLiteral(_);
                  break;
                case 131:
                  Be = this.parseStringLiteral(_);
                  break;
                case 133:
                  Be = this.parseBigIntLiteral(_);
                  break;
                case 134:
                  Be = this.parseDecimalLiteral(_);
                  break;
                case 136: {
                  let Cn = this.state.startLoc;
                  u != null
                    ? u.privateKeyLoc === null && (u.privateKeyLoc = Cn)
                    : this.raise(Wi.UnexpectedPrivateField, { at: Cn }),
                    (Be = this.parsePrivateName());
                  break;
                }
                default:
                  this.unexpected();
              }
            (g.key = Be), N !== 136 && (g.computed = !1);
          }
          return g.key;
        }
        initFunction(g, u) {
          (g.id = null), (g.generator = !1), (g.async = u);
        }
        parseMethod(g, u, N, _, Be, Cn, Yi = !1) {
          this.initFunction(g, N),
            (g.generator = u),
            this.scope.enter(18 | (Yi ? 64 : 0) | (Be ? 32 : 0)),
            this.prodParam.enter(kd(N, g.generator)),
            this.parseFunctionParams(g, _);
          let nl = this.parseFunctionBodyAndFinish(g, Cn, !0);
          return this.prodParam.exit(), this.scope.exit(), nl;
        }
        parseArrayLike(g, u, N, _) {
          N && this.expectPlugin('recordAndTuple');
          let Be = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          let Cn = this.startNode();
          return (
            this.next(),
            (Cn.elements = this.parseExprList(g, !N, _, Cn)),
            (this.state.inFSharpPipelineDirectBody = Be),
            this.finishNode(Cn, N ? 'TupleExpression' : 'ArrayExpression')
          );
        }
        parseArrowExpression(g, u, N, _) {
          this.scope.enter(6);
          let Be = kd(N, !1);
          !this.match(5) && this.prodParam.hasIn && (Be |= yd), this.prodParam.enter(Be), this.initFunction(g, N);
          let Cn = this.state.maybeInArrowParameters;
          return (
            u && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(g, u, _)),
            (this.state.maybeInArrowParameters = !1),
            this.parseFunctionBody(g, !0),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.maybeInArrowParameters = Cn),
            this.finishNode(g, 'ArrowFunctionExpression')
          );
        }
        setArrowFunctionParameters(g, u, N) {
          this.toAssignableList(u, N, !1), (g.params = u);
        }
        parseFunctionBodyAndFinish(g, u, N = !1) {
          return this.parseFunctionBody(g, !1, N), this.finishNode(g, u);
        }
        parseFunctionBody(g, u, N = !1) {
          let _ = u && !this.match(5);
          if ((this.expressionScope.enter(of()), _)) (g.body = this.parseMaybeAssign()), this.checkParams(g, !1, u, !1);
          else {
            let Be = this.state.strict,
              Cn = this.state.labels;
            (this.state.labels = []),
              this.prodParam.enter(this.prodParam.currentFlags() | Pf),
              (g.body = this.parseBlock(!0, !1, (Yi) => {
                let nl = !this.isSimpleParamList(g.params);
                Yi &&
                  nl &&
                  this.raise(Wi.IllegalLanguageModeDirective, {
                    at: (g.kind === 'method' || g.kind === 'constructor') && g.key ? g.key.loc.end : g,
                  });
                let xl = !Be && this.state.strict;
                this.checkParams(g, !this.state.strict && !u && !N && !nl, u, xl),
                  this.state.strict && g.id && this.checkIdentifier(g.id, 65, xl);
              })),
              this.prodParam.exit(),
              (this.state.labels = Cn);
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(g) {
          return g.type === 'Identifier';
        }
        isSimpleParamList(g) {
          for (let u = 0, N = g.length; u < N; u++) if (!this.isSimpleParameter(g[u])) return !1;
          return !0;
        }
        checkParams(g, u, N, _ = !0) {
          let Be = !u && new Set(),
            Cn = { type: 'FormalParameters' };
          for (let Yi of g.params) this.checkLVal(Yi, { in: Cn, binding: 5, checkClashes: Be, strictModeChanged: _ });
        }
        parseExprList(g, u, N, _) {
          let Be = [],
            Cn = !0;
          for (; !this.eat(g); ) {
            if (Cn) Cn = !1;
            else if ((this.expect(12), this.match(g))) {
              _ && this.addTrailingCommaExtraToNode(_), this.next();
              break;
            }
            Be.push(this.parseExprListItem(u, N));
          }
          return Be;
        }
        parseExprListItem(g, u, N) {
          let _;
          if (this.match(12))
            g || this.raise(Wi.UnexpectedToken, { at: this.state.curPosition(), unexpected: ',' }), (_ = null);
          else if (this.match(21)) {
            let Be = this.state.startLoc;
            _ = this.parseParenItem(this.parseSpread(u), Be);
          } else if (this.match(17)) {
            this.expectPlugin('partialApplication'),
              N || this.raise(Wi.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
            let Be = this.startNode();
            this.next(), (_ = this.finishNode(Be, 'ArgumentPlaceholder'));
          } else _ = this.parseMaybeAssignAllowIn(u, this.parseParenItem);
          return _;
        }
        parseIdentifier(g) {
          let u = this.startNode(),
            N = this.parseIdentifierName(g);
          return this.createIdentifier(u, N);
        }
        createIdentifier(g, u) {
          return (g.name = u), (g.loc.identifierName = u), this.finishNode(g, 'Identifier');
        }
        parseIdentifierName(g) {
          let u,
            { startLoc: N, type: _ } = this.state;
          gl(_) ? (u = this.state.value) : this.unexpected();
          let Be = Dh(_);
          return g ? Be && this.replaceToken(130) : this.checkReservedWord(u, N, Be, !1), this.next(), u;
        }
        checkReservedWord(g, u, N, _) {
          if (!(g.length > 10 || !t0(g))) {
            if (N && _d(g)) {
              this.raise(Wi.UnexpectedKeyword, { at: u, keyword: g });
              return;
            }
            if ((this.state.strict ? (_ ? Gd : Rd) : Jd)(g, this.inModule)) {
              this.raise(Wi.UnexpectedReservedWord, { at: u, reservedWord: g });
              return;
            } else if (g === 'yield') {
              if (this.prodParam.hasYield) {
                this.raise(Wi.YieldBindingIdentifier, { at: u });
                return;
              }
            } else if (g === 'await') {
              if (this.prodParam.hasAwait) {
                this.raise(Wi.AwaitBindingIdentifier, { at: u });
                return;
              }
              if (this.scope.inStaticBlock) {
                this.raise(Wi.AwaitBindingIdentifierInStaticBlock, { at: u });
                return;
              }
              this.expressionScope.recordAsyncArrowParametersError({ at: u });
            } else if (g === 'arguments' && this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(Wi.ArgumentsInClass, { at: u });
              return;
            }
          }
        }
        isAwaitAllowed() {
          return !!(this.prodParam.hasAwait || (this.options.allowAwaitOutsideFunction && !this.scope.inFunction));
        }
        parseAwait(g) {
          let u = this.startNodeAt(g);
          return (
            this.expressionScope.recordParameterInitializerError(Wi.AwaitExpressionFormalParameter, { at: u }),
            this.eat(55) && this.raise(Wi.ObsoleteAwaitStar, { at: u }),
            !this.scope.inFunction &&
              !this.options.allowAwaitOutsideFunction &&
              (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)),
            this.state.soloAwait || (u.argument = this.parseMaybeUnary(null, !0)),
            this.finishNode(u, 'AwaitExpression')
          );
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak()) return !0;
          let { type: g } = this.state;
          return (
            g === 53 ||
            g === 10 ||
            g === 0 ||
            Sh(g) ||
            (g === 101 && !this.state.containsEsc) ||
            g === 135 ||
            g === 56 ||
            (this.hasPlugin('v8intrinsic') && g === 54)
          );
        }
        parseYield() {
          let g = this.startNode();
          this.expressionScope.recordParameterInitializerError(Wi.YieldInParameter, { at: g }), this.next();
          let u = !1,
            N = null;
          if (!this.hasPrecedingLineBreak())
            switch (((u = this.eat(55)), this.state.type)) {
              case 13:
              case 137:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!u) break;
              default:
                N = this.parseMaybeAssign();
            }
          return (g.delegate = u), (g.argument = N), this.finishNode(g, 'YieldExpression');
        }
        checkPipelineAtInfixOperator(g, u) {
          this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) &&
            g.type === 'SequenceExpression' &&
            this.raise(Wi.PipelineHeadSequenceExpression, { at: u });
        }
        parseSmartPipelineBodyInStyle(g, u) {
          if (this.isSimpleReference(g)) {
            let N = this.startNodeAt(u);
            return (N.callee = g), this.finishNode(N, 'PipelineBareFunction');
          } else {
            let N = this.startNodeAt(u);
            return (
              this.checkSmartPipeTopicBodyEarlyErrors(u),
              (N.expression = g),
              this.finishNode(N, 'PipelineTopicExpression')
            );
          }
        }
        isSimpleReference(g) {
          switch (g.type) {
            case 'MemberExpression':
              return !g.computed && this.isSimpleReference(g.object);
            case 'Identifier':
              return !0;
            default:
              return !1;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(g) {
          if (this.match(19)) throw this.raise(Wi.PipelineBodyNoArrow, { at: this.state.startLoc });
          this.topicReferenceWasUsedInCurrentContext() || this.raise(Wi.PipelineTopicUnused, { at: g });
        }
        withTopicBindingContext(g) {
          let u = this.state.topicContext;
          this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
          try {
            return g();
          } finally {
            this.state.topicContext = u;
          }
        }
        withSmartMixTopicForbiddingContext(g) {
          if (this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) {
            let u = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
            try {
              return g();
            } finally {
              this.state.topicContext = u;
            }
          } else return g();
        }
        withSoloAwaitPermittingContext(g) {
          let u = this.state.soloAwait;
          this.state.soloAwait = !0;
          try {
            return g();
          } finally {
            this.state.soloAwait = u;
          }
        }
        allowInAnd(g) {
          let u = this.prodParam.currentFlags();
          if (yd & ~u) {
            this.prodParam.enter(u | yd);
            try {
              return g();
            } finally {
              this.prodParam.exit();
            }
          }
          return g();
        }
        disallowInAnd(g) {
          let u = this.prodParam.currentFlags();
          if (yd & u) {
            this.prodParam.enter(u & ~yd);
            try {
              return g();
            } finally {
              this.prodParam.exit();
            }
          }
          return g();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(g) {
          let u = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          let N = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !0;
          let _ = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), u, g);
          return (this.state.inFSharpPipelineDirectBody = N), _;
        }
        parseModuleExpression() {
          this.expectPlugin('moduleBlocks');
          let g = this.startNode();
          this.next(), this.match(5) || this.unexpected(null, 5);
          let u = this.startNodeAt(this.state.endLoc);
          this.next();
          let N = this.initializeScopes(!0);
          this.enterInitialScopes();
          try {
            g.body = this.parseProgram(u, 8, 'module');
          } finally {
            N();
          }
          return this.finishNode(g, 'ModuleExpression');
        }
        parsePropertyNamePrefixOperator(g) {}
      },
      Nd = { kind: 'loop' },
      C0 = { kind: 'switch' },
      Jf = /[\uD800-\uDFFF]/u,
      Id = /in(?:stanceof)?/y;
    function E0(g, u) {
      for (let N = 0; N < g.length; N++) {
        let _ = g[N],
          { type: Be } = _;
        if (typeof Be == 'number') {
          {
            if (Be === 136) {
              let { loc: Cn, start: Yi, value: nl, end: xl } = _,
                Dl = Yi + 1,
                jl = o(Cn.start, 1);
              g.splice(
                N,
                1,
                new Jh({ type: Fh(27), value: '#', start: Yi, end: Dl, startLoc: Cn.start, endLoc: jl }),
                new Jh({ type: Fh(130), value: nl, start: Dl, end: xl, startLoc: jl, endLoc: Cn.end }),
              ),
                N++;
              continue;
            }
            if (Sh(Be)) {
              let { loc: Cn, start: Yi, value: nl, end: xl } = _,
                Dl = Yi + 1,
                jl = o(Cn.start, 1),
                Zl;
              u.charCodeAt(Yi) === 96
                ? (Zl = new Jh({ type: Fh(22), value: '`', start: Yi, end: Dl, startLoc: Cn.start, endLoc: jl }))
                : (Zl = new Jh({ type: Fh(8), value: '}', start: Yi, end: Dl, startLoc: Cn.start, endLoc: jl }));
              let Zc, rh, Ph, Th;
              Be === 24
                ? ((rh = xl - 1),
                  (Ph = o(Cn.end, -1)),
                  (Zc = nl === null ? null : nl.slice(1, -1)),
                  (Th = new Jh({ type: Fh(22), value: '`', start: rh, end: xl, startLoc: Ph, endLoc: Cn.end })))
                : ((rh = xl - 2),
                  (Ph = o(Cn.end, -2)),
                  (Zc = nl === null ? null : nl.slice(1, -2)),
                  (Th = new Jh({ type: Fh(23), value: '${', start: rh, end: xl, startLoc: Ph, endLoc: Cn.end }))),
                g.splice(
                  N,
                  1,
                  Zl,
                  new Jh({ type: Fh(20), value: Zc, start: Dl, end: rh, startLoc: jl, endLoc: Ph }),
                  Th,
                ),
                (N += 2);
              continue;
            }
          }
          _.type = Fh(Be);
        }
      }
      return g;
    }
    var Gf = class extends x0 {
        parseTopLevel(g, u) {
          return (
            (g.program = this.parseProgram(u)),
            (g.comments = this.state.comments),
            this.options.tokens && (g.tokens = E0(this.tokens, this.input)),
            this.finishNode(g, 'File')
          );
        }
        parseProgram(g, u = 137, N = this.options.sourceType) {
          if (
            ((g.sourceType = N),
            (g.interpreter = this.parseInterpreterDirective()),
            this.parseBlockBody(g, !0, !0, u),
            this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
          )
            for (let [Be, Cn] of Array.from(this.scope.undefinedExports))
              this.raise(Wi.ModuleExportUndefined, { at: Cn, localName: Be });
          let _;
          return (
            u === 137
              ? (_ = this.finishNode(g, 'Program'))
              : (_ = this.finishNodeAt(g, 'Program', o(this.state.startLoc, -1))),
            _
          );
        }
        stmtToDirective(g) {
          let u = g;
          (u.type = 'Directive'), (u.value = u.expression), delete u.expression;
          let N = u.value,
            _ = N.value,
            Be = this.input.slice(N.start, N.end),
            Cn = (N.value = Be.slice(1, -1));
          return (
            this.addExtra(N, 'raw', Be),
            this.addExtra(N, 'rawValue', Cn),
            this.addExtra(N, 'expressionValue', _),
            (N.type = 'DirectiveLiteral'),
            u
          );
        }
        parseInterpreterDirective() {
          if (!this.match(28)) return null;
          let g = this.startNode();
          return (g.value = this.state.value), this.next(), this.finishNode(g, 'InterpreterDirective');
        }
        isLet() {
          return this.isContextual(99) ? this.hasFollowingBindingAtom() : !1;
        }
        chStartsBindingIdentifier(g, u) {
          if (Hh(g)) {
            if (((Id.lastIndex = u), Id.test(this.input))) {
              let N = this.codePointAtPos(Id.lastIndex);
              if (!Wh(N) && N !== 92) return !1;
            }
            return !0;
          } else return g === 92;
        }
        chStartsBindingPattern(g) {
          return g === 91 || g === 123;
        }
        hasFollowingBindingAtom() {
          let g = this.nextTokenStart(),
            u = this.codePointAtPos(g);
          return this.chStartsBindingPattern(u) || this.chStartsBindingIdentifier(u, g);
        }
        hasInLineFollowingBindingIdentifier() {
          let g = this.nextTokenInLineStart(),
            u = this.codePointAtPos(g);
          return this.chStartsBindingIdentifier(u, g);
        }
        startsUsingForOf() {
          let { type: g, containsEsc: u } = this.lookahead();
          if (g === 101 && !u) return !1;
          if (Ul(g) && !this.hasFollowingLineBreak()) return this.expectPlugin('explicitResourceManagement'), !0;
        }
        startsAwaitUsing() {
          let g = this.nextTokenInLineStart();
          if (this.isUnparsedContextual(g, 'using')) {
            g = this.nextTokenInLineStartSince(g + 5);
            let u = this.codePointAtPos(g);
            if (this.chStartsBindingIdentifier(u, g)) return this.expectPlugin('explicitResourceManagement'), !0;
          }
          return !1;
        }
        parseModuleItem() {
          return this.parseStatementLike(15);
        }
        parseStatementListItem() {
          return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
        }
        parseStatementOrSloppyAnnexBFunctionDeclaration(g = !1) {
          let u = 0;
          return this.options.annexB && !this.state.strict && ((u |= 4), g && (u |= 8)), this.parseStatementLike(u);
        }
        parseStatement() {
          return this.parseStatementLike(0);
        }
        parseStatementLike(g) {
          let u = null;
          return this.match(26) && (u = this.parseDecorators(!0)), this.parseStatementContent(g, u);
        }
        parseStatementContent(g, u) {
          let N = this.state.type,
            _ = this.startNode(),
            Be = !!(g & 2),
            Cn = !!(g & 4),
            Yi = g & 1;
          switch (N) {
            case 60:
              return this.parseBreakContinueStatement(_, !0);
            case 63:
              return this.parseBreakContinueStatement(_, !1);
            case 64:
              return this.parseDebuggerStatement(_);
            case 90:
              return this.parseDoWhileStatement(_);
            case 91:
              return this.parseForStatement(_);
            case 68:
              if (this.lookaheadCharCode() === 46) break;
              return (
                Cn ||
                  this.raise(
                    this.state.strict
                      ? Wi.StrictFunction
                      : this.options.annexB
                      ? Wi.SloppyFunctionAnnexB
                      : Wi.SloppyFunction,
                    { at: this.state.startLoc },
                  ),
                this.parseFunctionStatement(_, !1, !Be && Cn)
              );
            case 80:
              return Be || this.unexpected(), this.parseClass(this.maybeTakeDecorators(u, _), !0);
            case 69:
              return this.parseIfStatement(_);
            case 70:
              return this.parseReturnStatement(_);
            case 71:
              return this.parseSwitchStatement(_);
            case 72:
              return this.parseThrowStatement(_);
            case 73:
              return this.parseTryStatement(_);
            case 96:
              if (!this.state.containsEsc && this.startsAwaitUsing())
                return (
                  this.isAwaitAllowed()
                    ? Be || this.raise(Wi.UnexpectedLexicalDeclaration, { at: _ })
                    : this.raise(Wi.AwaitUsingNotInAsyncContext, { at: _ }),
                  this.next(),
                  this.parseVarStatement(_, 'await using')
                );
              break;
            case 105:
              if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
              return (
                this.expectPlugin('explicitResourceManagement'),
                !this.scope.inModule && this.scope.inTopLevel
                  ? this.raise(Wi.UnexpectedUsingDeclaration, { at: this.state.startLoc })
                  : Be || this.raise(Wi.UnexpectedLexicalDeclaration, { at: this.state.startLoc }),
                this.parseVarStatement(_, 'using')
              );
            case 99: {
              if (this.state.containsEsc) break;
              let Dl = this.nextTokenStart(),
                jl = this.codePointAtPos(Dl);
              if (
                jl !== 91 &&
                ((!Be && this.hasFollowingLineBreak()) || (!this.chStartsBindingIdentifier(jl, Dl) && jl !== 123))
              )
                break;
            }
            case 75:
              Be || this.raise(Wi.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
            case 74: {
              let Dl = this.state.value;
              return this.parseVarStatement(_, Dl);
            }
            case 92:
              return this.parseWhileStatement(_);
            case 76:
              return this.parseWithStatement(_);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(_);
            case 83: {
              let Dl = this.lookaheadCharCode();
              if (Dl === 40 || Dl === 46) break;
            }
            case 82: {
              !this.options.allowImportExportEverywhere &&
                !Yi &&
                this.raise(Wi.UnexpectedImportExport, { at: this.state.startLoc }),
                this.next();
              let Dl;
              return (
                N === 83
                  ? ((Dl = this.parseImport(_)),
                    Dl.type === 'ImportDeclaration' &&
                      (!Dl.importKind || Dl.importKind === 'value') &&
                      (this.sawUnambiguousESM = !0))
                  : ((Dl = this.parseExport(_, u)),
                    ((Dl.type === 'ExportNamedDeclaration' && (!Dl.exportKind || Dl.exportKind === 'value')) ||
                      (Dl.type === 'ExportAllDeclaration' && (!Dl.exportKind || Dl.exportKind === 'value')) ||
                      Dl.type === 'ExportDefaultDeclaration') &&
                      (this.sawUnambiguousESM = !0)),
                this.assertModuleNodeAllowed(Dl),
                Dl
              );
            }
            default:
              if (this.isAsyncFunction())
                return (
                  Be || this.raise(Wi.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }),
                  this.next(),
                  this.parseFunctionStatement(_, !0, !Be && Cn)
                );
          }
          let nl = this.state.value,
            xl = this.parseExpression();
          return Ul(N) && xl.type === 'Identifier' && this.eat(14)
            ? this.parseLabeledStatement(_, nl, xl, g)
            : this.parseExpressionStatement(_, xl, u);
        }
        assertModuleNodeAllowed(g) {
          !this.options.allowImportExportEverywhere && !this.inModule && this.raise(Wi.ImportOutsideModule, { at: g });
        }
        decoratorsEnabledBeforeExport() {
          return this.hasPlugin('decorators-legacy')
            ? !0
            : this.hasPlugin('decorators') && this.getPluginOption('decorators', 'decoratorsBeforeExport') !== !1;
        }
        maybeTakeDecorators(g, u, N) {
          return (
            g &&
              (u.decorators && u.decorators.length > 0
                ? (typeof this.getPluginOption('decorators', 'decoratorsBeforeExport') != 'boolean' &&
                    this.raise(Wi.DecoratorsBeforeAfterExport, { at: u.decorators[0] }),
                  u.decorators.unshift(...g))
                : (u.decorators = g),
              this.resetStartLocationFromNode(u, g[0]),
              N && this.resetStartLocationFromNode(N, u)),
            u
          );
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(g) {
          let u = [];
          do u.push(this.parseDecorator());
          while (this.match(26));
          if (this.match(82))
            g || this.unexpected(),
              this.decoratorsEnabledBeforeExport() || this.raise(Wi.DecoratorExportClass, { at: this.state.startLoc });
          else if (!this.canHaveLeadingDecorator())
            throw this.raise(Wi.UnexpectedLeadingDecorator, { at: this.state.startLoc });
          return u;
        }
        parseDecorator() {
          this.expectOnePlugin(['decorators', 'decorators-legacy']);
          let g = this.startNode();
          if ((this.next(), this.hasPlugin('decorators'))) {
            let u = this.state.startLoc,
              N;
            if (this.match(10)) {
              let _ = this.state.startLoc;
              this.next(), (N = this.parseExpression()), this.expect(11), (N = this.wrapParenthesis(_, N));
              let Be = this.state.startLoc;
              (g.expression = this.parseMaybeDecoratorArguments(N)),
                this.getPluginOption('decorators', 'allowCallParenthesized') === !1 &&
                  g.expression !== N &&
                  this.raise(Wi.DecoratorArgumentsOutsideParentheses, { at: Be });
            } else {
              for (N = this.parseIdentifier(!1); this.eat(16); ) {
                let _ = this.startNodeAt(u);
                (_.object = N),
                  this.match(136)
                    ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc),
                      (_.property = this.parsePrivateName()))
                    : (_.property = this.parseIdentifier(!0)),
                  (_.computed = !1),
                  (N = this.finishNode(_, 'MemberExpression'));
              }
              g.expression = this.parseMaybeDecoratorArguments(N);
            }
          } else g.expression = this.parseExprSubscripts();
          return this.finishNode(g, 'Decorator');
        }
        parseMaybeDecoratorArguments(g) {
          if (this.eat(10)) {
            let u = this.startNodeAtNode(g);
            return (
              (u.callee = g),
              (u.arguments = this.parseCallExpressionArguments(11, !1)),
              this.toReferencedList(u.arguments),
              this.finishNode(u, 'CallExpression')
            );
          }
          return g;
        }
        parseBreakContinueStatement(g, u) {
          return (
            this.next(),
            this.isLineTerminator() ? (g.label = null) : ((g.label = this.parseIdentifier()), this.semicolon()),
            this.verifyBreakContinue(g, u),
            this.finishNode(g, u ? 'BreakStatement' : 'ContinueStatement')
          );
        }
        verifyBreakContinue(g, u) {
          let N;
          for (N = 0; N < this.state.labels.length; ++N) {
            let _ = this.state.labels[N];
            if (
              (g.label == null || _.name === g.label.name) &&
              ((_.kind != null && (u || _.kind === 'loop')) || (g.label && u))
            )
              break;
          }
          if (N === this.state.labels.length) {
            let _ = u ? 'BreakStatement' : 'ContinueStatement';
            this.raise(Wi.IllegalBreakContinue, { at: g, type: _ });
          }
        }
        parseDebuggerStatement(g) {
          return this.next(), this.semicolon(), this.finishNode(g, 'DebuggerStatement');
        }
        parseHeaderExpression() {
          this.expect(10);
          let g = this.parseExpression();
          return this.expect(11), g;
        }
        parseDoWhileStatement(g) {
          return (
            this.next(),
            this.state.labels.push(Nd),
            (g.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.state.labels.pop(),
            this.expect(92),
            (g.test = this.parseHeaderExpression()),
            this.eat(13),
            this.finishNode(g, 'DoWhileStatement')
          );
        }
        parseForStatement(g) {
          this.next(), this.state.labels.push(Nd);
          let u = null;
          if (
            (this.isAwaitAllowed() && this.eatContextual(96) && (u = this.state.lastTokStartLoc),
            this.scope.enter(0),
            this.expect(10),
            this.match(13))
          )
            return u !== null && this.unexpected(u), this.parseFor(g, null);
          let N = this.isContextual(99);
          {
            let nl = this.isContextual(96) && this.startsAwaitUsing(),
              xl = nl || (this.isContextual(105) && this.startsUsingForOf()),
              Dl = (N && this.hasFollowingBindingAtom()) || xl;
            if (this.match(74) || this.match(75) || Dl) {
              let jl = this.startNode(),
                Zl;
              nl
                ? ((Zl = 'await using'),
                  this.isAwaitAllowed() || this.raise(Wi.AwaitUsingNotInAsyncContext, { at: this.state.startLoc }),
                  this.next())
                : (Zl = this.state.value),
                this.next(),
                this.parseVar(jl, !0, Zl);
              let Zc = this.finishNode(jl, 'VariableDeclaration'),
                rh = this.match(58);
              return (
                rh && xl && this.raise(Wi.ForInUsing, { at: Zc }),
                (rh || this.isContextual(101)) && Zc.declarations.length === 1
                  ? this.parseForIn(g, Zc, u)
                  : (u !== null && this.unexpected(u), this.parseFor(g, Zc))
              );
            }
          }
          let _ = this.isContextual(95),
            Be = new Zh(),
            Cn = this.parseExpression(!0, Be),
            Yi = this.isContextual(101);
          if (
            (Yi &&
              (N && this.raise(Wi.ForOfLet, { at: Cn }),
              u === null && _ && Cn.type === 'Identifier' && this.raise(Wi.ForOfAsync, { at: Cn })),
            Yi || this.match(58))
          ) {
            this.checkDestructuringPrivate(Be), this.toAssignable(Cn, !0);
            let nl = Yi ? 'ForOfStatement' : 'ForInStatement';
            return this.checkLVal(Cn, { in: { type: nl } }), this.parseForIn(g, Cn, u);
          } else this.checkExpressionErrors(Be, !0);
          return u !== null && this.unexpected(u), this.parseFor(g, Cn);
        }
        parseFunctionStatement(g, u, N) {
          return this.next(), this.parseFunction(g, 1 | (N ? 2 : 0) | (u ? 8 : 0));
        }
        parseIfStatement(g) {
          return (
            this.next(),
            (g.test = this.parseHeaderExpression()),
            (g.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration()),
            (g.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null),
            this.finishNode(g, 'IfStatement')
          );
        }
        parseReturnStatement(g) {
          return (
            !this.prodParam.hasReturn &&
              !this.options.allowReturnOutsideFunction &&
              this.raise(Wi.IllegalReturn, { at: this.state.startLoc }),
            this.next(),
            this.isLineTerminator() ? (g.argument = null) : ((g.argument = this.parseExpression()), this.semicolon()),
            this.finishNode(g, 'ReturnStatement')
          );
        }
        parseSwitchStatement(g) {
          this.next(), (g.discriminant = this.parseHeaderExpression());
          let u = (g.cases = []);
          this.expect(5), this.state.labels.push(C0), this.scope.enter(0);
          let N;
          for (let _; !this.match(8); )
            if (this.match(61) || this.match(65)) {
              let Be = this.match(61);
              N && this.finishNode(N, 'SwitchCase'),
                u.push((N = this.startNode())),
                (N.consequent = []),
                this.next(),
                Be
                  ? (N.test = this.parseExpression())
                  : (_ && this.raise(Wi.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }),
                    (_ = !0),
                    (N.test = null)),
                this.expect(14);
            } else N ? N.consequent.push(this.parseStatementListItem()) : this.unexpected();
          return (
            this.scope.exit(),
            N && this.finishNode(N, 'SwitchCase'),
            this.next(),
            this.state.labels.pop(),
            this.finishNode(g, 'SwitchStatement')
          );
        }
        parseThrowStatement(g) {
          return (
            this.next(),
            this.hasPrecedingLineBreak() && this.raise(Wi.NewlineAfterThrow, { at: this.state.lastTokEndLoc }),
            (g.argument = this.parseExpression()),
            this.semicolon(),
            this.finishNode(g, 'ThrowStatement')
          );
        }
        parseCatchClauseParam() {
          let g = this.parseBindingAtom();
          return (
            this.scope.enter(this.options.annexB && g.type === 'Identifier' ? 8 : 0),
            this.checkLVal(g, { in: { type: 'CatchClause' }, binding: 9 }),
            g
          );
        }
        parseTryStatement(g) {
          if ((this.next(), (g.block = this.parseBlock()), (g.handler = null), this.match(62))) {
            let u = this.startNode();
            this.next(),
              this.match(10)
                ? (this.expect(10), (u.param = this.parseCatchClauseParam()), this.expect(11))
                : ((u.param = null), this.scope.enter(0)),
              (u.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))),
              this.scope.exit(),
              (g.handler = this.finishNode(u, 'CatchClause'));
          }
          return (
            (g.finalizer = this.eat(67) ? this.parseBlock() : null),
            !g.handler && !g.finalizer && this.raise(Wi.NoCatchOrFinally, { at: g }),
            this.finishNode(g, 'TryStatement')
          );
        }
        parseVarStatement(g, u, N = !1) {
          return this.next(), this.parseVar(g, !1, u, N), this.semicolon(), this.finishNode(g, 'VariableDeclaration');
        }
        parseWhileStatement(g) {
          return (
            this.next(),
            (g.test = this.parseHeaderExpression()),
            this.state.labels.push(Nd),
            (g.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.state.labels.pop(),
            this.finishNode(g, 'WhileStatement')
          );
        }
        parseWithStatement(g) {
          return (
            this.state.strict && this.raise(Wi.StrictWith, { at: this.state.startLoc }),
            this.next(),
            (g.object = this.parseHeaderExpression()),
            (g.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.finishNode(g, 'WithStatement')
          );
        }
        parseEmptyStatement(g) {
          return this.next(), this.finishNode(g, 'EmptyStatement');
        }
        parseLabeledStatement(g, u, N, _) {
          for (let Cn of this.state.labels) Cn.name === u && this.raise(Wi.LabelRedeclaration, { at: N, labelName: u });
          let Be = th(this.state.type) ? 'loop' : this.match(71) ? 'switch' : null;
          for (let Cn = this.state.labels.length - 1; Cn >= 0; Cn--) {
            let Yi = this.state.labels[Cn];
            if (Yi.statementStart === g.start) (Yi.statementStart = this.state.start), (Yi.kind = Be);
            else break;
          }
          return (
            this.state.labels.push({ name: u, kind: Be, statementStart: this.state.start }),
            (g.body = _ & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement()),
            this.state.labels.pop(),
            (g.label = N),
            this.finishNode(g, 'LabeledStatement')
          );
        }
        parseExpressionStatement(g, u, N) {
          return (g.expression = u), this.semicolon(), this.finishNode(g, 'ExpressionStatement');
        }
        parseBlock(g = !1, u = !0, N) {
          let _ = this.startNode();
          return (
            g && this.state.strictErrors.clear(),
            this.expect(5),
            u && this.scope.enter(0),
            this.parseBlockBody(_, g, !1, 8, N),
            u && this.scope.exit(),
            this.finishNode(_, 'BlockStatement')
          );
        }
        isValidDirective(g) {
          return (
            g.type === 'ExpressionStatement' &&
            g.expression.type === 'StringLiteral' &&
            !g.expression.extra.parenthesized
          );
        }
        parseBlockBody(g, u, N, _, Be) {
          let Cn = (g.body = []),
            Yi = (g.directives = []);
          this.parseBlockOrModuleBlockBody(Cn, u ? Yi : void 0, N, _, Be);
        }
        parseBlockOrModuleBlockBody(g, u, N, _, Be) {
          let Cn = this.state.strict,
            Yi = !1,
            nl = !1;
          for (; !this.match(_); ) {
            let xl = N ? this.parseModuleItem() : this.parseStatementListItem();
            if (u && !nl) {
              if (this.isValidDirective(xl)) {
                let Dl = this.stmtToDirective(xl);
                u.push(Dl), !Yi && Dl.value.value === 'use strict' && ((Yi = !0), this.setStrict(!0));
                continue;
              }
              (nl = !0), this.state.strictErrors.clear();
            }
            g.push(xl);
          }
          Be == null || Be.call(this, Yi), Cn || this.setStrict(!1), this.next();
        }
        parseFor(g, u) {
          return (
            (g.init = u),
            this.semicolon(!1),
            (g.test = this.match(13) ? null : this.parseExpression()),
            this.semicolon(!1),
            (g.update = this.match(11) ? null : this.parseExpression()),
            this.expect(11),
            (g.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(g, 'ForStatement')
          );
        }
        parseForIn(g, u, N) {
          let _ = this.match(58);
          return (
            this.next(),
            _ ? N !== null && this.unexpected(N) : (g.await = N !== null),
            u.type === 'VariableDeclaration' &&
              u.declarations[0].init != null &&
              (!_ ||
                !this.options.annexB ||
                this.state.strict ||
                u.kind !== 'var' ||
                u.declarations[0].id.type !== 'Identifier') &&
              this.raise(Wi.ForInOfLoopInitializer, { at: u, type: _ ? 'ForInStatement' : 'ForOfStatement' }),
            u.type === 'AssignmentPattern' && this.raise(Wi.InvalidLhs, { at: u, ancestor: { type: 'ForStatement' } }),
            (g.left = u),
            (g.right = _ ? this.parseExpression() : this.parseMaybeAssignAllowIn()),
            this.expect(11),
            (g.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(g, _ ? 'ForInStatement' : 'ForOfStatement')
          );
        }
        parseVar(g, u, N, _ = !1) {
          let Be = (g.declarations = []);
          for (g.kind = N; ; ) {
            let Cn = this.startNode();
            if (
              (this.parseVarId(Cn, N),
              (Cn.init = this.eat(29)
                ? u
                  ? this.parseMaybeAssignDisallowIn()
                  : this.parseMaybeAssignAllowIn()
                : null),
              Cn.init === null &&
                !_ &&
                (Cn.id.type !== 'Identifier' && !(u && (this.match(58) || this.isContextual(101)))
                  ? this.raise(Wi.DeclarationMissingInitializer, {
                      at: this.state.lastTokEndLoc,
                      kind: 'destructuring',
                    })
                  : N === 'const' &&
                    !(this.match(58) || this.isContextual(101)) &&
                    this.raise(Wi.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: 'const' })),
              Be.push(this.finishNode(Cn, 'VariableDeclarator')),
              !this.eat(12))
            )
              break;
          }
          return g;
        }
        parseVarId(g, u) {
          let N = this.parseBindingAtom();
          this.checkLVal(N, { in: { type: 'VariableDeclarator' }, binding: u === 'var' ? 5 : 8201 }), (g.id = N);
        }
        parseAsyncFunctionExpression(g) {
          return this.parseFunction(g, 8);
        }
        parseFunction(g, u = 0) {
          let N = u & 2,
            _ = !!(u & 1),
            Be = _ && !(u & 4),
            Cn = !!(u & 8);
          this.initFunction(g, Cn),
            this.match(55) &&
              (N && this.raise(Wi.GeneratorInSingleStatementContext, { at: this.state.startLoc }),
              this.next(),
              (g.generator = !0)),
            _ && (g.id = this.parseFunctionId(Be));
          let Yi = this.state.maybeInArrowParameters;
          return (
            (this.state.maybeInArrowParameters = !1),
            this.scope.enter(2),
            this.prodParam.enter(kd(Cn, g.generator)),
            _ || (g.id = this.parseFunctionId()),
            this.parseFunctionParams(g, !1),
            this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(g, _ ? 'FunctionDeclaration' : 'FunctionExpression');
            }),
            this.prodParam.exit(),
            this.scope.exit(),
            _ && !N && this.registerFunctionStatementId(g),
            (this.state.maybeInArrowParameters = Yi),
            g
          );
        }
        parseFunctionId(g) {
          return g || Ul(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(g, u) {
          this.expect(10),
            this.expressionScope.enter(o0()),
            (g.params = this.parseBindingList(11, 41, 2 | (u ? 4 : 0))),
            this.expressionScope.exit();
        }
        registerFunctionStatementId(g) {
          g.id &&
            this.scope.declareName(
              g.id.name,
              !this.options.annexB || this.state.strict || g.generator || g.async
                ? this.scope.treatFunctionsAsVar
                  ? 5
                  : 8201
                : 17,
              g.id.loc.start,
            );
        }
        parseClass(g, u, N) {
          this.next();
          let _ = this.state.strict;
          return (
            (this.state.strict = !0),
            this.parseClassId(g, u, N),
            this.parseClassSuper(g),
            (g.body = this.parseClassBody(!!g.superClass, _)),
            this.finishNode(g, u ? 'ClassDeclaration' : 'ClassExpression')
          );
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(g) {
          return !g.computed && !g.static && (g.key.name === 'constructor' || g.key.value === 'constructor');
        }
        parseClassBody(g, u) {
          this.classScope.enter();
          let N = { hadConstructor: !1, hadSuperClass: g },
            _ = [],
            Be = this.startNode();
          if (
            ((Be.body = []),
            this.expect(5),
            this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (_.length > 0) throw this.raise(Wi.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                  continue;
                }
                if (this.match(26)) {
                  _.push(this.parseDecorator());
                  continue;
                }
                let Cn = this.startNode();
                _.length && ((Cn.decorators = _), this.resetStartLocationFromNode(Cn, _[0]), (_ = [])),
                  this.parseClassMember(Be, Cn, N),
                  Cn.kind === 'constructor' &&
                    Cn.decorators &&
                    Cn.decorators.length > 0 &&
                    this.raise(Wi.DecoratorConstructor, { at: Cn });
              }
            }),
            (this.state.strict = u),
            this.next(),
            _.length)
          )
            throw this.raise(Wi.TrailingDecorator, { at: this.state.startLoc });
          return this.classScope.exit(), this.finishNode(Be, 'ClassBody');
        }
        parseClassMemberFromModifier(g, u) {
          let N = this.parseIdentifier(!0);
          if (this.isClassMethod()) {
            let _ = u;
            return (
              (_.kind = 'method'),
              (_.computed = !1),
              (_.key = N),
              (_.static = !1),
              this.pushClassMethod(g, _, !1, !1, !1, !1),
              !0
            );
          } else if (this.isClassProperty()) {
            let _ = u;
            return (_.computed = !1), (_.key = N), (_.static = !1), g.body.push(this.parseClassProperty(_)), !0;
          }
          return this.resetPreviousNodeTrailingComments(N), !1;
        }
        parseClassMember(g, u, N) {
          let _ = this.isContextual(104);
          if (_) {
            if (this.parseClassMemberFromModifier(g, u)) return;
            if (this.eat(5)) {
              this.parseClassStaticBlock(g, u);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(g, u, N, _);
        }
        parseClassMemberWithIsStatic(g, u, N, _) {
          let Be = u,
            Cn = u,
            Yi = u,
            nl = u,
            xl = u,
            Dl = Be,
            jl = Be;
          if (((u.static = _), this.parsePropertyNamePrefixOperator(u), this.eat(55))) {
            Dl.kind = 'method';
            let Th = this.match(136);
            if ((this.parseClassElementName(Dl), Th)) {
              this.pushClassPrivateMethod(g, Cn, !0, !1);
              return;
            }
            this.isNonstaticConstructor(Be) && this.raise(Wi.ConstructorIsGenerator, { at: Be.key }),
              this.pushClassMethod(g, Be, !0, !1, !1, !1);
            return;
          }
          let Zl = Ul(this.state.type) && !this.state.containsEsc,
            Zc = this.match(136),
            rh = this.parseClassElementName(u),
            Ph = this.state.startLoc;
          if ((this.parsePostMemberNameModifiers(jl), this.isClassMethod())) {
            if (((Dl.kind = 'method'), Zc)) {
              this.pushClassPrivateMethod(g, Cn, !1, !1);
              return;
            }
            let Th = this.isNonstaticConstructor(Be),
              Oh = !1;
            Th &&
              ((Be.kind = 'constructor'),
              N.hadConstructor && !this.hasPlugin('typescript') && this.raise(Wi.DuplicateConstructor, { at: rh }),
              Th && this.hasPlugin('typescript') && u.override && this.raise(Wi.OverrideOnConstructor, { at: rh }),
              (N.hadConstructor = !0),
              (Oh = N.hadSuperClass)),
              this.pushClassMethod(g, Be, !1, !1, Th, Oh);
          } else if (this.isClassProperty()) Zc ? this.pushClassPrivateProperty(g, nl) : this.pushClassProperty(g, Yi);
          else if (Zl && rh.name === 'async' && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(rh);
            let Th = this.eat(55);
            jl.optional && this.unexpected(Ph), (Dl.kind = 'method');
            let Oh = this.match(136);
            this.parseClassElementName(Dl),
              this.parsePostMemberNameModifiers(jl),
              Oh
                ? this.pushClassPrivateMethod(g, Cn, Th, !0)
                : (this.isNonstaticConstructor(Be) && this.raise(Wi.ConstructorIsAsync, { at: Be.key }),
                  this.pushClassMethod(g, Be, Th, !0, !1, !1));
          } else if (Zl && (rh.name === 'get' || rh.name === 'set') && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(rh), (Dl.kind = rh.name);
            let Th = this.match(136);
            this.parseClassElementName(Be),
              Th
                ? this.pushClassPrivateMethod(g, Cn, !1, !1)
                : (this.isNonstaticConstructor(Be) && this.raise(Wi.ConstructorIsAccessor, { at: Be.key }),
                  this.pushClassMethod(g, Be, !1, !1, !1, !1)),
              this.checkGetterSetterParams(Be);
          } else if (Zl && rh.name === 'accessor' && !this.isLineTerminator()) {
            this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(rh);
            let Th = this.match(136);
            this.parseClassElementName(Yi), this.pushClassAccessorProperty(g, xl, Th);
          } else
            this.isLineTerminator()
              ? Zc
                ? this.pushClassPrivateProperty(g, nl)
                : this.pushClassProperty(g, Yi)
              : this.unexpected();
        }
        parseClassElementName(g) {
          let { type: u, value: N } = this.state;
          if (
            ((u === 130 || u === 131) &&
              g.static &&
              N === 'prototype' &&
              this.raise(Wi.StaticPrototype, { at: this.state.startLoc }),
            u === 136)
          ) {
            N === 'constructor' && this.raise(Wi.ConstructorClassPrivateField, { at: this.state.startLoc });
            let _ = this.parsePrivateName();
            return (g.key = _), _;
          }
          return this.parsePropertyName(g);
        }
        parseClassStaticBlock(g, u) {
          var N;
          this.scope.enter(208);
          let _ = this.state.labels;
          (this.state.labels = []), this.prodParam.enter(gd);
          let Be = (u.body = []);
          this.parseBlockOrModuleBlockBody(Be, void 0, !1, 8),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.labels = _),
            g.body.push(this.finishNode(u, 'StaticBlock')),
            (N = u.decorators) != null && N.length && this.raise(Wi.DecoratorStaticBlock, { at: u });
        }
        pushClassProperty(g, u) {
          !u.computed &&
            (u.key.name === 'constructor' || u.key.value === 'constructor') &&
            this.raise(Wi.ConstructorClassField, { at: u.key }),
            g.body.push(this.parseClassProperty(u));
        }
        pushClassPrivateProperty(g, u) {
          let N = this.parseClassPrivateProperty(u);
          g.body.push(N), this.classScope.declarePrivateName(this.getPrivateNameSV(N.key), 0, N.key.loc.start);
        }
        pushClassAccessorProperty(g, u, N) {
          if (!N && !u.computed) {
            let Be = u.key;
            (Be.name === 'constructor' || Be.value === 'constructor') &&
              this.raise(Wi.ConstructorClassField, { at: Be });
          }
          let _ = this.parseClassAccessorProperty(u);
          g.body.push(_), N && this.classScope.declarePrivateName(this.getPrivateNameSV(_.key), 0, _.key.loc.start);
        }
        pushClassMethod(g, u, N, _, Be, Cn) {
          g.body.push(this.parseMethod(u, N, _, Be, Cn, 'ClassMethod', !0));
        }
        pushClassPrivateMethod(g, u, N, _) {
          let Be = this.parseMethod(u, N, _, !1, !1, 'ClassPrivateMethod', !0);
          g.body.push(Be);
          let Cn = Be.kind === 'get' ? (Be.static ? 6 : 2) : Be.kind === 'set' ? (Be.static ? 5 : 1) : 0;
          this.declareClassPrivateMethodInScope(Be, Cn);
        }
        declareClassPrivateMethodInScope(g, u) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(g.key), u, g.key.loc.start);
        }
        parsePostMemberNameModifiers(g) {}
        parseClassPrivateProperty(g) {
          return this.parseInitializer(g), this.semicolon(), this.finishNode(g, 'ClassPrivateProperty');
        }
        parseClassProperty(g) {
          return this.parseInitializer(g), this.semicolon(), this.finishNode(g, 'ClassProperty');
        }
        parseClassAccessorProperty(g) {
          return this.parseInitializer(g), this.semicolon(), this.finishNode(g, 'ClassAccessorProperty');
        }
        parseInitializer(g) {
          this.scope.enter(80),
            this.expressionScope.enter(of()),
            this.prodParam.enter(gd),
            (g.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null),
            this.expressionScope.exit(),
            this.prodParam.exit(),
            this.scope.exit();
        }
        parseClassId(g, u, N, _ = 8331) {
          if (Ul(this.state.type)) (g.id = this.parseIdentifier()), u && this.declareNameFromIdentifier(g.id, _);
          else if (N || !u) g.id = null;
          else throw this.raise(Wi.MissingClassName, { at: this.state.startLoc });
        }
        parseClassSuper(g) {
          g.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(g, u) {
          let N = this.parseMaybeImportPhase(g, !0),
            _ = this.maybeParseExportDefaultSpecifier(g, N),
            Be = !_ || this.eat(12),
            Cn = Be && this.eatExportStar(g),
            Yi = Cn && this.maybeParseExportNamespaceSpecifier(g),
            nl = Be && (!Yi || this.eat(12)),
            xl = _ || Cn;
          if (Cn && !Yi) {
            if ((_ && this.unexpected(), u)) throw this.raise(Wi.UnsupportedDecoratorExport, { at: g });
            return this.parseExportFrom(g, !0), this.finishNode(g, 'ExportAllDeclaration');
          }
          let Dl = this.maybeParseExportNamedSpecifiers(g);
          _ && Be && !Cn && !Dl && this.unexpected(null, 5), Yi && nl && this.unexpected(null, 97);
          let jl;
          if (xl || Dl) {
            if (((jl = !1), u)) throw this.raise(Wi.UnsupportedDecoratorExport, { at: g });
            this.parseExportFrom(g, xl);
          } else jl = this.maybeParseExportDeclaration(g);
          if (xl || Dl || jl) {
            var Zl;
            let Zc = g;
            if (
              (this.checkExport(Zc, !0, !1, !!Zc.source),
              ((Zl = Zc.declaration) == null ? void 0 : Zl.type) === 'ClassDeclaration')
            )
              this.maybeTakeDecorators(u, Zc.declaration, Zc);
            else if (u) throw this.raise(Wi.UnsupportedDecoratorExport, { at: g });
            return this.finishNode(Zc, 'ExportNamedDeclaration');
          }
          if (this.eat(65)) {
            let Zc = g,
              rh = this.parseExportDefaultExpression();
            if (((Zc.declaration = rh), rh.type === 'ClassDeclaration')) this.maybeTakeDecorators(u, rh, Zc);
            else if (u) throw this.raise(Wi.UnsupportedDecoratorExport, { at: g });
            return this.checkExport(Zc, !0, !0), this.finishNode(Zc, 'ExportDefaultDeclaration');
          }
          this.unexpected(null, 5);
        }
        eatExportStar(g) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(g, u) {
          if (u || this.isExportDefaultSpecifier()) {
            this.expectPlugin('exportDefaultFrom', u == null ? void 0 : u.loc.start);
            let N = u || this.parseIdentifier(!0),
              _ = this.startNodeAtNode(N);
            return (_.exported = N), (g.specifiers = [this.finishNode(_, 'ExportDefaultSpecifier')]), !0;
          }
          return !1;
        }
        maybeParseExportNamespaceSpecifier(g) {
          if (this.isContextual(93)) {
            g.specifiers || (g.specifiers = []);
            let u = this.startNodeAt(this.state.lastTokStartLoc);
            return (
              this.next(),
              (u.exported = this.parseModuleExportName()),
              g.specifiers.push(this.finishNode(u, 'ExportNamespaceSpecifier')),
              !0
            );
          }
          return !1;
        }
        maybeParseExportNamedSpecifiers(g) {
          if (this.match(5)) {
            g.specifiers || (g.specifiers = []);
            let u = g.exportKind === 'type';
            return (
              g.specifiers.push(...this.parseExportSpecifiers(u)),
              (g.source = null),
              (g.declaration = null),
              this.hasPlugin('importAssertions') && (g.assertions = []),
              !0
            );
          }
          return !1;
        }
        maybeParseExportDeclaration(g) {
          return this.shouldParseExportDeclaration()
            ? ((g.specifiers = []),
              (g.source = null),
              this.hasPlugin('importAssertions') && (g.assertions = []),
              (g.declaration = this.parseExportDeclaration(g)),
              !0)
            : !1;
        }
        isAsyncFunction() {
          if (!this.isContextual(95)) return !1;
          let g = this.nextTokenInLineStart();
          return this.isUnparsedContextual(g, 'function');
        }
        parseExportDefaultExpression() {
          let g = this.startNode();
          if (this.match(68)) return this.next(), this.parseFunction(g, 5);
          if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(g, 13);
          if (this.match(80)) return this.parseClass(g, !0, !0);
          if (this.match(26))
            return (
              this.hasPlugin('decorators') &&
                this.getPluginOption('decorators', 'decoratorsBeforeExport') === !0 &&
                this.raise(Wi.DecoratorBeforeExport, { at: this.state.startLoc }),
              this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0)
            );
          if (this.match(75) || this.match(74) || this.isLet())
            throw this.raise(Wi.UnsupportedDefaultExport, { at: this.state.startLoc });
          let u = this.parseMaybeAssignAllowIn();
          return this.semicolon(), u;
        }
        parseExportDeclaration(g) {
          return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
        }
        isExportDefaultSpecifier() {
          let { type: g } = this.state;
          if (Ul(g)) {
            if ((g === 95 && !this.state.containsEsc) || g === 99) return !1;
            if ((g === 128 || g === 127) && !this.state.containsEsc) {
              let { type: _ } = this.lookahead();
              if ((Ul(_) && _ !== 97) || _ === 5) return this.expectOnePlugin(['flow', 'typescript']), !1;
            }
          } else if (!this.match(65)) return !1;
          let u = this.nextTokenStart(),
            N = this.isUnparsedContextual(u, 'from');
          if (this.input.charCodeAt(u) === 44 || (Ul(this.state.type) && N)) return !0;
          if (this.match(65) && N) {
            let _ = this.input.charCodeAt(this.nextTokenStartSince(u + 4));
            return _ === 34 || _ === 39;
          }
          return !1;
        }
        parseExportFrom(g, u) {
          this.eatContextual(97)
            ? ((g.source = this.parseImportSource()),
              this.checkExport(g),
              this.maybeParseImportAttributes(g),
              this.checkJSONModuleImport(g))
            : u && this.unexpected(),
            this.semicolon();
        }
        shouldParseExportDeclaration() {
          let { type: g } = this.state;
          return g === 26 && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators'))
            ? (this.getPluginOption('decorators', 'decoratorsBeforeExport') === !0 &&
                this.raise(Wi.DecoratorBeforeExport, { at: this.state.startLoc }),
              !0)
            : g === 74 || g === 75 || g === 68 || g === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(g, u, N, _) {
          if (u) {
            var Be;
            if (N) {
              if ((this.checkDuplicateExports(g, 'default'), this.hasPlugin('exportDefaultFrom'))) {
                var Cn;
                let Yi = g.declaration;
                Yi.type === 'Identifier' &&
                  Yi.name === 'from' &&
                  Yi.end - Yi.start === 4 &&
                  !((Cn = Yi.extra) != null && Cn.parenthesized) &&
                  this.raise(Wi.ExportDefaultFromAsIdentifier, { at: Yi });
              }
            } else if ((Be = g.specifiers) != null && Be.length)
              for (let Yi of g.specifiers) {
                let { exported: nl } = Yi,
                  xl = nl.type === 'Identifier' ? nl.name : nl.value;
                if ((this.checkDuplicateExports(Yi, xl), !_ && Yi.local)) {
                  let { local: Dl } = Yi;
                  Dl.type !== 'Identifier'
                    ? this.raise(Wi.ExportBindingIsString, { at: Yi, localName: Dl.value, exportName: xl })
                    : (this.checkReservedWord(Dl.name, Dl.loc.start, !0, !1), this.scope.checkLocalExport(Dl));
                }
              }
            else if (g.declaration) {
              if (g.declaration.type === 'FunctionDeclaration' || g.declaration.type === 'ClassDeclaration') {
                let Yi = g.declaration.id;
                if (!Yi) throw new Error('Assertion failure');
                this.checkDuplicateExports(g, Yi.name);
              } else if (g.declaration.type === 'VariableDeclaration')
                for (let Yi of g.declaration.declarations) this.checkDeclaration(Yi.id);
            }
          }
        }
        checkDeclaration(g) {
          if (g.type === 'Identifier') this.checkDuplicateExports(g, g.name);
          else if (g.type === 'ObjectPattern') for (let u of g.properties) this.checkDeclaration(u);
          else if (g.type === 'ArrayPattern') for (let u of g.elements) u && this.checkDeclaration(u);
          else
            g.type === 'ObjectProperty'
              ? this.checkDeclaration(g.value)
              : g.type === 'RestElement'
              ? this.checkDeclaration(g.argument)
              : g.type === 'AssignmentPattern' && this.checkDeclaration(g.left);
        }
        checkDuplicateExports(g, u) {
          this.exportedIdentifiers.has(u) &&
            (u === 'default'
              ? this.raise(Wi.DuplicateDefaultExport, { at: g })
              : this.raise(Wi.DuplicateExport, { at: g, exportName: u })),
            this.exportedIdentifiers.add(u);
        }
        parseExportSpecifiers(g) {
          let u = [],
            N = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (N) N = !1;
            else if ((this.expect(12), this.eat(8))) break;
            let _ = this.isContextual(128),
              Be = this.match(131),
              Cn = this.startNode();
            (Cn.local = this.parseModuleExportName()), u.push(this.parseExportSpecifier(Cn, Be, g, _));
          }
          return u;
        }
        parseExportSpecifier(g, u, N, _) {
          return (
            this.eatContextual(93)
              ? (g.exported = this.parseModuleExportName())
              : u
              ? (g.exported = Nf(g.local))
              : g.exported || (g.exported = ed(g.local)),
            this.finishNode(g, 'ExportSpecifier')
          );
        }
        parseModuleExportName() {
          if (this.match(131)) {
            let g = this.parseStringLiteral(this.state.value),
              u = g.value.match(Jf);
            return (
              u && this.raise(Wi.ModuleExportNameHasLoneSurrogate, { at: g, surrogateCharCode: u[0].charCodeAt(0) }), g
            );
          }
          return this.parseIdentifier(!0);
        }
        isJSONModuleImport(g) {
          return g.assertions != null
            ? g.assertions.some(
                ({ key: u, value: N }) =>
                  N.value === 'json' && (u.type === 'Identifier' ? u.name === 'type' : u.value === 'type'),
              )
            : !1;
        }
        checkImportReflection(g) {
          if (g.module) {
            var u;
            (g.specifiers.length !== 1 || g.specifiers[0].type !== 'ImportDefaultSpecifier') &&
              this.raise(Wi.ImportReflectionNotBinding, { at: g.specifiers[0].loc.start }),
              ((u = g.assertions) == null ? void 0 : u.length) > 0 &&
                this.raise(Wi.ImportReflectionHasAssertion, { at: g.specifiers[0].loc.start });
          }
        }
        checkJSONModuleImport(g) {
          if (this.isJSONModuleImport(g) && g.type !== 'ExportAllDeclaration') {
            let { specifiers: u } = g;
            if (u != null) {
              let N = u.find((_) => {
                let Be;
                if (
                  (_.type === 'ExportSpecifier' ? (Be = _.local) : _.type === 'ImportSpecifier' && (Be = _.imported),
                  Be !== void 0)
                )
                  return Be.type === 'Identifier' ? Be.name !== 'default' : Be.value !== 'default';
              });
              N !== void 0 && this.raise(Wi.ImportJSONBindingNotDefault, { at: N.loc.start });
            }
          }
        }
        isPotentialImportPhase(g) {
          return !g && this.isContextual(125);
        }
        applyImportPhase(g, u, N, _) {
          u ||
            (N === 'module'
              ? (this.expectPlugin('importReflection', _), (g.module = !0))
              : this.hasPlugin('importReflection') && (g.module = !1));
        }
        parseMaybeImportPhase(g, u) {
          if (!this.isPotentialImportPhase(u)) return this.applyImportPhase(g, u, null), null;
          let N = this.parseIdentifier(!0),
            { type: _ } = this.state;
          return (gl(_) ? _ !== 97 || this.lookaheadCharCode() === 102 : _ !== 12)
            ? (this.resetPreviousIdentifierLeadingComments(N), this.applyImportPhase(g, u, N.name, N.loc.start), null)
            : (this.applyImportPhase(g, u, null), N);
        }
        isPrecedingIdImportPhase(g) {
          let { type: u } = this.state;
          return Ul(u) ? u !== 97 || this.lookaheadCharCode() === 102 : u !== 12;
        }
        parseImport(g) {
          return this.match(131)
            ? this.parseImportSourceAndAttributes(g)
            : this.parseImportSpecifiersAndAfter(g, this.parseMaybeImportPhase(g, !1));
        }
        parseImportSpecifiersAndAfter(g, u) {
          g.specifiers = [];
          let N = !this.maybeParseDefaultImportSpecifier(g, u) || this.eat(12),
            _ = N && this.maybeParseStarImportSpecifier(g);
          return (
            N && !_ && this.parseNamedImportSpecifiers(g),
            this.expectContextual(97),
            this.parseImportSourceAndAttributes(g)
          );
        }
        parseImportSourceAndAttributes(g) {
          return (
            g.specifiers != null || (g.specifiers = []),
            (g.source = this.parseImportSource()),
            this.maybeParseImportAttributes(g),
            this.checkImportReflection(g),
            this.checkJSONModuleImport(g),
            this.semicolon(),
            this.finishNode(g, 'ImportDeclaration')
          );
        }
        parseImportSource() {
          return this.match(131) || this.unexpected(), this.parseExprAtom();
        }
        parseImportSpecifierLocal(g, u, N) {
          (u.local = this.parseIdentifier()), g.specifiers.push(this.finishImportSpecifier(u, N));
        }
        finishImportSpecifier(g, u, N = 8201) {
          return this.checkLVal(g.local, { in: { type: u }, binding: N }), this.finishNode(g, u);
        }
        parseImportAttributes() {
          this.expect(5);
          let g = [],
            u = new Set();
          do {
            if (this.match(8)) break;
            let N = this.startNode(),
              _ = this.state.value;
            if (
              (u.has(_) && this.raise(Wi.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: _ }),
              u.add(_),
              this.match(131) ? (N.key = this.parseStringLiteral(_)) : (N.key = this.parseIdentifier(!0)),
              this.expect(14),
              !this.match(131))
            )
              throw this.raise(Wi.ModuleAttributeInvalidValue, { at: this.state.startLoc });
            (N.value = this.parseStringLiteral(this.state.value)), g.push(this.finishNode(N, 'ImportAttribute'));
          } while (this.eat(12));
          return this.expect(8), g;
        }
        parseModuleAttributes() {
          let g = [],
            u = new Set();
          do {
            let N = this.startNode();
            if (
              ((N.key = this.parseIdentifier(!0)),
              N.key.name !== 'type' && this.raise(Wi.ModuleAttributeDifferentFromType, { at: N.key }),
              u.has(N.key.name) && this.raise(Wi.ModuleAttributesWithDuplicateKeys, { at: N.key, key: N.key.name }),
              u.add(N.key.name),
              this.expect(14),
              !this.match(131))
            )
              throw this.raise(Wi.ModuleAttributeInvalidValue, { at: this.state.startLoc });
            (N.value = this.parseStringLiteral(this.state.value)), g.push(this.finishNode(N, 'ImportAttribute'));
          } while (this.eat(12));
          return g;
        }
        maybeParseImportAttributes(g) {
          let u,
            N = !1;
          if (this.match(76)) {
            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
            this.next(),
              this.hasPlugin('moduleAttributes')
                ? (u = this.parseModuleAttributes())
                : (this.expectImportAttributesPlugin(), (u = this.parseImportAttributes())),
              (N = !0);
          } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
            this.hasPlugin('importAttributes')
              ? (this.getPluginOption('importAttributes', 'deprecatedAssertSyntax') !== !0 &&
                  this.raise(Wi.ImportAttributesUseAssert, { at: this.state.startLoc }),
                this.addExtra(g, 'deprecatedAssertSyntax', !0))
              : this.expectOnePlugin(['importAttributes', 'importAssertions']),
              this.next(),
              (u = this.parseImportAttributes());
          else if (this.hasPlugin('importAttributes') || this.hasPlugin('importAssertions')) u = [];
          else if (this.hasPlugin('moduleAttributes')) u = [];
          else return;
          !N && this.hasPlugin('importAssertions') ? (g.assertions = u) : (g.attributes = u);
        }
        maybeParseDefaultImportSpecifier(g, u) {
          if (u) {
            let N = this.startNodeAtNode(u);
            return (N.local = u), g.specifiers.push(this.finishImportSpecifier(N, 'ImportDefaultSpecifier')), !0;
          } else if (gl(this.state.type))
            return this.parseImportSpecifierLocal(g, this.startNode(), 'ImportDefaultSpecifier'), !0;
          return !1;
        }
        maybeParseStarImportSpecifier(g) {
          if (this.match(55)) {
            let u = this.startNode();
            return (
              this.next(),
              this.expectContextual(93),
              this.parseImportSpecifierLocal(g, u, 'ImportNamespaceSpecifier'),
              !0
            );
          }
          return !1;
        }
        parseNamedImportSpecifiers(g) {
          let u = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (u) u = !1;
            else {
              if (this.eat(14)) throw this.raise(Wi.DestructureNamedImport, { at: this.state.startLoc });
              if ((this.expect(12), this.eat(8))) break;
            }
            let N = this.startNode(),
              _ = this.match(131),
              Be = this.isContextual(128);
            N.imported = this.parseModuleExportName();
            let Cn = this.parseImportSpecifier(N, _, g.importKind === 'type' || g.importKind === 'typeof', Be, void 0);
            g.specifiers.push(Cn);
          }
        }
        parseImportSpecifier(g, u, N, _, Be) {
          if (this.eatContextual(93)) g.local = this.parseIdentifier();
          else {
            let { imported: Cn } = g;
            if (u) throw this.raise(Wi.ImportBindingIsString, { at: g, importName: Cn.value });
            this.checkReservedWord(Cn.name, g.loc.start, !0, !0), g.local || (g.local = ed(Cn));
          }
          return this.finishImportSpecifier(g, 'ImportSpecifier', Be);
        }
        isThisParam(g) {
          return g.type === 'Identifier' && g.name === 'this';
        }
      },
      gf = class extends Gf {
        constructor(g, u) {
          (g = D0(g)),
            super(g, u),
            (this.options = g),
            this.initializeScopes(),
            (this.plugins = Cd(this.options.plugins)),
            (this.filename = g.sourceFilename);
        }
        getScopeHandler() {
          return Xd;
        }
        parse() {
          this.enterInitialScopes();
          let g = this.startNode(),
            u = this.startNode();
          return this.nextToken(), (g.errors = null), this.parseTopLevel(g, u), (g.errors = this.state.errors), g;
        }
      };
    function Cd(g) {
      let u = new Map();
      for (let N of g) {
        let [_, Be] = Array.isArray(N) ? N : [N, {}];
        u.has(_) || u.set(_, Be || {});
      }
      return u;
    }
    function Yf(g, u) {
      var N;
      if (((N = u) == null ? void 0 : N.sourceType) === 'unambiguous') {
        u = Object.assign({}, u);
        try {
          u.sourceType = 'module';
          let _ = Od(u, g),
            Be = _.parse();
          if (_.sawUnambiguousESM) return Be;
          if (_.ambiguousScriptDifferentAst)
            try {
              return (u.sourceType = 'script'), Od(u, g).parse();
            } catch {}
          else Be.program.sourceType = 'script';
          return Be;
        } catch (_) {
          try {
            return (u.sourceType = 'script'), Od(u, g).parse();
          } catch {}
          throw _;
        }
      } else return Od(u, g).parse();
    }
    function Xf(g, u) {
      let N = Od(u, g);
      return N.options.strictMode && (N.state.strict = !0), N.getExpression();
    }
    function b0(g) {
      let u = {};
      for (let N of Object.keys(g)) u[N] = Fh(g[N]);
      return u;
    }
    var Md = b0(zc);
    function Od(g, u) {
      let N = gf;
      return g != null && g.plugins && (Kf(g.plugins), (N = Qf(g.plugins))), new N(g, u);
    }
    var yf = {};
    function Qf(g) {
      let u = y0.filter((Be) => Mh(g, Be)),
        N = u.join('/'),
        _ = yf[N];
      if (!_) {
        _ = gf;
        for (let Be of u) _ = Wd[Be](_);
        yf[N] = _;
      }
      return _;
    }
    (r.parse = Yf), (r.parseExpression = Xf), (r.tokTypes = Md);
  }),
  Ns$1 = Bt$1((r) => {
    Object.defineProperty(r, '__esModule', { value: !0 }),
      (r.extract = I),
      (r.parse = V),
      (r.parseWithComments = se),
      (r.print = Ee),
      (r.strip = L);
    var e = /\*\/$/,
      n = /^\/\*\*?/,
      s = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      o = /(^|\s+)\/\/([^\r\n]*)/g,
      a = /^(\r?\n)+/,
      l = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      f = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      m = /(\r?\n|^) *\* ?/g,
      v = [];
    function I(ar) {
      let $i = ar.match(s);
      return $i ? $i[0].trimLeft() : '';
    }
    function L(ar) {
      let $i = ar.match(s);
      return $i && $i[0] ? ar.substring($i[0].length) : ar;
    }
    function V(ar) {
      return se(ar).pragmas;
    }
    function se(ar) {
      let $i = `
`;
      ar = ar.replace(n, '').replace(e, '').replace(m, '$1');
      let tl = '';
      for (; tl !== ar; ) (tl = ar), (ar = ar.replace(l, `${$i}$1 $2${$i}`));
      ar = ar.replace(a, '').trimRight();
      let Wi = Object.create(null),
        hl = ar.replace(f, '').replace(a, '').trimRight(),
        fl;
      for (; (fl = f.exec(ar)); ) {
        let dl = fl[2].replace(o, '');
        typeof Wi[fl[1]] == 'string' || Array.isArray(Wi[fl[1]])
          ? (Wi[fl[1]] = v.concat(Wi[fl[1]], dl))
          : (Wi[fl[1]] = dl);
      }
      return { comments: hl, pragmas: Wi };
    }
    function Ee({ comments: ar = '', pragmas: $i = {} }) {
      let tl = `
`,
        Wi = '/**',
        hl = ' *',
        fl = ' */',
        dl = Object.keys($i),
        Al = dl
          .map((vl) => ht(vl, $i[vl]))
          .reduce((vl, kl) => vl.concat(kl), [])
          .map((vl) => `${hl} ${vl}${tl}`)
          .join('');
      if (!ar) {
        if (dl.length === 0) return '';
        if (dl.length === 1 && !Array.isArray($i[dl[0]])) {
          let vl = $i[dl[0]];
          return `${Wi} ${ht(dl[0], vl)[0]}${fl}`;
        }
      }
      let Fl =
        ar
          .split(tl)
          .map((vl) => `${hl} ${vl}`)
          .join(tl) + tl;
      return Wi + tl + (ar ? Fl : '') + (ar && dl.length ? hl + tl : '') + Al + fl;
    }
    function ht(ar, $i) {
      return v.concat($i).map((tl) => `@${ar} ${tl}`.trim());
    }
  }),
  Ft$1 = {};
si$1(Ft$1, { parsers: () => da$1 });
var ze$1 = qe$1(kt$1(), 1);
function Ir$1(r) {
  let e = [];
  for (let n of r)
    try {
      return n();
    } catch (s) {
      e.push(s);
    }
  throw Object.assign(new Error('All combinations failed'), { errors: e });
}
var ms$1 = Ir$1;
function Nr$1(r) {
  if (!r.startsWith('#!')) return '';
  let e = r.indexOf(`
`);
  return e === -1 ? r : r.slice(0, e);
}
var _e$1 = Nr$1;
function kr$1(r, e) {
  if (e === !1) return !1;
  if (r.charAt(e) === '/' && r.charAt(e + 1) === '*') {
    for (let n = e + 2; n < r.length; ++n) if (r.charAt(n) === '*' && r.charAt(n + 1) === '/') return n + 2;
  }
  return e;
}
var ys$1 = kr$1;
function vr$1(r, e, n) {
  let s = !!(n != null && n.backwards);
  if (e === !1) return !1;
  let o = r.charAt(e);
  if (s) {
    if (
      r.charAt(e - 1) === '\r' &&
      o ===
        `
`
    )
      return e - 2;
    if (
      o ===
        `
` ||
      o === '\r' ||
      o === '\u2028' ||
      o === '\u2029'
    )
      return e - 1;
  } else {
    if (
      o === '\r' &&
      r.charAt(e + 1) ===
        `
`
    )
      return e + 2;
    if (
      o ===
        `
` ||
      o === '\r' ||
      o === '\u2028' ||
      o === '\u2029'
    )
      return e + 1;
  }
  return e;
}
var xs$1 = vr$1;
function Ue$1(r) {
  return (e, n, s) => {
    let o = !!(s != null && s.backwards);
    if (n === !1) return !1;
    let { length: a } = e,
      l = n;
    for (; l >= 0 && l < a; ) {
      let f = e.charAt(l);
      if (r instanceof RegExp) {
        if (!r.test(f)) return l;
      } else if (!r.includes(f)) return l;
      o ? l-- : l++;
    }
    return l === -1 || l === a ? l : !1;
  };
}
var Ps$1 = Ue$1(' 	'),
  gs$1 = Ue$1(/[^\n\r]/);
function Lr$1(r, e) {
  return e === !1 ? !1 : r.charAt(e) === '/' && r.charAt(e + 1) === '/' ? gs$1(r, e) : e;
}
var Ts$1 = Lr$1;
function Dr$1(r, e) {
  let n = null,
    s = e;
  for (; s !== n; ) (n = s), (s = Ps$1(r, s)), (s = ys$1(r, s)), (s = Ts$1(r, s)), (s = xs$1(r, s));
  return s;
}
var bs$1 = Dr$1,
  ne$1 = qe$1(Ns$1(), 1);
function Vr$1(r) {
  let e = _e$1(r);
  e && (r = r.slice(e.length + 1));
  let n = (0, ne$1.extract)(r),
    { pragmas: s, comments: o } = (0, ne$1.parseWithComments)(n);
  return { shebang: e, text: r, pragmas: s, comments: o };
}
function ks$1(r) {
  let { pragmas: e } = Vr$1(r);
  return Object.prototype.hasOwnProperty.call(e, 'prettier') || Object.prototype.hasOwnProperty.call(e, 'format');
}
function zr$1(r) {
  return Array.isArray(r) && r.length > 0;
}
var Y$1 = zr$1;
function D$1(r) {
  var e;
  let n = r.range ? r.range[0] : r.start,
    s = ((e = r.declaration) == null ? void 0 : e.decorators) ?? r.decorators;
  return Y$1(s) ? Math.min(D$1(s[0]), n) : n;
}
function B$2(r) {
  return r.range ? r.range[1] : r.end;
}
function Kr$1(r) {
  return (
    (r = typeof r == 'function' ? { parse: r } : r),
    { astFormat: 'estree', hasPragma: ks$1, locStart: D$1, locEnd: B$2, ...r }
  );
}
var oe$1 = Kr$1;
function qr$1(r, e) {
  let n = new SyntaxError(r + ' (' + e.loc.start.line + ':' + e.loc.start.column + ')');
  return Object.assign(n, e);
}
var je$1 = qr$1;
function Hr$1(r) {
  let { message: e, loc: n } = r;
  return je$1(e.replace(/ \(.*\)$/, ''), {
    loc: { start: { line: n ? n.line : 0, column: n ? n.column + 1 : 0 } },
    cause: r,
  });
}
var Ae$1 = Hr$1,
  Wr$1 = (r, e, n) => {
    if (!(r && e == null)) return Array.isArray(e) || typeof e == 'string' ? e[n < 0 ? e.length + n : n] : e.at(n);
  },
  vt$1 = Wr$1;
function Jr$1(r) {
  return (r = new Set(r)), (e) => r.has(e == null ? void 0 : e.type);
}
var vs$1 = Jr$1,
  Xr$1 = vs$1(['Block', 'CommentBlock', 'MultiLine']),
  Se = Xr$1;
function Gr$1(r) {
  return Se(r) && r.value[0] === '*' && /@(?:type|satisfies)\b/.test(r.value);
}
var Ls$1 = Gr$1;
function Yr$1(r) {
  let e = `*${r.value}*`.split(`
`);
  return e.length > 1 && e.every((n) => n.trimStart()[0] === '*');
}
var Lt$1 = Yr$1,
  we$1 = null;
function Ce$1(r) {
  if (we$1 !== null && typeof we$1.property) {
    let e = we$1;
    return (we$1 = Ce$1.prototype = null), e;
  }
  return (we$1 = Ce$1.prototype = r ?? Object.create(null)), new Ce$1();
}
var Qr$1 = 10;
for (let r = 0; r <= Qr$1; r++) Ce$1();
function Dt$1(r) {
  return Ce$1(r);
}
function Zr$1(r, e = 'type') {
  Dt$1(r);
  function n(s) {
    let o = s[e],
      a = r[o];
    if (!Array.isArray(a)) throw Object.assign(new Error(`Missing visitor keys for '${o}'.`), { node: s });
    return a;
  }
  return n;
}
var Ds$1 = Zr$1,
  Ms$1 = {
    ArrayExpression: ['elements'],
    AssignmentExpression: ['left', 'right'],
    BinaryExpression: ['left', 'right'],
    InterpreterDirective: [],
    Directive: ['value'],
    DirectiveLiteral: [],
    BlockStatement: ['directives', 'body'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    CatchClause: ['param', 'body'],
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DoWhileStatement: ['test', 'body'],
    EmptyStatement: [],
    ExpressionStatement: ['expression'],
    File: ['program'],
    ForInStatement: ['left', 'right', 'body'],
    ForStatement: ['init', 'test', 'update', 'body'],
    FunctionDeclaration: ['id', 'params', 'body', 'returnType', 'typeParameters', 'predicate'],
    FunctionExpression: ['id', 'params', 'body', 'returnType', 'typeParameters'],
    Identifier: ['typeAnnotation', 'decorators'],
    IfStatement: ['test', 'consequent', 'alternate'],
    LabeledStatement: ['label', 'body'],
    StringLiteral: [],
    NumericLiteral: [],
    NullLiteral: [],
    BooleanLiteral: [],
    RegExpLiteral: [],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    Program: ['directives', 'body'],
    ObjectExpression: ['properties'],
    ObjectMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectProperty: ['key', 'value', 'decorators'],
    RestElement: ['argument', 'typeAnnotation', 'decorators'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    ParenthesizedExpression: ['expression'],
    SwitchCase: ['test', 'consequent'],
    SwitchStatement: ['discriminant', 'cases'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'],
    ArrayPattern: ['elements', 'typeAnnotation', 'decorators'],
    ArrowFunctionExpression: ['params', 'body', 'returnType', 'typeParameters', 'predicate'],
    ClassBody: ['body'],
    ClassExpression: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ClassDeclaration: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ExportAllDeclaration: ['source', 'attributes', 'assertions', 'exported'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes', 'assertions'],
    ExportSpecifier: ['local', 'exported'],
    ForOfStatement: ['left', 'right', 'body'],
    ImportDeclaration: ['specifiers', 'source', 'attributes', 'assertions'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['local', 'imported'],
    MetaProperty: ['meta', 'property'],
    ClassMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectPattern: ['properties', 'typeAnnotation', 'decorators'],
    SpreadElement: ['argument'],
    Super: [],
    TaggedTemplateExpression: ['tag', 'quasi', 'typeParameters', 'typeArguments'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    YieldExpression: ['argument'],
    AwaitExpression: ['argument'],
    Import: [],
    BigIntLiteral: [],
    ExportNamespaceSpecifier: ['exported'],
    OptionalMemberExpression: ['object', 'property'],
    OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    ClassProperty: ['key', 'value', 'typeAnnotation', 'decorators', 'variance'],
    ClassAccessorProperty: ['key', 'value', 'typeAnnotation', 'decorators'],
    ClassPrivateProperty: ['key', 'value', 'decorators', 'typeAnnotation', 'variance'],
    ClassPrivateMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    PrivateName: ['id'],
    StaticBlock: ['body'],
    AnyTypeAnnotation: [],
    ArrayTypeAnnotation: ['elementType'],
    BooleanTypeAnnotation: [],
    BooleanLiteralTypeAnnotation: [],
    NullLiteralTypeAnnotation: [],
    ClassImplements: ['id', 'typeParameters'],
    DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'],
    DeclareFunction: ['id', 'predicate'],
    DeclareInterface: ['id', 'typeParameters', 'extends', 'body'],
    DeclareModule: ['id', 'body'],
    DeclareModuleExports: ['typeAnnotation'],
    DeclareTypeAlias: ['id', 'typeParameters', 'right'],
    DeclareOpaqueType: ['id', 'typeParameters', 'supertype'],
    DeclareVariable: ['id'],
    DeclareExportDeclaration: ['declaration', 'specifiers', 'source'],
    DeclareExportAllDeclaration: ['source'],
    DeclaredPredicate: ['value'],
    ExistsTypeAnnotation: [],
    FunctionTypeAnnotation: ['typeParameters', 'params', 'rest', 'returnType', 'this'],
    FunctionTypeParam: ['name', 'typeAnnotation'],
    GenericTypeAnnotation: ['id', 'typeParameters'],
    InferredPredicate: [],
    InterfaceExtends: ['id', 'typeParameters'],
    InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    InterfaceTypeAnnotation: ['extends', 'body'],
    IntersectionTypeAnnotation: ['types'],
    MixedTypeAnnotation: [],
    EmptyTypeAnnotation: [],
    NullableTypeAnnotation: ['typeAnnotation'],
    NumberLiteralTypeAnnotation: [],
    NumberTypeAnnotation: [],
    ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'],
    ObjectTypeInternalSlot: ['id', 'value', 'optional', 'static', 'method'],
    ObjectTypeCallProperty: ['value'],
    ObjectTypeIndexer: ['id', 'key', 'value', 'variance'],
    ObjectTypeProperty: ['key', 'value', 'variance'],
    ObjectTypeSpreadProperty: ['argument'],
    OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'],
    QualifiedTypeIdentifier: ['id', 'qualification'],
    StringLiteralTypeAnnotation: [],
    StringTypeAnnotation: [],
    SymbolTypeAnnotation: [],
    ThisTypeAnnotation: [],
    TupleTypeAnnotation: ['types', 'elementTypes'],
    TypeofTypeAnnotation: ['argument'],
    TypeAlias: ['id', 'typeParameters', 'right'],
    TypeAnnotation: ['typeAnnotation'],
    TypeCastExpression: ['expression', 'typeAnnotation'],
    TypeParameter: ['bound', 'default', 'variance'],
    TypeParameterDeclaration: ['params'],
    TypeParameterInstantiation: ['params'],
    UnionTypeAnnotation: ['types'],
    Variance: [],
    VoidTypeAnnotation: [],
    EnumDeclaration: ['id', 'body'],
    EnumBooleanBody: ['members'],
    EnumNumberBody: ['members'],
    EnumStringBody: ['members'],
    EnumSymbolBody: ['members'],
    EnumBooleanMember: ['id', 'init'],
    EnumNumberMember: ['id', 'init'],
    EnumStringMember: ['id', 'init'],
    EnumDefaultedMember: ['id'],
    IndexedAccessType: ['objectType', 'indexType'],
    OptionalIndexedAccessType: ['objectType', 'indexType'],
    JSXAttribute: ['name', 'value'],
    JSXClosingElement: ['name'],
    JSXElement: ['openingElement', 'children', 'closingElement'],
    JSXEmptyExpression: [],
    JSXExpressionContainer: ['expression'],
    JSXSpreadChild: ['expression'],
    JSXIdentifier: [],
    JSXMemberExpression: ['object', 'property'],
    JSXNamespacedName: ['namespace', 'name'],
    JSXOpeningElement: ['name', 'attributes', 'typeArguments', 'typeParameters'],
    JSXSpreadAttribute: ['argument'],
    JSXText: [],
    JSXFragment: ['openingFragment', 'children', 'closingFragment'],
    JSXOpeningFragment: [],
    JSXClosingFragment: [],
    Noop: [],
    Placeholder: [],
    V8IntrinsicIdentifier: [],
    ArgumentPlaceholder: [],
    BindExpression: ['object', 'callee'],
    ImportAttribute: ['key', 'value'],
    Decorator: ['expression'],
    DoExpression: ['body'],
    ExportDefaultSpecifier: ['exported'],
    RecordExpression: ['properties'],
    TupleExpression: ['elements'],
    DecimalLiteral: [],
    ModuleExpression: ['body'],
    TopicReference: [],
    PipelineTopicExpression: ['expression'],
    PipelineBareFunction: ['callee'],
    PipelinePrimaryTopicReference: [],
    TSParameterProperty: ['parameter', 'decorators'],
    TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'],
    TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'],
    TSQualifiedName: ['left', 'right'],
    TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSPropertySignature: ['key', 'typeAnnotation'],
    TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSIndexSignature: ['parameters', 'typeAnnotation'],
    TSAnyKeyword: [],
    TSBooleanKeyword: [],
    TSBigIntKeyword: [],
    TSIntrinsicKeyword: [],
    TSNeverKeyword: [],
    TSNullKeyword: [],
    TSNumberKeyword: [],
    TSObjectKeyword: [],
    TSStringKeyword: [],
    TSSymbolKeyword: [],
    TSUndefinedKeyword: [],
    TSUnknownKeyword: [],
    TSVoidKeyword: [],
    TSThisType: [],
    TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'],
    TSTypePredicate: ['parameterName', 'typeAnnotation'],
    TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'],
    TSTypeLiteral: ['members'],
    TSArrayType: ['elementType'],
    TSTupleType: ['elementTypes'],
    TSOptionalType: ['typeAnnotation'],
    TSRestType: ['typeAnnotation'],
    TSNamedTupleMember: ['label', 'elementType'],
    TSUnionType: ['types'],
    TSIntersectionType: ['types'],
    TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'],
    TSInferType: ['typeParameter'],
    TSParenthesizedType: ['typeAnnotation'],
    TSTypeOperator: ['typeAnnotation'],
    TSIndexedAccessType: ['objectType', 'indexType'],
    TSMappedType: ['typeParameter', 'typeAnnotation', 'nameType'],
    TSLiteralType: ['literal'],
    TSExpressionWithTypeArguments: ['expression', 'typeParameters'],
    TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    TSInterfaceBody: ['body'],
    TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'],
    TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'],
    TSAsExpression: ['expression', 'typeAnnotation'],
    TSSatisfiesExpression: ['expression', 'typeAnnotation'],
    TSTypeAssertion: ['typeAnnotation', 'expression'],
    TSEnumDeclaration: ['id', 'members'],
    TSEnumMember: ['id', 'initializer'],
    TSModuleDeclaration: ['id', 'body'],
    TSModuleBlock: ['body'],
    TSImportType: ['argument', 'qualifier', 'typeParameters', 'typeArguments'],
    TSImportEqualsDeclaration: ['id', 'moduleReference'],
    TSExternalModuleReference: ['expression'],
    TSNonNullExpression: ['expression'],
    TSExportAssignment: ['expression'],
    TSNamespaceExportDeclaration: ['id'],
    TSTypeAnnotation: ['typeAnnotation'],
    TSTypeParameterInstantiation: ['params'],
    TSTypeParameterDeclaration: ['params'],
    TSTypeParameter: ['constraint', 'default', 'name'],
    ChainExpression: ['expression'],
    ExperimentalRestProperty: ['argument'],
    ExperimentalSpreadProperty: ['argument'],
    ImportExpression: ['source', 'attributes'],
    Literal: [],
    MethodDefinition: ['decorators', 'key', 'value'],
    PrivateIdentifier: [],
    Property: ['key', 'value'],
    PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'],
    AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'],
    TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'],
    TSAbstractKeyword: [],
    TSAbstractMethodDefinition: ['key', 'value'],
    TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'],
    TSAsyncKeyword: [],
    TSClassImplements: ['expression', 'typeArguments', 'typeParameters'],
    TSDeclareKeyword: [],
    TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'],
    TSExportKeyword: [],
    TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'],
    TSPrivateKeyword: [],
    TSProtectedKeyword: [],
    TSPublicKeyword: [],
    TSReadonlyKeyword: [],
    TSStaticKeyword: [],
    TSTemplateLiteralType: ['quasis', 'types'],
    BigIntLiteralTypeAnnotation: [],
    BigIntTypeAnnotation: [],
    ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'],
    DeclareEnum: ['id', 'body'],
    InferTypeAnnotation: ['typeParameter'],
    KeyofTypeAnnotation: ['argument'],
    ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'],
    QualifiedTypeofIdentifier: ['qualification', 'id'],
    TupleTypeLabeledElement: ['label', 'elementType', 'variance'],
    TupleTypeSpreadElement: ['label', 'typeAnnotation'],
    TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'],
    NGRoot: ['node'],
    NGPipeExpression: ['left', 'right', 'arguments'],
    NGChainedExpression: ['expressions'],
    NGEmptyExpression: [],
    NGMicrosyntax: ['body'],
    NGMicrosyntaxKey: [],
    NGMicrosyntaxExpression: ['expression', 'alias'],
    NGMicrosyntaxKeyedExpression: ['key', 'expression'],
    NGMicrosyntaxLet: ['key', 'value'],
    NGMicrosyntaxAs: ['key', 'alias'],
    JsExpressionRoot: ['node'],
    JsonRoot: ['node'],
    TSJSDocAllType: [],
    TSJSDocUnknownType: [],
    TSJSDocNullableType: ['typeAnnotation'],
    TSJSDocNonNullableType: ['typeAnnotation'],
    NeverTypeAnnotation: [],
    UndefinedTypeAnnotation: [],
    UnknownTypeAnnotation: [],
  },
  ea$1 = Ds$1(Ms$1),
  Os$1 = ea$1;
function Mt$1(r, e) {
  if (!(r !== null && typeof r == 'object')) return r;
  if (Array.isArray(r)) {
    for (let s = 0; s < r.length; s++) r[s] = Mt$1(r[s], e);
    return r;
  }
  let n = Os$1(r);
  for (let s = 0; s < n.length; s++) r[n[s]] = Mt$1(r[n[s]], e);
  return e(r) || r;
}
var $e$1 = Mt$1;
function ta$1(r, e) {
  let { parser: n, text: s } = e;
  if (r.type === 'File' && r.program.interpreter) {
    let {
      program: { interpreter: a },
      comments: l,
    } = r;
    delete r.program.interpreter, l.unshift(a);
  }
  if (n === 'babel') {
    let a = new Set();
    (r = $e$1(r, (l) => {
      var f;
      (f = l.leadingComments) != null && f.some(Ls$1) && a.add(D$1(l));
    })),
      (r = $e$1(r, (l) => {
        if (l.type === 'ParenthesizedExpression') {
          let { expression: f } = l;
          if (f.type === 'TypeCastExpression') return (f.range = l.range), f;
          let m = D$1(l);
          if (!a.has(m)) return (f.extra = { ...f.extra, parenthesized: !0 }), f;
        }
      }));
  }
  if (
    ((r = $e$1(r, (a) => {
      switch (a.type) {
        case 'LogicalExpression':
          if (Fs$1(a)) return Ot$1(a);
          break;
        case 'VariableDeclaration': {
          let l = vt$1(!1, a.declarations, -1);
          l != null && l.init && o(a, l);
          break;
        }
        case 'TSParenthesizedType':
          return a.typeAnnotation;
        case 'TSTypeParameter':
          if (typeof a.name == 'string') {
            let l = D$1(a);
            a.name = { type: 'Identifier', name: a.name, range: [l, l + a.name.length] };
          }
          break;
        case 'TopicReference':
          r.extra = { ...r.extra, __isUsingHackPipeline: !0 };
          break;
        case 'ExportAllDeclaration': {
          let { exported: l } = a;
          if (n === 'meriyah' && (l == null ? void 0 : l.type) === 'Identifier') {
            let f = s.slice(D$1(l), B$2(l));
            (f.startsWith('"') || f.startsWith("'")) &&
              (a.exported = { ...a.exported, type: 'Literal', value: a.exported.name, raw: f });
          }
          break;
        }
        case 'TSUnionType':
        case 'TSIntersectionType':
          if (a.types.length === 1) return a.types[0];
          break;
      }
    })),
    Y$1(r.comments))
  ) {
    let a = vt$1(!1, r.comments, -1);
    for (let l = r.comments.length - 2; l >= 0; l--) {
      let f = r.comments[l];
      B$2(f) === D$1(a) &&
        Se(f) &&
        Se(a) &&
        Lt$1(f) &&
        Lt$1(a) &&
        (r.comments.splice(l + 1, 1), (f.value += '*//*' + a.value), (f.range = [D$1(f), B$2(a)])),
        (a = f);
    }
  }
  return r.type === 'Program' && (r.range = [0, s.length]), r;
  function o(a, l) {
    s[B$2(l)] !== ';' && (a.range = [D$1(a), B$2(l)]);
  }
}
function Fs$1(r) {
  return r.type === 'LogicalExpression' && r.right.type === 'LogicalExpression' && r.operator === r.right.operator;
}
function Ot$1(r) {
  return Fs$1(r)
    ? Ot$1({
        type: 'LogicalExpression',
        operator: r.operator,
        left: Ot$1({
          type: 'LogicalExpression',
          operator: r.operator,
          left: r.left,
          right: r.right.left,
          range: [D$1(r.left), B$2(r.right.left)],
        }),
        right: r.right.right,
        range: [D$1(r), B$2(r)],
      })
    : r;
}
var Bs$1 = ta$1;
function sa$1(r) {
  let { filepath: e } = r;
  if (e) {
    if (((e = e.toLowerCase()), e.endsWith('.cjs'))) return 'script';
    if (e.endsWith('.mjs')) return 'module';
  }
}
var Rs$1 = sa$1;
function ia$1(r, e) {
  let { type: n = 'JsExpressionRoot', rootMarker: s, text: o } = e,
    { tokens: a, comments: l } = r;
  return (
    delete r.tokens,
    delete r.comments,
    { tokens: a, comments: l, type: n, node: r, range: [0, o.length], rootMarker: s }
  );
}
var Ve$1 = ia$1,
  he$1 = (r) => oe$1(la$1(r)),
  ra$1 = {
    sourceType: 'module',
    allowImportExportEverywhere: !0,
    allowReturnOutsideFunction: !0,
    allowNewTargetOutsideFunction: !0,
    allowSuperOutsideMethod: !0,
    allowUndeclaredExports: !0,
    errorRecovery: !0,
    createParenthesizedExpressions: !0,
    plugins: [
      'doExpressions',
      'exportDefaultFrom',
      'functionBind',
      'functionSent',
      'throwExpressions',
      'partialApplication',
      'decorators',
      'decimal',
      'moduleBlocks',
      'asyncDoExpressions',
      'regexpUnicodeSets',
      'destructuringPrivate',
      'decoratorAutoAccessors',
      'importReflection',
      'explicitResourceManagement',
      ['importAttributes', { deprecatedAssertSyntax: !0 }],
    ],
    tokens: !0,
    ranges: !0,
  },
  aa$1 = ['recordAndTuple', { syntaxType: 'hash' }],
  _s$1 = 'v8intrinsic',
  Us$1 = [
    ['pipelineOperator', { proposal: 'hack', topicToken: '%' }],
    ['pipelineOperator', { proposal: 'minimal' }],
    ['pipelineOperator', { proposal: 'fsharp' }],
  ],
  R = (r, e = ra$1) => ({ ...e, plugins: [...e.plugins, ...r] }),
  na$1 = /@(?:no)?flow\b/;
function oa$1(r, e) {
  var n;
  if ((n = e.filepath) != null && n.endsWith('.js.flow')) return !0;
  let s = _e$1(r);
  s && (r = r.slice(s.length));
  let o = bs$1(r, 0);
  return o !== !1 && (r = r.slice(0, o)), na$1.test(r);
}
function ha$1(r, e, n) {
  let s = r(e, n),
    o = s.errors.find((a) => !ca$1.has(a.reasonCode));
  if (o) throw o;
  return s;
}
function la$1({ isExpression: r = !1, optionsCombinations: e }) {
  return (n, s = {}) => {
    if ((s.parser === 'babel' || s.parser === '__babel_estree') && oa$1(n, s))
      return (s.parser = 'babel-flow'), qs$1.parse(n, s);
    let o = e;
    (s.__babelSourceType ?? Rs$1(s)) === 'script' && (o = o.map((m) => ({ ...m, sourceType: 'script' }))),
      /#[[{]/.test(n) && (o = o.map((m) => R([aa$1], m)));
    let a = /%[A-Z]/.test(n);
    n.includes('|>')
      ? (o = (a ? [...Us$1, _s$1] : Us$1).flatMap((m) => o.map((v) => R([m], v))))
      : a && (o = o.map((m) => R([_s$1], m)));
    let l = r ? ze$1.parseExpression : ze$1.parse,
      f;
    try {
      f = ms$1(o.map((m) => () => ha$1(l, n, m)));
    } catch ({ errors: [m] }) {
      throw Ae$1(m);
    }
    return r && (f = Ve$1(f, { text: n, rootMarker: s.rootMarker })), Bs$1(f, { parser: 'babel', text: n });
  };
}
var ca$1 = new Set([
    'StrictNumericEscape',
    'StrictWith',
    'StrictOctalLiteral',
    'StrictDelete',
    'StrictEvalArguments',
    'StrictEvalArgumentsBinding',
    'StrictFunction',
    'EmptyTypeArguments',
    'EmptyTypeParameters',
    'ConstructorHasTypeParameters',
    'UnsupportedParameterPropertyKind',
    'MixedLabeledAndUnlabeledElements',
    'DuplicateAccessibilityModifier',
    'DecoratorExportClass',
    'ParamDupe',
    'InvalidDecimal',
    'RestTrailingComma',
    'UnsupportedParameterDecorator',
    'UnterminatedJsxContent',
    'UnexpectedReservedWord',
    'ModuleAttributesWithDuplicateKeys',
    'LineTerminatorBeforeArrow',
    'InvalidEscapeSequenceTemplate',
    'NonAbstractClassHasAbstractMethod',
    'OptionalTypeBeforeRequired',
    'PatternIsOptional',
    'OptionalBindingPattern',
    'DeclareClassFieldHasInitializer',
    'TypeImportCannotSpecifyDefaultAndNamed',
    'DeclareFunctionHasImplementation',
    'ConstructorClassField',
    'VarRedeclaration',
    'InvalidPrivateFieldResolution',
    'DuplicateExport',
  ]),
  Ks$1 = [R(['jsx'])],
  js$1 = he$1({ optionsCombinations: Ks$1 }),
  $s$1 = he$1({ optionsCombinations: [R(['jsx', 'typescript']), R(['typescript'])] }),
  Vs$1 = he$1({ isExpression: !0, optionsCombinations: [R(['jsx'])] }),
  zs$1 = he$1({ isExpression: !0, optionsCombinations: [R(['typescript'])] }),
  qs$1 = he$1({ optionsCombinations: [R(['jsx', ['flow', { all: !0, enums: !0 }], 'flowComments'])] }),
  pa$1 = he$1({ optionsCombinations: Ks$1.map((r) => R(['estree'], r)) }),
  Hs$1 = {
    'babel': js$1,
    'babel-flow': qs$1,
    'babel-ts': $s$1,
    '__js_expression': Vs$1,
    '__ts_expression': zs$1,
    '__vue_expression': Vs$1,
    '__vue_ts_expression': zs$1,
    '__vue_event_binding': js$1,
    '__vue_ts_event_binding': $s$1,
    '__babel_estree': pa$1,
  },
  Js$1 = qe$1(kt$1(), 1);
function Xs$1(r = {}) {
  let { allowComments: e = !0 } = r;
  return function (n) {
    let s;
    try {
      s = (0, Js$1.parseExpression)(n, { tokens: !0, ranges: !0 });
    } catch (o) {
      throw (o == null ? void 0 : o.reasonCode) === 'MissingPlugin' ||
        (o == null ? void 0 : o.reasonCode) === 'MissingOneOfPlugins'
        ? Ae$1({ message: 'Unexpected token', loc: o.loc })
        : Ae$1(o);
    }
    if (!e && Y$1(s.comments)) throw H$1(s.comments[0], 'Comment');
    return le$1(s), Ve$1(s, { type: 'JsonRoot', text: n });
  };
}
function H$1(r, e) {
  let [n, s] = [r.loc.start, r.loc.end].map(({ line: o, column: a }) => ({ line: o, column: a + 1 }));
  return je$1(`${e} is not allowed in JSON.`, { loc: { start: n, end: s } });
}
function le$1(r) {
  switch (r.type) {
    case 'ArrayExpression':
      for (let e of r.elements) e !== null && le$1(e);
      return;
    case 'ObjectExpression':
      for (let e of r.properties) le$1(e);
      return;
    case 'ObjectProperty':
      if (r.computed) throw H$1(r.key, 'Computed key');
      if (r.shorthand) throw H$1(r.key, 'Shorthand property');
      r.key.type !== 'Identifier' && le$1(r.key), le$1(r.value);
      return;
    case 'UnaryExpression': {
      let { operator: e, argument: n } = r;
      if (e !== '+' && e !== '-') throw H$1(r, `Operator '${r.operator}'`);
      if (n.type === 'NumericLiteral' || (n.type === 'Identifier' && (n.name === 'Infinity' || n.name === 'NaN')))
        return;
      throw H$1(n, `Operator '${e}' before '${n.type}'`);
    }
    case 'Identifier':
      if (r.name !== 'Infinity' && r.name !== 'NaN' && r.name !== 'undefined') throw H$1(r, `Identifier '${r.name}'`);
      return;
    case 'TemplateLiteral':
      if (Y$1(r.expressions)) throw H$1(r.expressions[0], "'TemplateLiteral' with expression");
      for (let e of r.quasis) le$1(e);
      return;
    case 'NullLiteral':
    case 'BooleanLiteral':
    case 'NumericLiteral':
    case 'StringLiteral':
    case 'TemplateElement':
      return;
    default:
      throw H$1(r, `'${r.type}'`);
  }
}
var Ws$1 = Xs$1(),
  ua$1 = {
    'json': oe$1({
      parse: Ws$1,
      hasPragma() {
        return !0;
      },
    }),
    'json5': oe$1(Ws$1),
    'json-stringify': oe$1({ parse: Xs$1({ allowComments: !1 }), astFormat: 'estree-json' }),
  },
  Gs$1 = ua$1,
  da$1 = { ...Hs$1, ...Gs$1 },
  Kn$1 = Ft$1,
  ua = Object.create,
  Tn = Object.defineProperty,
  ia = Object.getOwnPropertyDescriptor,
  aa = Object.getOwnPropertyNames,
  oa = Object.getPrototypeOf,
  pa = Object.prototype.hasOwnProperty,
  ca = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports),
  or = (r, e) => {
    for (var n in e) Tn(r, n, { get: e[n], enumerable: !0 });
  },
  la = (r, e, n, s) => {
    if ((e && typeof e == 'object') || typeof e == 'function')
      for (let o of aa(e))
        !pa.call(r, o) && o !== n && Tn(r, o, { get: () => e[o], enumerable: !(s = ia(e, o)) || s.enumerable });
    return r;
  },
  ma = (r, e, n) => (
    (n = r != null ? ua(oa(r)) : {}),
    la(e || !r || !r.__esModule ? Tn(n, 'default', { value: r, enumerable: !0 }) : n, r)
  ),
  Bs = (r, e, n) => {
    if (!e.has(r)) throw TypeError('Cannot ' + n);
  },
  st = (r, e, n) => (Bs(r, e, 'read from private field'), n ? n.call(r) : e.get(r)),
  bs = (r, e, n) => {
    if (e.has(r)) throw TypeError('Cannot add the same private member more than once');
    e instanceof WeakSet ? e.add(r) : e.set(r, n);
  },
  Ps = (r, e, n, s) => (Bs(r, e, 'write to private field'), s ? s.call(r, n) : e.set(r, n), n),
  Hi = ca((r) => {
    Object.defineProperty(r, '__esModule', { value: !0 }),
      (r.extract = I),
      (r.parse = V),
      (r.parseWithComments = se),
      (r.print = Ee),
      (r.strip = L);
    var e = /\*\/$/,
      n = /^\/\*\*?/,
      s = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
      o = /(^|\s+)\/\/([^\r\n]*)/g,
      a = /^(\r?\n)+/,
      l = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
      f = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
      m = /(\r?\n|^) *\* ?/g,
      v = [];
    function I(ar) {
      let $i = ar.match(s);
      return $i ? $i[0].trimLeft() : '';
    }
    function L(ar) {
      let $i = ar.match(s);
      return $i && $i[0] ? ar.substring($i[0].length) : ar;
    }
    function V(ar) {
      return se(ar).pragmas;
    }
    function se(ar) {
      let $i = `
`;
      ar = ar.replace(n, '').replace(e, '').replace(m, '$1');
      let tl = '';
      for (; tl !== ar; ) (tl = ar), (ar = ar.replace(l, `${$i}$1 $2${$i}`));
      ar = ar.replace(a, '').trimRight();
      let Wi = Object.create(null),
        hl = ar.replace(f, '').replace(a, '').trimRight(),
        fl;
      for (; (fl = f.exec(ar)); ) {
        let dl = fl[2].replace(o, '');
        typeof Wi[fl[1]] == 'string' || Array.isArray(Wi[fl[1]])
          ? (Wi[fl[1]] = v.concat(Wi[fl[1]], dl))
          : (Wi[fl[1]] = dl);
      }
      return { comments: hl, pragmas: Wi };
    }
    function Ee({ comments: ar = '', pragmas: $i = {} }) {
      let tl = `
`,
        Wi = '/**',
        hl = ' *',
        fl = ' */',
        dl = Object.keys($i),
        Al = dl
          .map((vl) => ht(vl, $i[vl]))
          .reduce((vl, kl) => vl.concat(kl), [])
          .map((vl) => `${hl} ${vl}${tl}`)
          .join('');
      if (!ar) {
        if (dl.length === 0) return '';
        if (dl.length === 1 && !Array.isArray($i[dl[0]])) {
          let vl = $i[dl[0]];
          return `${Wi} ${ht(dl[0], vl)[0]}${fl}`;
        }
      }
      let Fl =
        ar
          .split(tl)
          .map((vl) => `${hl} ${vl}`)
          .join(tl) + tl;
      return Wi + tl + (ar ? Fl : '') + (ar && dl.length ? hl + tl : '') + Al + fl;
    }
    function ht(ar, $i) {
      return v.concat($i).map((tl) => `@${ar} ${tl}`.trim());
    }
  }),
  Ss = {};
or(Ss, { languages: () => yl, options: () => sa, printers: () => ml });
var gs = {};
or(gs, {
  canAttachComment: () => Wo,
  embed: () => Ni,
  experimentalFeatures: () => il,
  getCommentChildNodes: () => Yo,
  getVisitorKeys: () => fr,
  handleComments: () => Kn,
  insertPragma: () => zi,
  isBlockComment: () => ae,
  isGap: () => Xo,
  massageAstNode: () => Gi,
  print: () => Ii,
  printComment: () => Tu,
  willPrintOwnComments: () => zn,
});
function ya(r, e) {
  let { originalText: n, [Symbol.for('comments')]: s, locStart: o, locEnd: a, [Symbol.for('printedComments')]: l } = e,
    { node: f } = r,
    m = o(f),
    v = a(f);
  for (let I of s) o(I) >= m && a(I) <= v && l.add(I);
  return n.slice(m, v);
}
var ks = ya,
  Ke = 'string',
  je = 'array',
  ze = 'cursor',
  Me = 'indent',
  Re = 'align',
  Qe = 'trim',
  ue = 'group',
  ye = 'fill',
  Fe = 'if-break',
  Je = 'indent-if-break',
  Ne = 'line-suffix',
  Ue = 'line-suffix-boundary',
  ie = 'line',
  be = 'label',
  Pe = 'break-parent',
  pr = new Set([ze, Me, Re, Qe, ue, ye, Fe, Je, Ne, Ue, ie, be, Pe]);
function Da(r) {
  if (typeof r == 'string') return Ke;
  if (Array.isArray(r)) return je;
  if (!r) return;
  let { type: e } = r;
  if (pr.has(e)) return e;
}
var Ze = Da,
  fa = (r) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(r);
function Ea(r) {
  let e = r === null ? 'null' : typeof r;
  if (e !== 'string' && e !== 'object')
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Ze(r)) throw new Error('doc is valid.');
  let n = Object.prototype.toString.call(r);
  if (n !== '[object Object]') return `Unexpected doc '${n}'.`;
  let s = fa([...pr].map((o) => `'${o}'`));
  return `Unexpected doc.type '${r.type}'.
Expected it to be ${s}.`;
}
var xn = class extends Error {
    constructor(e) {
      super(Ea(e));
      Cf(this, 'name', 'InvalidDocError');
      this.doc = e;
    }
  },
  lt = xn,
  Is = {};
function Fa(r, e, n, s) {
  let o = [r];
  for (; o.length > 0; ) {
    let a = o.pop();
    if (a === Is) {
      n(o.pop());
      continue;
    }
    n && o.push(a, Is);
    let l = Ze(a);
    if (!l) throw new lt(a);
    if ((e == null ? void 0 : e(a)) !== !1)
      switch (l) {
        case je:
        case ye: {
          let f = l === je ? a : a.parts;
          for (let m = f.length, v = m - 1; v >= 0; --v) o.push(f[v]);
          break;
        }
        case Fe:
          o.push(a.flatContents, a.breakContents);
          break;
        case ue:
          if (s && a.expandedStates)
            for (let f = a.expandedStates.length, m = f - 1; m >= 0; --m) o.push(a.expandedStates[m]);
          else o.push(a.contents);
          break;
        case Re:
        case Me:
        case Je:
        case be:
        case Ne:
          o.push(a.contents);
          break;
        case Ke:
        case ze:
        case Qe:
        case Ue:
        case ie:
        case Pe:
          break;
        default:
          throw new lt(a);
      }
  }
}
var gn = Fa,
  Ls = () => {},
  cr = Ls;
function E(r) {
  return { type: Me, contents: r };
}
function De(r, e) {
  return { type: Re, contents: e, n: r };
}
function y$1(r, e = {}) {
  return (
    cr(e.expandedStates), { type: ue, id: e.id, contents: r, break: !!e.shouldBreak, expandedStates: e.expandedStates }
  );
}
function ws(r) {
  return De(Number.NEGATIVE_INFINITY, r);
}
function Os(r) {
  return De(-1, r);
}
function qe(r, e) {
  return y$1(r[0], { ...e, expandedStates: r });
}
function St(r) {
  return { type: ye, parts: r };
}
function P$1(r, e = '', n = {}) {
  return { type: Fe, breakContents: r, flatContents: e, groupId: n.groupId };
}
function mt(r, e) {
  return { type: Je, contents: r, groupId: e.groupId, negate: e.negate };
}
function hn(r) {
  return { type: Ne, contents: r };
}
var de = { type: Ue },
  Ae = { type: Pe },
  Sn = { type: ie, hard: !0 },
  Ca = { type: ie, hard: !0, literal: !0 },
  A = { type: ie },
  F$1 = { type: ie, soft: !0 },
  C$1 = [Sn, Ae],
  lr = [Ca, Ae],
  Bn = { type: ze };
function B$1(r, e) {
  let n = [];
  for (let s = 0; s < e.length; s++) s !== 0 && n.push(r), n.push(e[s]);
  return n;
}
function vs(r, e, n) {
  let s = r;
  if (e > 0) {
    for (let o = 0; o < Math.floor(e / n); ++o) s = E(s);
    (s = De(e % n, s)), (s = De(Number.NEGATIVE_INFINITY, s));
  }
  return s;
}
function et(r, e) {
  return r ? { type: be, label: r, contents: e } : e;
}
var da = (r, e, n) => {
    if (!(r && e == null)) return Array.isArray(e) || typeof e == 'string' ? e[n < 0 ? e.length + n : n] : e.at(n);
  },
  w$1 = da,
  mr = (r) => {
    if (Array.isArray(r)) return r;
    if (r.type !== ye) throw new Error(`Expect doc to be 'array' or '${ye}'.`);
    return r.parts;
  };
function ut(r, e) {
  if (typeof r == 'string') return e(r);
  let n = new Map();
  return s(r);
  function s(a) {
    if (n.has(a)) return n.get(a);
    let l = o(a);
    return n.set(a, l), l;
  }
  function o(a) {
    switch (Ze(a)) {
      case je:
        return e(a.map(s));
      case ye:
        return e({ ...a, parts: a.parts.map(s) });
      case Fe:
        return e({ ...a, breakContents: s(a.breakContents), flatContents: s(a.flatContents) });
      case ue: {
        let { expandedStates: l, contents: f } = a;
        return l ? ((l = l.map(s)), (f = l[0])) : (f = s(f)), e({ ...a, contents: f, expandedStates: l });
      }
      case Re:
      case Me:
      case Je:
      case be:
      case Ne:
        return e({ ...a, contents: s(a.contents) });
      case Ke:
      case ze:
      case Qe:
      case Ue:
      case ie:
      case Pe:
        return e(a);
      default:
        throw new lt(a);
    }
  }
}
function js(r, e, n) {
  let s = n,
    o = !1;
  function a(l) {
    if (o) return !1;
    let f = e(l);
    f !== void 0 && ((o = !0), (s = f));
  }
  return gn(r, a), s;
}
function Aa(r) {
  if ((r.type === ue && r.break) || (r.type === ie && r.hard) || r.type === Pe) return !0;
}
function K(r) {
  return js(r, Aa, !1);
}
function _s(r) {
  if (r.length > 0) {
    let e = w$1(!1, r, -1);
    !e.expandedStates && !e.break && (e.break = 'propagated');
  }
  return null;
}
function Ms(r) {
  let e = new Set(),
    n = [];
  function s(a) {
    if ((a.type === Pe && _s(n), a.type === ue)) {
      if ((n.push(a), e.has(a))) return !1;
      e.add(a);
    }
  }
  function o(a) {
    a.type === ue && n.pop().break && _s(n);
  }
  gn(r, s, o, !0);
}
function Ta(r) {
  return r.type === ie && !r.hard ? (r.soft ? '' : ' ') : r.type === Fe ? r.flatContents : r;
}
function Ut(r) {
  return ut(r, Ta);
}
function xa(r) {
  switch (Ze(r)) {
    case ye:
      if (r.parts.every((e) => e === '')) return '';
      break;
    case ue:
      if (!r.contents && !r.id && !r.break && !r.expandedStates) return '';
      if (
        r.contents.type === ue &&
        r.contents.id === r.id &&
        r.contents.break === r.break &&
        r.contents.expandedStates === r.expandedStates
      )
        return r.contents;
      break;
    case Re:
    case Me:
    case Je:
    case Ne:
      if (!r.contents) return '';
      break;
    case Fe:
      if (!r.flatContents && !r.breakContents) return '';
      break;
    case je: {
      let e = [];
      for (let n of r) {
        if (!n) continue;
        let [s, ...o] = Array.isArray(n) ? n : [n];
        typeof s == 'string' && typeof w$1(!1, e, -1) == 'string' ? (e[e.length - 1] += s) : e.push(s), e.push(...o);
      }
      return e.length === 0 ? '' : e.length === 1 ? e[0] : e;
    }
    case Ke:
    case ze:
    case Qe:
    case Ue:
    case ie:
    case be:
    case Pe:
      break;
    default:
      throw new lt(r);
  }
  return r;
}
function Bt(r) {
  return ut(r, (e) => xa(e));
}
function Te(r, e = lr) {
  return ut(r, (n) =>
    typeof n == 'string'
      ? B$1(
          e,
          n.split(`
`),
        )
      : n,
  );
}
function ga(r) {
  if (r.type === ie) return !0;
}
function Rs(r) {
  return js(r, ga, !1);
}
function Gt(r, e) {
  return r.type === be ? { ...r, contents: e(r.contents) } : e(r);
}
function ha(r) {
  return Array.isArray(r) && r.length > 0;
}
var b = ha,
  Sa =
    /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/,
  Ba = (r) => Sa.test(r),
  Js = Ba;
function ba(r) {
  return r !== null && typeof r == 'object';
}
var Ns = ba;
function* Pa(r, e) {
  let { getVisitorKeys: n, filter: s = () => !0 } = e,
    o = (a) => Ns(a) && s(a);
  for (let a of n(r)) {
    let l = r[a];
    if (Array.isArray(l)) for (let f of l) o(f) && (yield f);
    else o(l) && (yield l);
  }
}
function* ka(r, e) {
  let n = [r];
  for (let s = 0; s < n.length; s++) {
    let o = n[s];
    for (let a of Pa(o, e)) yield a, n.push(a);
  }
}
function Us(r, { getVisitorKeys: e, predicate: n }) {
  for (let s of ka(r, { getVisitorKeys: e })) if (n(s)) return !0;
  return !1;
}
function yr(r) {
  return (e, n, s) => {
    let o = !!(s != null && s.backwards);
    if (n === !1) return !1;
    let { length: a } = e,
      l = n;
    for (; l >= 0 && l < a; ) {
      let f = e.charAt(l);
      if (r instanceof RegExp) {
        if (!r.test(f)) return l;
      } else if (!r.includes(f)) return l;
      o ? l-- : l++;
    }
    return l === -1 || l === a ? l : !1;
  };
}
var We = yr(' 	'),
  Gs = yr(',; 	'),
  qs = yr(/[^\n\r]/);
function Ia(r, e, n) {
  let s = !!(n != null && n.backwards);
  if (e === !1) return !1;
  let o = r.charAt(e);
  if (s) {
    if (
      r.charAt(e - 1) === '\r' &&
      o ===
        `
`
    )
      return e - 2;
    if (
      o ===
        `
` ||
      o === '\r' ||
      o === '\u2028' ||
      o === '\u2029'
    )
      return e - 1;
  } else {
    if (
      o === '\r' &&
      r.charAt(e + 1) ===
        `
`
    )
      return e + 2;
    if (
      o ===
        `
` ||
      o === '\r' ||
      o === '\u2028' ||
      o === '\u2029'
    )
      return e + 1;
  }
  return e;
}
var Ye = Ia;
function La(r, e, n = {}) {
  let s = We(r, n.backwards ? e - 1 : e, n),
    o = Ye(r, s, n);
  return s !== o;
}
var z$1 = La;
function wa(r, e) {
  if (e === !1) return !1;
  if (r.charAt(e) === '/' && r.charAt(e + 1) === '*') {
    for (let n = e + 2; n < r.length; ++n) if (r.charAt(n) === '*' && r.charAt(n + 1) === '/') return n + 2;
  }
  return e;
}
var bt = wa;
function Oa(r, e) {
  return e === !1 ? !1 : r.charAt(e) === '/' && r.charAt(e + 1) === '/' ? qs(r, e) : e;
}
var Pt = Oa;
function va(r, e) {
  let n = null,
    s = e;
  for (; s !== n; ) (n = s), (s = Gs(r, s)), (s = bt(r, s)), (s = We(r, s));
  return (s = Pt(r, s)), (s = Ye(r, s)), s !== !1 && z$1(r, s);
}
var kt = va,
  Ws = () =>
    /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g,
  Ys = {
    eastAsianWidth(r) {
      var e = r.charCodeAt(0),
        n = r.length == 2 ? r.charCodeAt(1) : 0,
        s = e;
      return (
        55296 <= e &&
          e <= 56319 &&
          56320 <= n &&
          n <= 57343 &&
          ((e &= 1023), (n &= 1023), (s = (e << 10) | n), (s += 65536)),
        s == 12288 || (65281 <= s && s <= 65376) || (65504 <= s && s <= 65510)
          ? 'F'
          : (4352 <= s && s <= 4447) ||
            (4515 <= s && s <= 4519) ||
            (4602 <= s && s <= 4607) ||
            (9001 <= s && s <= 9002) ||
            (11904 <= s && s <= 11929) ||
            (11931 <= s && s <= 12019) ||
            (12032 <= s && s <= 12245) ||
            (12272 <= s && s <= 12283) ||
            (12289 <= s && s <= 12350) ||
            (12353 <= s && s <= 12438) ||
            (12441 <= s && s <= 12543) ||
            (12549 <= s && s <= 12589) ||
            (12593 <= s && s <= 12686) ||
            (12688 <= s && s <= 12730) ||
            (12736 <= s && s <= 12771) ||
            (12784 <= s && s <= 12830) ||
            (12832 <= s && s <= 12871) ||
            (12880 <= s && s <= 13054) ||
            (13056 <= s && s <= 19903) ||
            (19968 <= s && s <= 42124) ||
            (42128 <= s && s <= 42182) ||
            (43360 <= s && s <= 43388) ||
            (44032 <= s && s <= 55203) ||
            (55216 <= s && s <= 55238) ||
            (55243 <= s && s <= 55291) ||
            (63744 <= s && s <= 64255) ||
            (65040 <= s && s <= 65049) ||
            (65072 <= s && s <= 65106) ||
            (65108 <= s && s <= 65126) ||
            (65128 <= s && s <= 65131) ||
            (110592 <= s && s <= 110593) ||
            (127488 <= s && s <= 127490) ||
            (127504 <= s && s <= 127546) ||
            (127552 <= s && s <= 127560) ||
            (127568 <= s && s <= 127569) ||
            (131072 <= s && s <= 194367) ||
            (177984 <= s && s <= 196605) ||
            (196608 <= s && s <= 262141)
          ? 'W'
          : 'N'
      );
    },
  },
  _a$1 = /[^\x20-\x7F]/;
function ja(r) {
  if (!r) return 0;
  if (!_a$1.test(r)) return r.length;
  r = r.replace(Ws(), '  ');
  let e = 0;
  for (let n of r) {
    let s = n.codePointAt(0);
    if (s <= 31 || (s >= 127 && s <= 159) || (s >= 768 && s <= 879)) continue;
    let o = Ys.eastAsianWidth(n);
    e += o === 'F' || o === 'W' ? 2 : 1;
  }
  return e;
}
var tt = ja;
function U$1(r) {
  var e;
  let n = r.range ? r.range[0] : r.start,
    s = ((e = r.declaration) == null ? void 0 : e.decorators) ?? r.decorators;
  return b(s) ? Math.min(U$1(s[0]), n) : n;
}
function O$1(r) {
  return r.range ? r.range[1] : r.end;
}
function yt(r, e) {
  let n = U$1(r);
  return Number.isInteger(n) && n === U$1(e);
}
function Ma(r, e) {
  let n = O$1(r);
  return Number.isInteger(n) && n === O$1(e);
}
function Xs(r, e) {
  return yt(r, e) && Ma(r, e);
}
var qt = null;
function Wt(r) {
  if (qt !== null && typeof qt.property) {
    let e = qt;
    return (qt = Wt.prototype = null), e;
  }
  return (qt = Wt.prototype = r ?? Object.create(null)), new Wt();
}
var Ra = 10;
for (let r = 0; r <= Ra; r++) Wt();
function bn(r) {
  return Wt(r);
}
function Ja(r, e = 'type') {
  bn(r);
  function n(s) {
    let o = s[e],
      a = r[o];
    if (!Array.isArray(a)) throw Object.assign(new Error(`Missing visitor keys for '${o}'.`), { node: s });
    return a;
  }
  return n;
}
var Dr = Ja,
  $s = {
    ArrayExpression: ['elements'],
    AssignmentExpression: ['left', 'right'],
    BinaryExpression: ['left', 'right'],
    InterpreterDirective: [],
    Directive: ['value'],
    DirectiveLiteral: [],
    BlockStatement: ['directives', 'body'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    CatchClause: ['param', 'body'],
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DoWhileStatement: ['test', 'body'],
    EmptyStatement: [],
    ExpressionStatement: ['expression'],
    File: ['program'],
    ForInStatement: ['left', 'right', 'body'],
    ForStatement: ['init', 'test', 'update', 'body'],
    FunctionDeclaration: ['id', 'params', 'body', 'returnType', 'typeParameters', 'predicate'],
    FunctionExpression: ['id', 'params', 'body', 'returnType', 'typeParameters'],
    Identifier: ['typeAnnotation', 'decorators'],
    IfStatement: ['test', 'consequent', 'alternate'],
    LabeledStatement: ['label', 'body'],
    StringLiteral: [],
    NumericLiteral: [],
    NullLiteral: [],
    BooleanLiteral: [],
    RegExpLiteral: [],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    Program: ['directives', 'body'],
    ObjectExpression: ['properties'],
    ObjectMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectProperty: ['key', 'value', 'decorators'],
    RestElement: ['argument', 'typeAnnotation', 'decorators'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    ParenthesizedExpression: ['expression'],
    SwitchCase: ['test', 'consequent'],
    SwitchStatement: ['discriminant', 'cases'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'],
    ArrayPattern: ['elements', 'typeAnnotation', 'decorators'],
    ArrowFunctionExpression: ['params', 'body', 'returnType', 'typeParameters', 'predicate'],
    ClassBody: ['body'],
    ClassExpression: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ClassDeclaration: [
      'id',
      'body',
      'superClass',
      'mixins',
      'typeParameters',
      'superTypeParameters',
      'implements',
      'decorators',
      'superTypeArguments',
    ],
    ExportAllDeclaration: ['source', 'attributes', 'assertions', 'exported'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes', 'assertions'],
    ExportSpecifier: ['local', 'exported'],
    ForOfStatement: ['left', 'right', 'body'],
    ImportDeclaration: ['specifiers', 'source', 'attributes', 'assertions'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['local', 'imported'],
    MetaProperty: ['meta', 'property'],
    ClassMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    ObjectPattern: ['properties', 'typeAnnotation', 'decorators'],
    SpreadElement: ['argument'],
    Super: [],
    TaggedTemplateExpression: ['tag', 'quasi', 'typeParameters', 'typeArguments'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    YieldExpression: ['argument'],
    AwaitExpression: ['argument'],
    Import: [],
    BigIntLiteral: [],
    ExportNamespaceSpecifier: ['exported'],
    OptionalMemberExpression: ['object', 'property'],
    OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
    ClassProperty: ['key', 'value', 'typeAnnotation', 'decorators', 'variance'],
    ClassAccessorProperty: ['key', 'value', 'typeAnnotation', 'decorators'],
    ClassPrivateProperty: ['key', 'value', 'decorators', 'typeAnnotation', 'variance'],
    ClassPrivateMethod: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
    PrivateName: ['id'],
    StaticBlock: ['body'],
    AnyTypeAnnotation: [],
    ArrayTypeAnnotation: ['elementType'],
    BooleanTypeAnnotation: [],
    BooleanLiteralTypeAnnotation: [],
    NullLiteralTypeAnnotation: [],
    ClassImplements: ['id', 'typeParameters'],
    DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'],
    DeclareFunction: ['id', 'predicate'],
    DeclareInterface: ['id', 'typeParameters', 'extends', 'body'],
    DeclareModule: ['id', 'body'],
    DeclareModuleExports: ['typeAnnotation'],
    DeclareTypeAlias: ['id', 'typeParameters', 'right'],
    DeclareOpaqueType: ['id', 'typeParameters', 'supertype'],
    DeclareVariable: ['id'],
    DeclareExportDeclaration: ['declaration', 'specifiers', 'source'],
    DeclareExportAllDeclaration: ['source'],
    DeclaredPredicate: ['value'],
    ExistsTypeAnnotation: [],
    FunctionTypeAnnotation: ['typeParameters', 'params', 'rest', 'returnType', 'this'],
    FunctionTypeParam: ['name', 'typeAnnotation'],
    GenericTypeAnnotation: ['id', 'typeParameters'],
    InferredPredicate: [],
    InterfaceExtends: ['id', 'typeParameters'],
    InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    InterfaceTypeAnnotation: ['extends', 'body'],
    IntersectionTypeAnnotation: ['types'],
    MixedTypeAnnotation: [],
    EmptyTypeAnnotation: [],
    NullableTypeAnnotation: ['typeAnnotation'],
    NumberLiteralTypeAnnotation: [],
    NumberTypeAnnotation: [],
    ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'],
    ObjectTypeInternalSlot: ['id', 'value', 'optional', 'static', 'method'],
    ObjectTypeCallProperty: ['value'],
    ObjectTypeIndexer: ['id', 'key', 'value', 'variance'],
    ObjectTypeProperty: ['key', 'value', 'variance'],
    ObjectTypeSpreadProperty: ['argument'],
    OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'],
    QualifiedTypeIdentifier: ['id', 'qualification'],
    StringLiteralTypeAnnotation: [],
    StringTypeAnnotation: [],
    SymbolTypeAnnotation: [],
    ThisTypeAnnotation: [],
    TupleTypeAnnotation: ['types', 'elementTypes'],
    TypeofTypeAnnotation: ['argument'],
    TypeAlias: ['id', 'typeParameters', 'right'],
    TypeAnnotation: ['typeAnnotation'],
    TypeCastExpression: ['expression', 'typeAnnotation'],
    TypeParameter: ['bound', 'default', 'variance'],
    TypeParameterDeclaration: ['params'],
    TypeParameterInstantiation: ['params'],
    UnionTypeAnnotation: ['types'],
    Variance: [],
    VoidTypeAnnotation: [],
    EnumDeclaration: ['id', 'body'],
    EnumBooleanBody: ['members'],
    EnumNumberBody: ['members'],
    EnumStringBody: ['members'],
    EnumSymbolBody: ['members'],
    EnumBooleanMember: ['id', 'init'],
    EnumNumberMember: ['id', 'init'],
    EnumStringMember: ['id', 'init'],
    EnumDefaultedMember: ['id'],
    IndexedAccessType: ['objectType', 'indexType'],
    OptionalIndexedAccessType: ['objectType', 'indexType'],
    JSXAttribute: ['name', 'value'],
    JSXClosingElement: ['name'],
    JSXElement: ['openingElement', 'children', 'closingElement'],
    JSXEmptyExpression: [],
    JSXExpressionContainer: ['expression'],
    JSXSpreadChild: ['expression'],
    JSXIdentifier: [],
    JSXMemberExpression: ['object', 'property'],
    JSXNamespacedName: ['namespace', 'name'],
    JSXOpeningElement: ['name', 'attributes', 'typeArguments', 'typeParameters'],
    JSXSpreadAttribute: ['argument'],
    JSXText: [],
    JSXFragment: ['openingFragment', 'children', 'closingFragment'],
    JSXOpeningFragment: [],
    JSXClosingFragment: [],
    Noop: [],
    Placeholder: [],
    V8IntrinsicIdentifier: [],
    ArgumentPlaceholder: [],
    BindExpression: ['object', 'callee'],
    ImportAttribute: ['key', 'value'],
    Decorator: ['expression'],
    DoExpression: ['body'],
    ExportDefaultSpecifier: ['exported'],
    RecordExpression: ['properties'],
    TupleExpression: ['elements'],
    DecimalLiteral: [],
    ModuleExpression: ['body'],
    TopicReference: [],
    PipelineTopicExpression: ['expression'],
    PipelineBareFunction: ['callee'],
    PipelinePrimaryTopicReference: [],
    TSParameterProperty: ['parameter', 'decorators'],
    TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'],
    TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'],
    TSQualifiedName: ['left', 'right'],
    TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSPropertySignature: ['key', 'typeAnnotation'],
    TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSIndexSignature: ['parameters', 'typeAnnotation'],
    TSAnyKeyword: [],
    TSBooleanKeyword: [],
    TSBigIntKeyword: [],
    TSIntrinsicKeyword: [],
    TSNeverKeyword: [],
    TSNullKeyword: [],
    TSNumberKeyword: [],
    TSObjectKeyword: [],
    TSStringKeyword: [],
    TSSymbolKeyword: [],
    TSUndefinedKeyword: [],
    TSUnknownKeyword: [],
    TSVoidKeyword: [],
    TSThisType: [],
    TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'],
    TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'],
    TSTypePredicate: ['parameterName', 'typeAnnotation'],
    TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'],
    TSTypeLiteral: ['members'],
    TSArrayType: ['elementType'],
    TSTupleType: ['elementTypes'],
    TSOptionalType: ['typeAnnotation'],
    TSRestType: ['typeAnnotation'],
    TSNamedTupleMember: ['label', 'elementType'],
    TSUnionType: ['types'],
    TSIntersectionType: ['types'],
    TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'],
    TSInferType: ['typeParameter'],
    TSParenthesizedType: ['typeAnnotation'],
    TSTypeOperator: ['typeAnnotation'],
    TSIndexedAccessType: ['objectType', 'indexType'],
    TSMappedType: ['typeParameter', 'typeAnnotation', 'nameType'],
    TSLiteralType: ['literal'],
    TSExpressionWithTypeArguments: ['expression', 'typeParameters'],
    TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'],
    TSInterfaceBody: ['body'],
    TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'],
    TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'],
    TSAsExpression: ['expression', 'typeAnnotation'],
    TSSatisfiesExpression: ['expression', 'typeAnnotation'],
    TSTypeAssertion: ['typeAnnotation', 'expression'],
    TSEnumDeclaration: ['id', 'members'],
    TSEnumMember: ['id', 'initializer'],
    TSModuleDeclaration: ['id', 'body'],
    TSModuleBlock: ['body'],
    TSImportType: ['argument', 'qualifier', 'typeParameters', 'typeArguments'],
    TSImportEqualsDeclaration: ['id', 'moduleReference'],
    TSExternalModuleReference: ['expression'],
    TSNonNullExpression: ['expression'],
    TSExportAssignment: ['expression'],
    TSNamespaceExportDeclaration: ['id'],
    TSTypeAnnotation: ['typeAnnotation'],
    TSTypeParameterInstantiation: ['params'],
    TSTypeParameterDeclaration: ['params'],
    TSTypeParameter: ['constraint', 'default', 'name'],
    ChainExpression: ['expression'],
    ExperimentalRestProperty: ['argument'],
    ExperimentalSpreadProperty: ['argument'],
    ImportExpression: ['source', 'attributes'],
    Literal: [],
    MethodDefinition: ['decorators', 'key', 'value'],
    PrivateIdentifier: [],
    Property: ['key', 'value'],
    PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'],
    AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'],
    TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'],
    TSAbstractKeyword: [],
    TSAbstractMethodDefinition: ['key', 'value'],
    TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'],
    TSAsyncKeyword: [],
    TSClassImplements: ['expression', 'typeArguments', 'typeParameters'],
    TSDeclareKeyword: [],
    TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'],
    TSExportKeyword: [],
    TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'],
    TSPrivateKeyword: [],
    TSProtectedKeyword: [],
    TSPublicKeyword: [],
    TSReadonlyKeyword: [],
    TSStaticKeyword: [],
    TSTemplateLiteralType: ['quasis', 'types'],
    BigIntLiteralTypeAnnotation: [],
    BigIntTypeAnnotation: [],
    ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'],
    DeclareEnum: ['id', 'body'],
    InferTypeAnnotation: ['typeParameter'],
    KeyofTypeAnnotation: ['argument'],
    ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'],
    QualifiedTypeofIdentifier: ['qualification', 'id'],
    TupleTypeLabeledElement: ['label', 'elementType', 'variance'],
    TupleTypeSpreadElement: ['label', 'typeAnnotation'],
    TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'],
    NGRoot: ['node'],
    NGPipeExpression: ['left', 'right', 'arguments'],
    NGChainedExpression: ['expressions'],
    NGEmptyExpression: [],
    NGMicrosyntax: ['body'],
    NGMicrosyntaxKey: [],
    NGMicrosyntaxExpression: ['expression', 'alias'],
    NGMicrosyntaxKeyedExpression: ['key', 'expression'],
    NGMicrosyntaxLet: ['key', 'value'],
    NGMicrosyntaxAs: ['key', 'alias'],
    JsExpressionRoot: ['node'],
    JsonRoot: ['node'],
    TSJSDocAllType: [],
    TSJSDocUnknownType: [],
    TSJSDocNullableType: ['typeAnnotation'],
    TSJSDocNonNullableType: ['typeAnnotation'],
    NeverTypeAnnotation: [],
    UndefinedTypeAnnotation: [],
    UnknownTypeAnnotation: [],
  },
  Na = Dr($s),
  fr = Na;
function Ua(r) {
  return (r = new Set(r)), (e) => r.has(e == null ? void 0 : e.type);
}
var j$1 = Ua,
  Ga = j$1(['Block', 'CommentBlock', 'MultiLine']),
  ae = Ga;
function qa(r, e) {
  let n = e.split('.');
  for (let s = n.length - 1; s >= 0; s--) {
    let o = n[s];
    if (s === 0) return r.type === 'Identifier' && r.name === o;
    if (
      r.type !== 'MemberExpression' ||
      r.optional ||
      r.computed ||
      r.property.type !== 'Identifier' ||
      r.property.name !== o
    )
      return !1;
    r = r.object;
  }
}
function Wa(r, e) {
  return e.some((n) => qa(r, n));
}
var Vs = Wa,
  Ya = j$1([
    'AnyTypeAnnotation',
    'ThisTypeAnnotation',
    'NumberTypeAnnotation',
    'VoidTypeAnnotation',
    'BooleanTypeAnnotation',
    'BigIntTypeAnnotation',
    'SymbolTypeAnnotation',
    'StringTypeAnnotation',
    'NeverTypeAnnotation',
    'UndefinedTypeAnnotation',
    'UnknownTypeAnnotation',
    'EmptyTypeAnnotation',
    'MixedTypeAnnotation',
  ]),
  Er = Ya;
function Xa({ type: r }) {
  return r.startsWith('TS') && r.endsWith('Keyword');
}
var Fr = Xa;
function Xt(r, e) {
  return e(r) || Us(r, { getVisitorKeys: fr, predicate: e });
}
function Lt(r) {
  return (
    r.type === 'AssignmentExpression' ||
    r.type === 'BinaryExpression' ||
    r.type === 'LogicalExpression' ||
    r.type === 'NGPipeExpression' ||
    r.type === 'ConditionalExpression' ||
    k(r) ||
    J(r) ||
    r.type === 'SequenceExpression' ||
    r.type === 'TaggedTemplateExpression' ||
    r.type === 'BindExpression' ||
    (r.type === 'UpdateExpression' && !r.prefix) ||
    Le(r) ||
    r.type === 'TSNonNullExpression' ||
    r.type === 'ChainExpression'
  );
}
function zs(r) {
  return r.expressions
    ? r.expressions[0]
    : r.left ?? r.test ?? r.callee ?? r.object ?? r.tag ?? r.argument ?? r.expression;
}
function dr(r) {
  if (r.expressions) return ['expressions', 0];
  if (r.left) return ['left'];
  if (r.test) return ['test'];
  if (r.object) return ['object'];
  if (r.callee) return ['callee'];
  if (r.tag) return ['tag'];
  if (r.argument) return ['argument'];
  if (r.expression) return ['expression'];
  throw new Error('Unexpected node has no left side.');
}
var $t = j$1([
    'Line',
    'CommentLine',
    'SingleLine',
    'HashbangComment',
    'HTMLOpen',
    'HTMLClose',
    'Hashbang',
    'InterpreterDirective',
  ]),
  Qs = j$1([
    'ExportDefaultDeclaration',
    'DeclareExportDeclaration',
    'ExportNamedDeclaration',
    'ExportAllDeclaration',
    'DeclareExportAllDeclaration',
  ]),
  G = j$1(['ArrayExpression', 'TupleExpression']),
  Z = j$1(['ObjectExpression', 'RecordExpression']);
function ge(r) {
  return r.type === 'NumericLiteral' || (r.type === 'Literal' && typeof r.value == 'number');
}
function Ar(r) {
  return r.type === 'UnaryExpression' && (r.operator === '+' || r.operator === '-') && ge(r.argument);
}
function ee(r) {
  return r.type === 'StringLiteral' || (r.type === 'Literal' && typeof r.value == 'string');
}
function wn(r) {
  return r.type === 'RegExpLiteral' || (r.type === 'Literal' && !!r.regex);
}
var ke = j$1(['ObjectTypeAnnotation', 'TSTypeLiteral', 'TSMappedType']),
  It = j$1(['FunctionExpression', 'ArrowFunctionExpression']);
function $a(r) {
  return r.type === 'FunctionExpression' || (r.type === 'ArrowFunctionExpression' && r.body.type === 'BlockStatement');
}
function Pn(r) {
  return (
    k(r) && r.callee.type === 'Identifier' && ['async', 'inject', 'fakeAsync', 'waitForAsync'].includes(r.callee.name)
  );
}
var Y = j$1(['JSXElement', 'JSXFragment']);
function On(r) {
  return r.kind === 'get' || r.kind === 'set';
}
function vn(r) {
  return On(r) || yt(r, r.value);
}
function Tr(r) {
  return (
    (r.type === 'ObjectTypeProperty' || r.type === 'ObjectTypeInternalSlot') &&
    r.value.type === 'FunctionTypeAnnotation' &&
    !r.static &&
    !vn(r)
  );
}
function Zs(r) {
  return (
    (r.type === 'TypeAnnotation' || r.type === 'TSTypeAnnotation') &&
    r.typeAnnotation.type === 'FunctionTypeAnnotation' &&
    !r.static &&
    !yt(r, r.typeAnnotation)
  );
}
var ce = j$1(['BinaryExpression', 'LogicalExpression', 'NGPipeExpression']);
function Dt(r) {
  return J(r) || (r.type === 'BindExpression' && !!r.object);
}
var Va = j$1([
  'TSThisType',
  'NullLiteralTypeAnnotation',
  'BooleanLiteralTypeAnnotation',
  'StringLiteralTypeAnnotation',
  'BigIntLiteralTypeAnnotation',
  'NumberLiteralTypeAnnotation',
  'TSLiteralType',
  'TSTemplateLiteralType',
]);
function wt(r) {
  return (
    Fr(r) ||
    Er(r) ||
    Va(r) ||
    ((r.type === 'GenericTypeAnnotation' || r.type === 'TSTypeReference') && !r.typeParameters)
  );
}
function Ha(r) {
  let e = /^(?:before|after)(?:Each|All)$/;
  return r.callee.type === 'Identifier' && r.arguments.length === 1 && e.test(r.callee.name);
}
var Ka = [
  'it',
  'it.only',
  'it.skip',
  'describe',
  'describe.only',
  'describe.skip',
  'test',
  'test.only',
  'test.skip',
  'test.step',
  'test.describe',
  'test.describe.only',
  'test.describe.parallel',
  'test.describe.parallel.only',
  'test.describe.serial',
  'test.describe.serial.only',
  'skip',
  'xit',
  'xdescribe',
  'xtest',
  'fit',
  'fdescribe',
  'ftest',
];
function za(r) {
  return Vs(r, Ka);
}
function Ct(r, e) {
  if (r.type !== 'CallExpression') return !1;
  if (r.arguments.length === 1) {
    if (Pn(r) && e && Ct(e)) return It(r.arguments[0]);
    if (Ha(r)) return Pn(r.arguments[0]);
  } else if (
    (r.arguments.length === 2 || r.arguments.length === 3) &&
    (r.arguments[0].type === 'TemplateLiteral' || ee(r.arguments[0])) &&
    za(r.callee)
  )
    return r.arguments[2] && !ge(r.arguments[2])
      ? !1
      : (r.arguments.length === 2 ? It(r.arguments[1]) : $a(r.arguments[1]) && X(r.arguments[1]).length <= 1) ||
          Pn(r.arguments[1]);
  return !1;
}
var k = j$1(['CallExpression', 'OptionalCallExpression']),
  J = j$1(['MemberExpression', 'OptionalMemberExpression']);
function eu(r) {
  let e = 'expressions';
  r.type === 'TSTemplateLiteralType' && (e = 'types');
  let n = r[e];
  return n.length === 0
    ? !1
    : n.every((s) => {
        if (d(s)) return !1;
        if (s.type === 'Identifier' || s.type === 'ThisExpression') return !0;
        if ((s.type === 'ChainExpression' && (s = s.expression), J(s))) {
          let o = s;
          for (; J(o); )
            if (
              (o.property.type !== 'Identifier' &&
                o.property.type !== 'Literal' &&
                o.property.type !== 'StringLiteral' &&
                o.property.type !== 'NumericLiteral') ||
              ((o = o.object), d(o))
            )
              return !1;
          return o.type === 'Identifier' || o.type === 'ThisExpression';
        }
        return !1;
      });
}
function Ie(r, e) {
  return Y(e) ? dt(e) : d(e, x$1.Leading, (n) => z$1(r, O$1(n)));
}
function _n(r, e) {
  return (
    e.parser !== 'json' &&
    ee(r.key) &&
    oe(r.key).slice(1, -1) === r.key.value &&
    ((Js(r.key.value) &&
      !(
        (e.parser === 'babel-ts' && r.type === 'ClassProperty') ||
        (e.parser === 'typescript' && r.type === 'PropertyDefinition')
      )) ||
      (jn(r.key.value) &&
        String(Number(r.key.value)) === r.key.value &&
        (e.parser === 'babel' ||
          e.parser === 'acorn' ||
          e.parser === 'espree' ||
          e.parser === 'meriyah' ||
          e.parser === '__babel_estree')))
  );
}
function jn(r) {
  return /^(?:\d+|\d+\.\d+)$/.test(r);
}
function Hs(r) {
  return r.quasis.some((e) =>
    e.value.raw.includes(`
`),
  );
}
function xr(r, e) {
  return (
    ((r.type === 'TemplateLiteral' && Hs(r)) || (r.type === 'TaggedTemplateExpression' && Hs(r.quasi))) &&
    !z$1(e, U$1(r), { backwards: !0 })
  );
}
function gr(r) {
  if (!d(r)) return !1;
  let e = w$1(!1, Kt(r, x$1.Dangling), -1);
  return e && !ae(e);
}
function tu(r) {
  if (r.length <= 1) return !1;
  let e = 0;
  for (let n of r)
    if (It(n)) {
      if (((e += 1), e > 1)) return !0;
    } else if (k(n)) {
      for (let s of n.arguments) if (It(s)) return !0;
    }
  return !1;
}
function hr(r) {
  let { node: e, parent: n, key: s } = r;
  return s === 'callee' && k(e) && k(n) && n.arguments.length > 0 && e.arguments.length > n.arguments.length;
}
var Qa = new Set(['!', '-', '+', '~']);
function xe(r, e = 2) {
  if (e <= 0) return !1;
  let n = (s) => xe(s, e - 1);
  if (wn(r)) return tt(r.pattern ?? r.regex.pattern) <= 5;
  if (
    r.type === 'Literal' ||
    r.type === 'BigIntLiteral' ||
    r.type === 'DecimalLiteral' ||
    r.type === 'BooleanLiteral' ||
    r.type === 'NullLiteral' ||
    r.type === 'NumericLiteral' ||
    r.type === 'StringLiteral' ||
    r.type === 'Identifier' ||
    r.type === 'ThisExpression' ||
    r.type === 'Super' ||
    r.type === 'PrivateName' ||
    r.type === 'PrivateIdentifier' ||
    r.type === 'ArgumentPlaceholder' ||
    r.type === 'Import'
  )
    return !0;
  if (r.type === 'TemplateLiteral')
    return (
      r.quasis.every(
        (s) =>
          !s.value.raw.includes(`
`),
      ) && r.expressions.every(n)
    );
  if (Z(r)) return r.properties.every((s) => !s.computed && (s.shorthand || (s.value && n(s.value))));
  if (G(r)) return r.elements.every((s) => s === null || n(s));
  if (it(r)) {
    if (r.type === 'ImportExpression' || xe(r.callee, e)) {
      let s = he(r);
      return s.length <= e && s.every(n);
    }
    return !1;
  }
  return J(r)
    ? xe(r.object, e) && xe(r.property, e)
    : (r.type === 'UnaryExpression' && Qa.has(r.operator)) || r.type === 'UpdateExpression'
    ? xe(r.argument, e)
    : r.type === 'TSNonNullExpression'
    ? xe(r.expression, e)
    : !1;
}
function oe(r) {
  var e;
  return ((e = r.extra) == null ? void 0 : e.raw) ?? r.raw;
}
function ru(r) {
  return r;
}
function le(r, e = 'es5') {
  return (r.trailingComma === 'es5' && e === 'es5') || (r.trailingComma === 'all' && (e === 'all' || e === 'es5'));
}
function re(r, e) {
  switch (r.type) {
    case 'BinaryExpression':
    case 'LogicalExpression':
    case 'AssignmentExpression':
    case 'NGPipeExpression':
      return re(r.left, e);
    case 'MemberExpression':
    case 'OptionalMemberExpression':
      return re(r.object, e);
    case 'TaggedTemplateExpression':
      return r.tag.type === 'FunctionExpression' ? !1 : re(r.tag, e);
    case 'CallExpression':
    case 'OptionalCallExpression':
      return r.callee.type === 'FunctionExpression' ? !1 : re(r.callee, e);
    case 'ConditionalExpression':
      return re(r.test, e);
    case 'UpdateExpression':
      return !r.prefix && re(r.argument, e);
    case 'BindExpression':
      return r.object && re(r.object, e);
    case 'SequenceExpression':
      return re(r.expressions[0], e);
    case 'ChainExpression':
    case 'TSSatisfiesExpression':
    case 'TSAsExpression':
    case 'TSNonNullExpression':
      return re(r.expression, e);
    default:
      return e(r);
  }
}
var Ks = { '==': !0, '!=': !0, '===': !0, '!==': !0 },
  Cr = { '*': !0, '/': !0, '%': !0 },
  Ln = { '>>': !0, '>>>': !0, '<<': !0 };
function Vt(r, e) {
  return !(
    Yt(e) !== Yt(r) ||
    r === '**' ||
    (Ks[r] && Ks[e]) ||
    (e === '%' && Cr[r]) ||
    (r === '%' && Cr[e]) ||
    (e !== r && Cr[e] && Cr[r]) ||
    (Ln[r] && Ln[e])
  );
}
var Za = new Map(
  [
    ['|>'],
    ['??'],
    ['||'],
    ['&&'],
    ['|'],
    ['^'],
    ['&'],
    ['==', '===', '!=', '!=='],
    ['<', '>', '<=', '>=', 'in', 'instanceof'],
    ['>>', '<<', '>>>'],
    ['+', '-'],
    ['*', '/', '%'],
    ['**'],
  ].flatMap((r, e) => r.map((n) => [n, e])),
);
function Yt(r) {
  return Za.get(r);
}
function nu(r) {
  return !!Ln[r] || r === '|' || r === '^' || r === '&';
}
function su(r) {
  var e;
  if (r.rest) return !0;
  let n = X(r);
  return ((e = w$1(!1, n, -1)) == null ? void 0 : e.type) === 'RestElement';
}
var kn = new WeakMap();
function X(r) {
  if (kn.has(r)) return kn.get(r);
  let e = [];
  return (
    r.this && e.push(r.this),
    Array.isArray(r.parameters) ? e.push(...r.parameters) : Array.isArray(r.params) && e.push(...r.params),
    r.rest && e.push(r.rest),
    kn.set(r, e),
    e
  );
}
function uu(r, e) {
  let { node: n } = r,
    s = 0,
    o = (a) => e(a, s++);
  n.this && r.call(o, 'this'),
    Array.isArray(n.parameters) ? r.each(o, 'parameters') : Array.isArray(n.params) && r.each(o, 'params'),
    n.rest && r.call(o, 'rest');
}
var In = new WeakMap();
function he(r) {
  if (In.has(r)) return In.get(r);
  let e = r.arguments;
  return r.type === 'ImportExpression' && ((e = [r.source]), r.attributes && e.push(r.attributes)), In.set(r, e), e;
}
function Sr(r, e) {
  let { node: n } = r;
  n.type === 'ImportExpression'
    ? (r.call((s) => e(s, 0), 'source'), n.attributes && r.call((s) => e(s, 1), 'attributes'))
    : r.each(e, 'arguments');
}
function Mn(r, e) {
  if (r.type === 'ImportExpression') {
    if (e === 0 || e === (r.attributes ? -2 : -1)) return 'source';
    if (r.attributes && (e === 1 || e === -1)) return 'attributes';
    throw new RangeError('Invalid argument index');
  }
  if ((e < 0 && (e = r.arguments.length + e), e < 0 || e >= r.arguments.length))
    throw new RangeError('Invalid argument index');
  return ['arguments', e];
}
function Ht(r) {
  return r.value.trim() === 'prettier-ignore' && !r.unignore;
}
function dt(r) {
  return (r == null ? void 0 : r.prettierIgnore) || d(r, x$1.PrettierIgnore);
}
var x$1 = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 },
  iu = (r, e) => {
    if ((typeof r == 'function' && ((e = r), (r = 0)), r || e))
      return (n, s, o) =>
        !(
          (r & x$1.Leading && !n.leading) ||
          (r & x$1.Trailing && !n.trailing) ||
          (r & x$1.Dangling && (n.leading || n.trailing)) ||
          (r & x$1.Block && !ae(n)) ||
          (r & x$1.Line && !$t(n)) ||
          (r & x$1.First && s !== 0) ||
          (r & x$1.Last && s !== o.length - 1) ||
          (r & x$1.PrettierIgnore && !Ht(n)) ||
          (e && !e(n))
        );
  };
function d(r, e, n) {
  if (!b(r == null ? void 0 : r.comments)) return !1;
  let s = iu(e, n);
  return s ? r.comments.some(s) : !0;
}
function Kt(r, e, n) {
  if (!Array.isArray(r == null ? void 0 : r.comments)) return [];
  let s = iu(e, n);
  return s ? r.comments.filter(s) : r.comments;
}
var me = (r, { originalText: e }) => kt(e, O$1(r));
function it(r) {
  return k(r) || r.type === 'NewExpression' || r.type === 'ImportExpression';
}
function fe(r) {
  return r && (r.type === 'ObjectProperty' || (r.type === 'Property' && !r.method && r.kind === 'init'));
}
var zt = Symbol('ifWithoutBlockAndSameLineComment'),
  Le = j$1(['TSAsExpression', 'TSSatisfiesExpression']);
function Rn(r, e) {
  var n, s, o, a, l, f, m;
  if (r.isRoot) return !1;
  let { node: v, key: I, parent: L } = r;
  if (e.__isInHtmlInterpolation && !e.bracketSpacing && no(v) && Qt(r)) return !0;
  if (eo(v)) return !1;
  if (v.type === 'Identifier') {
    if (
      ((n = v.extra) != null && n.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(v.name)) ||
      (I === 'left' && ((v.name === 'async' && !L.await) || v.name === 'let') && L.type === 'ForOfStatement')
    )
      return !0;
    if (v.name === 'let') {
      let V = (s = r.findAncestor((se) => se.type === 'ForOfStatement')) == null ? void 0 : s.left;
      if (V && re(V, (se) => se === v)) return !0;
    }
    if (I === 'object' && v.name === 'let' && L.type === 'MemberExpression' && L.computed && !L.optional) {
      let V = r.findAncestor(
          (Ee) => Ee.type === 'ExpressionStatement' || Ee.type === 'ForStatement' || Ee.type === 'ForInStatement',
        ),
        se = V
          ? V.type === 'ExpressionStatement'
            ? V.expression
            : V.type === 'ForStatement'
            ? V.init
            : V.left
          : void 0;
      if (se && re(se, (Ee) => Ee === v)) return !0;
    }
    return !1;
  }
  if (
    v.type === 'ObjectExpression' ||
    v.type === 'FunctionExpression' ||
    v.type === 'ClassExpression' ||
    v.type === 'DoExpression'
  ) {
    let V = (o = r.findAncestor((se) => se.type === 'ExpressionStatement')) == null ? void 0 : o.expression;
    if (V && re(V, (se) => se === v)) return !0;
  }
  if (v.type === 'ObjectExpression') {
    let V = (a = r.findAncestor((se) => se.type === 'ArrowFunctionExpression')) == null ? void 0 : a.body;
    if (V && V.type !== 'SequenceExpression' && V.type !== 'AssignmentExpression' && re(V, (se) => se === v)) return !0;
  }
  switch (L.type) {
    case 'ParenthesizedExpression':
      return !1;
    case 'ClassDeclaration':
    case 'ClassExpression':
      if (
        I === 'superClass' &&
        (v.type === 'ArrowFunctionExpression' ||
          v.type === 'AssignmentExpression' ||
          v.type === 'AwaitExpression' ||
          v.type === 'BinaryExpression' ||
          v.type === 'ConditionalExpression' ||
          v.type === 'LogicalExpression' ||
          v.type === 'NewExpression' ||
          v.type === 'ObjectExpression' ||
          v.type === 'SequenceExpression' ||
          v.type === 'TaggedTemplateExpression' ||
          v.type === 'UnaryExpression' ||
          v.type === 'UpdateExpression' ||
          v.type === 'YieldExpression' ||
          v.type === 'TSNonNullExpression' ||
          (v.type === 'ClassExpression' && b(v.decorators)))
      )
        return !0;
      break;
    case 'ExportDefaultDeclaration':
      return au(r, e) || v.type === 'SequenceExpression';
    case 'Decorator':
      if (I === 'expression') {
        if (J(v) && v.computed) return !0;
        let V = !1,
          se = !1,
          Ee = v;
        for (; Ee; )
          switch (Ee.type) {
            case 'MemberExpression':
              (se = !0), (Ee = Ee.object);
              break;
            case 'CallExpression':
              if (se || V) return e.parser !== 'typescript';
              (V = !0), (Ee = Ee.callee);
              break;
            case 'Identifier':
              return !1;
            case 'TaggedTemplateExpression':
              return e.parser !== 'typescript';
            default:
              return !0;
          }
        return !0;
      }
      break;
    case 'TypeAnnotation':
      if (r.match(void 0, void 0, (V, se) => se === 'returnType' && V.type === 'ArrowFunctionExpression') && ro(v))
        return !0;
      break;
  }
  switch (v.type) {
    case 'UpdateExpression':
      if (L.type === 'UnaryExpression')
        return v.prefix && ((v.operator === '++' && L.operator === '+') || (v.operator === '--' && L.operator === '-'));
    case 'UnaryExpression':
      switch (L.type) {
        case 'UnaryExpression':
          return v.operator === L.operator && (v.operator === '+' || v.operator === '-');
        case 'BindExpression':
          return !0;
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return I === 'object';
        case 'TaggedTemplateExpression':
          return !0;
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return I === 'callee';
        case 'BinaryExpression':
          return I === 'left' && L.operator === '**';
        case 'TSNonNullExpression':
          return !0;
        default:
          return !1;
      }
    case 'BinaryExpression':
      if (L.type === 'UpdateExpression' || (v.operator === 'in' && to(r))) return !0;
      if (v.operator === '|>' && (l = v.extra) != null && l.parenthesized) {
        let V = r.grandparent;
        if (V.type === 'BinaryExpression' && V.operator === '|>') return !0;
      }
    case 'TSTypeAssertion':
    case 'TSAsExpression':
    case 'TSSatisfiesExpression':
    case 'LogicalExpression':
      switch (L.type) {
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
          return !Le(v);
        case 'ConditionalExpression':
          return Le(v);
        case 'CallExpression':
        case 'NewExpression':
        case 'OptionalCallExpression':
          return I === 'callee';
        case 'ClassExpression':
        case 'ClassDeclaration':
          return I === 'superClass';
        case 'TSTypeAssertion':
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'JSXSpreadAttribute':
        case 'SpreadElement':
        case 'BindExpression':
        case 'AwaitExpression':
        case 'TSNonNullExpression':
        case 'UpdateExpression':
          return !0;
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return I === 'object';
        case 'AssignmentExpression':
        case 'AssignmentPattern':
          return I === 'left' && (v.type === 'TSTypeAssertion' || Le(v));
        case 'LogicalExpression':
          if (v.type === 'LogicalExpression') return L.operator !== v.operator;
        case 'BinaryExpression': {
          let { operator: V, type: se } = v;
          if (!V && se !== 'TSTypeAssertion') return !0;
          let Ee = Yt(V),
            ht = L.operator,
            ar = Yt(ht);
          return ar > Ee || (I === 'right' && ar === Ee) || (ar === Ee && !Vt(ht, V))
            ? !0
            : ar < Ee && V === '%'
            ? ht === '+' || ht === '-'
            : !!nu(ht);
        }
        default:
          return !1;
      }
    case 'SequenceExpression':
      switch (L.type) {
        case 'ReturnStatement':
          return !1;
        case 'ForStatement':
          return !1;
        case 'ExpressionStatement':
          return I !== 'expression';
        case 'ArrowFunctionExpression':
          return I !== 'body';
        default:
          return !0;
      }
    case 'YieldExpression':
      if (L.type === 'AwaitExpression') return !0;
    case 'AwaitExpression':
      switch (L.type) {
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'LogicalExpression':
        case 'SpreadElement':
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
        case 'TSNonNullExpression':
        case 'BindExpression':
          return !0;
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return I === 'object';
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return I === 'callee';
        case 'ConditionalExpression':
          return I === 'test';
        case 'BinaryExpression':
          return !(!v.argument && L.operator === '|>');
        default:
          return !1;
      }
    case 'TSFunctionType':
      if (
        r.match(
          (V) => V.type === 'TSFunctionType',
          (V, se) => se === 'typeAnnotation' && V.type === 'TSTypeAnnotation',
          (V, se) => se === 'returnType' && V.type === 'ArrowFunctionExpression',
        )
      )
        return !0;
    case 'TSConditionalType':
    case 'TSConstructorType':
      if (I === 'extendsType' && L.type === 'TSConditionalType') {
        if (v.type === 'TSConditionalType') return !0;
        let { typeAnnotation: V } = v.returnType || v.typeAnnotation;
        if (
          (V.type === 'TSTypePredicate' && V.typeAnnotation && (V = V.typeAnnotation.typeAnnotation),
          V.type === 'TSInferType' && V.typeParameter.constraint)
        )
          return !0;
      }
      if (I === 'checkType' && L.type === 'TSConditionalType') return !0;
    case 'TSUnionType':
    case 'TSIntersectionType':
      if (
        (L.type === 'TSUnionType' || L.type === 'TSIntersectionType') &&
        L.types.length > 1 &&
        (!v.types || v.types.length > 1)
      )
        return !0;
    case 'TSInferType':
      if (v.type === 'TSInferType' && L.type === 'TSRestType') return !1;
    case 'TSTypeOperator':
      return (
        L.type === 'TSArrayType' ||
        L.type === 'TSOptionalType' ||
        L.type === 'TSRestType' ||
        (I === 'objectType' && L.type === 'TSIndexedAccessType') ||
        L.type === 'TSTypeOperator' ||
        (L.type === 'TSTypeAnnotation' && r.grandparent.type.startsWith('TSJSDoc'))
      );
    case 'TSTypeQuery':
      return (
        (I === 'objectType' && L.type === 'TSIndexedAccessType') || (I === 'elementType' && L.type === 'TSArrayType')
      );
    case 'TypeofTypeAnnotation':
      return (
        (I === 'objectType' && (L.type === 'IndexedAccessType' || L.type === 'OptionalIndexedAccessType')) ||
        (I === 'elementType' && L.type === 'ArrayTypeAnnotation')
      );
    case 'ArrayTypeAnnotation':
      return L.type === 'NullableTypeAnnotation';
    case 'IntersectionTypeAnnotation':
    case 'UnionTypeAnnotation':
      return (
        L.type === 'ArrayTypeAnnotation' ||
        L.type === 'NullableTypeAnnotation' ||
        L.type === 'IntersectionTypeAnnotation' ||
        L.type === 'UnionTypeAnnotation' ||
        (I === 'objectType' && (L.type === 'IndexedAccessType' || L.type === 'OptionalIndexedAccessType'))
      );
    case 'InferTypeAnnotation':
    case 'NullableTypeAnnotation':
      return (
        L.type === 'ArrayTypeAnnotation' ||
        (I === 'objectType' && (L.type === 'IndexedAccessType' || L.type === 'OptionalIndexedAccessType'))
      );
    case 'FunctionTypeAnnotation': {
      if (
        r.match(
          void 0,
          (se, Ee) => Ee === 'typeAnnotation' && se.type === 'TypeAnnotation',
          (se, Ee) => Ee === 'returnType' && se.type === 'ArrowFunctionExpression',
        ) ||
        r.match(
          void 0,
          (se, Ee) => Ee === 'typeAnnotation' && se.type === 'TypePredicate',
          (se, Ee) => Ee === 'typeAnnotation' && se.type === 'TypeAnnotation',
          (se, Ee) => Ee === 'returnType' && se.type === 'ArrowFunctionExpression',
        )
      )
        return !0;
      let V = L.type === 'NullableTypeAnnotation' ? r.grandparent : L;
      return (
        V.type === 'UnionTypeAnnotation' ||
        V.type === 'IntersectionTypeAnnotation' ||
        V.type === 'ArrayTypeAnnotation' ||
        (I === 'objectType' && (V.type === 'IndexedAccessType' || V.type === 'OptionalIndexedAccessType')) ||
        (I === 'checkType' && L.type === 'ConditionalTypeAnnotation') ||
        (I === 'extendsType' &&
          L.type === 'ConditionalTypeAnnotation' &&
          v.returnType.type === 'InferTypeAnnotation' &&
          v.returnType.typeParameter.bound) ||
        V.type === 'NullableTypeAnnotation' ||
        (L.type === 'FunctionTypeParam' &&
          L.name === null &&
          X(v).some((se) => {
            var Ee;
            return ((Ee = se.typeAnnotation) == null ? void 0 : Ee.type) === 'NullableTypeAnnotation';
          }))
      );
    }
    case 'ConditionalTypeAnnotation':
      if (
        (I === 'extendsType' && L.type === 'ConditionalTypeAnnotation' && v.type === 'ConditionalTypeAnnotation') ||
        (I === 'checkType' && L.type === 'ConditionalTypeAnnotation')
      )
        return !0;
    case 'OptionalIndexedAccessType':
      return I === 'objectType' && L.type === 'IndexedAccessType';
    case 'StringLiteral':
    case 'NumericLiteral':
    case 'Literal':
      if (typeof v.value == 'string' && L.type === 'ExpressionStatement' && !L.directive) {
        let V = r.grandparent;
        return V.type === 'Program' || V.type === 'BlockStatement';
      }
      return I === 'object' && L.type === 'MemberExpression' && typeof v.value == 'number';
    case 'AssignmentExpression': {
      let V = r.grandparent;
      return I === 'body' && L.type === 'ArrowFunctionExpression'
        ? !0
        : (I === 'key' && (L.type === 'ClassProperty' || L.type === 'PropertyDefinition') && L.computed) ||
          ((I === 'init' || I === 'update') && L.type === 'ForStatement')
        ? !1
        : L.type === 'ExpressionStatement'
        ? v.left.type === 'ObjectPattern'
        : !(
            (I === 'key' && L.type === 'TSPropertySignature') ||
            L.type === 'AssignmentExpression' ||
            (L.type === 'SequenceExpression' && V.type === 'ForStatement' && (V.init === L || V.update === L)) ||
            (I === 'value' && L.type === 'Property' && V.type === 'ObjectPattern' && V.properties.includes(L)) ||
            L.type === 'NGChainedExpression'
          );
    }
    case 'ConditionalExpression':
      switch (L.type) {
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'SpreadElement':
        case 'BinaryExpression':
        case 'LogicalExpression':
        case 'NGPipeExpression':
        case 'ExportDefaultDeclaration':
        case 'AwaitExpression':
        case 'JSXSpreadAttribute':
        case 'TSTypeAssertion':
        case 'TypeCastExpression':
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
        case 'TSNonNullExpression':
          return !0;
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return I === 'callee';
        case 'ConditionalExpression':
          return I === 'test';
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return I === 'object';
        default:
          return !1;
      }
    case 'FunctionExpression':
      switch (L.type) {
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return I === 'callee';
        case 'TaggedTemplateExpression':
          return !0;
        default:
          return !1;
      }
    case 'ArrowFunctionExpression':
      switch (L.type) {
        case 'BinaryExpression':
          return L.operator !== '|>' || ((f = v.extra) == null ? void 0 : f.parenthesized);
        case 'NewExpression':
        case 'CallExpression':
        case 'OptionalCallExpression':
          return I === 'callee';
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return I === 'object';
        case 'TSAsExpression':
        case 'TSSatisfiesExpression':
        case 'TSNonNullExpression':
        case 'BindExpression':
        case 'TaggedTemplateExpression':
        case 'UnaryExpression':
        case 'LogicalExpression':
        case 'AwaitExpression':
        case 'TSTypeAssertion':
          return !0;
        case 'ConditionalExpression':
          return I === 'test';
        default:
          return !1;
      }
    case 'ClassExpression':
      switch (L.type) {
        case 'NewExpression':
          return I === 'callee';
        default:
          return !1;
      }
    case 'OptionalMemberExpression':
    case 'OptionalCallExpression':
    case 'CallExpression':
    case 'MemberExpression':
      if (so(r)) return !0;
    case 'TaggedTemplateExpression':
    case 'TSNonNullExpression':
      if (I === 'callee' && (L.type === 'BindExpression' || L.type === 'NewExpression')) {
        let V = v;
        for (; V; )
          switch (V.type) {
            case 'CallExpression':
            case 'OptionalCallExpression':
              return !0;
            case 'MemberExpression':
            case 'OptionalMemberExpression':
            case 'BindExpression':
              V = V.object;
              break;
            case 'TaggedTemplateExpression':
              V = V.tag;
              break;
            case 'TSNonNullExpression':
              V = V.expression;
              break;
            default:
              return !1;
          }
      }
      return !1;
    case 'BindExpression':
      return (
        (I === 'callee' && (L.type === 'BindExpression' || L.type === 'NewExpression')) || (I === 'object' && J(L))
      );
    case 'NGPipeExpression':
      return !(
        L.type === 'NGRoot' ||
        L.type === 'NGMicrosyntaxExpression' ||
        (L.type === 'ObjectProperty' && !((m = v.extra) != null && m.parenthesized)) ||
        G(L) ||
        (I === 'arguments' && k(L)) ||
        (I === 'right' && L.type === 'NGPipeExpression') ||
        (I === 'property' && L.type === 'MemberExpression') ||
        L.type === 'AssignmentExpression'
      );
    case 'JSXFragment':
    case 'JSXElement':
      return (
        I === 'callee' ||
        (I === 'left' && L.type === 'BinaryExpression' && L.operator === '<') ||
        (!G(L) &&
          L.type !== 'ArrowFunctionExpression' &&
          L.type !== 'AssignmentExpression' &&
          L.type !== 'AssignmentPattern' &&
          L.type !== 'BinaryExpression' &&
          L.type !== 'NewExpression' &&
          L.type !== 'ConditionalExpression' &&
          L.type !== 'ExpressionStatement' &&
          L.type !== 'JsExpressionRoot' &&
          L.type !== 'JSXAttribute' &&
          L.type !== 'JSXElement' &&
          L.type !== 'JSXExpressionContainer' &&
          L.type !== 'JSXFragment' &&
          L.type !== 'LogicalExpression' &&
          !k(L) &&
          !fe(L) &&
          L.type !== 'ReturnStatement' &&
          L.type !== 'ThrowStatement' &&
          L.type !== 'TypeCastExpression' &&
          L.type !== 'VariableDeclarator' &&
          L.type !== 'YieldExpression')
      );
    case 'TSInstantiationExpression':
      return I === 'object' && J(L);
  }
  return !1;
}
var eo = j$1([
  'BlockStatement',
  'BreakStatement',
  'ClassBody',
  'ClassDeclaration',
  'ClassMethod',
  'ClassProperty',
  'PropertyDefinition',
  'ClassPrivateProperty',
  'ContinueStatement',
  'DebuggerStatement',
  'DeclareClass',
  'DeclareExportAllDeclaration',
  'DeclareExportDeclaration',
  'DeclareFunction',
  'DeclareInterface',
  'DeclareModule',
  'DeclareModuleExports',
  'DeclareVariable',
  'DeclareEnum',
  'DoWhileStatement',
  'EnumDeclaration',
  'ExportAllDeclaration',
  'ExportDefaultDeclaration',
  'ExportNamedDeclaration',
  'ExpressionStatement',
  'ForInStatement',
  'ForOfStatement',
  'ForStatement',
  'FunctionDeclaration',
  'IfStatement',
  'ImportDeclaration',
  'InterfaceDeclaration',
  'LabeledStatement',
  'MethodDefinition',
  'ReturnStatement',
  'SwitchStatement',
  'ThrowStatement',
  'TryStatement',
  'TSDeclareFunction',
  'TSEnumDeclaration',
  'TSImportEqualsDeclaration',
  'TSInterfaceDeclaration',
  'TSModuleDeclaration',
  'TSNamespaceExportDeclaration',
  'TypeAlias',
  'VariableDeclaration',
  'WhileStatement',
  'WithStatement',
]);
function to(r) {
  let e = 0,
    { node: n } = r;
  for (; n; ) {
    let s = r.getParentNode(e++);
    if ((s == null ? void 0 : s.type) === 'ForStatement' && s.init === n) return !0;
    n = s;
  }
  return !1;
}
function ro(r) {
  return Xt(r, (e) => e.type === 'ObjectTypeAnnotation' && Xt(e, (n) => n.type === 'FunctionTypeAnnotation'));
}
function no(r) {
  return Z(r);
}
function Qt(r) {
  let { parent: e, key: n } = r;
  switch (e.type) {
    case 'NGPipeExpression':
      if (n === 'arguments' && r.isLast) return r.callParent(Qt);
      break;
    case 'ObjectProperty':
      if (n === 'value') return r.callParent(() => r.key === 'properties' && r.isLast);
      break;
    case 'BinaryExpression':
    case 'LogicalExpression':
      if (n === 'right') return r.callParent(Qt);
      break;
    case 'ConditionalExpression':
      if (n === 'alternate') return r.callParent(Qt);
      break;
    case 'UnaryExpression':
      if (e.prefix) return r.callParent(Qt);
      break;
  }
  return !1;
}
function au(r, e) {
  let { node: n, parent: s } = r;
  return n.type === 'FunctionExpression' || n.type === 'ClassExpression'
    ? s.type === 'ExportDefaultDeclaration' || !Rn(r, e)
    : !Lt(n) || (s.type !== 'ExportDefaultDeclaration' && Rn(r, e))
    ? !1
    : r.call(() => au(r, e), ...dr(n));
}
function so(r) {
  let { node: e, parent: n, grandparent: s, key: o } = r;
  return !!(
    ((e.type === 'OptionalMemberExpression' || e.type === 'OptionalCallExpression') &&
      ((o === 'object' && n.type === 'MemberExpression') ||
        (o === 'callee' && (n.type === 'CallExpression' || n.type === 'NewExpression')) ||
        (n.type === 'TSNonNullExpression' && s.type === 'MemberExpression' && s.object === n))) ||
    (r.match(
      () => e.type === 'CallExpression' || e.type === 'MemberExpression',
      (a, l) => l === 'expression' && a.type === 'ChainExpression',
    ) &&
      (r.match(
        void 0,
        void 0,
        (a, l) =>
          (l === 'callee' && ((a.type === 'CallExpression' && !a.optional) || a.type === 'NewExpression')) ||
          (l === 'object' && a.type === 'MemberExpression' && !a.optional),
      ) ||
        r.match(
          void 0,
          void 0,
          (a, l) => l === 'expression' && a.type === 'TSNonNullExpression',
          (a, l) => l === 'object' && a.type === 'MemberExpression',
        ))) ||
    r.match(
      () => e.type === 'CallExpression' || e.type === 'MemberExpression',
      (a, l) => l === 'expression' && a.type === 'TSNonNullExpression',
      (a, l) => l === 'expression' && a.type === 'ChainExpression',
      (a, l) => l === 'object' && a.type === 'MemberExpression',
    )
  );
}
var we = Rn,
  uo = (r, e, n, s) => {
    if (!(r && e == null)) return e.replaceAll ? e.replaceAll(n, s) : n.global ? e.replace(n, s) : e.split(n).join(s);
  },
  H = uo;
function io(r, e) {
  let n = e - 1;
  (n = We(r, n, { backwards: !0 })), (n = Ye(r, n, { backwards: !0 })), (n = We(r, n, { backwards: !0 }));
  let s = Ye(r, n, { backwards: !0 });
  return n !== s;
}
var ou = io,
  ao = () => !0;
function Jn(r, e) {
  let n = r.node;
  return (n.printed = !0), e.printer.printComment(r, e);
}
function oo(r, e) {
  var n;
  let s = r.node,
    o = [Jn(r, e)],
    { printer: a, originalText: l, locStart: f, locEnd: m } = e;
  if ((n = a.isBlockComment) != null && n.call(a, s)) {
    let I = z$1(l, m(s)) ? (z$1(l, f(s), { backwards: !0 }) ? C$1 : A) : ' ';
    o.push(I);
  } else o.push(C$1);
  let v = Ye(l, We(l, m(s)));
  return v !== !1 && z$1(l, v) && o.push(C$1), o;
}
function po(r, e, n) {
  var s;
  let o = r.node,
    a = Jn(r, e),
    { printer: l, originalText: f, locStart: m } = e,
    v = (s = l.isBlockComment) == null ? void 0 : s.call(l, o);
  if ((n != null && n.hasLineSuffix && !(n != null && n.isBlock)) || z$1(f, m(o), { backwards: !0 })) {
    let I = ou(f, m(o));
    return { doc: hn([C$1, I ? C$1 : '', a]), isBlock: v, hasLineSuffix: !0 };
  }
  return !v || (n != null && n.hasLineSuffix)
    ? { doc: [hn([' ', a]), Ae], isBlock: v, hasLineSuffix: !0 }
    : { doc: [' ', a], isBlock: v, hasLineSuffix: !1 };
}
function M(r, e, n = {}) {
  let { node: s } = r;
  if (!b(s == null ? void 0 : s.comments)) return '';
  let { indent: o = !1, marker: a, filter: l = ao } = n,
    f = [];
  if (
    (r.each(({ node: v }) => {
      v.leading || v.trailing || v.marker !== a || !l(v) || f.push(Jn(r, e));
    }, 'comments'),
    f.length === 0)
  )
    return '';
  let m = B$1(C$1, f);
  return o ? E([C$1, m]) : m;
}
function Nn(r, e) {
  let n = r.node;
  if (!n) return {};
  let s = e[Symbol.for('printedComments')];
  if ((n.comments || []).filter((f) => !s.has(f)).length === 0) return { leading: '', trailing: '' };
  let o = [],
    a = [],
    l;
  return (
    r.each(() => {
      let f = r.node;
      if (s != null && s.has(f)) return;
      let { leading: m, trailing: v } = f;
      m ? o.push(oo(r, e)) : v && ((l = po(r, e, l)), a.push(l.doc));
    }, 'comments'),
    { leading: o, trailing: a }
  );
}
function pe(r, e, n) {
  let { leading: s, trailing: o } = Nn(r, n);
  return !s && !o ? e : Gt(e, (a) => [s, a, o]);
}
var Un = class extends Error {
    constructor(e, n, s = 'type') {
      super(`Unexpected ${n} node ${s}: ${JSON.stringify(e[s])}.`);
      Cf(this, 'name', 'UnexpectedNodeError');
      this.node = e;
    }
  },
  Oe = Un,
  Br = "'",
  pu = '"';
function co(r, e) {
  let n = e === !0 || e === Br ? Br : pu,
    s = n === Br ? pu : Br,
    o = 0,
    a = 0;
  for (let l of r) l === n ? o++ : l === s && a++;
  return o > a ? s : n;
}
var br = co;
function Gn(r) {
  if (typeof r != 'string') throw new TypeError('Expected a string');
  return r.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
var ve,
  qn = class {
    constructor(r) {
      bs(this, ve, void 0), Ps(this, ve, new Set(r));
    }
    getLeadingWhitespaceCount(r) {
      let e = st(this, ve),
        n = 0;
      for (let s = 0; s < r.length && e.has(r.charAt(s)); s++) n++;
      return n;
    }
    getTrailingWhitespaceCount(r) {
      let e = st(this, ve),
        n = 0;
      for (let s = r.length - 1; s >= 0 && e.has(r.charAt(s)); s--) n++;
      return n;
    }
    getLeadingWhitespace(r) {
      let e = this.getLeadingWhitespaceCount(r);
      return r.slice(0, e);
    }
    getTrailingWhitespace(r) {
      let e = this.getTrailingWhitespaceCount(r);
      return r.slice(r.length - e);
    }
    hasLeadingWhitespace(r) {
      return st(this, ve).has(r.charAt(0));
    }
    hasTrailingWhitespace(r) {
      return st(this, ve).has(w$1(!1, r, -1));
    }
    trimStart(r) {
      let e = this.getLeadingWhitespaceCount(r);
      return r.slice(e);
    }
    trimEnd(r) {
      let e = this.getTrailingWhitespaceCount(r);
      return r.slice(0, r.length - e);
    }
    trim(r) {
      return this.trimEnd(this.trimStart(r));
    }
    split(r, e = !1) {
      let n = `[${Gn([...st(this, ve)].join(''))}]+`,
        s = new RegExp(e ? `(${n})` : n);
      return r.split(s);
    }
    hasWhitespaceCharacter(r) {
      let e = st(this, ve);
      return Array.prototype.some.call(r, (n) => e.has(n));
    }
    hasNonWhitespaceCharacter(r) {
      let e = st(this, ve);
      return Array.prototype.some.call(r, (n) => !e.has(n));
    }
    isWhitespaceOnly(r) {
      let e = st(this, ve);
      return Array.prototype.every.call(r, (n) => e.has(n));
    }
  };
ve = new WeakMap();
var cu = qn,
  Kn = {};
or(Kn, { endOfLine: () => Fo, ownLine: () => Eo, remaining: () => Co });
function lo(r, e) {
  let n = null,
    s = e;
  for (; s !== n; ) (n = s), (s = We(r, s)), (s = bt(r, s)), (s = Pt(r, s)), (s = Ye(r, s));
  return s;
}
var Xe = lo;
function mo(r, e) {
  let n = Xe(r, e);
  return n === !1 ? '' : r.charAt(n);
}
var $e = mo;
function yo(r, e, n) {
  for (let s = e; s < n; ++s)
    if (
      r.charAt(s) ===
      `
`
    )
      return !0;
  return !1;
}
var rt = yo;
function Do(r) {
  let e = r.type || r.kind || '(unknown type)',
    n = String(
      r.name ||
        (r.id && (typeof r.id == 'object' ? r.id.name : r.id)) ||
        (r.key && (typeof r.key == 'object' ? r.key.name : r.key)) ||
        (r.value && (typeof r.value == 'object' ? '' : String(r.value))) ||
        r.operator ||
        '',
    );
  return n.length > 20 && (n = n.slice(0, 19) + '…'), e + (n ? ' ' + n : '');
}
function Wn(r, e) {
  (r.comments ?? (r.comments = [])).push(e), (e.printed = !1), (e.nodeDescription = Do(r));
}
function ne(r, e) {
  (e.leading = !0), (e.trailing = !1), Wn(r, e);
}
function _e(r, e, n) {
  (e.leading = !1), (e.trailing = !1), n && (e.marker = n), Wn(r, e);
}
function te(r, e) {
  (e.leading = !1), (e.trailing = !0), Wn(r, e);
}
function fo(r) {
  return ae(r) && r.value[0] === '*' && /@(?:type|satisfies)\b/.test(r.value);
}
var lu = fo;
function Eo(r) {
  return [Cu, fu, To, Xn, $n, mu, yu, Oo, Lo, Hn, Fu, vo, Du, Eu, Vn].some((e) => e(r));
}
function Fo(r) {
  return [Ao, fu, xo, Fu, Xn, $n, mu, yu, Eu, Io, wo, Hn, Mo, Vn, No].some((e) => e(r));
}
function Co(r) {
  return [Cu, Xn, $n, go, ko, Du, Hn, Po, bo, Jo, Vn, Ro].some((e) => e(r));
}
function At(r, e) {
  let n = (r.body || r.properties).find(({ type: s }) => s !== 'EmptyStatement');
  n ? ne(n, e) : _e(r, e);
}
function Yn(r, e) {
  r.type === 'BlockStatement' ? At(r, e) : ne(r, e);
}
function Ao({ comment: r, followingNode: e }) {
  return e && lu(r) ? (ne(e, r), !0) : !1;
}
function Xn({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s, text: o }) {
  if ((n == null ? void 0 : n.type) !== 'IfStatement' || !s) return !1;
  if ($e(o, O$1(r)) === ')') return te(e, r), !0;
  if (e === n.consequent && s === n.alternate) {
    if (e.type === 'BlockStatement') te(e, r);
    else {
      let a = r.type === 'SingleLine' || r.loc.start.line === r.loc.end.line,
        l = r.loc.start.line === e.loc.start.line;
      a && l ? _e(e, r, e.type === 'ExpressionStatement' ? zt : void 0) : _e(n, r);
    }
    return !0;
  }
  return s.type === 'BlockStatement'
    ? (At(s, r), !0)
    : s.type === 'IfStatement'
    ? (Yn(s.consequent, r), !0)
    : n.consequent === s
    ? (ne(s, r), !0)
    : !1;
}
function $n({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s, text: o }) {
  return (n == null ? void 0 : n.type) !== 'WhileStatement' || !s
    ? !1
    : $e(o, O$1(r)) === ')'
    ? (te(e, r), !0)
    : s.type === 'BlockStatement'
    ? (At(s, r), !0)
    : n.body === s
    ? (ne(s, r), !0)
    : !1;
}
function mu({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s }) {
  return ((n == null ? void 0 : n.type) !== 'TryStatement' && (n == null ? void 0 : n.type) !== 'CatchClause') || !s
    ? !1
    : n.type === 'CatchClause' && e
    ? (te(e, r), !0)
    : s.type === 'BlockStatement'
    ? (At(s, r), !0)
    : s.type === 'TryStatement'
    ? (Yn(s.finalizer, r), !0)
    : s.type === 'CatchClause'
    ? (Yn(s.body, r), !0)
    : !1;
}
function To({ comment: r, enclosingNode: e, followingNode: n }) {
  return J(e) && (n == null ? void 0 : n.type) === 'Identifier' ? (ne(e, r), !0) : !1;
}
function xo({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s, text: o }) {
  let a = e && !rt(o, O$1(e), U$1(r));
  return (!e || !a) &&
    ((n == null ? void 0 : n.type) === 'ConditionalExpression' ||
      (n == null ? void 0 : n.type) === 'TSConditionalType') &&
    s
    ? (ne(s, r), !0)
    : !1;
}
function go({ comment: r, precedingNode: e, enclosingNode: n }) {
  return fe(n) && n.shorthand && n.key === e && n.value.type === 'AssignmentPattern' ? (te(n.value.left, r), !0) : !1;
}
var ho = new Set([
  'ClassDeclaration',
  'ClassExpression',
  'DeclareClass',
  'DeclareInterface',
  'InterfaceDeclaration',
  'TSInterfaceDeclaration',
]);
function yu({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s }) {
  if (ho.has(n == null ? void 0 : n.type)) {
    if (b(n.decorators) && (s == null ? void 0 : s.type) !== 'Decorator') return te(w$1(!1, n.decorators, -1), r), !0;
    if (n.body && s === n.body) return At(n.body, r), !0;
    if (s) {
      if (n.superClass && s === n.superClass && e && (e === n.id || e === n.typeParameters)) return te(e, r), !0;
      for (let o of ['implements', 'extends', 'mixins'])
        if (n[o] && s === n[o][0])
          return e && (e === n.id || e === n.typeParameters || e === n.superClass) ? te(e, r) : _e(n, r, o), !0;
    }
  }
  return !1;
}
var So = new Set([
  'ClassMethod',
  'ClassProperty',
  'PropertyDefinition',
  'TSAbstractPropertyDefinition',
  'TSAbstractMethodDefinition',
  'TSDeclareMethod',
  'MethodDefinition',
  'ClassAccessorProperty',
  'AccessorProperty',
  'TSAbstractAccessorProperty',
]);
function Du({ comment: r, precedingNode: e, enclosingNode: n, text: s }) {
  return (n &&
    e &&
    $e(s, O$1(r)) === '(' &&
    (n.type === 'Property' || n.type === 'TSDeclareMethod' || n.type === 'TSAbstractMethodDefinition') &&
    e.type === 'Identifier' &&
    n.key === e &&
    $e(s, O$1(e)) !== ':') ||
    ((e == null ? void 0 : e.type) === 'Decorator' && So.has(n == null ? void 0 : n.type))
    ? (te(e, r), !0)
    : !1;
}
var Bo = new Set(['FunctionDeclaration', 'FunctionExpression', 'ClassMethod', 'MethodDefinition', 'ObjectMethod']);
function bo({ comment: r, precedingNode: e, enclosingNode: n, text: s }) {
  return $e(s, O$1(r)) !== '(' ? !1 : e && Bo.has(n == null ? void 0 : n.type) ? (te(e, r), !0) : !1;
}
function Po({ comment: r, enclosingNode: e, text: n }) {
  if ((e == null ? void 0 : e.type) !== 'ArrowFunctionExpression') return !1;
  let s = Xe(n, O$1(r));
  return s !== !1 && n.slice(s, s + 2) === '=>' ? (_e(e, r), !0) : !1;
}
function ko({ comment: r, enclosingNode: e, text: n }) {
  return $e(n, O$1(r)) !== ')'
    ? !1
    : e && ((du(e) && X(e).length === 0) || (it(e) && he(e).length === 0))
    ? (_e(e, r), !0)
    : ((e == null ? void 0 : e.type) === 'MethodDefinition' ||
        (e == null ? void 0 : e.type) === 'TSAbstractMethodDefinition') &&
      X(e.value).length === 0
    ? (_e(e.value, r), !0)
    : !1;
}
function fu({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s, text: o }) {
  if (
    ((e == null ? void 0 : e.type) === 'FunctionTypeParam' &&
      (n == null ? void 0 : n.type) === 'FunctionTypeAnnotation' &&
      (s == null ? void 0 : s.type) !== 'FunctionTypeParam') ||
    (((e == null ? void 0 : e.type) === 'Identifier' ||
      (e == null ? void 0 : e.type) === 'AssignmentPattern' ||
      (e == null ? void 0 : e.type) === 'ObjectPattern' ||
      (e == null ? void 0 : e.type) === 'ArrayPattern' ||
      (e == null ? void 0 : e.type) === 'RestElement') &&
      n &&
      du(n) &&
      $e(o, O$1(r)) === ')')
  )
    return te(e, r), !0;
  if ((n == null ? void 0 : n.type) === 'FunctionDeclaration' && (s == null ? void 0 : s.type) === 'BlockStatement') {
    let a = (() => {
      let l = X(n);
      if (l.length > 0) return Xe(o, O$1(w$1(!1, l, -1)));
      let f = Xe(o, O$1(n.id));
      return f !== !1 && Xe(o, f + 1);
    })();
    if (U$1(r) > a) return At(s, r), !0;
  }
  return !1;
}
function Eu({ comment: r, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === 'LabeledStatement' ? (ne(e, r), !0) : !1;
}
function Vn({ comment: r, enclosingNode: e }) {
  return ((e == null ? void 0 : e.type) === 'ContinueStatement' ||
    (e == null ? void 0 : e.type) === 'BreakStatement') &&
    !e.label
    ? (te(e, r), !0)
    : !1;
}
function Io({ comment: r, precedingNode: e, enclosingNode: n }) {
  return k(n) && e && n.callee === e && n.arguments.length > 0 ? (ne(n.arguments[0], r), !0) : !1;
}
function Lo({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s }) {
  return (n == null ? void 0 : n.type) === 'UnionTypeAnnotation' || (n == null ? void 0 : n.type) === 'TSUnionType'
    ? (Ht(r) && ((s.prettierIgnore = !0), (r.unignore = !0)), e ? (te(e, r), !0) : !1)
    : (((s == null ? void 0 : s.type) === 'UnionTypeAnnotation' || (s == null ? void 0 : s.type) === 'TSUnionType') &&
        Ht(r) &&
        ((s.types[0].prettierIgnore = !0), (r.unignore = !0)),
      !1);
}
function wo({ comment: r, enclosingNode: e }) {
  return fe(e) ? (ne(e, r), !0) : !1;
}
function Hn({ comment: r, enclosingNode: e, followingNode: n, ast: s, isLastComment: o }) {
  var a;
  return ((a = s == null ? void 0 : s.body) == null ? void 0 : a.length) === 0
    ? (o ? _e(s, r) : ne(s, r), !0)
    : (e == null ? void 0 : e.type) === 'Program' && e.body.length === 0 && !b(e.directives)
    ? (o ? _e(e, r) : ne(e, r), !0)
    : (n == null ? void 0 : n.type) === 'Program' &&
      n.body.length === 0 &&
      (e == null ? void 0 : e.type) === 'ModuleExpression'
    ? (_e(n, r), !0)
    : !1;
}
function Oo({ comment: r, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === 'ForInStatement' || (e == null ? void 0 : e.type) === 'ForOfStatement'
    ? (ne(e, r), !0)
    : !1;
}
function Fu({ comment: r, precedingNode: e, enclosingNode: n, text: s }) {
  if ((n == null ? void 0 : n.type) === 'ImportSpecifier' || (n == null ? void 0 : n.type) === 'ExportSpecifier')
    return ne(n, r), !0;
  let o = (e == null ? void 0 : e.type) === 'ImportSpecifier' && (n == null ? void 0 : n.type) === 'ImportDeclaration',
    a =
      (e == null ? void 0 : e.type) === 'ExportSpecifier' && (n == null ? void 0 : n.type) === 'ExportNamedDeclaration';
  return (o || a) && z$1(s, O$1(r)) ? (te(e, r), !0) : !1;
}
function vo({ comment: r, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === 'AssignmentPattern' ? (ne(e, r), !0) : !1;
}
var _o = new Set(['VariableDeclarator', 'AssignmentExpression', 'TypeAlias', 'TSTypeAliasDeclaration']),
  jo = new Set([
    'ObjectExpression',
    'RecordExpression',
    'ArrayExpression',
    'TupleExpression',
    'TemplateLiteral',
    'TaggedTemplateExpression',
    'ObjectTypeAnnotation',
    'TSTypeLiteral',
  ]);
function Mo({ comment: r, enclosingNode: e, followingNode: n }) {
  return _o.has(e == null ? void 0 : e.type) && n && (jo.has(n.type) || ae(r)) ? (ne(n, r), !0) : !1;
}
function Ro({ comment: r, enclosingNode: e, followingNode: n, text: s }) {
  return !n &&
    ((e == null ? void 0 : e.type) === 'TSMethodSignature' ||
      (e == null ? void 0 : e.type) === 'TSDeclareFunction' ||
      (e == null ? void 0 : e.type) === 'TSAbstractMethodDefinition') &&
    $e(s, O$1(r)) === ';'
    ? (te(e, r), !0)
    : !1;
}
function Cu({ comment: r, enclosingNode: e, followingNode: n }) {
  if (
    Ht(r) &&
    (e == null ? void 0 : e.type) === 'TSMappedType' &&
    (n == null ? void 0 : n.type) === 'TSTypeParameter' &&
    n.constraint
  )
    return (e.prettierIgnore = !0), (r.unignore = !0), !0;
}
function Jo({ comment: r, precedingNode: e, enclosingNode: n, followingNode: s }) {
  return (n == null ? void 0 : n.type) !== 'TSMappedType'
    ? !1
    : (s == null ? void 0 : s.type) === 'TSTypeParameter' && s.name
    ? (ne(s.name, r), !0)
    : (e == null ? void 0 : e.type) === 'TSTypeParameter' && e.constraint
    ? (te(e.constraint, r), !0)
    : !1;
}
function No({ comment: r, enclosingNode: e, followingNode: n }) {
  return !e || e.type !== 'SwitchCase' || e.test || !n || n !== e.consequent[0]
    ? !1
    : (n.type === 'BlockStatement' && $t(r) ? At(n, r) : _e(e, r), !0);
}
var du = j$1([
  'ArrowFunctionExpression',
  'FunctionExpression',
  'FunctionDeclaration',
  'ObjectMethod',
  'ClassMethod',
  'TSDeclareFunction',
  'TSCallSignatureDeclaration',
  'TSConstructSignatureDeclaration',
  'TSMethodSignature',
  'TSConstructorType',
  'TSFunctionType',
  'TSDeclareMethod',
]);
function Uo(r) {
  let e = `*${r.value}*`.split(`
`);
  return e.length > 1 && e.every((n) => n.trimStart()[0] === '*');
}
var Au = Uo;
function Tu(r, e) {
  let n = r.node;
  if ($t(n)) return e.originalText.slice(U$1(n), O$1(n)).trimEnd();
  if (ae(n)) return Au(n) ? Go(n) : ['/*', Te(n.value), '*/'];
  throw new Error('Not a comment: ' + JSON.stringify(n));
}
function Go(r) {
  let e = r.value.split(`
`);
  return [
    '/*',
    B$1(
      C$1,
      e.map((n, s) => (s === 0 ? n.trimEnd() : ' ' + (s < e.length - 1 ? n.trim() : n.trimStart()))),
    ),
    '*/',
  ];
}
var qo = new Set(['EmptyStatement', 'TemplateElement', 'Import', 'TSEmptyBodyFunctionExpression', 'ChainExpression']);
function Wo(r) {
  return !qo.has(r.type);
}
function Yo(r, e) {
  var n;
  if (
    (e.parser === 'typescript' ||
      e.parser === 'flow' ||
      e.parser === 'acorn' ||
      e.parser === 'espree' ||
      e.parser === 'meriyah' ||
      e.parser === '__babel_estree') &&
    r.type === 'MethodDefinition' &&
    ((n = r.value) == null ? void 0 : n.type) === 'FunctionExpression' &&
    X(r.value).length === 0 &&
    !r.value.returnType &&
    !b(r.value.typeParameters) &&
    r.value.body
  )
    return [...(r.decorators || []), r.key, r.value.body];
}
function zn(r) {
  let { node: e, parent: n } = r;
  return (
    (Y(e) ||
      (n &&
        (n.type === 'JSXSpreadAttribute' ||
          n.type === 'JSXSpreadChild' ||
          n.type === 'UnionTypeAnnotation' ||
          n.type === 'TSUnionType' ||
          ((n.type === 'ClassDeclaration' || n.type === 'ClassExpression') && n.superClass === e)))) &&
    (!dt(e) || n.type === 'UnionTypeAnnotation' || n.type === 'TSUnionType')
  );
}
function Xo(r, { parser: e }) {
  if (e === 'flow' || e === 'babel-flow') return (r = H(!1, r, /[\s(]/g, '')), r === '' || r === '/*' || r === '/*::';
}
var Pr = new cu(` 
\r	`),
  Qn = (r) => r === '' || r === A || r === C$1 || r === F$1;
function $o(r, e, n) {
  var s, o, a;
  let { node: l } = r;
  if (l.type === 'JSXElement' && ap(l)) return [n('openingElement'), n('closingElement')];
  let f = l.type === 'JSXElement' ? n('openingElement') : n('openingFragment'),
    m = l.type === 'JSXElement' ? n('closingElement') : n('closingFragment');
  if (
    l.children.length === 1 &&
    l.children[0].type === 'JSXExpressionContainer' &&
    (l.children[0].expression.type === 'TemplateLiteral' ||
      l.children[0].expression.type === 'TaggedTemplateExpression')
  )
    return [f, ...r.map(n, 'children'), m];
  l.children = l.children.map((dl) => (op(dl) ? { type: 'JSXText', value: ' ', raw: ' ' } : dl));
  let v = l.children.some(Y),
    I = l.children.filter((dl) => dl.type === 'JSXExpressionContainer').length > 1,
    L = l.type === 'JSXElement' && l.openingElement.attributes.length > 1,
    V = K(f) || v || L || I,
    se = r.parent.rootMarker === 'mdx',
    Ee = e.singleQuote ? "{' '}" : '{" "}',
    ht = se ? ' ' : P$1([Ee, F$1], ' '),
    ar = ((o = (s = l.openingElement) == null ? void 0 : s.name) == null ? void 0 : o.name) === 'fbt',
    $i = Vo(r, e, n, ht, ar),
    tl = l.children.some((dl) => Zt(dl));
  for (let dl = $i.length - 2; dl >= 0; dl--) {
    let Al = $i[dl] === '' && $i[dl + 1] === '',
      Fl = $i[dl] === C$1 && $i[dl + 1] === '' && $i[dl + 2] === C$1,
      vl = ($i[dl] === F$1 || $i[dl] === C$1) && $i[dl + 1] === '' && $i[dl + 2] === ht,
      kl = $i[dl] === ht && $i[dl + 1] === '' && ($i[dl + 2] === F$1 || $i[dl + 2] === C$1),
      El = $i[dl] === ht && $i[dl + 1] === '' && $i[dl + 2] === ht,
      Jl =
        ($i[dl] === F$1 && $i[dl + 1] === '' && $i[dl + 2] === C$1) ||
        ($i[dl] === C$1 && $i[dl + 1] === '' && $i[dl + 2] === F$1);
    (Fl && tl) || Al || vl || El || Jl ? $i.splice(dl, 2) : kl && $i.splice(dl + 1, 2);
  }
  for (; $i.length > 0 && Qn(w$1(!1, $i, -1)); ) $i.pop();
  for (; $i.length > 1 && Qn($i[0]) && Qn($i[1]); ) $i.shift(), $i.shift();
  let Wi = [];
  for (let [dl, Al] of $i.entries()) {
    if (Al === ht) {
      if (dl === 1 && $i[dl - 1] === '') {
        if ($i.length === 2) {
          Wi.push(Ee);
          continue;
        }
        Wi.push([Ee, C$1]);
        continue;
      } else if (dl === $i.length - 1) {
        Wi.push(Ee);
        continue;
      } else if ($i[dl - 1] === '' && $i[dl - 2] === C$1) {
        Wi.push(Ee);
        continue;
      }
    }
    Wi.push(Al), K(Al) && (V = !0);
  }
  let hl = tl ? St(Wi) : y$1(Wi, { shouldBreak: !0 });
  if (
    (((a = e.cursorNode) == null ? void 0 : a.type) === 'JSXText' &&
      l.children.includes(e.cursorNode) &&
      (hl = [Bn, hl, Bn]),
    se)
  )
    return hl;
  let fl = y$1([f, E([C$1, hl]), C$1, m]);
  return V ? fl : qe([y$1([f, ...$i, m]), fl]);
}
function Vo(r, e, n, s, o) {
  let a = [];
  return (
    r.each(({ node: l, next: f }) => {
      if (l.type === 'JSXText') {
        let m = oe(l);
        if (Zt(l)) {
          let v = Pr.split(m, !0);
          v[0] === '' && (a.push(''), v.shift(), /\n/.test(v[0]) ? a.push(gu(o, v[1], l, f)) : a.push(s), v.shift());
          let I;
          if ((w$1(!1, v, -1) === '' && (v.pop(), (I = v.pop())), v.length === 0)) return;
          for (let [L, V] of v.entries()) L % 2 === 1 ? a.push(A) : a.push(V);
          I !== void 0
            ? /\n/.test(I)
              ? a.push(gu(o, w$1(!1, a, -1), l, f))
              : a.push(s)
            : a.push(xu(o, w$1(!1, a, -1), l, f));
        } else /\n/.test(m) ? m.match(/\n/g).length > 1 && a.push('', C$1) : a.push('', s);
      } else {
        let m = n();
        if ((a.push(m), f && Zt(f))) {
          let v = Pr.trim(oe(f)),
            [I] = Pr.split(v);
          a.push(xu(o, I, l, f));
        } else a.push(C$1);
      }
    }, 'children'),
    a
  );
}
function xu(r, e, n, s) {
  return r
    ? ''
    : (n.type === 'JSXElement' && !n.closingElement) ||
      ((s == null ? void 0 : s.type) === 'JSXElement' && !s.closingElement)
    ? e.length === 1
      ? F$1
      : C$1
    : F$1;
}
function gu(r, e, n, s) {
  return r
    ? C$1
    : e.length === 1
    ? (n.type === 'JSXElement' && !n.closingElement) ||
      ((s == null ? void 0 : s.type) === 'JSXElement' && !s.closingElement)
      ? C$1
      : F$1
    : C$1;
}
var Ho = new Set([
  'ArrayExpression',
  'TupleExpression',
  'JSXAttribute',
  'JSXElement',
  'JSXExpressionContainer',
  'JSXFragment',
  'ExpressionStatement',
  'CallExpression',
  'OptionalCallExpression',
  'ConditionalExpression',
  'JsExpressionRoot',
]);
function Ko(r, e, n) {
  let { parent: s } = r;
  if (Ho.has(s.type)) return e;
  let o = r.match(
      void 0,
      (l) => l.type === 'ArrowFunctionExpression',
      k,
      (l) => l.type === 'JSXExpressionContainer',
    ),
    a = we(r, n);
  return y$1([a ? '' : P$1('('), E([F$1, e]), F$1, a ? '' : P$1(')')], { shouldBreak: o });
}
function zo(r, e, n) {
  let { node: s } = r,
    o = [];
  if ((o.push(n('name')), s.value)) {
    let a;
    if (ee(s.value)) {
      let l = oe(s.value),
        f = H(!1, H(!1, l.slice(1, -1), '&apos;', "'"), '&quot;', '"'),
        m = br(f, e.jsxSingleQuote);
      (f = m === '"' ? H(!1, f, '"', '&quot;') : H(!1, f, "'", '&apos;')),
        (a = r.call(() => pe(r, Te(m + f + m), e), 'value'));
    } else a = n('value');
    o.push('=', a);
  }
  return o;
}
function Qo(r, e, n) {
  let { node: s } = r,
    o = (a, l) =>
      a.type === 'JSXEmptyExpression' ||
      (!d(a) &&
        (G(a) ||
          Z(a) ||
          a.type === 'ArrowFunctionExpression' ||
          (a.type === 'AwaitExpression' && (o(a.argument, a) || a.argument.type === 'JSXElement')) ||
          k(a) ||
          (a.type === 'ChainExpression' && k(a.expression)) ||
          a.type === 'FunctionExpression' ||
          a.type === 'TemplateLiteral' ||
          a.type === 'TaggedTemplateExpression' ||
          a.type === 'DoExpression' ||
          (Y(l) && (a.type === 'ConditionalExpression' || ce(a)))));
  return o(s.expression, r.parent)
    ? y$1(['{', n('expression'), de, '}'])
    : y$1(['{', E([F$1, n('expression')]), F$1, de, '}']);
}
function Zo(r, e, n) {
  var s, o;
  let { node: a } = r,
    l = d(a.name) || d(a.typeParameters);
  if (a.selfClosing && a.attributes.length === 0 && !l) return ['<', n('name'), n('typeParameters'), ' />'];
  if (
    ((s = a.attributes) == null ? void 0 : s.length) === 1 &&
    a.attributes[0].value &&
    ee(a.attributes[0].value) &&
    !a.attributes[0].value.value.includes(`
`) &&
    !l &&
    !d(a.attributes[0])
  )
    return y$1(['<', n('name'), n('typeParameters'), ' ', ...r.map(n, 'attributes'), a.selfClosing ? ' />' : '>']);
  let f =
      (o = a.attributes) == null
        ? void 0
        : o.some(
            (v) =>
              v.value &&
              ee(v.value) &&
              v.value.value.includes(`
`),
          ),
    m = e.singleAttributePerLine && a.attributes.length > 1 ? C$1 : A;
  return y$1(['<', n('name'), n('typeParameters'), E(r.map(() => [m, n()], 'attributes')), ...ep(a, e, l)], {
    shouldBreak: f,
  });
}
function ep(r, e, n) {
  return r.selfClosing ? [A, '/>'] : tp(r, e, n) ? ['>'] : [F$1, '>'];
}
function tp(r, e, n) {
  let s = r.attributes.length > 0 && d(w$1(!1, r.attributes, -1), x$1.Trailing);
  return (
    (r.attributes.length === 0 && !n) ||
    ((e.bracketSameLine || e.jsxBracketSameLine) && (!n || r.attributes.length > 0) && !s)
  );
}
function rp(r, e, n) {
  let { node: s } = r,
    o = [];
  o.push('</');
  let a = n('name');
  return (
    d(s.name, x$1.Leading | x$1.Line)
      ? o.push(E([C$1, a]), C$1)
      : d(s.name, x$1.Leading | x$1.Block)
      ? o.push(' ', a)
      : o.push(a),
    o.push('>'),
    o
  );
}
function np(r, e) {
  let { node: n } = r,
    s = d(n),
    o = d(n, x$1.Line),
    a = n.type === 'JSXOpeningFragment';
  return [a ? '<' : '</', E([o ? C$1 : s && !a ? ' ' : '', M(r, e)]), o ? C$1 : '', '>'];
}
function sp(r, e, n) {
  let s = pe(r, $o(r, e, n), e);
  return Ko(r, s, e);
}
function up(r, e) {
  let { node: n } = r,
    s = d(n, x$1.Line);
  return [M(r, e, { indent: s }), s ? C$1 : ''];
}
function ip(r, e, n) {
  let { node: s } = r;
  return [
    '{',
    r.call(
      ({ node: o }) => {
        let a = ['...', n()];
        return !d(o) || !zn(r) ? a : [E([F$1, pe(r, a, e)]), F$1];
      },
      s.type === 'JSXSpreadAttribute' ? 'argument' : 'expression',
    ),
    '}',
  ];
}
function hu(r, e, n) {
  let { node: s } = r;
  if (s.type.startsWith('JSX'))
    switch (s.type) {
      case 'JSXAttribute':
        return zo(r, e, n);
      case 'JSXIdentifier':
        return s.name;
      case 'JSXNamespacedName':
        return B$1(':', [n('namespace'), n('name')]);
      case 'JSXMemberExpression':
        return B$1('.', [n('object'), n('property')]);
      case 'JSXSpreadAttribute':
      case 'JSXSpreadChild':
        return ip(r, e, n);
      case 'JSXExpressionContainer':
        return Qo(r, e, n);
      case 'JSXFragment':
      case 'JSXElement':
        return sp(r, e, n);
      case 'JSXOpeningElement':
        return Zo(r, e, n);
      case 'JSXClosingElement':
        return rp(r, e, n);
      case 'JSXOpeningFragment':
      case 'JSXClosingFragment':
        return np(r, e);
      case 'JSXEmptyExpression':
        return up(r, e);
      case 'JSXText':
        throw new Error('JSXText should be handled by JSXElement');
      default:
        throw new Oe(s, 'JSX');
    }
}
function ap(r) {
  if (r.children.length === 0) return !0;
  if (r.children.length > 1) return !1;
  let e = r.children[0];
  return e.type === 'JSXText' && !Zt(e);
}
function Zt(r) {
  return r.type === 'JSXText' && (Pr.hasNonWhitespaceCharacter(oe(r)) || !/\n/.test(oe(r)));
}
function op(r) {
  return r.type === 'JSXExpressionContainer' && ee(r.expression) && r.expression.value === ' ' && !d(r.expression);
}
function Su(r) {
  let { node: e, parent: n } = r;
  if (!Y(e) || !Y(n)) return !1;
  let { index: s, siblings: o } = r,
    a;
  for (let l = s; l > 0; l--) {
    let f = o[l - 1];
    if (!(f.type === 'JSXText' && !Zt(f))) {
      a = f;
      break;
    }
  }
  return (
    (a == null ? void 0 : a.type) === 'JSXExpressionContainer' &&
    a.expression.type === 'JSXEmptyExpression' &&
    dt(a.expression)
  );
}
function pp(r) {
  return dt(r.node) || Su(r);
}
var kr = pp,
  cp = 0;
function Ir(r, e, n) {
  var s;
  let { node: o, parent: a, grandparent: l, key: f } = r,
    m =
      f !== 'body' &&
      (a.type === 'IfStatement' ||
        a.type === 'WhileStatement' ||
        a.type === 'SwitchStatement' ||
        a.type === 'DoWhileStatement'),
    v = o.operator === '|>' && ((s = r.root.extra) == null ? void 0 : s.__isUsingHackPipeline),
    I = Zn(r, n, e, !1, m);
  if (m) return I;
  if (v) return y$1(I);
  if ((k(a) && a.callee === o) || a.type === 'UnaryExpression' || (J(a) && !a.computed))
    return y$1([E([F$1, ...I]), F$1]);
  let L =
      a.type === 'ReturnStatement' ||
      a.type === 'ThrowStatement' ||
      (a.type === 'JSXExpressionContainer' && l.type === 'JSXAttribute') ||
      (o.operator !== '|' && a.type === 'JsExpressionRoot') ||
      (o.type !== 'NGPipeExpression' &&
        ((a.type === 'NGRoot' && e.parser === '__ng_binding') ||
          (a.type === 'NGMicrosyntaxExpression' && l.type === 'NGMicrosyntax' && l.body.length === 1))) ||
      (o === a.body && a.type === 'ArrowFunctionExpression') ||
      (o !== a.body && a.type === 'ForStatement') ||
      (a.type === 'ConditionalExpression' && l.type !== 'ReturnStatement' && l.type !== 'ThrowStatement' && !k(l)) ||
      a.type === 'TemplateLiteral',
    V =
      a.type === 'AssignmentExpression' ||
      a.type === 'VariableDeclarator' ||
      a.type === 'ClassProperty' ||
      a.type === 'PropertyDefinition' ||
      a.type === 'TSAbstractPropertyDefinition' ||
      a.type === 'ClassPrivateProperty' ||
      fe(a),
    se = ce(o.left) && Vt(o.operator, o.left.operator);
  if (L || (Ot(o) && !se) || (!Ot(o) && V)) return y$1(I);
  if (I.length === 0) return '';
  let Ee = Y(o.right),
    ht = I.findIndex((fl) => typeof fl != 'string' && !Array.isArray(fl) && fl.type === ue),
    ar = I.slice(0, ht === -1 ? 1 : ht + 1),
    $i = I.slice(ar.length, Ee ? -1 : void 0),
    tl = Symbol('logicalChain-' + ++cp),
    Wi = y$1([...ar, E($i)], { id: tl });
  if (!Ee) return Wi;
  let hl = w$1(!1, I, -1);
  return y$1([Wi, mt(hl, { groupId: tl })]);
}
function Zn(r, e, n, s, o) {
  var a;
  let { node: l } = r;
  if (!ce(l)) return [y$1(e())];
  let f = [];
  Vt(l.operator, l.left.operator) ? (f = r.call((ar) => Zn(ar, e, n, !0, o), 'left')) : f.push(y$1(e('left')));
  let m = Ot(l),
    v = (l.operator === '|>' || l.type === 'NGPipeExpression' || lp(r, n)) && !Ie(n.originalText, l.right),
    I = l.type === 'NGPipeExpression' ? '|' : l.operator,
    L =
      l.type === 'NGPipeExpression' && l.arguments.length > 0
        ? y$1(
            E([
              F$1,
              ': ',
              B$1(
                [A, ': '],
                r.map(() => De(2, y$1(e())), 'arguments'),
              ),
            ]),
          )
        : '',
    V;
  if (m) V = [I, ' ', e('right'), L];
  else {
    let ar =
      I === '|>' && (a = r.root.extra) != null && a.__isUsingHackPipeline
        ? r.call(($i) => Zn($i, e, n, !0, o), 'right')
        : e('right');
    V = [v ? A : '', I, v ? ' ' : A, ar, L];
  }
  let { parent: se } = r,
    Ee = d(l.left, x$1.Trailing | x$1.Line),
    ht =
      Ee ||
      (!(o && l.type === 'LogicalExpression') &&
        se.type !== l.type &&
        l.left.type !== l.type &&
        l.right.type !== l.type);
  if ((f.push(v ? '' : ' ', ht ? y$1(V, { shouldBreak: Ee }) : V), s && d(l))) {
    let ar = Bt(pe(r, f, n));
    return Array.isArray(ar) || ar.type === ye ? mr(ar) : [ar];
  }
  return f;
}
function Ot(r) {
  return r.type !== 'LogicalExpression'
    ? !1
    : !!((Z(r.right) && r.right.properties.length > 0) || (G(r.right) && r.right.elements.length > 0) || Y(r.right));
}
var Bu = (r) => r.type === 'BinaryExpression' && r.operator === '|';
function lp(r, e) {
  return (
    (e.parser === '__vue_expression' || e.parser === '__vue_ts_expression') &&
    Bu(r.node) &&
    !r.hasAncestor((n) => !Bu(n) && n.type !== 'JsExpressionRoot')
  );
}
var at = class extends Error {
  constructor() {
    super(...arguments);
    Cf(this, 'name', 'ArgExpansionBailout');
  }
};
function mp(r, e, n, s) {
  let { node: o } = r;
  return d(o, x$1.Dangling) ? y$1([n, M(r, e, { indent: !0 }), F$1, s]) : [n, s];
}
function vt(r, e, n) {
  let { node: s } = r,
    o = [],
    a = s.type === 'TupleExpression' ? '#[' : '[',
    l = ']',
    f =
      s.type === 'TupleTypeAnnotation' && s.types
        ? 'types'
        : s.type === 'TSTupleType' || s.type === 'TupleTypeAnnotation'
        ? 'elementTypes'
        : 'elements',
    m = s[f];
  if (m.length === 0) o.push(mp(r, e, a, l));
  else {
    let v = w$1(!1, m, -1),
      I = (v == null ? void 0 : v.type) !== 'RestElement',
      L = v === null,
      V = Symbol('array'),
      se =
        !e.__inJestEach &&
        m.length > 1 &&
        m.every((ar, $i, tl) => {
          let Wi = ar == null ? void 0 : ar.type;
          if (!G(ar) && !Z(ar)) return !1;
          let hl = tl[$i + 1];
          if (hl && Wi !== hl.type) return !1;
          let fl = G(ar) ? 'elements' : 'properties';
          return ar[fl] && ar[fl].length > 1;
        }),
      Ee = es(s, e),
      ht = I ? (L ? ',' : le(e) ? (Ee ? P$1(',', '', { groupId: V }) : P$1(',')) : '') : '';
    o.push(
      y$1([a, E([F$1, Ee ? Dp(r, e, n, ht) : [yp(r, e, f, n), ht], M(r, e)]), F$1, l], { shouldBreak: se, id: V }),
    );
  }
  return o.push($(r), q(r, n)), o;
}
function es(r, e) {
  return (
    G(r) &&
    r.elements.length > 1 &&
    r.elements.every(
      (n) =>
        n &&
        (ge(n) || (Ar(n) && !d(n.argument))) &&
        !d(n, x$1.Trailing | x$1.Line, (s) => !z$1(e.originalText, U$1(s), { backwards: !0 })),
    )
  );
}
function bu({ node: r }, { originalText: e }) {
  let n = (o) => bt(e, Pt(e, o)),
    s = (o) => (e[o] === ',' ? o : s(n(o + 1)));
  return kt(e, s(O$1(r)));
}
function yp(r, e, n, s) {
  let o = [];
  return (
    r.each(({ node: a, isLast: l }) => {
      o.push(a ? y$1(s()) : ''), l || o.push([',', A, a && bu(r, e) ? F$1 : '']);
    }, n),
    o
  );
}
function Dp(r, e, n, s) {
  let o = [];
  return (
    r.each(({ isLast: a, next: l }) => {
      o.push([n(), a ? s : ',']), a || o.push(bu(r, e) ? [C$1, C$1] : d(l, x$1.Leading | x$1.Line) ? C$1 : A);
    }, 'elements'),
    St(o)
  );
}
function fp(r, e, n) {
  let { node: s } = r,
    o = he(s);
  if (o.length === 0) return ['(', M(r, e), ')'];
  if (Cp(o)) return ['(', n(['arguments', 0]), ', ', n(['arguments', 1]), ')'];
  let a = !1,
    l = o.length - 1,
    f = [];
  Sr(r, ({ node: L }, V) => {
    let se = n();
    V === l || (me(L, e) ? ((a = !0), (se = [se, ',', C$1, C$1])) : (se = [se, ',', A])), f.push(se);
  });
  let m = !(s.type === 'ImportExpression' || s.callee.type === 'Import') && le(e, 'all') ? ',' : '';
  function v() {
    return y$1(['(', E([A, ...f]), m, A, ')'], { shouldBreak: !0 });
  }
  if (a || (r.parent.type !== 'Decorator' && tu(o))) return v();
  if (Fp(o)) {
    let L = f.slice(1);
    if (L.some(K)) return v();
    let V;
    try {
      V = n(Mn(s, 0), { expandFirstArg: !0 });
    } catch (se) {
      if (se instanceof at) return v();
      throw se;
    }
    return K(V)
      ? [Ae, qe([['(', y$1(V, { shouldBreak: !0 }), ', ', ...L, ')'], v()])]
      : qe([['(', V, ', ', ...L, ')'], ['(', y$1(V, { shouldBreak: !0 }), ', ', ...L, ')'], v()]);
  }
  if (Ep(o, f, e)) {
    let L = f.slice(0, -1);
    if (L.some(K)) return v();
    let V;
    try {
      V = n(Mn(s, -1), { expandLastArg: !0 });
    } catch (se) {
      if (se instanceof at) return v();
      throw se;
    }
    return K(V)
      ? [Ae, qe([['(', ...L, y$1(V, { shouldBreak: !0 }), ')'], v()])]
      : qe([['(', ...L, V, ')'], ['(', ...L, y$1(V, { shouldBreak: !0 }), ')'], v()]);
  }
  let I = ['(', E([F$1, ...f]), P$1(m), F$1, ')'];
  return hr(r) ? I : y$1(I, { shouldBreak: f.some(K) || a });
}
function er(r, e = !1) {
  return (
    (Z(r) && (r.properties.length > 0 || d(r))) ||
    (G(r) && (r.elements.length > 0 || d(r))) ||
    (r.type === 'TSTypeAssertion' && er(r.expression)) ||
    (Le(r) && er(r.expression)) ||
    r.type === 'FunctionExpression' ||
    (r.type === 'ArrowFunctionExpression' &&
      (!r.returnType ||
        !r.returnType.typeAnnotation ||
        r.returnType.typeAnnotation.type !== 'TSTypeReference' ||
        dp(r.body)) &&
      (r.body.type === 'BlockStatement' ||
        (r.body.type === 'ArrowFunctionExpression' && er(r.body, !0)) ||
        Z(r.body) ||
        G(r.body) ||
        (!e && (k(r.body) || r.body.type === 'ConditionalExpression')) ||
        Y(r.body))) ||
    r.type === 'DoExpression' ||
    r.type === 'ModuleExpression'
  );
}
function Ep(r, e, n) {
  var s, o;
  let a = w$1(!1, r, -1);
  if (r.length === 1) {
    let f = w$1(!1, e, -1);
    if ((s = f.label) != null && s.embed && ((o = f.label) == null ? void 0 : o.hug) !== !1) return !0;
  }
  let l = w$1(!1, r, -2);
  return (
    !d(a, x$1.Leading) &&
    !d(a, x$1.Trailing) &&
    er(a) &&
    (!l || l.type !== a.type) &&
    (r.length !== 2 || l.type !== 'ArrowFunctionExpression' || !G(a)) &&
    !(r.length > 1 && es(a, n))
  );
}
function Fp(r) {
  if (r.length !== 2) return !1;
  let [e, n] = r;
  return e.type === 'ModuleExpression' && Ap(n)
    ? !0
    : !d(e) &&
        (e.type === 'FunctionExpression' ||
          (e.type === 'ArrowFunctionExpression' && e.body.type === 'BlockStatement')) &&
        n.type !== 'FunctionExpression' &&
        n.type !== 'ArrowFunctionExpression' &&
        n.type !== 'ConditionalExpression' &&
        Pu(n) &&
        !er(n);
}
function Pu(r) {
  var e;
  if (r.type === 'ParenthesizedExpression') return Pu(r.expression);
  if (Le(r) || r.type === 'TypeCastExpression') {
    let { typeAnnotation: n } = r;
    return (
      n.type === 'TypeAnnotation' && (n = n.typeAnnotation),
      n.type === 'TSArrayType' && ((n = n.elementType), n.type === 'TSArrayType' && (n = n.elementType)),
      (n.type === 'GenericTypeAnnotation' || n.type === 'TSTypeReference') &&
        ((e = n.typeParameters) == null ? void 0 : e.params.length) === 1 &&
        (n = n.typeParameters.params[0]),
      wt(n) && xe(r.expression, 1)
    );
  }
  return it(r) && he(r).length > 1 ? !1 : ce(r) ? xe(r.left, 1) && xe(r.right, 1) : wn(r) || xe(r);
}
function Cp(r) {
  return (
    r.length === 2 &&
    r[0].type === 'ArrowFunctionExpression' &&
    X(r[0]).length === 0 &&
    r[0].body.type === 'BlockStatement' &&
    r[1].type === 'ArrayExpression' &&
    !r.some((e) => d(e))
  );
}
function dp(r) {
  return r.type === 'BlockStatement' && (r.body.some((e) => e.type !== 'EmptyStatement') || d(r, x$1.Dangling));
}
function Ap(r) {
  return (
    r.type === 'ObjectExpression' &&
    r.properties.length === 1 &&
    fe(r.properties[0]) &&
    r.properties[0].key.type === 'Identifier' &&
    r.properties[0].key.name === 'type' &&
    ee(r.properties[0].value) &&
    r.properties[0].value.value === 'module'
  );
}
var tr = fp;
function ku(r, e, n) {
  var s;
  let o = n('object'),
    a = ts(r, e, n),
    { node: l, parent: f } = r,
    m = r.findAncestor((I) => !(J(I) || I.type === 'TSNonNullExpression')),
    v =
      (m &&
        (m.type === 'NewExpression' ||
          m.type === 'BindExpression' ||
          (m.type === 'AssignmentExpression' && m.left.type !== 'Identifier'))) ||
      l.computed ||
      (l.object.type === 'Identifier' && l.property.type === 'Identifier' && !J(f)) ||
      ((f.type === 'AssignmentExpression' || f.type === 'VariableDeclarator') &&
        ((k(l.object) && l.object.arguments.length > 0) ||
          (l.object.type === 'TSNonNullExpression' &&
            k(l.object.expression) &&
            l.object.expression.arguments.length > 0) ||
          ((s = o.label) == null ? void 0 : s.memberChain)));
  return et(o.label, [o, v ? a : y$1(E([F$1, a]))]);
}
function ts(r, e, n) {
  let s = n('property'),
    { node: o } = r,
    a = $(r);
  return o.computed
    ? !o.property || ge(o.property)
      ? [a, '[', s, ']']
      : y$1([a, '[', E([F$1, s]), F$1, ']'])
    : [a, '.', s];
}
function Tp(r, e, n) {
  let { parent: s } = r,
    o = !s || s.type === 'ExpressionStatement',
    a = [];
  function l(Il) {
    let { originalText: Ll } = e,
      Nl = Xe(Ll, O$1(Il));
    return Ll.charAt(Nl) === ')' ? Nl !== !1 && kt(Ll, Nl + 1) : me(Il, e);
  }
  function f(Il) {
    let { node: Ll } = Il;
    k(Ll) && (Dt(Ll.callee) || k(Ll.callee))
      ? (a.unshift({ node: Ll, printed: [pe(Il, [$(Il), Ve(Il, e, n), tr(Il, e, n)], e), l(Ll) ? C$1 : ''] }),
        Il.call((Nl) => f(Nl), 'callee'))
      : Dt(Ll)
      ? (a.unshift({ node: Ll, needsParens: we(Il, e), printed: pe(Il, J(Ll) ? ts(Il, e, n) : Lr(Il, e, n), e) }),
        Il.call((Nl) => f(Nl), 'object'))
      : Ll.type === 'TSNonNullExpression'
      ? (a.unshift({ node: Ll, printed: pe(Il, '!', e) }), Il.call((Nl) => f(Nl), 'expression'))
      : a.unshift({ node: Ll, printed: n() });
  }
  let { node: m } = r;
  a.unshift({ node: m, printed: [$(r), Ve(r, e, n), tr(r, e, n)] }), m.callee && r.call((Il) => f(Il), 'callee');
  let v = [],
    I = [a[0]],
    L = 1;
  for (
    ;
    L < a.length &&
    (a[L].node.type === 'TSNonNullExpression' ||
      k(a[L].node) ||
      (J(a[L].node) && a[L].node.computed && ge(a[L].node.property)));
    ++L
  )
    I.push(a[L]);
  if (!k(a[0].node)) for (; L + 1 < a.length && Dt(a[L].node) && Dt(a[L + 1].node); ++L) I.push(a[L]);
  v.push(I), (I = []);
  let V = !1;
  for (; L < a.length; ++L) {
    if (V && Dt(a[L].node)) {
      if (a[L].node.computed && ge(a[L].node.property)) {
        I.push(a[L]);
        continue;
      }
      v.push(I), (I = []), (V = !1);
    }
    (k(a[L].node) || a[L].node.type === 'ImportExpression') && (V = !0),
      I.push(a[L]),
      d(a[L].node, x$1.Trailing) && (v.push(I), (I = []), (V = !1));
  }
  I.length > 0 && v.push(I);
  function se(Il) {
    return /^[A-Z]|^[$_]+$/.test(Il);
  }
  function Ee(Il) {
    return Il.length <= e.tabWidth;
  }
  function ht(Il) {
    var Ll;
    let Nl = (Ll = Il[1][0]) == null ? void 0 : Ll.node.computed;
    if (Il[0].length === 1) {
      let Bl = Il[0][0].node;
      return Bl.type === 'ThisExpression' || (Bl.type === 'Identifier' && (se(Bl.name) || (o && Ee(Bl.name)) || Nl));
    }
    let Hl = w$1(!1, Il[0], -1).node;
    return J(Hl) && Hl.property.type === 'Identifier' && (se(Hl.property.name) || Nl);
  }
  let ar = v.length >= 2 && !d(v[1][0].node) && ht(v);
  function $i(Il) {
    let Ll = Il.map((Nl) => Nl.printed);
    return Il.length > 0 && w$1(!1, Il, -1).needsParens ? ['(', ...Ll, ')'] : Ll;
  }
  function tl(Il) {
    return Il.length === 0 ? '' : E(y$1([C$1, B$1(C$1, Il.map($i))]));
  }
  let Wi = v.map($i),
    hl = Wi,
    fl = ar ? 3 : 2,
    dl = v.flat(),
    Al =
      dl.slice(1, -1).some((Il) => d(Il.node, x$1.Leading)) ||
      dl.slice(0, -1).some((Il) => d(Il.node, x$1.Trailing)) ||
      (v[fl] && d(v[fl][0].node, x$1.Leading));
  if (v.length <= fl && !Al) return hr(r) ? hl : y$1(hl);
  let Fl = w$1(!1, v[ar ? 1 : 0], -1).node,
    vl = !k(Fl) && l(Fl),
    kl = [$i(v[0]), ar ? v.slice(1, 2).map($i) : '', vl ? C$1 : '', tl(v.slice(ar ? 2 : 1))],
    El = a.map(({ node: Il }) => Il).filter(k);
  function Jl() {
    let Il = w$1(!1, w$1(!1, v, -1), -1).node,
      Ll = w$1(!1, Wi, -1);
    return k(Il) && K(Ll) && El.slice(0, -1).some((Nl) => Nl.arguments.some(It));
  }
  let Kc;
  return (
    Al || (El.length > 2 && El.some((Il) => !Il.arguments.every((Ll) => xe(Ll)))) || Wi.slice(0, -1).some(K) || Jl()
      ? (Kc = y$1(kl))
      : (Kc = [K(hl) || vl ? Ae : '', qe([hl, kl])]),
    et({ memberChain: !0 }, Kc)
  );
}
var Iu = Tp;
function wr(r, e, n) {
  var s;
  let { node: o, parent: a } = r,
    l = o.type === 'NewExpression',
    f = o.type === 'ImportExpression',
    m = $(r),
    v = he(o),
    I = v.length === 1 && xr(v[0], e.originalText);
  if (I || (v.length > 0 && !l && !f && (xp(o, a) || Ct(o, a)))) {
    let V = [];
    if (
      (Sr(r, () => {
        V.push(n());
      }),
      !(I && (s = V[0].label) != null && s.embed))
    )
      return [l ? 'new ' : '', n('callee'), m, Ve(r, e, n), '(', B$1(', ', V), ')'];
  }
  if (!f && !l && Dt(o.callee) && !r.call((V) => we(V, e), 'callee')) return Iu(r, e, n);
  let L = [l ? 'new ' : '', f ? 'import' : n('callee'), m, Ve(r, e, n), tr(r, e, n)];
  return f || k(o.callee) ? y$1(L) : L;
}
function xp(r, e) {
  if (r.callee.type !== 'Identifier') return !1;
  if (r.callee.name === 'require') return !0;
  if (r.callee.name === 'define') {
    let n = he(r);
    return (
      e.type === 'ExpressionStatement' &&
      (n.length === 1 ||
        (n.length === 2 && n[0].type === 'ArrayExpression') ||
        (n.length === 3 && ee(n[0]) && n[1].type === 'ArrayExpression'))
    );
  }
  return !1;
}
function gp(r, e, n) {
  let s = e === '"' ? "'" : '"',
    o = H(!1, r, /\\(.)|(["'])/gs, (a, l, f) =>
      l === s ? l : f === e ? '\\' + f : f || (n && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(l) ? l : '\\' + l),
    );
  return e + o + e;
}
var Lu = gp;
function hp(r, e) {
  let n = r.slice(1, -1),
    s =
      e.parser === 'json' || (e.parser === 'json5' && e.quoteProps === 'preserve' && !e.singleQuote)
        ? '"'
        : e.__isInHtmlAttribute
        ? "'"
        : br(n, e.singleQuote);
  return Lu(n, s, !(e.parser === 'css' || e.parser === 'less' || e.parser === 'scss' || e.__embeddedInHtml));
}
var Tt = hp;
function Sp(r) {
  return r
    .toLowerCase()
    .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, '$1$2')
    .replace(/^([+-]?[\d.]+)e[+-]?0+$/, '$1')
    .replace(/^([+-])?\./, '$10.')
    .replace(/(\.\d+?)0+(?=e|$)/, '$1')
    .replace(/\.(?=e|$)/, '');
}
var He = Sp;
function vu(r, e) {
  let { node: n } = r;
  switch (n.type) {
    case 'RegExpLiteral':
      return wu(n);
    case 'BigIntLiteral':
      return Or(n.extra.raw);
    case 'NumericLiteral':
      return He(n.extra.raw);
    case 'StringLiteral':
      return Te(Tt(n.extra.raw, e));
    case 'NullLiteral':
      return 'null';
    case 'BooleanLiteral':
      return String(n.value);
    case 'DecimalLiteral':
      return He(n.value) + 'm';
    case 'DirectiveLiteral':
      return Ou(n.extra.raw, e);
    case 'Literal': {
      if (n.regex) return wu(n.regex);
      if (n.bigint) return Or(n.raw);
      if (n.decimal) return He(n.decimal) + 'm';
      let { value: s } = n;
      return typeof s == 'number'
        ? He(n.raw)
        : typeof s == 'string'
        ? Bp(r)
          ? Ou(n.raw, e)
          : Te(Tt(n.raw, e))
        : String(s);
    }
  }
}
function Bp(r) {
  if (r.key !== 'expression') return;
  let { parent: e } = r;
  return e.type === 'ExpressionStatement' && e.directive;
}
function Or(r) {
  return r.toLowerCase();
}
function wu({ pattern: r, flags: e }) {
  return (e = [...e].sort().join('')), `/${r}/${e}`;
}
function Ou(r, e) {
  let n = r.slice(1, -1);
  if (n.includes('"') || n.includes("'")) return r;
  let s = e.singleQuote ? "'" : '"';
  return s + n + s;
}
var vr = j$1([
  'Literal',
  'BigIntLiteral',
  'BooleanLiteral',
  'DecimalLiteral',
  'DirectiveLiteral',
  'NullLiteral',
  'NumericLiteral',
  'RegExpLiteral',
  'StringLiteral',
]);
function ft(r, e, n, s, o, a) {
  let l = bp(r, e, n, s, a),
    f = a ? n(a, { assignmentLayout: l }) : '';
  switch (l) {
    case 'break-after-operator':
      return y$1([y$1(s), o, y$1(E([A, f]))]);
    case 'never-break-after-operator':
      return y$1([y$1(s), o, ' ', f]);
    case 'fluid': {
      let m = Symbol('assignment');
      return y$1([y$1(s), o, y$1(E(A), { id: m }), de, mt(f, { groupId: m })]);
    }
    case 'break-lhs':
      return y$1([s, o, ' ', y$1(f)]);
    case 'chain':
      return [y$1(s), o, A, f];
    case 'chain-tail':
      return [y$1(s), o, E([A, f])];
    case 'chain-tail-arrow-chain':
      return [y$1(s), o, f];
    case 'only-left':
      return s;
  }
}
function ju(r, e, n) {
  let { node: s } = r;
  return ft(r, e, n, n('left'), [' ', s.operator], 'right');
}
function Mu(r, e, n) {
  return ft(r, e, n, n('id'), ' =', 'init');
}
function bp(r, e, n, s, o) {
  let { node: a } = r,
    l = a[o];
  if (!l) return 'only-left';
  let f = !_r(l);
  if (r.match(_r, Ru, (v) => !f || (v.type !== 'ExpressionStatement' && v.type !== 'VariableDeclaration')))
    return f
      ? l.type === 'ArrowFunctionExpression' && l.body.type === 'ArrowFunctionExpression'
        ? 'chain-tail-arrow-chain'
        : 'chain-tail'
      : 'chain';
  if ((!f && _r(l.right)) || Ie(e.originalText, l)) return 'break-after-operator';
  if ((l.type === 'CallExpression' && l.callee.name === 'require') || e.parser === 'json5' || e.parser === 'json')
    return 'never-break-after-operator';
  if (kp(a) || Ip(a) || Op(a) || (rs(a) && Rs(s))) return 'break-lhs';
  let m = Mp(a, s, e);
  return r.call(() => Pp(r, e, n, m), o)
    ? 'break-after-operator'
    : m ||
      l.type === 'TemplateLiteral' ||
      l.type === 'TaggedTemplateExpression' ||
      l.type === 'BooleanLiteral' ||
      ge(l) ||
      l.type === 'ClassExpression'
    ? 'never-break-after-operator'
    : 'fluid';
}
function Pp(r, e, n, s) {
  let o = r.node;
  if (ce(o) && !Ot(o)) return !0;
  switch (o.type) {
    case 'StringLiteralTypeAnnotation':
    case 'SequenceExpression':
      return !0;
    case 'ConditionalExpression': {
      let { test: f } = o;
      return ce(f) && !Ot(f);
    }
    case 'ClassExpression':
      return b(o.decorators);
  }
  if (s) return !1;
  let a = o,
    l = [];
  for (;;)
    if (
      a.type === 'UnaryExpression' ||
      a.type === 'AwaitExpression' ||
      (a.type === 'YieldExpression' && a.argument !== null)
    )
      (a = a.argument), l.push('argument');
    else if (a.type === 'TSNonNullExpression') (a = a.expression), l.push('expression');
    else break;
  return !!(ee(a) || r.call(() => Ju(r, e, n), ...l));
}
function kp(r) {
  if (Ru(r)) {
    let e = r.left || r.id;
    return (
      e.type === 'ObjectPattern' &&
      e.properties.length > 2 &&
      e.properties.some((n) => {
        var s;
        return fe(n) && (!n.shorthand || ((s = n.value) == null ? void 0 : s.type) === 'AssignmentPattern');
      })
    );
  }
  return !1;
}
function _r(r) {
  return r.type === 'AssignmentExpression';
}
function Ru(r) {
  return _r(r) || r.type === 'VariableDeclarator';
}
function Ip(r) {
  let e = wp(r);
  if (b(e)) {
    let n = r.type === 'TSTypeAliasDeclaration' ? 'constraint' : 'bound';
    if (e.length > 1 && e.some((s) => s[n] || s.default)) return !0;
  }
  return !1;
}
var Lp = j$1(['TSTypeAliasDeclaration', 'TypeAlias']);
function wp(r) {
  var e;
  if (Lp(r)) return (e = r.typeParameters) == null ? void 0 : e.params;
}
function Op(r) {
  if (r.type !== 'VariableDeclarator') return !1;
  let { typeAnnotation: e } = r.id;
  if (!e || !e.typeAnnotation) return !1;
  let n = _u(e.typeAnnotation);
  return b(n) && n.length > 1 && n.some((s) => b(_u(s)) || s.type === 'TSConditionalType');
}
function rs(r) {
  var e;
  return r.type === 'VariableDeclarator' && ((e = r.init) == null ? void 0 : e.type) === 'ArrowFunctionExpression';
}
var vp = j$1(['TSTypeReference', 'GenericTypeAnnotation']);
function _u(r) {
  var e;
  if (vp(r)) return (e = r.typeParameters) == null ? void 0 : e.params;
}
function Ju(r, e, n, s = !1) {
  var o;
  let { node: a } = r,
    l = () => Ju(r, e, n, !0);
  if (a.type === 'ChainExpression' || a.type === 'TSNonNullExpression') return r.call(l, 'expression');
  if (k(a)) {
    if ((o = wr(r, e, n).label) != null && o.memberChain) return !1;
    let f = he(a);
    return !(f.length === 0 || (f.length === 1 && jp(f[0], e))) || Rp(a, n) ? !1 : r.call(l, 'callee');
  }
  return J(a) ? r.call(l, 'object') : s && (a.type === 'Identifier' || a.type === 'ThisExpression');
}
var _p = 0.25;
function jp(r, { printWidth: e }) {
  if (d(r)) return !1;
  let n = e * _p;
  if (r.type === 'ThisExpression' || (r.type === 'Identifier' && r.name.length <= n) || (Ar(r) && !d(r.argument)))
    return !0;
  let s = (r.type === 'Literal' && 'regex' in r && r.regex.pattern) || (r.type === 'RegExpLiteral' && r.pattern);
  return s
    ? s.length <= n
    : ee(r)
    ? oe(r).length <= n
    : r.type === 'TemplateLiteral'
    ? r.expressions.length === 0 &&
      r.quasis[0].value.raw.length <= n &&
      !r.quasis[0].value.raw.includes(`
`)
    : vr(r);
}
function Mp(r, e, n) {
  if (!fe(r)) return !1;
  e = Bt(e);
  let s = 3;
  return typeof e == 'string' && tt(e) < n.tabWidth + s;
}
function Rp(r, e) {
  let n = Jp(r);
  if (b(n)) {
    if (n.length > 1) return !0;
    if (n.length === 1) {
      let o = n[0];
      if (
        o.type === 'TSUnionType' ||
        o.type === 'UnionTypeAnnotation' ||
        o.type === 'TSIntersectionType' ||
        o.type === 'IntersectionTypeAnnotation' ||
        o.type === 'TSTypeLiteral' ||
        o.type === 'ObjectTypeAnnotation'
      )
        return !0;
    }
    let s = r.typeParameters ? 'typeParameters' : 'typeArguments';
    if (K(e(s))) return !0;
  }
  return !1;
}
function Jp(r) {
  var e;
  return (e = r.typeParameters ?? r.typeArguments) == null ? void 0 : e.params;
}
function ot(r, e, n, s, o) {
  let a = r.node,
    l = X(a),
    f = o ? Ve(r, n, e) : '';
  if (l.length === 0) return [f, '(', M(r, n, { filter: (se) => $e(n.originalText, O$1(se)) === ')' }), ')'];
  let { parent: m } = r,
    v = Ct(m),
    I = ns(a),
    L = [];
  if (
    (uu(r, (se, Ee) => {
      let ht = Ee === l.length - 1;
      ht && a.rest && L.push('...'),
        L.push(e()),
        !ht && (L.push(','), v || I ? L.push(' ') : me(l[Ee], n) ? L.push(C$1, C$1) : L.push(A));
    }),
    s && !Up(r))
  ) {
    if (K(f) || K(L)) throw new at();
    return y$1([Ut(f), '(', Ut(L), ')']);
  }
  let V = l.every((se) => !b(se.decorators));
  return I && V
    ? [f, '(', ...L, ')']
    : v
    ? [f, '(', ...L, ')']
    : (Tr(m) ||
        Zs(m) ||
        m.type === 'TypeAlias' ||
        m.type === 'UnionTypeAnnotation' ||
        m.type === 'TSUnionType' ||
        m.type === 'IntersectionTypeAnnotation' ||
        (m.type === 'FunctionTypeAnnotation' && m.returnType === a)) &&
      l.length === 1 &&
      l[0].name === null &&
      a.this !== l[0] &&
      l[0].typeAnnotation &&
      a.typeParameters === null &&
      wt(l[0].typeAnnotation) &&
      !a.rest
    ? n.arrowParens === 'always'
      ? ['(', ...L, ')']
      : L
    : [f, '(', E([F$1, ...L]), P$1(!su(a) && le(n, 'all') ? ',' : ''), F$1, ')'];
}
function ns(r) {
  if (!r) return !1;
  let e = X(r);
  if (e.length !== 1) return !1;
  let [n] = e;
  return (
    !d(n) &&
    (n.type === 'ObjectPattern' ||
      n.type === 'ArrayPattern' ||
      (n.type === 'Identifier' &&
        n.typeAnnotation &&
        (n.typeAnnotation.type === 'TypeAnnotation' || n.typeAnnotation.type === 'TSTypeAnnotation') &&
        ke(n.typeAnnotation.typeAnnotation)) ||
      (n.type === 'FunctionTypeParam' && ke(n.typeAnnotation) && n !== r.rest) ||
      (n.type === 'AssignmentPattern' &&
        (n.left.type === 'ObjectPattern' || n.left.type === 'ArrayPattern') &&
        (n.right.type === 'Identifier' ||
          (Z(n.right) && n.right.properties.length === 0) ||
          (G(n.right) && n.right.elements.length === 0))))
  );
}
function Np(r) {
  let e;
  return (
    r.returnType
      ? ((e = r.returnType), e.typeAnnotation && (e = e.typeAnnotation))
      : r.typeAnnotation && (e = r.typeAnnotation),
    e
  );
}
function xt(r, e) {
  var n;
  let s = Np(r);
  if (!s) return !1;
  let o = (n = r.typeParameters) == null ? void 0 : n.params;
  if (o) {
    if (o.length > 1) return !1;
    if (o.length === 1) {
      let a = o[0];
      if (a.constraint || a.default) return !1;
    }
  }
  return X(r).length === 1 && (ke(s) || K(e));
}
function Up(r) {
  return r.match(
    (e) => e.type === 'ArrowFunctionExpression' && e.body.type === 'BlockStatement',
    (e, n) => {
      if (
        e.type === 'CallExpression' &&
        n === 'arguments' &&
        e.arguments.length === 1 &&
        e.callee.type === 'CallExpression'
      ) {
        let s = e.callee.callee;
        return (
          s.type === 'Identifier' ||
          (s.type === 'MemberExpression' &&
            !s.computed &&
            s.object.type === 'Identifier' &&
            s.property.type === 'Identifier')
        );
      }
      return !1;
    },
    (e, n) =>
      (e.type === 'VariableDeclarator' && n === 'init') ||
      (e.type === 'ExportDefaultDeclaration' && n === 'declaration') ||
      (e.type === 'TSExportAssignment' && n === 'expression') ||
      (e.type === 'AssignmentExpression' &&
        n === 'right' &&
        e.left.type === 'MemberExpression' &&
        e.left.object.type === 'Identifier' &&
        e.left.object.name === 'module' &&
        e.left.property.type === 'Identifier' &&
        e.left.property.name === 'exports'),
    (e) => e.type !== 'VariableDeclaration' || (e.kind === 'const' && e.declarations.length === 1),
  );
}
function Nu(r) {
  let e = X(r);
  return e.length > 1 && e.some((n) => n.type === 'TSParameterProperty');
}
function ss(r) {
  if (wt(r) || ke(r)) return !0;
  if (r.type === 'UnionTypeAnnotation' || r.type === 'TSUnionType') {
    let e = r.types.filter(
        (o) =>
          o.type === 'VoidTypeAnnotation' ||
          o.type === 'TSVoidKeyword' ||
          o.type === 'NullLiteralTypeAnnotation' ||
          o.type === 'TSNullKeyword',
      ).length,
      n = r.types.some(
        (o) =>
          o.type === 'ObjectTypeAnnotation' ||
          o.type === 'TSTypeLiteral' ||
          o.type === 'GenericTypeAnnotation' ||
          o.type === 'TSTypeReference',
      ),
      s = r.types.some((o) => d(o));
    if (r.types.length - 1 === e && n && !s) return !0;
  }
  return !1;
}
function Uu(r, e, n) {
  let s = e.semi ? ';' : '',
    { node: o } = r,
    a = [Q(r), 'opaque type ', n('id'), n('typeParameters')];
  return o.supertype && a.push(': ', n('supertype')), o.impltype && a.push(' = ', n('impltype')), a.push(s), a;
}
function jr(r, e, n) {
  let s = e.semi ? ';' : '',
    { node: o } = r,
    a = [Q(r)];
  a.push('type ', n('id'), n('typeParameters'));
  let l = o.type === 'TSTypeAliasDeclaration' ? 'typeAnnotation' : 'right';
  return [ft(r, e, n, a, ' =', l), s];
}
function Mr(r, e, n) {
  let s = !1;
  return y$1(
    r.map(({ isFirst: o, previous: a, node: l, index: f }) => {
      let m = n();
      if (o) return m;
      let v = ke(l),
        I = ke(a);
      return I && v
        ? [' & ', s ? E(m) : m]
        : !I && !v
        ? E([' &', A, m])
        : (f > 1 && (s = !0), [' & ', f > 1 ? E(m) : m]);
    }, 'types'),
  );
}
function Rr(r, e, n) {
  let { node: s } = r,
    { parent: o } = r,
    a =
      o.type !== 'TypeParameterInstantiation' &&
      o.type !== 'TSTypeParameterInstantiation' &&
      o.type !== 'GenericTypeAnnotation' &&
      o.type !== 'TSTypeReference' &&
      o.type !== 'TSTypeAssertion' &&
      o.type !== 'TupleTypeAnnotation' &&
      o.type !== 'TSTupleType' &&
      !(o.type === 'FunctionTypeParam' && !o.name && r.grandparent.this !== o) &&
      !(
        (o.type === 'TypeAlias' || o.type === 'VariableDeclarator' || o.type === 'TSTypeAliasDeclaration') &&
        Ie(e.originalText, s)
      ),
    l = ss(s),
    f = r.map((I) => {
      let L = n();
      return l || (L = De(2, L)), pe(I, L, e);
    }, 'types');
  if (l) return B$1(' | ', f);
  let m = a && !Ie(e.originalText, s),
    v = [P$1([m ? A : '', '| ']), B$1([A, '| '], f)];
  return we(r, e)
    ? y$1([E(v), F$1])
    : (o.type === 'TupleTypeAnnotation' || o.type === 'TSTupleType') &&
      o[o.type === 'TupleTypeAnnotation' && o.types ? 'types' : 'elementTypes'].length > 1
    ? y$1([E([P$1(['(', F$1]), v]), F$1, P$1(')')])
    : y$1(a ? E(v) : v);
}
function Gp(r) {
  var e;
  let { node: n, parent: s } = r;
  return (
    n.type === 'FunctionTypeAnnotation' &&
    (Tr(s) ||
      !(
        ((s.type === 'ObjectTypeProperty' || s.type === 'ObjectTypeInternalSlot') &&
          !s.variance &&
          !s.optional &&
          yt(s, n)) ||
        s.type === 'ObjectTypeCallProperty' ||
        ((e = r.getParentNode(2)) == null ? void 0 : e.type) === 'DeclareFunction'
      ))
  );
}
function Jr(r, e, n) {
  let { node: s } = r,
    o = [_t(r)];
  (s.type === 'TSConstructorType' || s.type === 'TSConstructSignatureDeclaration') && o.push('new ');
  let a = ot(r, n, e, !1, !0),
    l = [];
  return (
    s.type === 'FunctionTypeAnnotation'
      ? l.push(Gp(r) ? ' => ' : ': ', n('returnType'))
      : l.push(q(r, n, s.returnType ? 'returnType' : 'typeAnnotation')),
    xt(s, l) && (a = y$1(a)),
    o.push(a, l),
    y$1(o)
  );
}
function Nr(r, e, n) {
  return [n('objectType'), $(r), '[', n('indexType'), ']'];
}
function Ur(r, e, n) {
  return ['infer ', n('typeParameter')];
}
function us(r, e, n) {
  let { node: s } = r;
  return [s.postfix ? '' : n, q(r, e), s.postfix ? n : ''];
}
function Gr(r, e, n) {
  let { node: s } = r;
  return ['...', ...(s.type === 'TupleTypeSpreadElement' && s.label ? [n('label'), ': '] : []), n('typeAnnotation')];
}
function qr(r, e, n) {
  let { node: s } = r;
  return [s.variance ? n('variance') : '', n('label'), s.optional ? '?' : '', ': ', n('elementType')];
}
var qp = new WeakSet();
function q(r, e, n = 'typeAnnotation') {
  let {
    node: { [n]: s },
  } = r;
  if (!s) return '';
  let o = !1;
  if (s.type === 'TSTypeAnnotation' || s.type === 'TypeAnnotation') {
    let a = r.call(Gu, n);
    (a === '=>' || (a === ':' && d(s, x$1.Leading))) && (o = !0), qp.add(s);
  }
  return o ? [' ', e(n)] : e(n);
}
var Gu = (r) =>
  r.match(
    (e) => e.type === 'TSTypeAnnotation',
    (e, n) =>
      (n === 'returnType' || n === 'typeAnnotation') && (e.type === 'TSFunctionType' || e.type === 'TSConstructorType'),
  )
    ? '=>'
    : r.match(
        (e) => e.type === 'TSTypeAnnotation',
        (e, n) =>
          n === 'typeAnnotation' &&
          (e.type === 'TSJSDocNullableType' || e.type === 'TSJSDocNonNullableType' || e.type === 'TSTypePredicate'),
      ) ||
      r.match(
        (e) => e.type === 'TypeAnnotation',
        (e, n) => n === 'typeAnnotation' && e.type === 'Identifier',
        (e, n) => n === 'id' && e.type === 'DeclareFunction',
      ) ||
      r.match(
        (e) => e.type === 'TypeAnnotation',
        (e, n) => n === 'bound' && e.type === 'TypeParameter' && e.usesExtendsBound,
      )
    ? ''
    : ':';
function Wr(r, e, n) {
  let s = Gu(r);
  return s ? [s, ' ', n('typeAnnotation')] : n('typeAnnotation');
}
function Yr(r) {
  return [r('elementType'), '[]'];
}
function Xr({ node: r }, e) {
  return ['typeof ', ...(r.type === 'TSTypeQuery' ? [e('exprName'), e('typeParameters')] : [e('argument')])];
}
function $r(r, e) {
  let { node: n } = r;
  return [n.asserts ? 'asserts ' : '', e('parameterName'), n.typeAnnotation ? [' is ', q(r, e)] : ''];
}
function $(r) {
  let { node: e } = r;
  return !e.optional || (e.type === 'Identifier' && e === r.parent.key)
    ? ''
    : k(e) || (J(e) && e.computed) || e.type === 'OptionalIndexedAccessType'
    ? '?.'
    : '?';
}
function Vr(r) {
  return r.node.definite || r.match(void 0, (e, n) => n === 'id' && e.type === 'VariableDeclarator' && e.definite)
    ? '!'
    : '';
}
var Wp = new Set([
  'DeclareClass',
  'DeclareFunction',
  'DeclareVariable',
  'DeclareExportDeclaration',
  'DeclareExportAllDeclaration',
  'DeclareOpaqueType',
  'DeclareTypeAlias',
  'DeclareEnum',
  'DeclareInterface',
]);
function Q(r) {
  let { node: e } = r;
  return e.declare || (Wp.has(e.type) && r.parent.type !== 'DeclareExportDeclaration') ? 'declare ' : '';
}
var Yp = new Set(['TSAbstractMethodDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
function _t({ node: r }) {
  return r.abstract || Yp.has(r.type) ? 'abstract ' : '';
}
function Ve(r, e, n) {
  let s = r.node;
  return s.typeArguments ? n('typeArguments') : s.typeParameters ? n('typeParameters') : '';
}
function Lr(r, e, n) {
  return ['::', n('callee')];
}
function pt(r, e, n) {
  return r.type === 'EmptyStatement' ? ';' : r.type === 'BlockStatement' || n ? [' ', e] : E([A, e]);
}
function Hr(r, e) {
  return ['...', e('argument'), q(r, e)];
}
function jt(r) {
  return r.accessibility ? r.accessibility + ' ' : '';
}
function is(r, e, n) {
  let { node: s } = r;
  return y$1([B$1(A, r.map(n, 'decorators')), Yu(s, e) ? C$1 : A]);
}
function qu(r, e, n) {
  return Xu(r.node) ? [B$1(C$1, r.map(n, 'declaration', 'decorators')), C$1] : '';
}
function Wu(r, e, n) {
  let { node: s, parent: o } = r,
    { decorators: a } = s;
  if (!b(a) || Xu(o) || kr(r)) return '';
  let l = s.type === 'ClassExpression' || s.type === 'ClassDeclaration' || Yu(s, e);
  return [r.key === 'declaration' && Qs(o) ? C$1 : l ? Ae : '', B$1(A, r.map(n, 'decorators')), A];
}
function Yu(r, e) {
  return r.decorators.some((n) => z$1(e.originalText, O$1(n)));
}
function Xu(r) {
  var e;
  if (
    r.type !== 'ExportDefaultDeclaration' &&
    r.type !== 'ExportNamedDeclaration' &&
    r.type !== 'DeclareExportDeclaration'
  )
    return !1;
  let n = (e = r.declaration) == null ? void 0 : e.decorators;
  return b(n) && yt(r, n[0]);
}
function $u(r, e, n) {
  let { node: s } = r;
  return ['import', s.module ? ' module' : '', os(s), Ku(r, e, n), Hu(r, e, n), Qu(r, e, n), e.semi ? ';' : ''];
}
var Vu = (r) => r.type === 'ExportDefaultDeclaration' || (r.type === 'DeclareExportDeclaration' && r.default);
function Kr(r, e, n) {
  let { node: s } = r,
    o = [qu(r, e, n), Q(r), 'export', Vu(s) ? ' default' : ''],
    { declaration: a, exported: l } = s;
  return (
    d(s, x$1.Dangling) && (o.push(' ', M(r, e)), gr(s) && o.push(C$1)),
    a
      ? o.push(' ', n('declaration'))
      : (o.push(Vp(s)),
        s.type === 'ExportAllDeclaration' || s.type === 'DeclareExportAllDeclaration'
          ? (o.push(' *'), l && o.push(' as ', n('exported')))
          : o.push(Ku(r, e, n)),
        o.push(Hu(r, e, n), Qu(r, e, n))),
    o.push($p(s, e)),
    o
  );
}
var Xp = j$1([
  'ClassDeclaration',
  'FunctionDeclaration',
  'TSInterfaceDeclaration',
  'DeclareClass',
  'DeclareFunction',
  'TSDeclareFunction',
  'EnumDeclaration',
]);
function $p(r, e) {
  return e.semi && (!r.declaration || (Vu(r) && !Xp(r.declaration))) ? ';' : '';
}
function as(r, e = !0) {
  return r && r !== 'value' ? `${e ? ' ' : ''}${r}${e ? '' : ' '}` : '';
}
function os(r, e) {
  return as(r.importKind, e);
}
function Vp(r) {
  return as(r.exportKind);
}
function Hu(r, e, n) {
  let { node: s } = r;
  if (!s.source) return '';
  let o = [];
  return zu(s, e) || o.push(' from'), o.push(' ', n('source')), o;
}
function Ku(r, e, n) {
  let { node: s } = r;
  if (zu(s, e)) return '';
  let o = [' '];
  if (b(s.specifiers)) {
    let a = [],
      l = [];
    r.each(() => {
      let f = r.node.type;
      if (
        f === 'ExportNamespaceSpecifier' ||
        f === 'ExportDefaultSpecifier' ||
        f === 'ImportNamespaceSpecifier' ||
        f === 'ImportDefaultSpecifier'
      )
        a.push(n());
      else if (f === 'ExportSpecifier' || f === 'ImportSpecifier') l.push(n());
      else throw new Oe(s, 'specifier');
    }, 'specifiers'),
      o.push(B$1(', ', a)),
      l.length > 0 &&
        (a.length > 0 && o.push(', '),
        l.length > 1 || a.length > 0 || s.specifiers.some((f) => d(f))
          ? o.push(
              y$1([
                '{',
                E([e.bracketSpacing ? A : F$1, B$1([',', A], l)]),
                P$1(le(e) ? ',' : ''),
                e.bracketSpacing ? A : F$1,
                '}',
              ]),
            )
          : o.push(['{', e.bracketSpacing ? ' ' : '', ...l, e.bracketSpacing ? ' ' : '', '}']));
  } else o.push('{}');
  return o;
}
function zu(r, e) {
  let { type: n, importKind: s, source: o, specifiers: a } = r;
  return n !== 'ImportDeclaration' || b(a) || s === 'type' ? !1 : !/{\s*}/.test(e.originalText.slice(U$1(r), U$1(o)));
}
function Qu(r, e, n) {
  var s;
  let { node: o } = r,
    a = b(o.attributes) ? 'attributes' : b(o.assertions) ? 'assertions' : void 0;
  return a
    ? [
        ` ${a === 'assertions' || ((s = o.extra) != null && s.deprecatedAssertSyntax) ? 'assert' : 'with'} {`,
        e.bracketSpacing ? ' ' : '',
        B$1(', ', r.map(n, a)),
        e.bracketSpacing ? ' ' : '',
        '}',
      ]
    : '';
}
function Zu(r, e, n) {
  let { node: s } = r,
    { type: o } = s,
    a = o.startsWith('Import'),
    l = a ? 'imported' : 'local',
    f = a ? 'local' : 'exported',
    m = s[l],
    v = s[f],
    I = '',
    L = '';
  return (
    o === 'ExportNamespaceSpecifier' || o === 'ImportNamespaceSpecifier' ? (I = '*') : m && (I = n(l)),
    v && !Hp(s) && (L = n(f)),
    [as(o === 'ImportSpecifier' ? s.importKind : s.exportKind, !1), I, I && L ? ' as ' : '', L]
  );
}
function Hp(r) {
  if (r.type !== 'ImportSpecifier' && r.type !== 'ExportSpecifier') return !1;
  let { local: e, [r.type === 'ImportSpecifier' ? 'imported' : 'exported']: n } = r;
  if (e.type !== n.type || !Xs(e, n)) return !1;
  if (ee(e)) return e.value === n.value && oe(e) === oe(n);
  switch (e.type) {
    case 'Identifier':
      return e.name === n.name;
    default:
      return !1;
  }
}
function Kp(r) {
  let e = [r];
  for (let n = 0; n < e.length; n++) {
    let s = e[n];
    for (let o of ['test', 'consequent', 'alternate']) {
      let a = s[o];
      if (Y(a)) return !0;
      a.type === 'ConditionalExpression' && e.push(a);
    }
  }
  return !1;
}
function zp(r, e, n) {
  let { node: s } = r,
    o = s.type === 'ConditionalExpression',
    a = o ? 'alternate' : 'falseType',
    { parent: l } = r,
    f = o ? n('test') : [n('checkType'), ' ', 'extends', ' ', n('extendsType')];
  return l.type === s.type && l[a] === s ? De(2, f) : f;
}
var Qp = new Map([
  ['AssignmentExpression', 'right'],
  ['VariableDeclarator', 'init'],
  ['ReturnStatement', 'argument'],
  ['ThrowStatement', 'argument'],
  ['UnaryExpression', 'argument'],
  ['YieldExpression', 'argument'],
]);
function Zp(r) {
  let { node: e } = r;
  if (e.type !== 'ConditionalExpression') return !1;
  let n,
    s = e;
  for (let o = 0; !n; o++) {
    let a = r.getParentNode(o);
    if (
      (a.type === 'ChainExpression' && a.expression === s) ||
      (k(a) && a.callee === s) ||
      (J(a) && a.object === s) ||
      (a.type === 'TSNonNullExpression' && a.expression === s)
    ) {
      s = a;
      continue;
    }
    (a.type === 'NewExpression' && a.callee === s) || (Le(a) && a.expression === s)
      ? ((n = r.getParentNode(o + 1)), (s = a))
      : (n = a);
  }
  return s === e ? !1 : n[Qp.get(n.type)] === s;
}
function Mt(r, e, n) {
  let { node: s } = r,
    o = s.type === 'ConditionalExpression',
    a = o ? 'consequent' : 'trueType',
    l = o ? 'alternate' : 'falseType',
    f = o ? ['test'] : ['checkType', 'extendsType'],
    m = s[a],
    v = s[l],
    I = [],
    L = !1,
    { parent: V } = r,
    se = V.type === s.type && f.some((vl) => V[vl] === s),
    Ee = V.type === s.type && !se,
    ht,
    ar,
    $i = 0;
  do (ar = ht || s), (ht = r.getParentNode($i)), $i++;
  while (ht && ht.type === s.type && f.every((vl) => ht[vl] !== ar));
  let tl = ht || V,
    Wi = ar;
  if (o && (Y(s[f[0]]) || Y(m) || Y(v) || Kp(Wi))) {
    (L = !0), (Ee = !0);
    let vl = (El) => [P$1('('), E([F$1, El]), F$1, P$1(')')],
      kl = (El) =>
        El.type === 'NullLiteral' ||
        (El.type === 'Literal' && El.value === null) ||
        (El.type === 'Identifier' && El.name === 'undefined');
    I.push(' ? ', kl(m) ? n(a) : vl(n(a)), ' : ', v.type === s.type || kl(v) ? n(l) : vl(n(l)));
  } else {
    let vl = [
      A,
      '? ',
      m.type === s.type ? P$1('', '(') : '',
      De(2, n(a)),
      m.type === s.type ? P$1('', ')') : '',
      A,
      ': ',
      v.type === s.type ? n(l) : De(2, n(l)),
    ];
    I.push(V.type !== s.type || V[l] === s || se ? vl : e.useTabs ? Os(E(vl)) : De(Math.max(0, e.tabWidth - 2), vl));
  }
  let hl = [a, l, ...f].some((vl) => d(s[vl], (kl) => ae(kl) && rt(e.originalText, U$1(kl), O$1(kl)))),
    fl = (vl) => (V === tl ? y$1(vl, { shouldBreak: hl }) : hl ? [vl, Ae] : vl),
    dl = !L && (J(V) || (V.type === 'NGPipeExpression' && V.left === s)) && !V.computed,
    Al = Zp(r),
    Fl = fl([zp(r, e, n), Ee ? I : E(I), o && dl && !Al ? F$1 : '']);
  return se || Al ? y$1([E([F$1, Fl]), F$1]) : Fl;
}
function ec(r, e, n = 0) {
  let s = 0;
  for (let o = n; o < r.length; ++o) r[o] === '	' ? (s = s + e - (s % e)) : s++;
  return s;
}
var ei = ec;
function tc(r, e) {
  let n = r.lastIndexOf(`
`);
  return n === -1 ? 0 : ei(r.slice(n + 1).match(/^[\t ]*/)[0], e);
}
var ti = tc;
function ri(r) {
  switch (r) {
    case 'cr':
      return '\r';
    case 'crlf':
      return `\r
`;
    default:
      return `
`;
  }
}
var Ce = Symbol('MODE_BREAK'),
  nt = Symbol('MODE_FLAT'),
  rr = Symbol('cursor');
function ni() {
  return { value: '', length: 0, queue: [] };
}
function rc(r, e) {
  return ps(r, { type: 'indent' }, e);
}
function nc(r, e, n) {
  return e === Number.NEGATIVE_INFINITY
    ? r.root || ni()
    : e < 0
    ? ps(r, { type: 'dedent' }, n)
    : e
    ? e.type === 'root'
      ? { ...r, root: r }
      : ps(r, { type: typeof e == 'string' ? 'stringAlign' : 'numberAlign', n: e }, n)
    : r;
}
function ps(r, e, n) {
  let s = e.type === 'dedent' ? r.queue.slice(0, -1) : [...r.queue, e],
    o = '',
    a = 0,
    l = 0,
    f = 0;
  for (let Ee of s)
    switch (Ee.type) {
      case 'indent':
        I(), n.useTabs ? m(1) : v(n.tabWidth);
        break;
      case 'stringAlign':
        I(), (o += Ee.n), (a += Ee.n.length);
        break;
      case 'numberAlign':
        (l += 1), (f += Ee.n);
        break;
      default:
        throw new Error(`Unexpected type '${Ee.type}'`);
    }
  return V(), { ...r, value: o, length: a, queue: s };
  function m(Ee) {
    (o += '	'.repeat(Ee)), (a += n.tabWidth * Ee);
  }
  function v(Ee) {
    (o += ' '.repeat(Ee)), (a += Ee);
  }
  function I() {
    n.useTabs ? L() : V();
  }
  function L() {
    l > 0 && m(l), se();
  }
  function V() {
    f > 0 && v(f), se();
  }
  function se() {
    (l = 0), (f = 0);
  }
}
function cs(r) {
  let e = 0,
    n = 0,
    s = r.length;
  e: for (; s--; ) {
    let o = r[s];
    if (o === rr) {
      n++;
      continue;
    }
    for (let a = o.length - 1; a >= 0; a--) {
      let l = o[a];
      if (l === ' ' || l === '	') e++;
      else {
        r[s] = o.slice(0, a + 1);
        break e;
      }
    }
  }
  if (e > 0 || n > 0) for (r.length = s + 1; n-- > 0; ) r.push(rr);
  return e;
}
function zr(r, e, n, s, o, a) {
  if (n === Number.POSITIVE_INFINITY) return !0;
  let l = e.length,
    f = [r],
    m = [];
  for (; n >= 0; ) {
    if (f.length === 0) {
      if (l === 0) return !0;
      f.push(e[--l]);
      continue;
    }
    let { mode: v, doc: I } = f.pop();
    switch (Ze(I)) {
      case Ke:
        m.push(I), (n -= tt(I));
        break;
      case je:
      case ye: {
        let L = mr(I);
        for (let V = L.length - 1; V >= 0; V--) f.push({ mode: v, doc: L[V] });
        break;
      }
      case Me:
      case Re:
      case Je:
      case be:
        f.push({ mode: v, doc: I.contents });
        break;
      case Qe:
        n += cs(m);
        break;
      case ue: {
        if (a && I.break) return !1;
        let L = I.break ? Ce : v,
          V = I.expandedStates && L === Ce ? w$1(!1, I.expandedStates, -1) : I.contents;
        f.push({ mode: L, doc: V });
        break;
      }
      case Fe: {
        let L = (I.groupId ? o[I.groupId] || nt : v) === Ce ? I.breakContents : I.flatContents;
        L && f.push({ mode: v, doc: L });
        break;
      }
      case ie:
        if (v === Ce || I.hard) return !0;
        I.soft || (m.push(' '), n--);
        break;
      case Ne:
        s = !0;
        break;
      case Ue:
        if (s) return !1;
        break;
    }
  }
  return !1;
}
function ls(r, e) {
  let n = {},
    s = e.printWidth,
    o = ri(e.endOfLine),
    a = 0,
    l = [{ ind: ni(), mode: Ce, doc: r }],
    f = [],
    m = !1,
    v = [],
    I = 0;
  for (Ms(r); l.length > 0; ) {
    let { ind: V, mode: se, doc: Ee } = l.pop();
    switch (Ze(Ee)) {
      case Ke: {
        let ht =
          o !==
          `
`
            ? H(
                !1,
                Ee,
                `
`,
                o,
              )
            : Ee;
        f.push(ht), l.length > 0 && (a += tt(ht));
        break;
      }
      case je:
        for (let ht = Ee.length - 1; ht >= 0; ht--) l.push({ ind: V, mode: se, doc: Ee[ht] });
        break;
      case ze:
        if (I >= 2) throw new Error("There are too many 'cursor' in doc.");
        f.push(rr), I++;
        break;
      case Me:
        l.push({ ind: rc(V, e), mode: se, doc: Ee.contents });
        break;
      case Re:
        l.push({ ind: nc(V, Ee.n, e), mode: se, doc: Ee.contents });
        break;
      case Qe:
        a -= cs(f);
        break;
      case ue:
        switch (se) {
          case nt:
            if (!m) {
              l.push({ ind: V, mode: Ee.break ? Ce : nt, doc: Ee.contents });
              break;
            }
          case Ce: {
            m = !1;
            let ht = { ind: V, mode: nt, doc: Ee.contents },
              ar = s - a,
              $i = v.length > 0;
            if (!Ee.break && zr(ht, l, ar, $i, n)) l.push(ht);
            else if (Ee.expandedStates) {
              let tl = w$1(!1, Ee.expandedStates, -1);
              if (Ee.break) {
                l.push({ ind: V, mode: Ce, doc: tl });
                break;
              } else
                for (let Wi = 1; Wi < Ee.expandedStates.length + 1; Wi++)
                  if (Wi >= Ee.expandedStates.length) {
                    l.push({ ind: V, mode: Ce, doc: tl });
                    break;
                  } else {
                    let hl = Ee.expandedStates[Wi],
                      fl = { ind: V, mode: nt, doc: hl };
                    if (zr(fl, l, ar, $i, n)) {
                      l.push(fl);
                      break;
                    }
                  }
            } else l.push({ ind: V, mode: Ce, doc: Ee.contents });
            break;
          }
        }
        Ee.id && (n[Ee.id] = w$1(!1, l, -1).mode);
        break;
      case ye: {
        let ht = s - a,
          { parts: ar } = Ee;
        if (ar.length === 0) break;
        let [$i, tl] = ar,
          Wi = { ind: V, mode: nt, doc: $i },
          hl = { ind: V, mode: Ce, doc: $i },
          fl = zr(Wi, [], ht, v.length > 0, n, !0);
        if (ar.length === 1) {
          fl ? l.push(Wi) : l.push(hl);
          break;
        }
        let dl = { ind: V, mode: nt, doc: tl },
          Al = { ind: V, mode: Ce, doc: tl };
        if (ar.length === 2) {
          fl ? l.push(dl, Wi) : l.push(Al, hl);
          break;
        }
        ar.splice(0, 2);
        let Fl = { ind: V, mode: se, doc: St(ar) },
          vl = ar[0];
        zr({ ind: V, mode: nt, doc: [$i, tl, vl] }, [], ht, v.length > 0, n, !0)
          ? l.push(Fl, dl, Wi)
          : fl
          ? l.push(Fl, Al, Wi)
          : l.push(Fl, Al, hl);
        break;
      }
      case Fe:
      case Je: {
        let ht = Ee.groupId ? n[Ee.groupId] : se;
        if (ht === Ce) {
          let ar = Ee.type === Fe ? Ee.breakContents : Ee.negate ? Ee.contents : E(Ee.contents);
          ar && l.push({ ind: V, mode: se, doc: ar });
        }
        if (ht === nt) {
          let ar = Ee.type === Fe ? Ee.flatContents : Ee.negate ? E(Ee.contents) : Ee.contents;
          ar && l.push({ ind: V, mode: se, doc: ar });
        }
        break;
      }
      case Ne:
        v.push({ ind: V, mode: se, doc: Ee.contents });
        break;
      case Ue:
        v.length > 0 && l.push({ ind: V, mode: se, doc: Sn });
        break;
      case ie:
        switch (se) {
          case nt:
            if (Ee.hard) m = !0;
            else {
              Ee.soft || (f.push(' '), (a += 1));
              break;
            }
          case Ce:
            if (v.length > 0) {
              l.push({ ind: V, mode: se, doc: Ee }, ...v.reverse()), (v.length = 0);
              break;
            }
            Ee.literal
              ? V.root
                ? (f.push(o, V.root.value), (a = V.root.length))
                : (f.push(o), (a = 0))
              : ((a -= cs(f)), f.push(o + V.value), (a = V.length));
            break;
        }
        break;
      case be:
        l.push({ ind: V, mode: se, doc: Ee.contents });
        break;
      case Pe:
        break;
      default:
        throw new lt(Ee);
    }
    l.length === 0 && v.length > 0 && (l.push(...v.reverse()), (v.length = 0));
  }
  let L = f.indexOf(rr);
  if (L !== -1) {
    let V = f.indexOf(rr, L + 1),
      se = f.slice(0, L).join(''),
      Ee = f.slice(L + 1, V).join(''),
      ht = f.slice(V + 1).join('');
    return { formatted: se + Ee + ht, cursorNodeStart: se.length, cursorNodeText: Ee };
  }
  return { formatted: f.join('') };
}
function Qr(r, e, n) {
  let { node: s } = r;
  if (s.type === 'TemplateLiteral' && ic(r)) {
    let v = sc(r, n, e);
    if (v) return v;
  }
  let o = 'expressions';
  s.type === 'TSTemplateLiteralType' && (o = 'types');
  let a = [],
    l = r.map(e, o),
    f = eu(s);
  f && (l = l.map((v) => ls(v, { ...n, printWidth: Number.POSITIVE_INFINITY }).formatted)), a.push(de, '`');
  let m = 0;
  return (
    r.each(({ index: v, node: I }) => {
      if ((a.push(e()), I.tail)) return;
      let { tabWidth: L } = n,
        V = I.value.raw,
        se = V.includes(`
`)
          ? ti(V, L)
          : m;
      m = se;
      let Ee = l[v];
      if (!f) {
        let ar = s[o][v];
        (d(ar) ||
          J(ar) ||
          ar.type === 'ConditionalExpression' ||
          ar.type === 'SequenceExpression' ||
          Le(ar) ||
          ce(ar)) &&
          (Ee = [E([F$1, Ee]), F$1]);
      }
      let ht =
        se === 0 &&
        V.endsWith(`
`)
          ? De(Number.NEGATIVE_INFINITY, Ee)
          : vs(Ee, se, L);
      a.push(y$1(['${', ht, de, '}']));
    }, 'quasis'),
    a.push('`'),
    a
  );
}
function si(r) {
  let e = r('quasi');
  return et(e.label && { tagged: !0, ...e.label }, [r('tag'), r('typeParameters'), de, e]);
}
function sc(r, e, n) {
  let { node: s } = r,
    o = s.quasis[0].value.raw.trim().split(/\s*\|\s*/);
  if (o.length > 1 || o.some((a) => a.length > 0)) {
    e.__inJestEach = !0;
    let a = r.map(n, 'expressions');
    e.__inJestEach = !1;
    let l = [],
      f = a.map((V) => '${' + ls(V, { ...e, printWidth: Number.POSITIVE_INFINITY, endOfLine: 'lf' }).formatted + '}'),
      m = [{ hasLineBreak: !1, cells: [] }];
    for (let V = 1; V < s.quasis.length; V++) {
      let se = w$1(!1, m, -1),
        Ee = f[V - 1];
      se.cells.push(Ee),
        Ee.includes(`
`) && (se.hasLineBreak = !0),
        s.quasis[V].value.raw.includes(`
`) && m.push({ hasLineBreak: !1, cells: [] });
    }
    let v = Math.max(o.length, ...m.map((V) => V.cells.length)),
      I = Array.from({ length: v }).fill(0),
      L = [{ cells: o }, ...m.filter((V) => V.cells.length > 0)];
    for (let { cells: V } of L.filter((se) => !se.hasLineBreak))
      for (let [se, Ee] of V.entries()) I[se] = Math.max(I[se], tt(Ee));
    return (
      l.push(
        de,
        '`',
        E([
          C$1,
          B$1(
            C$1,
            L.map((V) =>
              B$1(
                ' | ',
                V.cells.map((se, Ee) => (V.hasLineBreak ? se : se + ' '.repeat(I[Ee] - tt(se)))),
              ),
            ),
          ),
        ]),
        C$1,
        '`',
      ),
      l
    );
  }
}
function uc(r, e) {
  let { node: n } = r,
    s = e();
  return d(n) && (s = y$1([E([F$1, s]), F$1])), ['${', s, de, '}'];
}
function Rt(r, e) {
  return r.map((n) => uc(n, e), 'expressions');
}
function Zr(r, e) {
  return ut(r, (n) => (typeof n == 'string' ? (e ? H(!1, n, /(\\*)`/g, '$1$1\\`') : ms(n)) : n));
}
function ms(r) {
  return H(!1, r, /([\\`]|\${)/g, '\\$1');
}
function ic({ node: r, parent: e }) {
  let n = /^[fx]?(?:describe|it|test)$/;
  return (
    e.type === 'TaggedTemplateExpression' &&
    e.quasi === r &&
    e.tag.type === 'MemberExpression' &&
    e.tag.property.type === 'Identifier' &&
    e.tag.property.name === 'each' &&
    ((e.tag.object.type === 'Identifier' && n.test(e.tag.object.name)) ||
      (e.tag.object.type === 'MemberExpression' &&
        e.tag.object.property.type === 'Identifier' &&
        (e.tag.object.property.name === 'only' || e.tag.object.property.name === 'skip') &&
        e.tag.object.object.type === 'Identifier' &&
        n.test(e.tag.object.object.name)))
  );
}
function ac(r) {
  let e = new WeakMap();
  return function (n) {
    return e.has(n) || e.set(n, Symbol(r)), e.get(n);
  };
}
var en = ac;
function oc(r) {
  switch (r) {
    case null:
      return '';
    case 'PlusOptional':
      return '+?';
    case 'MinusOptional':
      return '-?';
    case 'Optional':
      return '?';
  }
}
function ui(r, e, n) {
  let { node: s } = r;
  return y$1([
    s.variance ? n('variance') : '',
    '[',
    E([n('keyTparam'), ' in ', n('sourceType')]),
    ']',
    oc(s.optional),
    ': ',
    n('propType'),
  ]);
}
function ys(r, e) {
  return r === '+' || r === '-' ? r + e : e;
}
function ii(r, e, n) {
  let { node: s } = r,
    o = rt(e.originalText, U$1(s), U$1(s.typeParameter));
  return y$1(
    [
      '{',
      E([
        e.bracketSpacing ? A : F$1,
        y$1([
          n('typeParameter'),
          s.optional ? ys(s.optional, '?') : '',
          s.typeAnnotation ? ': ' : '',
          n('typeAnnotation'),
        ]),
        e.semi ? P$1(';') : '',
      ]),
      M(r, e),
      e.bracketSpacing ? A : F$1,
      '}',
    ],
    { shouldBreak: o },
  );
}
var nr = en('typeParameters');
function pc(r, e, n) {
  let { node: s } = r;
  return (
    X(s).length === 1 &&
    s.type.startsWith('TS') &&
    !s[n][0].constraint &&
    r.parent.type === 'ArrowFunctionExpression' &&
    !(e.filepath && /\.ts$/.test(e.filepath))
  );
}
function gt(r, e, n, s) {
  let { node: o } = r;
  if (!o[s]) return '';
  if (!Array.isArray(o[s])) return n(s);
  let a = r.getNode(2),
    l = a && Ct(a),
    f = r.match(
      (v) => !(v[s].length === 1 && ke(v[s][0])),
      void 0,
      (v, I) => I === 'typeAnnotation',
      (v) => v.type === 'Identifier',
      rs,
    );
  if (
    o[s].length === 0 ||
    (!f && (l || (o[s].length === 1 && (o[s][0].type === 'NullableTypeAnnotation' || ss(o[s][0])))))
  )
    return ['<', B$1(', ', r.map(n, s)), cc(r, e), '>'];
  let m = o.type === 'TSTypeParameterInstantiation' ? '' : pc(r, e, s) ? ',' : le(e) ? P$1(',') : '';
  return y$1(['<', E([F$1, B$1([',', A], r.map(n, s))]), m, F$1, '>'], { id: nr(o) });
}
function cc(r, e) {
  let { node: n } = r;
  if (!d(n, x$1.Dangling)) return '';
  let s = !d(n, x$1.Line),
    o = M(r, e, { indent: !s });
  return s ? o : [o, C$1];
}
function tn(r, e, n) {
  let { node: s, parent: o } = r,
    a = [s.type === 'TSTypeParameter' && s.const ? 'const ' : ''],
    l = s.type === 'TSTypeParameter' ? n('name') : s.name;
  if (o.type === 'TSMappedType')
    return (
      o.readonly && a.push(ys(o.readonly, 'readonly'), ' '),
      a.push('[', l),
      s.constraint && a.push(' in ', n('constraint')),
      o.nameType &&
        a.push(
          ' as ',
          r.callParent(() => n('nameType')),
        ),
      a.push(']'),
      a
    );
  if (
    (s.variance && a.push(n('variance')),
    s.in && a.push('in '),
    s.out && a.push('out '),
    a.push(l),
    s.bound && (s.usesExtendsBound && a.push(' extends '), a.push(q(r, n, 'bound'))),
    s.constraint)
  ) {
    let f = Symbol('constraint');
    a.push(' extends', y$1(E(A), { id: f }), de, mt(n('constraint'), { groupId: f }));
  }
  return s.default && a.push(' = ', n('default')), y$1(a);
}
var ai = new Proxy(() => {}, { get: () => ai }),
  rn = ai,
  nn = new WeakMap();
function ct(r, e, n) {
  let { node: s } = r;
  if (s.computed) return ['[', n('key'), ']'];
  let { parent: o } = r,
    { key: a } = s;
  if (e.quoteProps === 'consistent' && !nn.has(o)) {
    let l = (o.properties || o.body || o.members).some((f) => !f.computed && f.key && ee(f.key) && !_n(f, e));
    nn.set(o, l);
  }
  if (
    (a.type === 'Identifier' ||
      (ge(a) &&
        jn(He(oe(a))) &&
        String(a.value) === He(oe(a)) &&
        !(e.parser === 'typescript' || e.parser === 'babel-ts'))) &&
    (e.parser === 'json' || (e.quoteProps === 'consistent' && nn.get(o)))
  ) {
    let l = Tt(JSON.stringify(a.type === 'Identifier' ? a.name : a.value.toString()), e);
    return r.call((f) => pe(f, l, e), 'key');
  }
  return _n(s, e) && (e.quoteProps === 'as-needed' || (e.quoteProps === 'consistent' && !nn.get(o)))
    ? r.call((l) => pe(l, /^\d/.test(a.value) ? He(a.value) : a.value, e), 'key')
    : n('key');
}
function oi(r, e, n) {
  let { node: s } = r;
  return s.shorthand ? n('value') : ft(r, e, n, ct(r, e, n), ':', 'value');
}
var lc = (r) =>
    r.type === 'ObjectMethod' ||
    r.type === 'ClassMethod' ||
    r.type === 'ClassPrivateMethod' ||
    r.type === 'MethodDefinition' ||
    r.type === 'TSAbstractMethodDefinition' ||
    r.type === 'TSDeclareMethod' ||
    ((r.type === 'Property' || r.type === 'ObjectProperty') && (r.method || r.kind === 'get' || r.kind === 'set')),
  mc = (r) => r.node.type === 'FunctionExpression' && r.key === 'value' && lc(r.parent);
function sn(r, e, n, s) {
  if (mc(r)) return un(r, n, e);
  let { node: o } = r,
    a = !1;
  if ((o.type === 'FunctionDeclaration' || o.type === 'FunctionExpression') && s != null && s.expandLastArg) {
    let { parent: I } = r;
    k(I) && (he(I).length > 1 || X(o).every((L) => L.type === 'Identifier' && !L.typeAnnotation)) && (a = !0);
  }
  let l = [Q(r), o.async ? 'async ' : '', `function${o.generator ? '*' : ''} `, o.id ? e('id') : ''],
    f = ot(r, e, n, a),
    m = on(r, e),
    v = xt(o, m);
  return (
    l.push(Ve(r, n, e), y$1([v ? y$1(f) : f, m]), o.body ? ' ' : '', e('body')),
    n.semi && (o.declare || !o.body) && l.push(';'),
    l
  );
}
function sr(r, e, n) {
  let { node: s } = r,
    { kind: o } = s,
    a = s.value || s,
    l = [];
  return (
    !o || o === 'init' || o === 'method' || o === 'constructor'
      ? a.async && l.push('async ')
      : (rn.ok(o === 'get' || o === 'set'), l.push(o, ' ')),
    a.generator && l.push('*'),
    l.push(ct(r, e, n), s.optional || s.key.optional ? '?' : '', s === a ? un(r, e, n) : n('value')),
    l
  );
}
function un(r, e, n) {
  let { node: s } = r,
    o = ot(r, n, e),
    a = on(r, n),
    l = Nu(s),
    f = xt(s, a),
    m = [Ve(r, e, n), y$1([l ? y$1(o, { shouldBreak: !0 }) : f ? y$1(o) : o, a])];
  return s.body ? m.push(' ', n('body')) : m.push(e.semi ? ';' : ''), m;
}
function yc(r) {
  let e = X(r);
  return (
    e.length === 1 &&
    !r.typeParameters &&
    !d(r, x$1.Dangling) &&
    e[0].type === 'Identifier' &&
    !e[0].typeAnnotation &&
    !d(e[0]) &&
    !e[0].optional &&
    !r.predicate &&
    !r.returnType
  );
}
function an(r, e) {
  if (e.arrowParens === 'always') return !1;
  if (e.arrowParens === 'avoid') {
    let { node: n } = r;
    return yc(n);
  }
  return !1;
}
function on(r, e) {
  let { node: n } = r,
    s = [q(r, e, 'returnType')];
  return n.predicate && s.push(e('predicate')), s;
}
function pi(r, e, n) {
  let { node: s } = r,
    o = e.semi ? ';' : '',
    a = [];
  if (s.argument) {
    let m = n('argument');
    Dc(e, s.argument)
      ? (m = ['(', E([C$1, m]), C$1, ')'])
      : (ce(s.argument) || s.argument.type === 'SequenceExpression') &&
        (m = y$1([P$1('('), E([F$1, m]), F$1, P$1(')')])),
      a.push(' ', m);
  }
  let l = d(s, x$1.Dangling),
    f = o && l && d(s, x$1.Last | x$1.Line);
  return f && a.push(o), l && a.push(' ', M(r, e)), f || a.push(o), a;
}
function ci(r, e, n) {
  return ['return', pi(r, e, n)];
}
function li(r, e, n) {
  return ['throw', pi(r, e, n)];
}
function Dc(r, e) {
  if (Ie(r.originalText, e) || (d(e, x$1.Leading, (n) => rt(r.originalText, U$1(n), O$1(n))) && !Y(e))) return !0;
  if (Lt(e)) {
    let n = e,
      s;
    for (; (s = zs(n)); ) if (((n = s), Ie(r.originalText, n))) return !0;
  }
  return !1;
}
var mi = j$1([
  'ClassProperty',
  'PropertyDefinition',
  'ClassPrivateProperty',
  'ClassAccessorProperty',
  'AccessorProperty',
  'TSAbstractPropertyDefinition',
  'TSAbstractAccessorProperty',
]);
function pn(r, e, n) {
  let { node: s } = r,
    o = [Q(r), _t(r), 'class'],
    a =
      d(s.id, x$1.Trailing) ||
      d(s.typeParameters, x$1.Trailing) ||
      d(s.superClass) ||
      b(s.extends) ||
      b(s.mixins) ||
      b(s.implements),
    l = [],
    f = [];
  if ((s.id && l.push(' ', n('id')), l.push(n('typeParameters')), s.superClass)) {
    let m = [Ec(r, e, n), n('superTypeParameters')],
      v = r.call((I) => ['extends ', pe(I, m, e)], 'superClass');
    a ? f.push(A, y$1(v)) : f.push(' ', v);
  } else f.push(Ds(r, e, n, 'extends'));
  if ((f.push(Ds(r, e, n, 'mixins'), Ds(r, e, n, 'implements')), a)) {
    let m;
    Di(s) ? (m = [...l, E(f)]) : (m = E([...l, f])), o.push(y$1(m, { id: yi(s) }));
  } else o.push(...l, ...f);
  return o.push(' ', n('body')), o;
}
var yi = en('heritageGroup');
function fs(r) {
  return P$1(C$1, '', { groupId: yi(r) });
}
function fc(r) {
  return (
    ['extends', 'mixins', 'implements'].reduce(
      (e, n) => e + (Array.isArray(r[n]) ? r[n].length : 0),
      r.superClass ? 1 : 0,
    ) > 1
  );
}
function Di(r) {
  return r.typeParameters && !d(r.typeParameters, x$1.Trailing | x$1.Line) && !fc(r);
}
function Ds(r, e, n, s) {
  let { node: o } = r;
  if (!b(o[s])) return '';
  let a = M(r, e, { marker: s });
  return [
    Di(o) ? P$1(' ', A, { groupId: nr(o.typeParameters) }) : A,
    a,
    a && C$1,
    s,
    y$1(E([A, B$1([',', A], r.map(n, s))])),
  ];
}
function Ec(r, e, n) {
  let s = n('superClass'),
    { parent: o } = r;
  return o.type === 'AssignmentExpression' ? y$1(P$1(['(', E([F$1, s]), F$1, ')'], s)) : s;
}
function cn(r, e, n) {
  let { node: s } = r,
    o = [];
  return (
    b(s.decorators) && o.push(is(r, e, n)),
    o.push(jt(s)),
    s.static && o.push('static '),
    o.push(_t(r)),
    s.override && o.push('override '),
    o.push(sr(r, e, n)),
    o
  );
}
function ln(r, e, n) {
  let { node: s } = r,
    o = [],
    a = e.semi ? ';' : '';
  b(s.decorators) && o.push(is(r, e, n)),
    o.push(jt(s), Q(r)),
    s.static && o.push('static '),
    o.push(_t(r)),
    s.override && o.push('override '),
    s.readonly && o.push('readonly '),
    s.variance && o.push(n('variance')),
    (s.type === 'ClassAccessorProperty' || s.type === 'AccessorProperty' || s.type === 'TSAbstractAccessorProperty') &&
      o.push('accessor '),
    o.push(ct(r, e, n), $(r), Vr(r), q(r, n));
  let l = s.type === 'TSAbstractPropertyDefinition' || s.type === 'TSAbstractAccessorProperty';
  return [ft(r, e, n, o, ' =', l ? void 0 : 'value'), a];
}
function fi(r, e, n) {
  let { node: s } = r,
    o = [];
  return (
    r.each(({ node: a, next: l, isLast: f }) => {
      o.push(n()), !e.semi && mi(a) && Fc(a, l) && o.push(';'), f || (o.push(C$1), me(a, e) && o.push(C$1));
    }, 'body'),
    d(s, x$1.Dangling) && o.push(M(r, e)),
    [b(s.body) ? fs(r.parent) : '', '{', o.length > 0 ? [E([C$1, o]), C$1] : '', '}']
  );
}
function Fc(r, e) {
  var n;
  let { type: s, name: o } = r.key;
  if (
    !r.computed &&
    s === 'Identifier' &&
    (o === 'static' || o === 'get' || o === 'set') &&
    !r.value &&
    !r.typeAnnotation
  )
    return !0;
  if (!e || e.static || e.accessibility) return !1;
  if (!e.computed) {
    let a = (n = e.key) == null ? void 0 : n.name;
    if (a === 'in' || a === 'instanceof') return !0;
  }
  if (mi(e) && e.variance && !e.static && !e.declare) return !0;
  switch (e.type) {
    case 'ClassProperty':
    case 'PropertyDefinition':
    case 'TSAbstractPropertyDefinition':
      return e.computed;
    case 'MethodDefinition':
    case 'TSAbstractMethodDefinition':
    case 'ClassMethod':
    case 'ClassPrivateMethod': {
      if ((e.value ? e.value.async : e.async) || e.kind === 'get' || e.kind === 'set') return !1;
      let a = e.value ? e.value.generator : e.generator;
      return !!(e.computed || a);
    }
    case 'TSIndexSignature':
      return !0;
  }
  return !1;
}
function Et(r, e, n) {
  var s;
  let o = e.semi ? ';' : '',
    { node: a } = r,
    l = a.type === 'ObjectTypeAnnotation',
    f =
      a.type === 'TSEnumDeclaration' ||
      a.type === 'EnumBooleanBody' ||
      a.type === 'EnumNumberBody' ||
      a.type === 'EnumStringBody' ||
      a.type === 'EnumSymbolBody',
    m = [a.type === 'TSTypeLiteral' || f ? 'members' : a.type === 'TSInterfaceBody' ? 'body' : 'properties'];
  l && m.push('indexers', 'callProperties', 'internalSlots');
  let v = m.flatMap((dl) => r.map(({ node: Al }) => ({ node: Al, printed: n(), loc: U$1(Al) }), dl));
  m.length > 1 && v.sort((dl, Al) => dl.loc - Al.loc);
  let { parent: I, key: L } = r,
    V =
      l &&
      L === 'body' &&
      (I.type === 'InterfaceDeclaration' || I.type === 'DeclareInterface' || I.type === 'DeclareClass'),
    se =
      a.type === 'TSInterfaceBody' ||
      f ||
      V ||
      (a.type === 'ObjectPattern' &&
        I.type !== 'FunctionDeclaration' &&
        I.type !== 'FunctionExpression' &&
        I.type !== 'ArrowFunctionExpression' &&
        I.type !== 'ObjectMethod' &&
        I.type !== 'ClassMethod' &&
        I.type !== 'ClassPrivateMethod' &&
        I.type !== 'AssignmentPattern' &&
        I.type !== 'CatchClause' &&
        a.properties.some(
          (dl) => dl.value && (dl.value.type === 'ObjectPattern' || dl.value.type === 'ArrayPattern'),
        )) ||
      (a.type !== 'ObjectPattern' && v.length > 0 && rt(e.originalText, U$1(a), v[0].loc)),
    Ee = V ? ';' : a.type === 'TSInterfaceBody' || a.type === 'TSTypeLiteral' ? P$1(o, ';') : ',',
    ht = a.type === 'RecordExpression' ? '#{' : a.exact ? '{|' : '{',
    ar = a.exact ? '|}' : '}',
    $i = [],
    tl = v.map((dl) => {
      let Al = [...$i, y$1(dl.printed)];
      return (
        ($i = [Ee, A]),
        (dl.node.type === 'TSPropertySignature' ||
          dl.node.type === 'TSMethodSignature' ||
          dl.node.type === 'TSConstructSignatureDeclaration' ||
          dl.node.type === 'TSCallSignatureDeclaration') &&
          d(dl.node, x$1.PrettierIgnore) &&
          $i.shift(),
        me(dl.node, e) && $i.push(C$1),
        Al
      );
    });
  if (a.inexact || a.hasUnknownMembers) {
    let dl;
    if (d(a, x$1.Dangling)) {
      let Al = d(a, x$1.Line);
      dl = [M(r, e), Al || z$1(e.originalText, O$1(w$1(!1, Kt(a), -1))) ? C$1 : A, '...'];
    } else dl = ['...'];
    tl.push([...$i, ...dl]);
  }
  let Wi = (s = w$1(!1, v, -1)) == null ? void 0 : s.node,
    hl = !(
      a.inexact ||
      a.hasUnknownMembers ||
      (Wi &&
        (Wi.type === 'RestElement' ||
          ((Wi.type === 'TSPropertySignature' ||
            Wi.type === 'TSCallSignatureDeclaration' ||
            Wi.type === 'TSMethodSignature' ||
            Wi.type === 'TSConstructSignatureDeclaration') &&
            d(Wi, x$1.PrettierIgnore))))
    ),
    fl;
  if (tl.length === 0) {
    if (!d(a, x$1.Dangling)) return [ht, ar, q(r, n)];
    fl = y$1([ht, M(r, e, { indent: !0 }), F$1, ar, $(r), q(r, n)]);
  } else
    fl = [
      V && b(a.properties) ? fs(I) : '',
      ht,
      E([e.bracketSpacing ? A : F$1, ...tl]),
      P$1(hl && (Ee !== ',' || le(e)) ? Ee : ''),
      e.bracketSpacing ? A : F$1,
      ar,
      $(r),
      q(r, n),
    ];
  return r.match((dl) => dl.type === 'ObjectPattern' && !b(dl.decorators), Es) ||
    (ke(a) &&
      (r.match(
        void 0,
        (dl, Al) => Al === 'typeAnnotation',
        (dl, Al) => Al === 'typeAnnotation',
        Es,
      ) ||
        r.match(void 0, (dl, Al) => dl.type === 'FunctionTypeParam' && Al === 'typeAnnotation', Es))) ||
    (!se &&
      r.match(
        (dl) => dl.type === 'ObjectPattern',
        (dl) => dl.type === 'AssignmentExpression' || dl.type === 'VariableDeclarator',
      ))
    ? fl
    : y$1(fl, { shouldBreak: se });
}
function Es(r, e) {
  return (e === 'params' || e === 'parameters' || e === 'this' || e === 'rest') && ns(r);
}
var Fs = new WeakMap();
function Ei(r) {
  return (
    Fs.has(r) || Fs.set(r, r.type === 'ConditionalExpression' && !re(r, (e) => e.type === 'ObjectExpression')),
    Fs.get(r)
  );
}
var Fi = (r) => r.type === 'SequenceExpression';
function Ci(r, e, n, s = {}) {
  let o = [],
    a,
    l = [],
    f = !1,
    m = !s.expandLastArg && r.node.body.type === 'ArrowFunctionExpression',
    v;
  (function ar() {
    let { node: $i } = r,
      tl = Cc(r, e, n, s);
    if (o.length === 0) o.push(tl);
    else {
      let { leading: Wi, trailing: hl } = Nn(r, e);
      o.push([Wi, tl]), l.unshift(hl);
    }
    m &&
      (f ||
        (f = ($i.returnType && X($i).length > 0) || $i.typeParameters || X($i).some((Wi) => Wi.type !== 'Identifier'))),
      !m || $i.body.type !== 'ArrowFunctionExpression' ? ((a = n('body', s)), (v = $i.body)) : r.call(ar, 'body');
  })();
  let I = !Ie(e.originalText, v) && (Fi(v) || dc(v, a, e) || (!f && Ei(v))),
    L = r.key === 'callee' && it(r.parent),
    V = Symbol('arrow-chain'),
    se = Ac(r, s, { signatureDocs: o, shouldBreak: f }),
    Ee,
    ht = !1;
  return (
    m && (L || s.assignmentLayout) && ((ht = !0), (Ee = s.assignmentLayout === 'chain-tail-arrow-chain' || (L && !I))),
    (a = Tc(r, e, s, { bodyDoc: a, bodyComments: l, functionBody: v, shouldPutBodyOnSameLine: I })),
    y$1([
      y$1(ht ? E([F$1, se]) : se, { shouldBreak: Ee, id: V }),
      ' =>',
      m ? mt(a, { groupId: V }) : y$1(a),
      m && L ? P$1(F$1, '', { groupId: V }) : '',
    ])
  );
}
function Cc(r, e, n, s) {
  let { node: o } = r,
    a = [];
  if ((o.async && a.push('async '), an(r, e))) a.push(n(['params', 0]));
  else {
    let f = s.expandLastArg || s.expandFirstArg,
      m = on(r, n);
    if (f) {
      if (K(m)) throw new at();
      m = y$1(Ut(m));
    }
    a.push(y$1([ot(r, n, e, f, !0), m]));
  }
  let l = M(r, e, {
    filter(f) {
      let m = Xe(e.originalText, O$1(f));
      return m !== !1 && e.originalText.slice(m, m + 2) === '=>';
    },
  });
  return l && a.push(' ', l), a;
}
function dc(r, e, n) {
  var s, o;
  return (
    G(r) ||
    Z(r) ||
    r.type === 'ArrowFunctionExpression' ||
    r.type === 'DoExpression' ||
    r.type === 'BlockStatement' ||
    Y(r) ||
    (((s = e.label) == null ? void 0 : s.hug) !== !1 &&
      (((o = e.label) == null ? void 0 : o.embed) || xr(r, n.originalText)))
  );
}
function Ac(r, e, { signatureDocs: n, shouldBreak: s }) {
  if (n.length === 1) return n[0];
  let { parent: o, key: a } = r;
  return (a !== 'callee' && it(o)) || ce(o)
    ? y$1([n[0], ' =>', E([A, B$1([' =>', A], n.slice(1))])], { shouldBreak: s })
    : (a === 'callee' && it(o)) || e.assignmentLayout
    ? y$1(B$1([' =>', A], n), { shouldBreak: s })
    : y$1(E(B$1([' =>', A], n)), { shouldBreak: s });
}
function Tc(r, e, n, { bodyDoc: s, bodyComments: o, functionBody: a, shouldPutBodyOnSameLine: l }) {
  let { node: f, parent: m } = r,
    v = n.expandLastArg && le(e, 'all') ? P$1(',') : '',
    I = (n.expandLastArg || m.type === 'JSXExpressionContainer') && !d(f) ? F$1 : '';
  return l && Ei(a)
    ? [' ', y$1([P$1('', '('), E([F$1, s]), P$1('', ')'), v, I]), o]
    : (Fi(a) && (s = y$1(['(', E([F$1, s]), F$1, ')'])), l ? [' ', s, o] : [E([A, s, o]), v, I]);
}
function ur(r, e, n, s) {
  let { node: o } = r,
    a = [],
    l = xc(o[s]);
  return (
    r.each(({ node: f }) => {
      f.type !== 'EmptyStatement' && (a.push(n()), f !== l && (a.push(C$1), me(f, e) && a.push(C$1)));
    }, s),
    a
  );
}
function xc(r) {
  for (let e = r.length - 1; e >= 0; e--) {
    let n = r[e];
    if (n.type !== 'EmptyStatement') return n;
  }
}
function mn(r, e, n) {
  let { node: s } = r,
    o = [];
  s.type === 'StaticBlock' && o.push('static '), o.push('{');
  let a = Cs(r, e, n);
  if (a) o.push(E([C$1, a]), C$1);
  else {
    let { parent: l } = r,
      f = r.grandparent;
    l.type === 'ArrowFunctionExpression' ||
      l.type === 'FunctionExpression' ||
      l.type === 'FunctionDeclaration' ||
      l.type === 'ObjectMethod' ||
      l.type === 'ClassMethod' ||
      l.type === 'ClassPrivateMethod' ||
      l.type === 'ForStatement' ||
      l.type === 'WhileStatement' ||
      l.type === 'DoWhileStatement' ||
      l.type === 'DoExpression' ||
      (l.type === 'CatchClause' && !f.finalizer) ||
      l.type === 'TSModuleDeclaration' ||
      l.type === 'TSDeclareFunction' ||
      s.type === 'StaticBlock' ||
      o.push(C$1);
  }
  return o.push('}'), o;
}
function Cs(r, e, n) {
  var s;
  let { node: o } = r,
    a = b(o.directives),
    l = o.body.some((v) => v.type !== 'EmptyStatement'),
    f = d(o, x$1.Dangling);
  if (!a && !l && !f) return '';
  let m = [];
  return (
    a &&
      (m.push(ur(r, e, n, 'directives')), (l || f) && (m.push(C$1), me(w$1(!1, o.directives, -1), e) && m.push(C$1))),
    l && m.push(ur(r, e, n, 'body')),
    f && m.push(M(r, e)),
    o.type === 'Program' && ((s = r.parent) == null ? void 0 : s.type) !== 'ModuleExpression' && m.push(C$1),
    m
  );
}
function di(r, e) {
  if (e.semi || ds(r, e) || Ts(r, e)) return !1;
  let { node: n, key: s, parent: o } = r;
  return !!(
    n.type === 'ExpressionStatement' &&
    ((s === 'body' &&
      (o.type === 'Program' ||
        o.type === 'BlockStatement' ||
        o.type === 'StaticBlock' ||
        o.type === 'TSModuleBlock')) ||
      (s === 'consequent' && o.type === 'SwitchCase')) &&
    r.call(() => Ai(r, e), 'expression')
  );
}
function Ai(r, e) {
  let { node: n } = r;
  switch (n.type) {
    case 'ParenthesizedExpression':
    case 'TypeCastExpression':
    case 'ArrayExpression':
    case 'ArrayPattern':
    case 'TemplateLiteral':
    case 'TemplateElement':
    case 'RegExpLiteral':
      return !0;
    case 'ArrowFunctionExpression':
      if (!an(r, e)) return !0;
      break;
    case 'UnaryExpression': {
      let { prefix: s, operator: o } = n;
      if (s && (o === '+' || o === '-')) return !0;
      break;
    }
    case 'BindExpression':
      if (!n.object) return !0;
      break;
    case 'Literal':
      if (n.regex) return !0;
      break;
    default:
      if (Y(n)) return !0;
  }
  return we(r, e) ? !0 : Lt(n) ? r.call(() => Ai(r, e), ...dr(n)) : !1;
}
function ds({ node: r, parent: e }, n) {
  return (
    (n.parentParser === 'markdown' || n.parentParser === 'mdx') &&
    r.type === 'ExpressionStatement' &&
    Y(r.expression) &&
    e.type === 'Program' &&
    e.body.length === 1
  );
}
function As(r) {
  switch (r.type) {
    case 'MemberExpression':
      switch (r.property.type) {
        case 'Identifier':
        case 'NumericLiteral':
        case 'StringLiteral':
          return As(r.object);
      }
      return !1;
    case 'Identifier':
      return !0;
    default:
      return !1;
  }
}
function Ts({ node: r, parent: e }, n) {
  return (
    (n.parser === '__vue_event_binding' || n.parser === '__vue_ts_event_binding') &&
    r.type === 'ExpressionStatement' &&
    e.type === 'Program' &&
    e.body.length === 1
  );
}
function Ti(r, e, n) {
  let s = [n('expression')];
  return (
    Ts(r, e) ? As(r.node.expression) && s.push(';') : ds(r, e) || (e.semi && s.push(';')),
    d(r.node, x$1.Dangling, ({ marker: o }) => o === zt) && s.push(' ', M(r, e, { marker: zt })),
    s
  );
}
function xi(r, e, n) {
  if (e.__isVueBindings || e.__isVueForBindingLeft) {
    let s = r.map(n, 'program', 'body', 0, 'params');
    if (s.length === 1) return s[0];
    let o = B$1([',', A], s);
    return e.__isVueForBindingLeft ? ['(', E([F$1, y$1(o)]), F$1, ')'] : o;
  }
  if (e.__isEmbeddedTypescriptGenericParameters) {
    let s = r.map(n, 'program', 'body', 0, 'typeParameters', 'params');
    return B$1([',', A], s);
  }
}
function gi(r, e, n, s) {
  let { node: o } = r;
  if (vr(o)) return vu(r, e);
  let a = e.semi ? ';' : '',
    l = [];
  switch (o.type) {
    case 'JsExpressionRoot':
      return n('node');
    case 'JsonRoot':
      return [n('node'), C$1];
    case 'File':
      return xi(r, e, n) ?? n('program');
    case 'Program':
      return Cs(r, e, n);
    case 'EmptyStatement':
      return '';
    case 'ExpressionStatement':
      return Ti(r, e, n);
    case 'ChainExpression':
      return n('expression');
    case 'ParenthesizedExpression':
      return !d(o.expression) && (Z(o.expression) || G(o.expression))
        ? ['(', n('expression'), ')']
        : y$1(['(', E([F$1, n('expression')]), F$1, ')']);
    case 'AssignmentExpression':
      return ju(r, e, n);
    case 'VariableDeclarator':
      return Mu(r, e, n);
    case 'BinaryExpression':
    case 'LogicalExpression':
      return Ir(r, e, n);
    case 'AssignmentPattern':
      return [n('left'), ' = ', n('right')];
    case 'OptionalMemberExpression':
    case 'MemberExpression':
      return ku(r, e, n);
    case 'MetaProperty':
      return [n('meta'), '.', n('property')];
    case 'BindExpression':
      return o.object && l.push(n('object')), l.push(y$1(E([F$1, Lr(r, e, n)]))), l;
    case 'Identifier':
      return [o.name, $(r), Vr(r), q(r, n)];
    case 'V8IntrinsicIdentifier':
      return ['%', o.name];
    case 'SpreadElement':
    case 'SpreadElementPattern':
    case 'SpreadPropertyPattern':
    case 'RestElement':
      return Hr(r, n);
    case 'FunctionDeclaration':
    case 'FunctionExpression':
      return sn(r, n, e, s);
    case 'ArrowFunctionExpression':
      return Ci(r, e, n, s);
    case 'YieldExpression':
      return l.push('yield'), o.delegate && l.push('*'), o.argument && l.push(' ', n('argument')), l;
    case 'AwaitExpression':
      if ((l.push('await'), o.argument)) {
        l.push(' ', n('argument'));
        let { parent: f } = r;
        if ((k(f) && f.callee === o) || (J(f) && f.object === o)) {
          l = [E([F$1, ...l]), F$1];
          let m = r.findAncestor((v) => v.type === 'AwaitExpression' || v.type === 'BlockStatement');
          if ((m == null ? void 0 : m.type) !== 'AwaitExpression' || !re(m.argument, (v) => v === o)) return y$1(l);
        }
      }
      return l;
    case 'ExportDefaultDeclaration':
    case 'ExportNamedDeclaration':
    case 'ExportAllDeclaration':
      return Kr(r, e, n);
    case 'ImportDeclaration':
      return $u(r, e, n);
    case 'ImportSpecifier':
    case 'ExportSpecifier':
    case 'ImportNamespaceSpecifier':
    case 'ExportNamespaceSpecifier':
    case 'ImportDefaultSpecifier':
    case 'ExportDefaultSpecifier':
      return Zu(r, e, n);
    case 'ImportAttribute':
      return [n('key'), ': ', n('value')];
    case 'Import':
      return 'import';
    case 'BlockStatement':
    case 'StaticBlock':
      return mn(r, e, n);
    case 'ClassBody':
      return fi(r, e, n);
    case 'ThrowStatement':
      return li(r, e, n);
    case 'ReturnStatement':
      return ci(r, e, n);
    case 'NewExpression':
    case 'ImportExpression':
    case 'OptionalCallExpression':
    case 'CallExpression':
      return wr(r, e, n);
    case 'ObjectExpression':
    case 'ObjectPattern':
    case 'RecordExpression':
      return Et(r, e, n);
    case 'ObjectProperty':
    case 'Property':
      return o.method || o.kind === 'get' || o.kind === 'set' ? sr(r, e, n) : oi(r, e, n);
    case 'ObjectMethod':
      return sr(r, e, n);
    case 'Decorator':
      return ['@', n('expression')];
    case 'ArrayExpression':
    case 'ArrayPattern':
    case 'TupleExpression':
      return vt(r, e, n);
    case 'SequenceExpression': {
      let { parent: f } = r;
      if (f.type === 'ExpressionStatement' || f.type === 'ForStatement') {
        let m = [];
        return (
          r.each(({ isFirst: v }) => {
            v ? m.push(n()) : m.push(',', E([A, n()]));
          }, 'expressions'),
          y$1(m)
        );
      }
      return y$1(B$1([',', A], r.map(n, 'expressions')));
    }
    case 'ThisExpression':
      return 'this';
    case 'Super':
      return 'super';
    case 'Directive':
      return [n('value'), a];
    case 'UnaryExpression':
      return (
        l.push(o.operator),
        /[a-z]$/.test(o.operator) && l.push(' '),
        d(o.argument) ? l.push(y$1(['(', E([F$1, n('argument')]), F$1, ')'])) : l.push(n('argument')),
        l
      );
    case 'UpdateExpression':
      return l.push(n('argument'), o.operator), o.prefix && l.reverse(), l;
    case 'ConditionalExpression':
      return Mt(r, e, n);
    case 'VariableDeclaration': {
      let f = r.map(n, 'declarations'),
        m = r.parent,
        v = m.type === 'ForStatement' || m.type === 'ForInStatement' || m.type === 'ForOfStatement',
        I = o.declarations.some((V) => V.init),
        L;
      return (
        f.length === 1 && !d(o.declarations[0]) ? (L = f[0]) : f.length > 0 && (L = E(f[0])),
        (l = [Q(r), o.kind, L ? [' ', L] : '', E(f.slice(1).map((V) => [',', I && !v ? C$1 : A, V]))]),
        (v && m.body !== o) || l.push(a),
        y$1(l)
      );
    }
    case 'WithStatement':
      return y$1(['with (', n('object'), ')', pt(o.body, n('body'))]);
    case 'IfStatement': {
      let f = pt(o.consequent, n('consequent')),
        m = y$1(['if (', y$1([E([F$1, n('test')]), F$1]), ')', f]);
      if ((l.push(m), o.alternate)) {
        let v = d(o.consequent, x$1.Trailing | x$1.Line) || gr(o),
          I = o.consequent.type === 'BlockStatement' && !v;
        l.push(I ? ' ' : C$1),
          d(o, x$1.Dangling) && l.push(M(r, e), v ? C$1 : ' '),
          l.push('else', y$1(pt(o.alternate, n('alternate'), o.alternate.type === 'IfStatement')));
      }
      return l;
    }
    case 'ForStatement': {
      let f = pt(o.body, n('body')),
        m = M(r, e),
        v = m ? [m, F$1] : '';
      return !o.init && !o.test && !o.update
        ? [v, y$1(['for (;;)', f])]
        : [v, y$1(['for (', y$1([E([F$1, n('init'), ';', A, n('test'), ';', A, n('update')]), F$1]), ')', f])];
    }
    case 'WhileStatement':
      return y$1(['while (', y$1([E([F$1, n('test')]), F$1]), ')', pt(o.body, n('body'))]);
    case 'ForInStatement':
      return y$1(['for (', n('left'), ' in ', n('right'), ')', pt(o.body, n('body'))]);
    case 'ForOfStatement':
      return y$1(['for', o.await ? ' await' : '', ' (', n('left'), ' of ', n('right'), ')', pt(o.body, n('body'))]);
    case 'DoWhileStatement': {
      let f = pt(o.body, n('body'));
      return (
        (l = [y$1(['do', f])]),
        o.body.type === 'BlockStatement' ? l.push(' ') : l.push(C$1),
        l.push('while (', y$1([E([F$1, n('test')]), F$1]), ')', a),
        l
      );
    }
    case 'DoExpression':
      return [o.async ? 'async ' : '', 'do ', n('body')];
    case 'BreakStatement':
    case 'ContinueStatement':
      return (
        l.push(o.type === 'BreakStatement' ? 'break' : 'continue'), o.label && l.push(' ', n('label')), l.push(a), l
      );
    case 'LabeledStatement':
      return o.body.type === 'EmptyStatement' ? [n('label'), ':;'] : [n('label'), ': ', n('body')];
    case 'TryStatement':
      return [
        'try ',
        n('block'),
        o.handler ? [' ', n('handler')] : '',
        o.finalizer ? [' finally ', n('finalizer')] : '',
      ];
    case 'CatchClause':
      if (o.param) {
        let f = d(
            o.param,
            (v) =>
              !ae(v) ||
              (v.leading && z$1(e.originalText, O$1(v))) ||
              (v.trailing && z$1(e.originalText, U$1(v), { backwards: !0 })),
          ),
          m = n('param');
        return ['catch ', f ? ['(', E([F$1, m]), F$1, ') '] : ['(', m, ') '], n('body')];
      }
      return ['catch ', n('body')];
    case 'SwitchStatement':
      return [
        y$1(['switch (', E([F$1, n('discriminant')]), F$1, ')']),
        ' {',
        o.cases.length > 0
          ? E([
              C$1,
              B$1(
                C$1,
                r.map(({ node: f, isLast: m }) => [n(), !m && me(f, e) ? C$1 : ''], 'cases'),
              ),
            ])
          : '',
        C$1,
        '}',
      ];
    case 'SwitchCase': {
      o.test ? l.push('case ', n('test'), ':') : l.push('default:'), d(o, x$1.Dangling) && l.push(' ', M(r, e));
      let f = o.consequent.filter((m) => m.type !== 'EmptyStatement');
      if (f.length > 0) {
        let m = ur(r, e, n, 'consequent');
        l.push(f.length === 1 && f[0].type === 'BlockStatement' ? [' ', m] : E([C$1, m]));
      }
      return l;
    }
    case 'DebuggerStatement':
      return ['debugger', a];
    case 'ClassDeclaration':
    case 'ClassExpression':
      return pn(r, e, n);
    case 'ClassMethod':
    case 'ClassPrivateMethod':
    case 'MethodDefinition':
      return cn(r, e, n);
    case 'ClassProperty':
    case 'PropertyDefinition':
    case 'ClassPrivateProperty':
    case 'ClassAccessorProperty':
    case 'AccessorProperty':
      return ln(r, e, n);
    case 'TemplateElement':
      return Te(o.value.raw);
    case 'TemplateLiteral':
      return Qr(r, n, e);
    case 'TaggedTemplateExpression':
      return si(n);
    case 'PrivateIdentifier':
      return ['#', o.name];
    case 'PrivateName':
      return ['#', n('id')];
    case 'TopicReference':
      return '%';
    case 'ArgumentPlaceholder':
      return '?';
    case 'ModuleExpression': {
      l.push('module {');
      let f = n('body');
      return f && l.push(E([C$1, f]), C$1), l.push('}'), l;
    }
    case 'InterpreterDirective':
    default:
      throw new Oe(o, 'ESTree');
  }
}
function Si(r, e, n) {
  let { node: s } = r;
  if (s.type.startsWith('NG'))
    switch (s.type) {
      case 'NGRoot':
        return [n('node'), d(s.node) ? ' //' + Kt(s.node)[0].value.trimEnd() : ''];
      case 'NGPipeExpression':
        return Ir(r, e, n);
      case 'NGChainedExpression':
        return y$1(
          B$1(
            [';', A],
            r.map(() => (hc(r) ? n() : ['(', n(), ')']), 'expressions'),
          ),
        );
      case 'NGEmptyExpression':
        return '';
      case 'NGMicrosyntax':
        return r.map(() => [r.isFirst ? '' : hi(r) ? ' ' : [';', A], n()], 'body');
      case 'NGMicrosyntaxKey':
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(s.name) ? s.name : JSON.stringify(s.name);
      case 'NGMicrosyntaxExpression':
        return [n('expression'), s.alias === null ? '' : [' as ', n('alias')]];
      case 'NGMicrosyntaxKeyedExpression': {
        let { index: o, parent: a } = r,
          l =
            hi(r) ||
            (((o === 1 && (s.key.name === 'then' || s.key.name === 'else')) ||
              (o === 2 &&
                s.key.name === 'else' &&
                a.body[o - 1].type === 'NGMicrosyntaxKeyedExpression' &&
                a.body[o - 1].key.name === 'then')) &&
              a.body[0].type === 'NGMicrosyntaxExpression');
        return [n('key'), l ? ' ' : ': ', n('expression')];
      }
      case 'NGMicrosyntaxLet':
        return ['let ', n('key'), s.value === null ? '' : [' = ', n('value')]];
      case 'NGMicrosyntaxAs':
        return [n('key'), ' as ', n('alias')];
      default:
        throw new Oe(s, 'Angular');
    }
}
function hi({ node: r, index: e, parent: n }) {
  return (
    r.type === 'NGMicrosyntaxKeyedExpression' &&
    r.key.name === 'of' &&
    e === 1 &&
    n.body[0].type === 'NGMicrosyntaxLet' &&
    n.body[0].value === null
  );
}
var gc = j$1(['CallExpression', 'OptionalCallExpression', 'AssignmentExpression']);
function hc({ node: r }) {
  return Xt(r, gc);
}
function yn(r, e, n) {
  let { node: s } = r,
    o = [Q(r), 'interface'],
    a = [],
    l = [];
  s.type !== 'InterfaceTypeAnnotation' && a.push(' ', n('id'), n('typeParameters'));
  let f = s.typeParameters && !d(s.typeParameters, x$1.Trailing | x$1.Line);
  return (
    b(s.extends) &&
      l.push(
        f ? P$1(' ', A, { groupId: nr(s.typeParameters) }) : A,
        'extends ',
        (s.extends.length === 1 ? ru : E)(B$1([',', A], r.map(n, 'extends'))),
      ),
    d(s.id, x$1.Trailing) || b(s.extends)
      ? f
        ? o.push(y$1([...a, E(l)]))
        : o.push(y$1(E([...a, ...l])))
      : o.push(...a, ...l),
    o.push(' ', n('body')),
    y$1(o)
  );
}
function Bi(r, e, n) {
  return Et(r, n, e);
}
function Dn(r, e) {
  let { node: n } = r,
    s = e('id');
  n.computed && (s = ['[', s, ']']);
  let o = '';
  return n.initializer && (o = e('initializer')), n.init && (o = e('init')), o ? [s, ' = ', o] : s;
}
function bi(r, e, n) {
  let { node: s } = r,
    o;
  if (s.type === 'EnumSymbolBody' || s.explicitType)
    switch (s.type) {
      case 'EnumBooleanBody':
        o = 'boolean';
        break;
      case 'EnumNumberBody':
        o = 'number';
        break;
      case 'EnumStringBody':
        o = 'string';
        break;
      case 'EnumSymbolBody':
        o = 'symbol';
        break;
    }
  return [o ? `of ${o} ` : '', Bi(r, e, n)];
}
function fn(r, e, n) {
  let { node: s } = r;
  return [
    Q(r),
    s.const ? 'const ' : '',
    'enum ',
    e('id'),
    ' ',
    s.type === 'TSEnumDeclaration' ? Bi(r, e, n) : e('body'),
  ];
}
function Pi(r, e, n) {
  let { node: s } = r;
  if (Er(s)) return s.type.slice(0, -14).toLowerCase();
  let o = e.semi ? ';' : '';
  switch (s.type) {
    case 'DeclareClass':
      return pn(r, e, n);
    case 'DeclareFunction':
      return [Q(r), 'function ', n('id'), n('predicate'), o];
    case 'DeclareModule':
      return ['declare module ', n('id'), ' ', n('body')];
    case 'DeclareModuleExports':
      return ['declare module.exports', q(r, n), o];
    case 'DeclareVariable':
      return [Q(r), s.kind ?? 'var', ' ', n('id'), o];
    case 'DeclareExportDeclaration':
    case 'DeclareExportAllDeclaration':
      return Kr(r, e, n);
    case 'DeclareOpaqueType':
    case 'OpaqueType':
      return Uu(r, e, n);
    case 'DeclareTypeAlias':
    case 'TypeAlias':
      return jr(r, e, n);
    case 'IntersectionTypeAnnotation':
      return Mr(r, e, n);
    case 'UnionTypeAnnotation':
      return Rr(r, e, n);
    case 'ConditionalTypeAnnotation':
      return Mt(r, e, n);
    case 'InferTypeAnnotation':
      return Ur(r, e, n);
    case 'FunctionTypeAnnotation':
      return Jr(r, e, n);
    case 'TupleTypeAnnotation':
      return vt(r, e, n);
    case 'TupleTypeLabeledElement':
      return qr(r, e, n);
    case 'TupleTypeSpreadElement':
      return Gr(r, e, n);
    case 'GenericTypeAnnotation':
      return [n('id'), gt(r, e, n, 'typeParameters')];
    case 'IndexedAccessType':
    case 'OptionalIndexedAccessType':
      return Nr(r, e, n);
    case 'TypeAnnotation':
      return Wr(r, e, n);
    case 'TypeParameter':
      return tn(r, e, n);
    case 'TypeofTypeAnnotation':
      return Xr(r, n);
    case 'ExistsTypeAnnotation':
      return '*';
    case 'ArrayTypeAnnotation':
      return Yr(n);
    case 'DeclareEnum':
    case 'EnumDeclaration':
      return fn(r, n, e);
    case 'EnumBooleanBody':
    case 'EnumNumberBody':
    case 'EnumStringBody':
    case 'EnumSymbolBody':
      return bi(r, n, e);
    case 'EnumBooleanMember':
    case 'EnumNumberMember':
    case 'EnumStringMember':
    case 'EnumDefaultedMember':
      return Dn(r, n);
    case 'FunctionTypeParam': {
      let a = s.name ? n('name') : r.parent.this === s ? 'this' : '';
      return [a, $(r), a ? ': ' : '', n('typeAnnotation')];
    }
    case 'DeclareInterface':
    case 'InterfaceDeclaration':
    case 'InterfaceTypeAnnotation':
      return yn(r, e, n);
    case 'ClassImplements':
    case 'InterfaceExtends':
      return [n('id'), n('typeParameters')];
    case 'NullableTypeAnnotation':
      return ['?', n('typeAnnotation')];
    case 'Variance': {
      let { kind: a } = s;
      return rn.ok(a === 'plus' || a === 'minus'), a === 'plus' ? '+' : '-';
    }
    case 'KeyofTypeAnnotation':
      return ['keyof ', n('argument')];
    case 'ObjectTypeCallProperty':
      return [s.static ? 'static ' : '', n('value')];
    case 'ObjectTypeMappedTypeProperty':
      return ui(r, e, n);
    case 'ObjectTypeIndexer':
      return [
        s.static ? 'static ' : '',
        s.variance ? n('variance') : '',
        '[',
        n('id'),
        s.id ? ': ' : '',
        n('key'),
        ']: ',
        n('value'),
      ];
    case 'ObjectTypeProperty': {
      let a = '';
      return (
        s.proto ? (a = 'proto ') : s.static && (a = 'static '),
        [
          a,
          On(s) ? s.kind + ' ' : '',
          s.variance ? n('variance') : '',
          ct(r, e, n),
          $(r),
          vn(s) ? '' : ': ',
          n('value'),
        ]
      );
    }
    case 'ObjectTypeAnnotation':
      return Et(r, e, n);
    case 'ObjectTypeInternalSlot':
      return [s.static ? 'static ' : '', '[[', n('id'), ']]', $(r), s.method ? '' : ': ', n('value')];
    case 'ObjectTypeSpreadProperty':
      return Hr(r, n);
    case 'QualifiedTypeofIdentifier':
    case 'QualifiedTypeIdentifier':
      return [n('qualification'), '.', n('id')];
    case 'NullLiteralTypeAnnotation':
      return 'null';
    case 'BooleanLiteralTypeAnnotation':
      return String(s.value);
    case 'StringLiteralTypeAnnotation':
      return Te(Tt(oe(s), e));
    case 'NumberLiteralTypeAnnotation':
      return He(s.raw ?? s.extra.raw);
    case 'BigIntLiteralTypeAnnotation':
      return Or(s.raw ?? s.extra.raw);
    case 'TypeCastExpression':
      return ['(', n('expression'), q(r, n), ')'];
    case 'TypePredicate':
      return $r(r, n);
    case 'TypeParameterDeclaration':
    case 'TypeParameterInstantiation':
      return gt(r, e, n, 'params');
    case 'InferredPredicate':
    case 'DeclaredPredicate':
      return [
        r.key === 'predicate' && r.parent.type !== 'DeclareFunction' && !r.parent.returnType ? ': ' : ' ',
        '%checks',
        ...(s.type === 'DeclaredPredicate' ? ['(', n('value'), ')'] : []),
      ];
  }
}
function ki(r, e, n) {
  var s;
  let { node: o } = r;
  if (!o.type.startsWith('TS')) return;
  if (Fr(o)) return o.type.slice(2, -7).toLowerCase();
  let a = e.semi ? ';' : '',
    l = [];
  switch (o.type) {
    case 'TSThisType':
      return 'this';
    case 'TSTypeAssertion': {
      let f = !(G(o.expression) || Z(o.expression)),
        m = y$1(['<', E([F$1, n('typeAnnotation')]), F$1, '>']),
        v = [P$1('('), E([F$1, n('expression')]), F$1, P$1(')')];
      return f
        ? qe([
            [m, n('expression')],
            [m, y$1(v, { shouldBreak: !0 })],
            [m, n('expression')],
          ])
        : y$1([m, n('expression')]);
    }
    case 'TSDeclareFunction':
      return sn(r, n, e);
    case 'TSExportAssignment':
      return ['export = ', n('expression'), a];
    case 'TSModuleBlock':
      return mn(r, e, n);
    case 'TSInterfaceBody':
    case 'TSTypeLiteral':
      return Et(r, e, n);
    case 'TSTypeAliasDeclaration':
      return jr(r, e, n);
    case 'TSQualifiedName':
      return [n('left'), '.', n('right')];
    case 'TSAbstractMethodDefinition':
    case 'TSDeclareMethod':
      return cn(r, e, n);
    case 'TSAbstractAccessorProperty':
    case 'TSAbstractPropertyDefinition':
      return ln(r, e, n);
    case 'TSInterfaceHeritage':
    case 'TSClassImplements':
    case 'TSExpressionWithTypeArguments':
    case 'TSInstantiationExpression':
      return [n('expression'), n('typeParameters')];
    case 'TSTemplateLiteralType':
      return Qr(r, n, e);
    case 'TSNamedTupleMember':
      return qr(r, e, n);
    case 'TSRestType':
      return Gr(r, e, n);
    case 'TSOptionalType':
      return [n('typeAnnotation'), '?'];
    case 'TSInterfaceDeclaration':
      return yn(r, e, n);
    case 'TSTypeParameterDeclaration':
    case 'TSTypeParameterInstantiation':
      return gt(r, e, n, 'params');
    case 'TSTypeParameter':
      return tn(r, e, n);
    case 'TSAsExpression':
    case 'TSSatisfiesExpression': {
      let f = o.type === 'TSAsExpression' ? 'as' : 'satisfies';
      l.push(n('expression'), ` ${f} `, n('typeAnnotation'));
      let { parent: m } = r;
      return (k(m) && m.callee === o) || (J(m) && m.object === o) ? y$1([E([F$1, ...l]), F$1]) : l;
    }
    case 'TSArrayType':
      return Yr(n);
    case 'TSPropertySignature':
      return [o.readonly ? 'readonly ' : '', ct(r, e, n), $(r), q(r, n)];
    case 'TSParameterProperty':
      return [
        jt(o),
        o.static ? 'static ' : '',
        o.override ? 'override ' : '',
        o.readonly ? 'readonly ' : '',
        n('parameter'),
      ];
    case 'TSTypeQuery':
      return Xr(r, n);
    case 'TSIndexSignature': {
      let f = o.parameters.length > 1 ? P$1(le(e) ? ',' : '') : '',
        m = y$1([E([F$1, B$1([', ', F$1], r.map(n, 'parameters'))]), f, F$1]),
        v = r.parent.type === 'ClassBody' && r.key === 'body';
      return [
        v && o.static ? 'static ' : '',
        o.readonly ? 'readonly ' : '',
        '[',
        o.parameters ? m : '',
        ']',
        q(r, n),
        v ? a : '',
      ];
    }
    case 'TSTypePredicate':
      return $r(r, n);
    case 'TSNonNullExpression':
      return [n('expression'), '!'];
    case 'TSImportType':
      return [
        o.isTypeOf ? 'typeof ' : '',
        'import(',
        n('argument'),
        ')',
        o.qualifier ? ['.', n('qualifier')] : '',
        gt(r, e, n, o.typeArguments ? 'typeArguments' : 'typeParameters'),
      ];
    case 'TSLiteralType':
      return n('literal');
    case 'TSIndexedAccessType':
      return Nr(r, e, n);
    case 'TSTypeOperator':
      return [o.operator, ' ', n('typeAnnotation')];
    case 'TSMappedType':
      return ii(r, e, n);
    case 'TSMethodSignature': {
      let f = o.kind && o.kind !== 'method' ? `${o.kind} ` : '';
      l.push(jt(o), f, o.computed ? '[' : '', n('key'), o.computed ? ']' : '', $(r));
      let m = ot(r, n, e, !1, !0),
        v = o.returnType ? 'returnType' : 'typeAnnotation',
        I = o[v],
        L = I ? q(r, n, v) : '',
        V = xt(o, L);
      return l.push(V ? y$1(m) : m), I && l.push(y$1(L)), y$1(l);
    }
    case 'TSNamespaceExportDeclaration':
      return ['export as namespace ', n('id'), e.semi ? ';' : ''];
    case 'TSEnumDeclaration':
      return fn(r, n, e);
    case 'TSEnumMember':
      return Dn(r, n);
    case 'TSImportEqualsDeclaration':
      return [
        o.isExport ? 'export ' : '',
        'import ',
        os(o, !1),
        n('id'),
        ' = ',
        n('moduleReference'),
        e.semi ? ';' : '',
      ];
    case 'TSExternalModuleReference':
      return ['require(', n('expression'), ')'];
    case 'TSModuleDeclaration': {
      let { parent: f } = r,
        m = f.type === 'TSModuleDeclaration',
        v = ((s = o.body) == null ? void 0 : s.type) === 'TSModuleDeclaration';
      if (m) l.push('.');
      else if ((l.push(Q(r)), !(o.kind === 'global' || o.global))) {
        let I =
          o.kind ??
          (ee(o.id) || /(?:^|\s)module(?:\s|$)/.test(e.originalText.slice(U$1(o), U$1(o.id))) ? 'module' : 'namespace');
        l.push(I, ' ');
      }
      return l.push(n('id')), v ? l.push(n('body')) : o.body ? l.push(' ', y$1(n('body'))) : l.push(a), l;
    }
    case 'TSConditionalType':
      return Mt(r, e, n);
    case 'TSInferType':
      return Ur(r, e, n);
    case 'TSIntersectionType':
      return Mr(r, e, n);
    case 'TSUnionType':
      return Rr(r, e, n);
    case 'TSFunctionType':
    case 'TSCallSignatureDeclaration':
    case 'TSConstructorType':
    case 'TSConstructSignatureDeclaration':
      return Jr(r, e, n);
    case 'TSTupleType':
      return vt(r, e, n);
    case 'TSTypeReference':
      return [n('typeName'), gt(r, e, n, 'typeParameters')];
    case 'TSTypeAnnotation':
      return Wr(r, e, n);
    case 'TSEmptyBodyFunctionExpression':
      return un(r, e, n);
    case 'TSJSDocAllType':
      return '*';
    case 'TSJSDocUnknownType':
      return '?';
    case 'TSJSDocNullableType':
      return us(r, n, '?');
    case 'TSJSDocNonNullableType':
      return us(r, n, '!');
    case 'TSParenthesizedType':
    default:
      throw new Oe(o, 'TypeScript');
  }
}
function Sc(r, e, n, s) {
  if (kr(r)) return ks(r, e);
  for (let o of [Si, hu, Pi, ki, gi]) {
    let a = o(r, e, n, s);
    if (a !== void 0) return a;
  }
}
var Bc = j$1([
  'ClassMethod',
  'ClassPrivateMethod',
  'ClassProperty',
  'ClassAccessorProperty',
  'AccessorProperty',
  'TSAbstractAccessorProperty',
  'PropertyDefinition',
  'TSAbstractPropertyDefinition',
  'ClassPrivateProperty',
  'MethodDefinition',
  'TSAbstractMethodDefinition',
  'TSDeclareMethod',
]);
function bc(r, e, n, s) {
  var o;
  r.isRoot && ((o = e.__onHtmlBindingRoot) == null || o.call(e, r.node, e));
  let a = Sc(r, e, n, s);
  if (!a) return '';
  let { node: l } = r;
  if (Bc(l)) return a;
  let f = b(l.decorators),
    m = Wu(r, e, n),
    v = l.type === 'ClassExpression';
  if (f && !v) return Gt(a, (V) => y$1([m, V]));
  let I = we(r, e),
    L = di(r, e);
  return !m && !I && !L
    ? a
    : Gt(a, (V) => [L ? ';' : '', I ? '(' : '', I && v && f ? [E([A, m, V]), A] : [m, V], I ? ')' : '']);
}
var Ii = bc,
  Li = [
    (r, e) => r.type === 'ObjectExpression' && e === 'properties',
    (r, e) =>
      r.type === 'CallExpression' &&
      r.callee.type === 'Identifier' &&
      r.callee.name === 'Component' &&
      e === 'arguments',
    (r, e) => r.type === 'Decorator' && e === 'expression',
  ];
function wi(r) {
  return r.match(
    (e) => e.type === 'TemplateLiteral',
    (e, n) => G(e) && n === 'elements',
    (e, n) => fe(e) && e.key.type === 'Identifier' && e.key.name === 'styles' && n === 'value',
    ...Li,
  );
}
function Oi(r) {
  return r.match(
    (e) => e.type === 'TemplateLiteral',
    (e, n) => fe(e) && e.key.type === 'Identifier' && e.key.name === 'template' && n === 'value',
    ...Li,
  );
}
function En(r, e) {
  return d(r, x$1.Block | x$1.Leading, ({ value: n }) => n === ` ${e} `);
}
async function Pc(r, e, n) {
  let { node: s } = n,
    o = s.quasis.map((I) => I.value.raw),
    a = 0,
    l = o.reduce((I, L, V) => (V === 0 ? L : I + '@prettier-placeholder-' + a++ + '-id' + L), ''),
    f = await r(l, { parser: 'scss' }),
    m = Rt(n, e),
    v = kc(f, m);
  if (!v) throw new Error("Couldn't insert all the expressions");
  return ['`', E([C$1, v]), F$1, '`'];
}
function kc(r, e) {
  if (!b(e)) return r;
  let n = 0,
    s = ut(Bt(r), (o) =>
      typeof o != 'string' || !o.includes('@prettier-placeholder')
        ? o
        : o.split(/@prettier-placeholder-(\d+)-id/).map((a, l) => (l % 2 === 0 ? Te(a) : (n++, e[a]))),
    );
  return e.length === n ? s : null;
}
function Ic({ node: r, parent: e, grandparent: n }) {
  return (
    (n &&
      r.quasis &&
      e.type === 'JSXExpressionContainer' &&
      n.type === 'JSXElement' &&
      n.openingElement.name.name === 'style' &&
      n.openingElement.attributes.some((s) => s.name.name === 'jsx')) ||
    ((e == null ? void 0 : e.type) === 'TaggedTemplateExpression' &&
      e.tag.type === 'Identifier' &&
      e.tag.name === 'css') ||
    ((e == null ? void 0 : e.type) === 'TaggedTemplateExpression' &&
      e.tag.type === 'MemberExpression' &&
      e.tag.object.name === 'css' &&
      (e.tag.property.name === 'global' || e.tag.property.name === 'resolve'))
  );
}
function Fn(r) {
  return r.type === 'Identifier' && r.name === 'styled';
}
function vi(r) {
  return /^[A-Z]/.test(r.object.name) && r.property.name === 'extend';
}
function Lc({ parent: r }) {
  if (!r || r.type !== 'TaggedTemplateExpression') return !1;
  let e = r.tag.type === 'ParenthesizedExpression' ? r.tag.expression : r.tag;
  switch (e.type) {
    case 'MemberExpression':
      return Fn(e.object) || vi(e);
    case 'CallExpression':
      return (
        Fn(e.callee) ||
        (e.callee.type === 'MemberExpression' &&
          ((e.callee.object.type === 'MemberExpression' && (Fn(e.callee.object.object) || vi(e.callee.object))) ||
            (e.callee.object.type === 'CallExpression' && Fn(e.callee.object.callee))))
      );
    case 'Identifier':
      return e.name === 'css';
    default:
      return !1;
  }
}
function wc({ parent: r, grandparent: e }) {
  return (
    (e == null ? void 0 : e.type) === 'JSXAttribute' &&
    r.type === 'JSXExpressionContainer' &&
    e.name.type === 'JSXIdentifier' &&
    e.name.name === 'css'
  );
}
function Oc(r) {
  if (Ic(r) || Lc(r) || wc(r) || wi(r)) return Pc;
}
var _i = Oc;
async function vc(r, e, n) {
  let { node: s } = n,
    o = s.quasis.length,
    a = Rt(n, e),
    l = [];
  for (let f = 0; f < o; f++) {
    let m = s.quasis[f],
      v = f === 0,
      I = f === o - 1,
      L = m.value.cooked,
      V = L.split(`
`),
      se = V.length,
      Ee = a[f],
      ht = se > 2 && V[0].trim() === '' && V[1].trim() === '',
      ar = se > 2 && V[se - 1].trim() === '' && V[se - 2].trim() === '',
      $i = V.every((Wi) => /^\s*(?:#[^\n\r]*)?$/.test(Wi));
    if (!I && /#[^\n\r]*$/.test(V[se - 1])) return null;
    let tl = null;
    $i ? (tl = _c(V)) : (tl = await r(L, { parser: 'graphql' })),
      tl
        ? ((tl = Zr(tl, !1)), !v && ht && l.push(''), l.push(tl), !I && ar && l.push(''))
        : !v && !I && ht && l.push(''),
      Ee && l.push(Ee);
  }
  return ['`', E([C$1, B$1(C$1, l)]), C$1, '`'];
}
function _c(r) {
  let e = [],
    n = !1,
    s = r.map((o) => o.trim());
  for (let [o, a] of s.entries()) a !== '' && (s[o - 1] === '' && n ? e.push([C$1, a]) : e.push(a), (n = !0));
  return e.length === 0 ? null : B$1(C$1, e);
}
function jc({ node: r, parent: e }) {
  return (
    En(r, 'GraphQL') ||
    (e &&
      ((e.type === 'TaggedTemplateExpression' &&
        ((e.tag.type === 'MemberExpression' &&
          e.tag.object.name === 'graphql' &&
          e.tag.property.name === 'experimental') ||
          (e.tag.type === 'Identifier' && (e.tag.name === 'gql' || e.tag.name === 'graphql')))) ||
        (e.type === 'CallExpression' && e.callee.type === 'Identifier' && e.callee.name === 'graphql')))
  );
}
function Mc(r) {
  if (jc(r)) return vc;
}
var ji = Mc,
  xs = 0;
async function Mi(r, e, n, s, o) {
  let { node: a } = s,
    l = xs;
  xs = (xs + 1) >>> 0;
  let f = ($i) => `PRETTIER_HTML_PLACEHOLDER_${$i}_${l}_IN_JS`,
    m = a.quasis.map(($i, tl, Wi) => (tl === Wi.length - 1 ? $i.value.cooked : $i.value.cooked + f(tl))).join(''),
    v = Rt(s, n),
    I = new RegExp(f('(\\d+)'), 'g'),
    L = 0,
    V = await e(m, {
      parser: r,
      __onHtmlRoot($i) {
        L = $i.children.length;
      },
    }),
    se = ut(V, ($i) => {
      if (typeof $i != 'string') return $i;
      let tl = [],
        Wi = $i.split(I);
      for (let hl = 0; hl < Wi.length; hl++) {
        let fl = Wi[hl];
        if (hl % 2 === 0) {
          fl && ((fl = ms(fl)), o.__embeddedInHtml && (fl = H(!1, fl, /<\/(?=script\b)/gi, '<\\/')), tl.push(fl));
          continue;
        }
        let dl = Number(fl);
        tl.push(v[dl]);
      }
      return tl;
    }),
    Ee = /^\s/.test(m) ? ' ' : '',
    ht = /\s$/.test(m) ? ' ' : '',
    ar = o.htmlWhitespaceSensitivity === 'ignore' ? C$1 : Ee && ht ? A : null;
  return ar
    ? y$1(['`', E([ar, y$1(se)]), ar, '`'])
    : et({ hug: !1 }, y$1(['`', Ee, L > 1 ? E(y$1(se)) : y$1(se), ht, '`']));
}
function Rc(r) {
  return (
    En(r.node, 'HTML') ||
    r.match(
      (e) => e.type === 'TemplateLiteral',
      (e, n) =>
        e.type === 'TaggedTemplateExpression' && e.tag.type === 'Identifier' && e.tag.name === 'html' && n === 'quasi',
    )
  );
}
var Jc = Mi.bind(void 0, 'html'),
  Nc = Mi.bind(void 0, 'angular');
function Uc(r) {
  if (Rc(r)) return Jc;
  if (Oi(r)) return Nc;
}
var Ri = Uc;
async function Gc(r, e, n) {
  let { node: s } = n,
    o = H(!1, s.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (m, v) => '\\'.repeat(v.length / 2) + '`'),
    a = qc(o),
    l = a !== '';
  l && (o = H(!1, o, new RegExp(`^${a}`, 'gm'), ''));
  let f = Zr(await r(o, { parser: 'markdown', __inJsTemplate: !0 }), !0);
  return ['`', l ? E([F$1, f]) : [lr, ws(f)], F$1, '`'];
}
function qc(r) {
  let e = r.match(/^([^\S\n]*)\S/m);
  return e === null ? '' : e[1];
}
function Wc(r) {
  if (Yc(r)) return Gc;
}
function Yc({ node: r, parent: e }) {
  return (
    (e == null ? void 0 : e.type) === 'TaggedTemplateExpression' &&
    r.quasis.length === 1 &&
    e.tag.type === 'Identifier' &&
    (e.tag.name === 'md' || e.tag.name === 'markdown')
  );
}
var Ji = Wc;
function Xc(r) {
  let { node: e } = r;
  if (e.type !== 'TemplateLiteral' || $c(e)) return;
  let n;
  for (let s of [_i, ji, Ri, Ji])
    if (((n = s(r)), !!n))
      return e.quasis.length === 1 && e.quasis[0].value.raw.trim() === ''
        ? '``'
        : async (...o) => {
            let a = await n(...o);
            return a && et({ embed: !0, ...a.label }, a);
          };
}
function $c({ quasis: r }) {
  return r.some(({ value: { cooked: e } }) => e === null);
}
var Ni = Xc,
  Vc = new Set([
    'range',
    'raw',
    'comments',
    'leadingComments',
    'trailingComments',
    'innerComments',
    'extra',
    'start',
    'end',
    'loc',
    'flags',
    'errors',
    'tokens',
  ]),
  Jt = (r) => {
    for (let e of r.quasis) delete e.value;
  };
function Ui(r, e, n) {
  var s, o;
  if (
    (r.type === 'Program' && delete e.sourceType,
    (r.type === 'BigIntLiteral' || r.type === 'BigIntLiteralTypeAnnotation') &&
      e.value &&
      (e.value = e.value.toLowerCase()),
    (r.type === 'BigIntLiteral' || r.type === 'Literal') && e.bigint && (e.bigint = e.bigint.toLowerCase()),
    r.type === 'DecimalLiteral' && (e.value = Number(e.value)),
    r.type === 'Literal' && e.decimal && (e.decimal = Number(e.decimal)),
    r.type === 'EmptyStatement' ||
      r.type === 'JSXText' ||
      (r.type === 'JSXExpressionContainer' &&
        (r.expression.type === 'Literal' || r.expression.type === 'StringLiteral') &&
        r.expression.value === ' '))
  )
    return null;
  if (
    ((r.type === 'Property' ||
      r.type === 'ObjectProperty' ||
      r.type === 'MethodDefinition' ||
      r.type === 'ClassProperty' ||
      r.type === 'ClassMethod' ||
      r.type === 'PropertyDefinition' ||
      r.type === 'TSDeclareMethod' ||
      r.type === 'TSPropertySignature' ||
      r.type === 'ObjectTypeProperty') &&
      typeof r.key == 'object' &&
      r.key &&
      (r.key.type === 'Literal' ||
        r.key.type === 'NumericLiteral' ||
        r.key.type === 'StringLiteral' ||
        r.key.type === 'Identifier') &&
      delete e.key,
    r.type === 'JSXElement' &&
      r.openingElement.name.name === 'style' &&
      r.openingElement.attributes.some((l) => l.type === 'JSXAttribute' && l.name.name === 'jsx'))
  )
    for (let { type: l, expression: f } of e.children)
      l === 'JSXExpressionContainer' && f.type === 'TemplateLiteral' && Jt(f);
  r.type === 'JSXAttribute' &&
    r.name.name === 'css' &&
    r.value.type === 'JSXExpressionContainer' &&
    r.value.expression.type === 'TemplateLiteral' &&
    Jt(e.value.expression),
    r.type === 'JSXAttribute' &&
      ((s = r.value) == null ? void 0 : s.type) === 'Literal' &&
      /["']|&quot;|&apos;/.test(r.value.value) &&
      (e.value.value = H(!1, e.value.value, /["']|&quot;|&apos;/g, '"'));
  let a = r.expression || r.callee;
  if (
    r.type === 'Decorator' &&
    a.type === 'CallExpression' &&
    a.callee.name === 'Component' &&
    a.arguments.length === 1
  ) {
    let l = r.expression.arguments[0].properties;
    for (let [f, m] of e.expression.arguments[0].properties.entries())
      switch (l[f].key.name) {
        case 'styles':
          G(m.value) && Jt(m.value.elements[0]);
          break;
        case 'template':
          m.value.type === 'TemplateLiteral' && Jt(m.value);
          break;
      }
  }
  if (
    (r.type === 'TaggedTemplateExpression' &&
      (r.tag.type === 'MemberExpression' ||
        (r.tag.type === 'Identifier' &&
          (r.tag.name === 'gql' ||
            r.tag.name === 'graphql' ||
            r.tag.name === 'css' ||
            r.tag.name === 'md' ||
            r.tag.name === 'markdown' ||
            r.tag.name === 'html')) ||
        r.tag.type === 'CallExpression') &&
      Jt(e.quasi),
    r.type === 'TemplateLiteral' &&
      (((o = r.leadingComments) != null &&
        o.some((l) => ae(l) && ['GraphQL', 'HTML'].some((f) => l.value === ` ${f} `))) ||
        (n.type === 'CallExpression' && n.callee.name === 'graphql') ||
        !r.leadingComments) &&
      Jt(e),
    (r.type === 'TSIntersectionType' || r.type === 'TSUnionType') && r.types.length === 1)
  )
    return e.types[0];
  r.type === 'ChainExpression' &&
    r.expression.type === 'TSNonNullExpression' &&
    ([e.type, e.expression.type] = [e.expression.type, e.type]);
}
Ui.ignoredProperties = Vc;
var Gi = Ui,
  Ft = ma(Hi(), 1);
function sl(r) {
  if (!r.startsWith('#!')) return '';
  let e = r.indexOf(`
`);
  return e === -1 ? r : r.slice(0, e);
}
var Ki = sl;
function ul(r) {
  let e = Ki(r);
  e && (r = r.slice(e.length + 1));
  let n = (0, Ft.extract)(r),
    { pragmas: s, comments: o } = (0, Ft.parseWithComments)(n);
  return { shebang: e, text: r, pragmas: s, comments: o };
}
function zi(r) {
  let { shebang: e, text: n, pragmas: s, comments: o } = ul(r),
    a = (0, Ft.strip)(n),
    l = (0, Ft.print)({ pragmas: { format: '', ...s }, comments: o.trimStart() });
  return (
    (e
      ? `${e}
`
      : '') +
    l +
    (a.startsWith(`
`)
      ? `
`
      : `

`) +
    a
  );
}
var il = { avoidAstMutation: !0 },
  Qi = [
    {
      linguistLanguageId: 183,
      name: 'JavaScript',
      type: 'programming',
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'text/javascript',
      color: '#f1e05a',
      aliases: ['js', 'node'],
      extensions: [
        '.js',
        '._js',
        '.bones',
        '.cjs',
        '.es',
        '.es6',
        '.frag',
        '.gs',
        '.jake',
        '.javascript',
        '.jsb',
        '.jscad',
        '.jsfl',
        '.jslib',
        '.jsm',
        '.jspre',
        '.jss',
        '.mjs',
        '.njs',
        '.pac',
        '.sjs',
        '.ssjs',
        '.xsjs',
        '.xsjslib',
        '.wxs',
      ],
      filenames: ['Jakefile'],
      interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell', 'zx'],
      parsers: ['babel', 'acorn', 'espree', 'meriyah', 'babel-flow', 'babel-ts', 'flow', 'typescript'],
      vscodeLanguageIds: ['javascript', 'mongo'],
    },
    {
      linguistLanguageId: 183,
      name: 'Flow',
      type: 'programming',
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'text/javascript',
      color: '#f1e05a',
      aliases: [],
      extensions: ['.js.flow'],
      filenames: [],
      interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell'],
      parsers: ['flow', 'babel-flow'],
      vscodeLanguageIds: ['javascript'],
    },
    {
      linguistLanguageId: 183,
      name: 'JSX',
      type: 'programming',
      tmScope: 'source.js.jsx',
      aceMode: 'javascript',
      codemirrorMode: 'jsx',
      codemirrorMimeType: 'text/jsx',
      color: void 0,
      aliases: void 0,
      extensions: ['.jsx'],
      filenames: void 0,
      interpreters: void 0,
      parsers: ['babel', 'babel-flow', 'babel-ts', 'flow', 'typescript', 'espree', 'meriyah'],
      vscodeLanguageIds: ['javascriptreact'],
      group: 'JavaScript',
    },
    {
      linguistLanguageId: 378,
      name: 'TypeScript',
      type: 'programming',
      color: '#3178c6',
      aliases: ['ts'],
      interpreters: ['deno', 'ts-node'],
      extensions: ['.ts', '.cts', '.mts'],
      tmScope: 'source.ts',
      aceMode: 'typescript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/typescript',
      parsers: ['typescript', 'babel-ts'],
      vscodeLanguageIds: ['typescript'],
    },
    {
      linguistLanguageId: 94901924,
      name: 'TSX',
      type: 'programming',
      color: '#3178c6',
      group: 'TypeScript',
      extensions: ['.tsx'],
      tmScope: 'source.tsx',
      aceMode: 'javascript',
      codemirrorMode: 'jsx',
      codemirrorMimeType: 'text/jsx',
      parsers: ['typescript', 'babel-ts'],
      vscodeLanguageIds: ['typescriptreact'],
    },
  ],
  hs = {};
or(hs, { getVisitorKeys: () => ea, massageAstNode: () => ra, print: () => pl });
var al = {
    JsonRoot: ['node'],
    ArrayExpression: ['elements'],
    ObjectExpression: ['properties'],
    ObjectProperty: ['key', 'value'],
    UnaryExpression: ['argument'],
    NullLiteral: [],
    BooleanLiteral: [],
    StringLiteral: [],
    NumericLiteral: [],
    Identifier: [],
    TemplateLiteral: ['quasis'],
    TemplateElement: [],
  },
  Zi = al,
  ol = Dr(Zi),
  ea = ol;
function pl(r, e, n) {
  let { node: s } = r;
  switch (s.type) {
    case 'JsonRoot':
      return [n('node'), C$1];
    case 'ArrayExpression': {
      if (s.elements.length === 0) return '[]';
      let o = r.map(() => (r.node === null ? 'null' : n()), 'elements');
      return ['[', E([C$1, B$1([',', C$1], o)]), C$1, ']'];
    }
    case 'ObjectExpression':
      return s.properties.length === 0 ? '{}' : ['{', E([C$1, B$1([',', C$1], r.map(n, 'properties'))]), C$1, '}'];
    case 'ObjectProperty':
      return [n('key'), ': ', n('value')];
    case 'UnaryExpression':
      return [s.operator === '+' ? '' : s.operator, n('argument')];
    case 'NullLiteral':
      return 'null';
    case 'BooleanLiteral':
      return s.value ? 'true' : 'false';
    case 'StringLiteral':
      return JSON.stringify(s.value);
    case 'NumericLiteral':
      return ta(r) ? JSON.stringify(String(s.value)) : JSON.stringify(s.value);
    case 'Identifier':
      return ta(r) ? JSON.stringify(s.name) : s.name;
    case 'TemplateLiteral':
      return n(['quasis', 0]);
    case 'TemplateElement':
      return JSON.stringify(s.value.cooked);
    default:
      throw new Oe(s, 'JSON');
  }
}
function ta(r) {
  return r.key === 'key' && r.parent.type === 'ObjectProperty';
}
var cl = new Set([
  'start',
  'end',
  'extra',
  'loc',
  'comments',
  'leadingComments',
  'trailingComments',
  'innerComments',
  'errors',
  'range',
  'tokens',
]);
function ra(r, e) {
  let { type: n } = r;
  if (n === 'ObjectProperty') {
    let { key: s } = r;
    s.type === 'Identifier'
      ? (e.key = { type: 'StringLiteral', value: s.name })
      : s.type === 'NumericLiteral' && (e.key = { type: 'StringLiteral', value: String(s.value) });
    return;
  }
  if (n === 'UnaryExpression' && r.operator === '+') return e.argument;
  if (n === 'ArrayExpression') {
    for (let [s, o] of r.elements.entries()) o === null && e.elements.splice(s, 0, { type: 'NullLiteral' });
    return;
  }
  if (n === 'TemplateLiteral') return { type: 'StringLiteral', value: r.quasis[0].value.cooked };
}
ra.ignoredProperties = cl;
var na = [
    {
      linguistLanguageId: 174,
      name: 'JSON.stringify',
      type: 'data',
      color: '#292929',
      tmScope: 'source.json',
      aceMode: 'json',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/json',
      aliases: ['geojson', 'jsonl', 'topojson'],
      extensions: ['.importmap'],
      filenames: ['package.json', 'package-lock.json', 'composer.json'],
      parsers: ['json-stringify'],
      vscodeLanguageIds: ['json'],
    },
    {
      linguistLanguageId: 174,
      name: 'JSON',
      type: 'data',
      color: '#292929',
      tmScope: 'source.json',
      aceMode: 'json',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/json',
      aliases: ['geojson', 'jsonl', 'topojson'],
      extensions: [
        '.json',
        '.4DForm',
        '.4DProject',
        '.avsc',
        '.geojson',
        '.gltf',
        '.har',
        '.ice',
        '.JSON-tmLanguage',
        '.mcmeta',
        '.tfstate',
        '.tfstate.backup',
        '.topojson',
        '.webapp',
        '.webmanifest',
        '.yy',
        '.yyp',
      ],
      filenames: [
        '.all-contributorsrc',
        '.arcconfig',
        '.auto-changelog',
        '.c8rc',
        '.htmlhintrc',
        '.imgbotconfig',
        '.nycrc',
        '.tern-config',
        '.tern-project',
        '.watchmanconfig',
        'Pipfile.lock',
        'composer.lock',
        'flake.lock',
        'mcmod.info',
      ],
      parsers: ['json'],
      vscodeLanguageIds: ['json'],
    },
    {
      linguistLanguageId: 423,
      name: 'JSON with Comments',
      type: 'data',
      color: '#292929',
      group: 'JSON',
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'text/javascript',
      aliases: ['jsonc'],
      extensions: [
        '.jsonc',
        '.code-snippets',
        '.sublime-build',
        '.sublime-commands',
        '.sublime-completions',
        '.sublime-keymap',
        '.sublime-macro',
        '.sublime-menu',
        '.sublime-mousemap',
        '.sublime-project',
        '.sublime-settings',
        '.sublime-theme',
        '.sublime-workspace',
        '.sublime_metrics',
        '.sublime_session',
      ],
      filenames: [
        '.babelrc',
        '.devcontainer.json',
        '.eslintrc.json',
        '.jscsrc',
        '.jshintrc',
        '.jslintrc',
        '.swcrc',
        'api-extractor.json',
        'devcontainer.json',
        'jsconfig.json',
        'language-configuration.json',
        'tsconfig.json',
        'tslint.json',
        '.eslintrc',
      ],
      parsers: ['json'],
      vscodeLanguageIds: ['jsonc'],
    },
    {
      linguistLanguageId: 175,
      name: 'JSON5',
      type: 'data',
      color: '#267CB9',
      extensions: ['.json5'],
      tmScope: 'source.js',
      aceMode: 'javascript',
      codemirrorMode: 'javascript',
      codemirrorMimeType: 'application/json',
      parsers: ['json5'],
      vscodeLanguageIds: ['json5'],
    },
  ],
  ir = {
    bracketSpacing: {
      category: 'Common',
      type: 'boolean',
      default: !0,
      description: 'Print spaces between brackets.',
      oppositeDescription: 'Do not print spaces between brackets.',
    },
    singleQuote: {
      category: 'Common',
      type: 'boolean',
      default: !1,
      description: 'Use single quotes instead of double quotes.',
    },
    proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
        { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
        { value: 'never', description: 'Do not wrap prose.' },
        { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
    },
    bracketSameLine: {
      category: 'Common',
      type: 'boolean',
      default: !1,
      description: 'Put > of opening tags on the last line instead of on a new line.',
    },
    singleAttributePerLine: {
      category: 'Common',
      type: 'boolean',
      default: !1,
      description: 'Enforce single attribute per line in HTML, Vue and JSX.',
    },
  },
  Nt = 'JavaScript',
  ll = {
    arrowParens: {
      category: Nt,
      type: 'choice',
      default: 'always',
      description: 'Include parentheses around a sole arrow function parameter.',
      choices: [
        { value: 'always', description: 'Always include parens. Example: `(x) => x`' },
        { value: 'avoid', description: 'Omit parens when possible. Example: `x => x`' },
      ],
    },
    bracketSameLine: ir.bracketSameLine,
    bracketSpacing: ir.bracketSpacing,
    jsxBracketSameLine: {
      category: Nt,
      type: 'boolean',
      description: 'Put > on the last line instead of at a new line.',
      deprecated: '2.4.0',
    },
    semi: {
      category: Nt,
      type: 'boolean',
      default: !0,
      description: 'Print semicolons.',
      oppositeDescription: 'Do not print semicolons, except at the beginning of lines which may need them.',
    },
    singleQuote: ir.singleQuote,
    jsxSingleQuote: { category: Nt, type: 'boolean', default: !1, description: 'Use single quotes in JSX.' },
    quoteProps: {
      category: Nt,
      type: 'choice',
      default: 'as-needed',
      description: 'Change when properties in objects are quoted.',
      choices: [
        { value: 'as-needed', description: 'Only add quotes around object properties where required.' },
        {
          value: 'consistent',
          description: 'If at least one property in an object requires quotes, quote all properties.',
        },
        { value: 'preserve', description: 'Respect the input use of quotes in object properties.' },
      ],
    },
    trailingComma: {
      category: Nt,
      type: 'choice',
      default: 'all',
      description: 'Print trailing commas wherever possible when multi-line.',
      choices: [
        { value: 'all', description: 'Trailing commas wherever possible (including function arguments).' },
        { value: 'es5', description: 'Trailing commas where valid in ES5 (objects, arrays, etc.)' },
        { value: 'none', description: 'No trailing commas.' },
      ],
    },
    singleAttributePerLine: ir.singleAttributePerLine,
  },
  sa = ll,
  ml = { 'estree': gs, 'estree-json': hs },
  yl = [...Qi, ...na],
  FA = Ss;
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
  constructor(e, n) {
    (this.from = e), (this.to = n);
  }
}
class NodeProp {
  constructor(e = {}) {
    (this.id = nextPropID++),
      (this.perNode = !!e.perNode),
      (this.deserialize =
        e.deserialize ||
        (() => {
          throw new Error("This node type doesn't define a deserialize function");
        }));
  }
  add(e) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types");
    return (
      typeof e != 'function' && (e = NodeType.match(e)),
      (n) => {
        let s = e(n);
        return s === void 0 ? null : [this, s];
      }
    );
  }
}
NodeProp.closedBy = new NodeProp({ deserialize: (r) => r.split(' ') });
NodeProp.openedBy = new NodeProp({ deserialize: (r) => r.split(' ') });
NodeProp.group = new NodeProp({ deserialize: (r) => r.split(' ') });
NodeProp.contextHash = new NodeProp({ perNode: !0 });
NodeProp.lookAhead = new NodeProp({ perNode: !0 });
NodeProp.mounted = new NodeProp({ perNode: !0 });
class MountedTree {
  constructor(e, n, s) {
    (this.tree = e), (this.overlay = n), (this.parser = s);
  }
  static get(e) {
    return e && e.props && e.props[NodeProp.mounted.id];
  }
}
const noProps = Object.create(null);
class NodeType {
  constructor(e, n, s, o = 0) {
    (this.name = e), (this.props = n), (this.id = s), (this.flags = o);
  }
  static define(e) {
    let n = e.props && e.props.length ? Object.create(null) : noProps,
      s = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0),
      o = new NodeType(e.name || '', n, e.id, s);
    if (e.props) {
      for (let a of e.props)
        if ((Array.isArray(a) || (a = a(o)), a)) {
          if (a[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
          n[a[0].id] = a[1];
        }
    }
    return o;
  }
  prop(e) {
    return this.props[e.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(e) {
    if (typeof e == 'string') {
      if (this.name == e) return !0;
      let n = this.prop(NodeProp.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  static match(e) {
    let n = Object.create(null);
    for (let s in e) for (let o of s.split(' ')) n[o] = e[s];
    return (s) => {
      for (let o = s.prop(NodeProp.group), a = -1; a < (o ? o.length : 0); a++) {
        let l = n[a < 0 ? s.name : o[a]];
        if (l) return l;
      }
    };
  }
}
NodeType.none = new NodeType('', Object.create(null), 0, 8);
class NodeSet {
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError('Node type ids should correspond to array positions when creating a node set');
  }
  extend(...e) {
    let n = [];
    for (let s of this.types) {
      let o = null;
      for (let a of e) {
        let l = a(s);
        l && (o || (o = Object.assign({}, s.props)), (o[l[0].id] = l[1]));
      }
      n.push(o ? new NodeType(s.name, o, s.id, s.flags) : s);
    }
    return new NodeSet(n);
  }
}
const CachedNode = new WeakMap(),
  CachedInnerNode = new WeakMap();
var IterMode;
(function (r) {
  (r[(r.ExcludeBuffers = 1)] = 'ExcludeBuffers'),
    (r[(r.IncludeAnonymous = 2)] = 'IncludeAnonymous'),
    (r[(r.IgnoreMounts = 4)] = 'IgnoreMounts'),
    (r[(r.IgnoreOverlays = 8)] = 'IgnoreOverlays');
})(IterMode || (IterMode = {}));
class Tree {
  constructor(e, n, s, o, a) {
    if (
      ((this.type = e),
      (this.children = n),
      (this.positions = s),
      (this.length = o),
      (this.props = null),
      a && a.length)
    ) {
      this.props = Object.create(null);
      for (let [l, f] of a) this.props[typeof l == 'number' ? l : l.id] = f;
    }
  }
  toString() {
    let e = MountedTree.get(this);
    if (e && !e.overlay) return e.tree.toString();
    let n = '';
    for (let s of this.children) {
      let o = s.toString();
      o && (n && (n += ','), (n += o));
    }
    return this.type.name
      ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
          (n.length ? '(' + n + ')' : '')
      : n;
  }
  cursor(e = 0) {
    return new TreeCursor(this.topNode, e);
  }
  cursorAt(e, n = 0, s = 0) {
    let o = CachedNode.get(this) || this.topNode,
      a = new TreeCursor(o);
    return a.moveTo(e, n), CachedNode.set(this, a._tree), a;
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(e, n = 0) {
    let s = resolveNode(CachedNode.get(this) || this.topNode, e, n, !1);
    return CachedNode.set(this, s), s;
  }
  resolveInner(e, n = 0) {
    let s = resolveNode(CachedInnerNode.get(this) || this.topNode, e, n, !0);
    return CachedInnerNode.set(this, s), s;
  }
  resolveStack(e, n = 0) {
    return stackIterator(this, e, n);
  }
  iterate(e) {
    let { enter: n, leave: s, from: o = 0, to: a = this.length } = e,
      l = e.mode || 0,
      f = (l & IterMode.IncludeAnonymous) > 0;
    for (let m = this.cursor(l | IterMode.IncludeAnonymous); ; ) {
      let v = !1;
      if (m.from <= a && m.to >= o && ((!f && m.type.isAnonymous) || n(m) !== !1)) {
        if (m.firstChild()) continue;
        v = !0;
      }
      for (; v && s && (f || !m.type.isAnonymous) && s(m), !m.nextSibling(); ) {
        if (!m.parent()) return;
        v = !0;
      }
    }
  }
  prop(e) {
    return e.perNode ? (this.props ? this.props[e.id] : void 0) : this.type.prop(e);
  }
  get propValues() {
    let e = [];
    if (this.props) for (let n in this.props) e.push([+n, this.props[n]]);
    return e;
  }
  balance(e = {}) {
    return this.children.length <= 8
      ? this
      : balanceRange(
          NodeType.none,
          this.children,
          this.positions,
          0,
          this.children.length,
          0,
          this.length,
          (n, s, o) => new Tree(this.type, n, s, o, this.propValues),
          e.makeTree || ((n, s, o) => new Tree(NodeType.none, n, s, o)),
        );
  }
  static build(e) {
    return buildTree(e);
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
  constructor(e, n) {
    (this.buffer = e), (this.index = n);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
}
class TreeBuffer {
  constructor(e, n, s) {
    (this.buffer = e), (this.length = n), (this.set = s);
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; ) e.push(this.childString(n)), (n = this.buffer[n + 3]);
    return e.join(',');
  }
  childString(e) {
    let n = this.buffer[e],
      s = this.buffer[e + 3],
      o = this.set.types[n],
      a = o.name;
    if ((/\W/.test(a) && !o.isError && (a = JSON.stringify(a)), (e += 4), s == e)) return a;
    let l = [];
    for (; e < s; ) l.push(this.childString(e)), (e = this.buffer[e + 3]);
    return a + '(' + l.join(',') + ')';
  }
  findChild(e, n, s, o, a) {
    let { buffer: l } = this,
      f = -1;
    for (let m = e; m != n && !(checkSide(a, o, l[m + 1], l[m + 2]) && ((f = m), s > 0)); m = l[m + 3]);
    return f;
  }
  slice(e, n, s) {
    let o = this.buffer,
      a = new Uint16Array(n - e),
      l = 0;
    for (let f = e, m = 0; f < n; ) {
      (a[m++] = o[f++]), (a[m++] = o[f++] - s);
      let v = (a[m++] = o[f++] - s);
      (a[m++] = o[f++] - e), (l = Math.max(l, v));
    }
    return new TreeBuffer(a, l, this.set);
  }
}
function checkSide(r, e, n, s) {
  switch (r) {
    case -2:
      return n < e;
    case -1:
      return s >= e && n < e;
    case 0:
      return n < e && s > e;
    case 1:
      return n <= e && s > e;
    case 2:
      return s > e;
    case 4:
      return !0;
  }
}
function resolveNode(r, e, n, s) {
  for (var o; r.from == r.to || (n < 1 ? r.from >= e : r.from > e) || (n > -1 ? r.to <= e : r.to < e); ) {
    let l = !s && r instanceof TreeNode && r.index < 0 ? null : r.parent;
    if (!l) return r;
    r = l;
  }
  let a = s ? 0 : IterMode.IgnoreOverlays;
  if (s)
    for (let l = r, f = l.parent; f; l = f, f = l.parent)
      l instanceof TreeNode &&
        l.index < 0 &&
        ((o = f.enter(e, n, a)) === null || o === void 0 ? void 0 : o.from) != l.from &&
        (r = f);
  for (;;) {
    let l = r.enter(e, n, a);
    if (!l) return r;
    r = l;
  }
}
class BaseNode {
  cursor(e = 0) {
    return new TreeCursor(this, e);
  }
  getChild(e, n = null, s = null) {
    let o = getChildren(this, e, n, s);
    return o.length ? o[0] : null;
  }
  getChildren(e, n = null, s = null) {
    return getChildren(this, e, n, s);
  }
  resolve(e, n = 0) {
    return resolveNode(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return resolveNode(this, e, n, !0);
  }
  matchContext(e) {
    return matchNodeContext(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e),
      s = this;
    for (; n; ) {
      let o = n.lastChild;
      if (!o || o.to != n.to) break;
      o.type.isError && o.from == o.to ? ((s = n), (n = o.prevSibling)) : (n = o);
    }
    return s;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class TreeNode extends BaseNode {
  constructor(e, n, s, o) {
    super(), (this._tree = e), (this.from = n), (this.index = s), (this._parent = o);
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, s, o, a = 0) {
    for (let l = this; ; ) {
      for (let { children: f, positions: m } = l._tree, v = n > 0 ? f.length : -1; e != v; e += n) {
        let I = f[e],
          L = m[e] + l.from;
        if (checkSide(o, s, L, L + I.length)) {
          if (I instanceof TreeBuffer) {
            if (a & IterMode.ExcludeBuffers) continue;
            let V = I.findChild(0, I.buffer.length, n, s - L, o);
            if (V > -1) return new BufferNode(new BufferContext(l, I, e, L), null, V);
          } else if (a & IterMode.IncludeAnonymous || !I.type.isAnonymous || hasChild(I)) {
            let V;
            if (!(a & IterMode.IgnoreMounts) && (V = MountedTree.get(I)) && !V.overlay)
              return new TreeNode(V.tree, L, e, l);
            let se = new TreeNode(I, L, e, l);
            return a & IterMode.IncludeAnonymous || !se.type.isAnonymous
              ? se
              : se.nextChild(n < 0 ? I.children.length - 1 : 0, n, s, o);
          }
        }
      }
      if (
        a & IterMode.IncludeAnonymous ||
        !l.type.isAnonymous ||
        (l.index >= 0 ? (e = l.index + n) : (e = n < 0 ? -1 : l._parent._tree.children.length), (l = l._parent), !l)
      )
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(e) {
    return this.nextChild(0, 1, e, 2);
  }
  childBefore(e) {
    return this.nextChild(this._tree.children.length - 1, -1, e, -2);
  }
  enter(e, n, s = 0) {
    let o;
    if (!(s & IterMode.IgnoreOverlays) && (o = MountedTree.get(this._tree)) && o.overlay) {
      let a = e - this.from;
      for (let { from: l, to: f } of o.overlay)
        if ((n > 0 ? l <= a : l < a) && (n < 0 ? f >= a : f > a))
          return new TreeNode(o.tree, o.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, s);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; ) e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function getChildren(r, e, n, s) {
  let o = r.cursor(),
    a = [];
  if (!o.firstChild()) return a;
  if (n != null) {
    for (; !o.type.is(n); ) if (!o.nextSibling()) return a;
  }
  for (;;) {
    if (s != null && o.type.is(s)) return a;
    if ((o.type.is(e) && a.push(o.node), !o.nextSibling())) return s == null ? a : [];
  }
}
function matchNodeContext(r, e, n = e.length - 1) {
  for (let s = r.parent; n >= 0; s = s.parent) {
    if (!s) return !1;
    if (!s.type.isAnonymous) {
      if (e[n] && e[n] != s.name) return !1;
      n--;
    }
  }
  return !0;
}
class BufferContext {
  constructor(e, n, s, o) {
    (this.parent = e), (this.buffer = n), (this.index = s), (this.start = o);
  }
}
class BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, s) {
    super(),
      (this.context = e),
      (this._parent = n),
      (this.index = s),
      (this.type = e.buffer.set.types[e.buffer.buffer[s]]);
  }
  child(e, n, s) {
    let { buffer: o } = this.context,
      a = o.findChild(this.index + 4, o.buffer[this.index + 3], e, n - this.context.start, s);
    return a < 0 ? null : new BufferNode(this.context, this, a);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(e) {
    return this.child(1, e, 2);
  }
  childBefore(e) {
    return this.child(-1, e, -2);
  }
  enter(e, n, s = 0) {
    if (s & IterMode.ExcludeBuffers) return null;
    let { buffer: o } = this.context,
      a = o.findChild(this.index + 4, o.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return a < 0 ? null : new BufferNode(this.context, this, a);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
  }
  get nextSibling() {
    let { buffer: e } = this.context,
      n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length)
      ? new BufferNode(this.context, this._parent, n)
      : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context,
      n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n
      ? this.externalSibling(-1)
      : new BufferNode(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [],
      n = [],
      { buffer: s } = this.context,
      o = this.index + 4,
      a = s.buffer[this.index + 3];
    if (a > o) {
      let l = s.buffer[this.index + 1];
      e.push(s.slice(o, a, l)), n.push(0);
    }
    return new Tree(this.type, e, n, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function iterStack(r) {
  if (!r.length) return null;
  if (r.length == 1) return r[0];
  let e = 0,
    n = r[0];
  for (let a = 1; a < r.length; a++) {
    let l = r[a];
    (l.from > n.from || l.to < n.to) && ((n = l), (e = a));
  }
  let s = n instanceof TreeNode && n.index < 0 ? null : n.parent,
    o = r.slice();
  return s ? (o[e] = s) : o.splice(e, 1), new StackIterator(o, n);
}
class StackIterator {
  constructor(e, n) {
    (this.heads = e), (this.node = n);
  }
  get next() {
    return iterStack(this.heads);
  }
}
function stackIterator(r, e, n) {
  let s = r.resolveInner(e, n),
    o = null;
  for (let a = s instanceof TreeNode ? s : s.context.parent; a; a = a.parent)
    if (a.index < 0) {
      let l = a.parent;
      (o || (o = [s])).push(l.resolve(e, n)), (a = l);
    } else {
      let l = MountedTree.get(a.tree);
      if (l && l.overlay && l.overlay[0].from <= e && l.overlay[l.overlay.length - 1].to >= e) {
        let f = new TreeNode(l.tree, l.overlay[0].from + a.from, 0, null);
        (o || (o = [s])).push(resolveNode(f, e, n, !1));
      }
    }
  return o ? iterStack(o) : s;
}
class TreeCursor {
  get name() {
    return this.type.name;
  }
  constructor(e, n = 0) {
    if (
      ((this.mode = n),
      (this.buffer = null),
      (this.stack = []),
      (this.index = 0),
      (this.bufferNode = null),
      e instanceof TreeNode)
    )
      this.yieldNode(e);
    else {
      (this._tree = e.context.parent), (this.buffer = e.context);
      for (let s = e._parent; s; s = s._parent) this.stack.unshift(s.index);
      (this.bufferNode = e), this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? ((this._tree = e), (this.type = e.type), (this.from = e.from), (this.to = e.to), !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: s, buffer: o } = this.buffer;
    return (
      (this.type = n || o.set.types[o.buffer[e]]),
      (this.from = s + o.buffer[e + 1]),
      (this.to = s + o.buffer[e + 2]),
      !0
    );
  }
  yield(e) {
    return e
      ? e instanceof TreeNode
        ? ((this.buffer = null), this.yieldNode(e))
        : ((this.buffer = e.context), this.yieldBuf(e.index, e.type))
      : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(e, n, s) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, s, this.mode));
    let { buffer: o } = this.buffer,
      a = o.findChild(this.index + 4, o.buffer[this.index + 3], e, n - this.buffer.start, s);
    return a < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(a));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(e) {
    return this.enterChild(1, e, 2);
  }
  childBefore(e) {
    return this.enterChild(-1, e, -2);
  }
  enter(e, n, s = this.mode) {
    return this.buffer
      ? s & IterMode.ExcludeBuffers
        ? !1
        : this.enterChild(1, e, n)
      : this.yield(this._tree.enter(e, n, s));
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let e = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return (this.buffer = null), this.yieldNode(e);
  }
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent
        ? this.yield(
            this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode),
          )
        : !1;
    let { buffer: n } = this.buffer,
      s = this.stack.length - 1;
    if (e < 0) {
      let o = s < 0 ? 0 : this.stack[s] + 4;
      if (this.index != o) return this.yieldBuf(n.findChild(o, this.index, -1, 0, 4));
    } else {
      let o = n.buffer[this.index + 3];
      if (o < (s < 0 ? n.buffer.length : n.buffer[this.stack[s] + 3])) return this.yieldBuf(o);
    }
    return s < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n,
      s,
      { buffer: o } = this;
    if (o) {
      if (e > 0) {
        if (this.index < o.buffer.buffer.length) return !1;
      } else for (let a = 0; a < this.index; a++) if (o.buffer.buffer[a + 3] < this.index) return !1;
      ({ index: n, parent: s } = o);
    } else ({ index: n, _parent: s } = this._tree);
    for (; s; { index: n, _parent: s } = s)
      if (n > -1)
        for (let a = n + e, l = e < 0 ? -1 : s._tree.children.length; a != l; a += e) {
          let f = s._tree.children[a];
          if (this.mode & IterMode.IncludeAnonymous || f instanceof TreeBuffer || !f.type.isAnonymous || hasChild(f))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(e, 0, 4)) return !0;
    for (;;) {
      if (this.sibling(e)) return !0;
      if (this.atLastNode(e) || !this.parent()) return !1;
    }
  }
  next(e = !0) {
    return this.move(1, e);
  }
  prev(e = !0) {
    return this.move(-1, e);
  }
  moveTo(e, n = 0) {
    for (
      ;
      (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) &&
      this.parent();

    );
    for (; this.enterChild(1, e, n); );
    return this;
  }
  get node() {
    if (!this.buffer) return this._tree;
    let e = this.bufferNode,
      n = null,
      s = 0;
    if (e && e.context == this.buffer)
      e: for (let o = this.index, a = this.stack.length; a >= 0; ) {
        for (let l = e; l; l = l._parent)
          if (l.index == o) {
            if (o == this.index) return l;
            (n = l), (s = a + 1);
            break e;
          }
        o = this.stack[--a];
      }
    for (let o = s; o < this.stack.length; o++) n = new BufferNode(this.buffer, n, this.stack[o]);
    return (this.bufferNode = new BufferNode(this.buffer, n, this.index));
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(e, n) {
    for (let s = 0; ; ) {
      let o = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          s++;
          continue;
        }
        this.type.isAnonymous || (o = !0);
      }
      for (; o && n && n(this), (o = this.type.isAnonymous), !this.nextSibling(); ) {
        if (!s) return;
        this.parent(), s--, (o = !0);
      }
    }
  }
  matchContext(e) {
    if (!this.buffer) return matchNodeContext(this.node, e);
    let { buffer: n } = this.buffer,
      { types: s } = n.set;
    for (let o = e.length - 1, a = this.stack.length - 1; o >= 0; a--) {
      if (a < 0) return matchNodeContext(this.node, e, o);
      let l = s[n.buffer[this.stack[a]]];
      if (!l.isAnonymous) {
        if (e[o] && e[o] != l.name) return !1;
        o--;
      }
    }
    return !0;
  }
}
function hasChild(r) {
  return r.children.some((e) => e instanceof TreeBuffer || !e.type.isAnonymous || hasChild(e));
}
function buildTree(r) {
  var e;
  let {
      buffer: n,
      nodeSet: s,
      maxBufferLength: o = DefaultBufferLength,
      reused: a = [],
      minRepeatType: l = s.types.length,
    } = r,
    f = Array.isArray(n) ? new FlatBufferCursor(n, n.length) : n,
    m = s.types,
    v = 0,
    I = 0;
  function L(hl, fl, dl, Al, Fl) {
    let { id: vl, start: kl, end: El, size: Jl } = f,
      Kc = I;
    for (; Jl < 0; )
      if ((f.next(), Jl == -1)) {
        let Bl = a[vl];
        dl.push(Bl), Al.push(kl - hl);
        return;
      } else if (Jl == -3) {
        v = vl;
        return;
      } else if (Jl == -4) {
        I = vl;
        return;
      } else throw new RangeError(`Unrecognized record size: ${Jl}`);
    let Il = m[vl],
      Ll,
      Nl,
      Hl = kl - hl;
    if (El - kl <= o && (Nl = ht(f.pos - fl, Fl))) {
      let Bl = new Uint16Array(Nl.size - Nl.skip),
        ql = f.pos - Nl.size,
        Yl = Bl.length;
      for (; f.pos > ql; ) Yl = ar(Nl.start, Bl, Yl);
      (Ll = new TreeBuffer(Bl, El - Nl.start, s)), (Hl = Nl.start - hl);
    } else {
      let Bl = f.pos - Jl;
      f.next();
      let ql = [],
        Yl = [],
        ih = vl >= l ? vl : -1,
        ph = 0,
        gh = El;
      for (; f.pos > Bl; )
        ih >= 0 && f.id == ih && f.size >= 0
          ? (f.end <= gh - o && (se(ql, Yl, kl, ph, f.end, gh, ih, Kc), (ph = ql.length), (gh = f.end)), f.next())
          : L(kl, Bl, ql, Yl, ih);
      if (
        (ih >= 0 && ph > 0 && ph < ql.length && se(ql, Yl, kl, ph, kl, gh, ih, Kc),
        ql.reverse(),
        Yl.reverse(),
        ih > -1 && ph > 0)
      ) {
        let xh = V(Il);
        Ll = balanceRange(Il, ql, Yl, 0, ql.length, 0, El - kl, xh, xh);
      } else Ll = Ee(Il, ql, Yl, El - kl, Kc - El);
    }
    dl.push(Ll), Al.push(Hl);
  }
  function V(hl) {
    return (fl, dl, Al) => {
      let Fl = 0,
        vl = fl.length - 1,
        kl,
        El;
      if (vl >= 0 && (kl = fl[vl]) instanceof Tree) {
        if (!vl && kl.type == hl && kl.length == Al) return kl;
        (El = kl.prop(NodeProp.lookAhead)) && (Fl = dl[vl] + kl.length + El);
      }
      return Ee(hl, fl, dl, Al, Fl);
    };
  }
  function se(hl, fl, dl, Al, Fl, vl, kl, El) {
    let Jl = [],
      Kc = [];
    for (; hl.length > Al; ) Jl.push(hl.pop()), Kc.push(fl.pop() + dl - Fl);
    hl.push(Ee(s.types[kl], Jl, Kc, vl - Fl, El - vl)), fl.push(Fl - dl);
  }
  function Ee(hl, fl, dl, Al, Fl = 0, vl) {
    if (v) {
      let kl = [NodeProp.contextHash, v];
      vl = vl ? [kl].concat(vl) : [kl];
    }
    if (Fl > 25) {
      let kl = [NodeProp.lookAhead, Fl];
      vl = vl ? [kl].concat(vl) : [kl];
    }
    return new Tree(hl, fl, dl, Al, vl);
  }
  function ht(hl, fl) {
    let dl = f.fork(),
      Al = 0,
      Fl = 0,
      vl = 0,
      kl = dl.end - o,
      El = { size: 0, start: 0, skip: 0 };
    e: for (let Jl = dl.pos - hl; dl.pos > Jl; ) {
      let Kc = dl.size;
      if (dl.id == fl && Kc >= 0) {
        (El.size = Al), (El.start = Fl), (El.skip = vl), (vl += 4), (Al += 4), dl.next();
        continue;
      }
      let Il = dl.pos - Kc;
      if (Kc < 0 || Il < Jl || dl.start < kl) break;
      let Ll = dl.id >= l ? 4 : 0,
        Nl = dl.start;
      for (dl.next(); dl.pos > Il; ) {
        if (dl.size < 0)
          if (dl.size == -3) Ll += 4;
          else break e;
        else dl.id >= l && (Ll += 4);
        dl.next();
      }
      (Fl = Nl), (Al += Kc), (vl += Ll);
    }
    return (fl < 0 || Al == hl) && ((El.size = Al), (El.start = Fl), (El.skip = vl)), El.size > 4 ? El : void 0;
  }
  function ar(hl, fl, dl) {
    let { id: Al, start: Fl, end: vl, size: kl } = f;
    if ((f.next(), kl >= 0 && Al < l)) {
      let El = dl;
      if (kl > 4) {
        let Jl = f.pos - (kl - 4);
        for (; f.pos > Jl; ) dl = ar(hl, fl, dl);
      }
      (fl[--dl] = El), (fl[--dl] = vl - hl), (fl[--dl] = Fl - hl), (fl[--dl] = Al);
    } else kl == -3 ? (v = Al) : kl == -4 && (I = Al);
    return dl;
  }
  let $i = [],
    tl = [];
  for (; f.pos > 0; ) L(r.start || 0, r.bufferStart || 0, $i, tl, -1);
  let Wi = (e = r.length) !== null && e !== void 0 ? e : $i.length ? tl[0] + $i[0].length : 0;
  return new Tree(m[r.topID], $i.reverse(), tl.reverse(), Wi);
}
const nodeSizeCache = new WeakMap();
function nodeSize(r, e) {
  if (!r.isAnonymous || e instanceof TreeBuffer || e.type != r) return 1;
  let n = nodeSizeCache.get(e);
  if (n == null) {
    n = 1;
    for (let s of e.children) {
      if (s.type != r || !(s instanceof Tree)) {
        n = 1;
        break;
      }
      n += nodeSize(r, s);
    }
    nodeSizeCache.set(e, n);
  }
  return n;
}
function balanceRange(r, e, n, s, o, a, l, f, m) {
  let v = 0;
  for (let Ee = s; Ee < o; Ee++) v += nodeSize(r, e[Ee]);
  let I = Math.ceil((v * 1.5) / 8),
    L = [],
    V = [];
  function se(Ee, ht, ar, $i, tl) {
    for (let Wi = ar; Wi < $i; ) {
      let hl = Wi,
        fl = ht[Wi],
        dl = nodeSize(r, Ee[Wi]);
      for (Wi++; Wi < $i; Wi++) {
        let Al = nodeSize(r, Ee[Wi]);
        if (dl + Al >= I) break;
        dl += Al;
      }
      if (Wi == hl + 1) {
        if (dl > I) {
          let Al = Ee[hl];
          se(Al.children, Al.positions, 0, Al.children.length, ht[hl] + tl);
          continue;
        }
        L.push(Ee[hl]);
      } else {
        let Al = ht[Wi - 1] + Ee[Wi - 1].length - fl;
        L.push(balanceRange(r, Ee, ht, hl, Wi, fl, Al, null, m));
      }
      V.push(fl + tl - a);
    }
  }
  return se(e, n, s, o, 0), (f || m)(L, V, l);
}
class TreeFragment {
  constructor(e, n, s, o, a = !1, l = !1) {
    (this.from = e), (this.to = n), (this.tree = s), (this.offset = o), (this.open = (a ? 1 : 0) | (l ? 2 : 0));
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(e, n = [], s = !1) {
    let o = [new TreeFragment(0, e.length, e, 0, !1, s)];
    for (let a of n) a.to > e.length && o.push(a);
    return o;
  }
  static applyChanges(e, n, s = 128) {
    if (!n.length) return e;
    let o = [],
      a = 1,
      l = e.length ? e[0] : null;
    for (let f = 0, m = 0, v = 0; ; f++) {
      let I = f < n.length ? n[f] : null,
        L = I ? I.fromA : 1e9;
      if (L - m >= s)
        for (; l && l.from < L; ) {
          let V = l;
          if (m >= V.from || L <= V.to || v) {
            let se = Math.max(V.from, m) - v,
              Ee = Math.min(V.to, L) - v;
            V = se >= Ee ? null : new TreeFragment(se, Ee, V.tree, V.offset + v, f > 0, !!I);
          }
          if ((V && o.push(V), l.to > L)) break;
          l = a < e.length ? e[a++] : null;
        }
      if (!I) break;
      (m = I.toA), (v = I.toA - I.toB);
    }
    return o;
  }
}
class Parser {
  startParse(e, n, s) {
    return (
      typeof e == 'string' && (e = new StringInput(e)),
      (s = s ? (s.length ? s.map((o) => new Range(o.from, o.to)) : [new Range(0, 0)]) : [new Range(0, e.length)]),
      this.createParse(e, n || [], s)
    );
  }
  parse(e, n, s) {
    let o = this.startParse(e, n, s);
    for (;;) {
      let a = o.advance();
      if (a) return a;
    }
  }
}
class StringInput {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
new NodeProp({ perNode: !0 });
let nextTagID = 0;
class Tag {
  constructor(e, n, s) {
    (this.set = e), (this.base = n), (this.modified = s), (this.id = nextTagID++);
  }
  static define(e) {
    if (e != null && e.base) throw new Error('Can not derive from a modified tag');
    let n = new Tag([], null, []);
    if ((n.set.push(n), e)) for (let s of e.set) n.set.push(s);
    return n;
  }
  static defineModifier() {
    let e = new Modifier();
    return (n) =>
      n.modified.indexOf(e) > -1
        ? n
        : Modifier.get(
            n.base || n,
            n.modified.concat(e).sort((s, o) => s.id - o.id),
          );
  }
}
let nextModifierID = 0;
class Modifier {
  constructor() {
    (this.instances = []), (this.id = nextModifierID++);
  }
  static get(e, n) {
    if (!n.length) return e;
    let s = n[0].instances.find((f) => f.base == e && sameArray(n, f.modified));
    if (s) return s;
    let o = [],
      a = new Tag(o, e, n);
    for (let f of n) f.instances.push(a);
    let l = powerSet(n);
    for (let f of e.set) if (!f.modified.length) for (let m of l) o.push(Modifier.get(f, m));
    return a;
  }
}
function sameArray(r, e) {
  return r.length == e.length && r.every((n, s) => n == e[s]);
}
function powerSet(r) {
  let e = [[]];
  for (let n = 0; n < r.length; n++) for (let s = 0, o = e.length; s < o; s++) e.push(e[s].concat(r[n]));
  return e.sort((n, s) => s.length - n.length);
}
function styleTags(r) {
  let e = Object.create(null);
  for (let n in r) {
    let s = r[n];
    Array.isArray(s) || (s = [s]);
    for (let o of n.split(' '))
      if (o) {
        let a = [],
          l = 2,
          f = o;
        for (let L = 0; ; ) {
          if (f == '...' && L > 0 && L + 3 == o.length) {
            l = 1;
            break;
          }
          let V = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(f);
          if (!V) throw new RangeError('Invalid path: ' + o);
          if ((a.push(V[0] == '*' ? '' : V[0][0] == '"' ? JSON.parse(V[0]) : V[0]), (L += V[0].length), L == o.length))
            break;
          let se = o[L++];
          if (L == o.length && se == '!') {
            l = 0;
            break;
          }
          if (se != '/') throw new RangeError('Invalid path: ' + o);
          f = o.slice(L);
        }
        let m = a.length - 1,
          v = a[m];
        if (!v) throw new RangeError('Invalid path: ' + o);
        let I = new Rule(s, l, m > 0 ? a.slice(0, m) : null);
        e[v] = I.sort(e[v]);
      }
  }
  return ruleNodeProp.add(e);
}
const ruleNodeProp = new NodeProp();
class Rule {
  constructor(e, n, s, o) {
    (this.tags = e), (this.mode = n), (this.context = s), (this.next = o);
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? ((this.next = e), this) : ((e.next = this.sort(e.next)), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rule.empty = new Rule([], 2, null);
function tagHighlighter(r, e) {
  let n = Object.create(null);
  for (let a of r)
    if (!Array.isArray(a.tag)) n[a.tag.id] = a.class;
    else for (let l of a.tag) n[l.id] = a.class;
  let { scope: s, all: o = null } = e || {};
  return {
    style: (a) => {
      let l = o;
      for (let f of a)
        for (let m of f.set) {
          let v = n[m.id];
          if (v) {
            l = l ? l + ' ' + v : v;
            break;
          }
        }
      return l;
    },
    scope: s,
  };
}
function highlightTags(r, e) {
  let n = null;
  for (let s of r) {
    let o = s.style(e);
    o && (n = n ? n + ' ' + o : o);
  }
  return n;
}
function highlightTree(r, e, n, s = 0, o = r.length) {
  let a = new HighlightBuilder(s, Array.isArray(e) ? e : [e], n);
  a.highlightRange(r.cursor(), s, o, '', a.highlighters), a.flush(o);
}
class HighlightBuilder {
  constructor(e, n, s) {
    (this.at = e), (this.highlighters = n), (this.span = s), (this.class = '');
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), (this.class = n));
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, s, o, a) {
    let { type: l, from: f, to: m } = e;
    if (f >= s || m <= n) return;
    l.isTop && (a = this.highlighters.filter((se) => !se.scope || se.scope(l)));
    let v = o,
      I = getStyleTags(e) || Rule.empty,
      L = highlightTags(a, I.tags);
    if (
      (L && (v && (v += ' '), (v += L), I.mode == 1 && (o += (o ? ' ' : '') + L)),
      this.startSpan(Math.max(n, f), v),
      I.opaque)
    )
      return;
    let V = e.tree && e.tree.prop(NodeProp.mounted);
    if (V && V.overlay) {
      let se = e.node.enter(V.overlay[0].from + f, 1),
        Ee = this.highlighters.filter((ar) => !ar.scope || ar.scope(V.tree.type)),
        ht = e.firstChild();
      for (let ar = 0, $i = f; ; ar++) {
        let tl = ar < V.overlay.length ? V.overlay[ar] : null,
          Wi = tl ? tl.from + f : m,
          hl = Math.max(n, $i),
          fl = Math.min(s, Wi);
        if (hl < fl && ht)
          for (
            ;
            e.from < fl &&
            (this.highlightRange(e, hl, fl, o, a),
            this.startSpan(Math.min(fl, e.to), v),
            !(e.to >= Wi || !e.nextSibling()));

          );
        if (!tl || Wi > s) break;
        ($i = tl.to + f),
          $i > n &&
            (this.highlightRange(se.cursor(), Math.max(n, tl.from + f), Math.min(s, $i), '', Ee),
            this.startSpan(Math.min(s, $i), v));
      }
      ht && e.parent();
    } else if (e.firstChild()) {
      V && (o = '');
      do
        if (!(e.to <= n)) {
          if (e.from >= s) break;
          this.highlightRange(e, n, s, o, a), this.startSpan(Math.min(s, e.to), v);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function getStyleTags(r) {
  let e = r.type.prop(ruleNodeProp);
  for (; e && e.context && !r.matchContext(e.context); ) e = e.next;
  return e || null;
}
const t = Tag.define,
  comment = t(),
  name = t(),
  typeName = t(name),
  propertyName = t(name),
  literal$1 = t(),
  string = t(literal$1),
  number = t(literal$1),
  content = t(),
  heading = t(content),
  keyword = t(),
  operator = t(),
  punctuation = t(),
  bracket = t(punctuation),
  meta = t(),
  tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal: literal$1,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal$1),
    regexp: t(literal$1),
    escape: t(literal$1),
    color: t(literal$1),
    url: t(literal$1),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier(),
  };
tagHighlighter([
  { tag: tags.link, class: 'tok-link' },
  { tag: tags.heading, class: 'tok-heading' },
  { tag: tags.emphasis, class: 'tok-emphasis' },
  { tag: tags.strong, class: 'tok-strong' },
  { tag: tags.keyword, class: 'tok-keyword' },
  { tag: tags.atom, class: 'tok-atom' },
  { tag: tags.bool, class: 'tok-bool' },
  { tag: tags.url, class: 'tok-url' },
  { tag: tags.labelName, class: 'tok-labelName' },
  { tag: tags.inserted, class: 'tok-inserted' },
  { tag: tags.deleted, class: 'tok-deleted' },
  { tag: tags.literal, class: 'tok-literal' },
  { tag: tags.string, class: 'tok-string' },
  { tag: tags.number, class: 'tok-number' },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: 'tok-string2' },
  { tag: tags.variableName, class: 'tok-variableName' },
  { tag: tags.local(tags.variableName), class: 'tok-variableName tok-local' },
  { tag: tags.definition(tags.variableName), class: 'tok-variableName tok-definition' },
  { tag: tags.special(tags.variableName), class: 'tok-variableName2' },
  { tag: tags.definition(tags.propertyName), class: 'tok-propertyName tok-definition' },
  { tag: tags.typeName, class: 'tok-typeName' },
  { tag: tags.namespace, class: 'tok-namespace' },
  { tag: tags.className, class: 'tok-className' },
  { tag: tags.macroName, class: 'tok-macroName' },
  { tag: tags.propertyName, class: 'tok-propertyName' },
  { tag: tags.operator, class: 'tok-operator' },
  { tag: tags.comment, class: 'tok-comment' },
  { tag: tags.meta, class: 'tok-meta' },
  { tag: tags.invalid, class: 'tok-invalid' },
  { tag: tags.punctuation, class: 'tok-punctuation' },
]);
var _a;
const languageDataProp = new NodeProp();
function defineLanguageFacet(r) {
  return Facet.define({ combine: r ? (e) => e.concat(r) : void 0 });
}
const sublanguageProp = new NodeProp();
class Language {
  constructor(e, n, s = [], o = '') {
    (this.data = e),
      (this.name = o),
      EditorState.prototype.hasOwnProperty('tree') ||
        Object.defineProperty(EditorState.prototype, 'tree', {
          get() {
            return syntaxTree(this);
          },
        }),
      (this.parser = n),
      (this.extension = [
        language.of(this),
        EditorState.languageData.of((a, l, f) => {
          let m = topNodeAt(a, l, f),
            v = m.type.prop(languageDataProp);
          if (!v) return [];
          let I = a.facet(v),
            L = m.type.prop(sublanguageProp);
          if (L) {
            let V = m.resolve(l - m.from, f);
            for (let se of L)
              if (se.test(V, a)) {
                let Ee = a.facet(se.facet);
                return se.type == 'replace' ? Ee : Ee.concat(I);
              }
          }
          return I;
        }),
      ].concat(s));
  }
  isActiveAt(e, n, s = -1) {
    return topNodeAt(e, n, s).type.prop(languageDataProp) == this.data;
  }
  findRegions(e) {
    let n = e.facet(language);
    if ((n == null ? void 0 : n.data) == this.data) return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting) return [];
    let s = [],
      o = (a, l) => {
        if (a.prop(languageDataProp) == this.data) {
          s.push({ from: l, to: l + a.length });
          return;
        }
        let f = a.prop(NodeProp.mounted);
        if (f) {
          if (f.tree.prop(languageDataProp) == this.data) {
            if (f.overlay) for (let m of f.overlay) s.push({ from: m.from + l, to: m.to + l });
            else s.push({ from: l, to: l + a.length });
            return;
          } else if (f.overlay) {
            let m = s.length;
            if ((o(f.tree, f.overlay[0].from + l), s.length > m)) return;
          }
        }
        for (let m = 0; m < a.children.length; m++) {
          let v = a.children[m];
          v instanceof Tree && o(v, a.positions[m] + l);
        }
      };
    return o(syntaxTree(e), 0), s;
  }
  get allowsNesting() {
    return !0;
  }
}
Language.setState = StateEffect.define();
function topNodeAt(r, e, n) {
  let s = r.facet(language),
    o = syntaxTree(r).topNode;
  if (!s || s.allowsNesting) for (let a = o; a; a = a.enter(e, n, IterMode.ExcludeBuffers)) a.type.isTop && (o = a);
  return o;
}
class LRLanguage extends Language {
  constructor(e, n, s) {
    super(e, n, [], s), (this.parser = n);
  }
  static define(e) {
    let n = defineLanguageFacet(e.languageData);
    return new LRLanguage(
      n,
      e.parser.configure({ props: [languageDataProp.add((s) => (s.isTop ? n : void 0))] }),
      e.name,
    );
  }
  configure(e, n) {
    return new LRLanguage(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function syntaxTree(r) {
  let e = r.field(Language.state, !1);
  return e ? e.tree : Tree.empty;
}
class DocInput {
  constructor(e) {
    (this.doc = e), (this.cursorPos = 0), (this.string = ''), (this.cursor = e.iter());
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return (
      (this.string = this.cursor.next(e - this.cursorPos).value),
      (this.cursorPos = e + this.string.length),
      this.cursorPos - this.string.length
    );
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let s = this.cursorPos - this.string.length;
    return e < s || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - s, n - s);
  }
}
let currentContext = null;
class ParseContext {
  constructor(e, n, s = [], o, a, l, f, m) {
    (this.parser = e),
      (this.state = n),
      (this.fragments = s),
      (this.tree = o),
      (this.treeLen = a),
      (this.viewport = l),
      (this.skipped = f),
      (this.scheduleOn = m),
      (this.parse = null),
      (this.tempSkipped = []);
  }
  static create(e, n, s) {
    return new ParseContext(e, n, [], Tree.empty, 0, s, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  work(e, n) {
    return (
      n != null && n >= this.state.doc.length && (n = void 0),
      this.tree != Tree.empty && this.isDone(n ?? this.state.doc.length)
        ? (this.takeTree(), !0)
        : this.withContext(() => {
            var s;
            if (typeof e == 'number') {
              let o = Date.now() + e;
              e = () => Date.now() > o;
            }
            for (
              this.parse || (this.parse = this.startParse()),
                n != null &&
                  (this.parse.stoppedAt == null || this.parse.stoppedAt > n) &&
                  n < this.state.doc.length &&
                  this.parse.stopAt(n);
              ;

            ) {
              let o = this.parse.advance();
              if (o)
                if (
                  ((this.fragments = this.withoutTempSkipped(
                    TreeFragment.addTree(o, this.fragments, this.parse.stoppedAt != null),
                  )),
                  (this.treeLen = (s = this.parse.stoppedAt) !== null && s !== void 0 ? s : this.state.doc.length),
                  (this.tree = o),
                  (this.parse = null),
                  this.treeLen < (n ?? this.state.doc.length))
                )
                  this.parse = this.startParse();
                else return !0;
              if (e()) return !1;
            }
          })
    );
  }
  takeTree() {
    let e, n;
    this.parse &&
      (e = this.parse.parsedPos) >= this.treeLen &&
      ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e),
      this.withContext(() => {
        for (; !(n = this.parse.advance()); );
      }),
      (this.treeLen = e),
      (this.tree = n),
      (this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, !0))),
      (this.parse = null));
  }
  withContext(e) {
    let n = currentContext;
    currentContext = this;
    try {
      return e();
    } finally {
      currentContext = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; (n = this.tempSkipped.pop()); ) e = cutFragments(e, n.from, n.to);
    return e;
  }
  changes(e, n) {
    let { fragments: s, tree: o, treeLen: a, viewport: l, skipped: f } = this;
    if ((this.takeTree(), !e.empty)) {
      let m = [];
      if (
        (e.iterChangedRanges((v, I, L, V) => m.push({ fromA: v, toA: I, fromB: L, toB: V })),
        (s = TreeFragment.applyChanges(s, m)),
        (o = Tree.empty),
        (a = 0),
        (l = { from: e.mapPos(l.from, -1), to: e.mapPos(l.to, 1) }),
        this.skipped.length)
      ) {
        f = [];
        for (let v of this.skipped) {
          let I = e.mapPos(v.from, 1),
            L = e.mapPos(v.to, -1);
          I < L && f.push({ from: I, to: L });
        }
      }
    }
    return new ParseContext(this.parser, n, s, o, a, l, f, this.scheduleOn);
  }
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to) return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let s = 0; s < this.skipped.length; s++) {
      let { from: o, to: a } = this.skipped[s];
      o < e.to && a > e.from && ((this.fragments = cutFragments(this.fragments, o, a)), this.skipped.splice(s--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), (this.parse = null));
  }
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  static getSkippingParser(e) {
    return new (class extends Parser {
      createParse(n, s, o) {
        let a = o[0].from,
          l = o[o.length - 1].to;
        return {
          parsedPos: a,
          advance() {
            let m = currentContext;
            if (m) {
              for (let v of o) m.tempSkipped.push(v);
              e && (m.scheduleOn = m.scheduleOn ? Promise.all([m.scheduleOn, e]) : e);
            }
            return (this.parsedPos = l), new Tree(NodeType.none, [], [], l - a);
          },
          stoppedAt: null,
          stopAt() {},
        };
      }
    })();
  }
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  static get() {
    return currentContext;
  }
}
function cutFragments(r, e, n) {
  return TreeFragment.applyChanges(r, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class LanguageState {
  constructor(e) {
    (this.context = e), (this.tree = e.tree);
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree) return this;
    let n = this.context.changes(e.changes, e.state),
      s =
        this.context.treeLen == e.startState.doc.length
          ? void 0
          : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, s) || n.takeTree(), new LanguageState(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length),
      s = ParseContext.create(e.facet(language).parser, e, { from: 0, to: n });
    return s.work(20, n) || s.takeTree(), new LanguageState(s);
  }
}
Language.state = StateField.define({
  create: LanguageState.init,
  update(r, e) {
    for (let n of e.effects) if (n.is(Language.setState)) return n.value;
    return e.startState.facet(language) != e.state.facet(language) ? LanguageState.init(e.state) : r.apply(e);
  },
});
let requestIdle = (r) => {
  let e = setTimeout(() => r(), 500);
  return () => clearTimeout(e);
};
typeof requestIdleCallback < 'u' &&
  (requestIdle = (r) => {
    let e = -1,
      n = setTimeout(() => {
        e = requestIdleCallback(r, { timeout: 500 - 100 });
      }, 100);
    return () => (e < 0 ? clearTimeout(n) : cancelIdleCallback(e));
  });
const isInputPending =
    typeof navigator < 'u' && !((_a = navigator.scheduling) === null || _a === void 0) && _a.isInputPending
      ? () => navigator.scheduling.isInputPending()
      : null,
  parseWorker = ViewPlugin.fromClass(
    class {
      constructor(e) {
        (this.view = e),
          (this.working = null),
          (this.workScheduled = 0),
          (this.chunkEnd = -1),
          (this.chunkBudget = -1),
          (this.work = this.work.bind(this)),
          this.scheduleWork();
      }
      update(e) {
        let n = this.view.state.field(Language.state).context;
        (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(),
          (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()),
          this.checkAsyncSchedule(n);
      }
      scheduleWork() {
        if (this.working) return;
        let { state: e } = this.view,
          n = e.field(Language.state);
        (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = requestIdle(this.work));
      }
      work(e) {
        this.working = null;
        let n = Date.now();
        if (
          (this.chunkEnd < n &&
            (this.chunkEnd < 0 || this.view.hasFocus) &&
            ((this.chunkEnd = n + 3e4), (this.chunkBudget = 3e3)),
          this.chunkBudget <= 0)
        )
          return;
        let {
            state: s,
            viewport: { to: o },
          } = this.view,
          a = s.field(Language.state);
        if (a.tree == a.context.tree && a.context.isDone(o + 1e5)) return;
        let l =
            Date.now() +
            Math.min(this.chunkBudget, 100, e && !isInputPending ? Math.max(25, e.timeRemaining() - 5) : 1e9),
          f = a.context.treeLen < o && s.doc.length > o + 1e3,
          m = a.context.work(() => (isInputPending && isInputPending()) || Date.now() > l, o + (f ? 0 : 1e5));
        (this.chunkBudget -= Date.now() - n),
          (m || this.chunkBudget <= 0) &&
            (a.context.takeTree(), this.view.dispatch({ effects: Language.setState.of(new LanguageState(a.context)) })),
          this.chunkBudget > 0 && !(m && !f) && this.scheduleWork(),
          this.checkAsyncSchedule(a.context);
      }
      checkAsyncSchedule(e) {
        e.scheduleOn &&
          (this.workScheduled++,
          e.scheduleOn
            .then(() => this.scheduleWork())
            .catch((n) => logException(this.view.state, n))
            .then(() => this.workScheduled--),
          (e.scheduleOn = null));
      }
      destroy() {
        this.working && this.working();
      }
      isWorking() {
        return !!(this.working || this.workScheduled > 0);
      }
    },
    {
      eventHandlers: {
        focus() {
          this.scheduleWork();
        },
      },
    },
  ),
  language = Facet.define({
    combine(r) {
      return r.length ? r[0] : null;
    },
    enables: (r) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([r], (e) => {
        let n = e.facet(r);
        return n && n.name ? { 'data-language': n.name } : {};
      }),
    ],
  });
class LanguageSupport {
  constructor(e, n = []) {
    (this.language = e), (this.support = n), (this.extension = [e, n]);
  }
}
const indentService = Facet.define(),
  indentUnit = Facet.define({
    combine: (r) => {
      if (!r.length) return '  ';
      let e = r[0];
      if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
        throw new Error('Invalid indent unit: ' + JSON.stringify(r[0]));
      return e;
    },
  });
function getIndentUnit(r) {
  let e = r.facet(indentUnit);
  return e.charCodeAt(0) == 9 ? r.tabSize * e.length : e.length;
}
function indentString(r, e) {
  let n = '',
    s = r.tabSize,
    o = r.facet(indentUnit)[0];
  if (o == '	') {
    for (; e >= s; ) (n += '	'), (e -= s);
    o = ' ';
  }
  for (let a = 0; a < e; a++) n += o;
  return n;
}
function getIndentation(r, e) {
  r instanceof EditorState && (r = new IndentContext(r));
  for (let s of r.state.facet(indentService)) {
    let o = s(r, e);
    if (o !== void 0) return o;
  }
  let n = syntaxTree(r.state);
  return n.length >= e ? syntaxIndentation(r, n, e) : null;
}
class IndentContext {
  constructor(e, n = {}) {
    (this.state = e), (this.options = n), (this.unit = getIndentUnit(e));
  }
  lineAt(e, n = 1) {
    let s = this.state.doc.lineAt(e),
      { simulateBreak: o, simulateDoubleBreak: a } = this.options;
    return o != null && o >= s.from && o <= s.to
      ? a && o == e
        ? { text: '', from: e }
        : (n < 0 ? o < e : o <= e)
        ? { text: s.text.slice(o - s.from), from: o }
        : { text: s.text.slice(0, o - s.from), from: s.from }
      : s;
  }
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak) return '';
    let { text: s, from: o } = this.lineAt(e, n);
    return s.slice(e - o, Math.min(s.length, e + 100 - o));
  }
  column(e, n = 1) {
    let { text: s, from: o } = this.lineAt(e, n),
      a = this.countColumn(s, e - o),
      l = this.options.overrideIndentation ? this.options.overrideIndentation(o) : -1;
    return l > -1 && (a += l - this.countColumn(s, s.search(/\S|$/))), a;
  }
  countColumn(e, n = e.length) {
    return countColumn(e, this.state.tabSize, n);
  }
  lineIndent(e, n = 1) {
    let { text: s, from: o } = this.lineAt(e, n),
      a = this.options.overrideIndentation;
    if (a) {
      let l = a(o);
      if (l > -1) return l;
    }
    return this.countColumn(s, s.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const indentNodeProp = new NodeProp();
function syntaxIndentation(r, e, n) {
  let s = e.resolveStack(n),
    o = s.node.enterUnfinishedNodesBefore(n);
  if (o != s.node) {
    let a = [];
    for (let l = o; l != s.node; l = l.parent) a.push(l);
    for (let l = a.length - 1; l >= 0; l--) s = { node: a[l], next: s };
  }
  return indentFor(s, r, n);
}
function indentFor(r, e, n) {
  for (let s = r; s; s = s.next) {
    let o = indentStrategy(s.node);
    if (o) return o(TreeIndentContext.create(e, n, s));
  }
  return 0;
}
function ignoreClosed(r) {
  return r.pos == r.options.simulateBreak && r.options.simulateDoubleBreak;
}
function indentStrategy(r) {
  let e = r.type.prop(indentNodeProp);
  if (e) return e;
  let n = r.firstChild,
    s;
  if (n && (s = n.type.prop(NodeProp.closedBy))) {
    let o = r.lastChild,
      a = o && s.indexOf(o.name) > -1;
    return (l) => delimitedStrategy(l, !0, 1, void 0, a && !ignoreClosed(l) ? o.from : void 0);
  }
  return r.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
class TreeIndentContext extends IndentContext {
  constructor(e, n, s) {
    super(e.state, e.options), (this.base = e), (this.pos = n), (this.context = s);
  }
  get node() {
    return this.context.node;
  }
  static create(e, n, s) {
    return new TreeIndentContext(e, n, s);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (;;) {
      let s = e.resolve(n.from);
      for (; s.parent && s.parent.from == s.from; ) s = s.parent;
      if (isParent(s, e)) break;
      n = this.state.doc.lineAt(s.from);
    }
    return this.lineIndent(n.from);
  }
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
}
function isParent(r, e) {
  for (let n = e; n; n = n.parent) if (r == n) return !0;
  return !1;
}
function bracketedAligned(r) {
  let e = r.node,
    n = e.childAfter(e.from),
    s = e.lastChild;
  if (!n) return null;
  let o = r.options.simulateBreak,
    a = r.state.doc.lineAt(n.from),
    l = o == null || o <= a.from ? a.to : Math.min(a.to, o);
  for (let f = n.to; ; ) {
    let m = e.childAfter(f);
    if (!m || m == s) return null;
    if (!m.type.isSkipped) return m.from < l ? n : null;
    f = m.to;
  }
}
function delimitedStrategy(r, e, n, s, o) {
  let a = r.textAfter,
    l = a.match(/^\s*/)[0].length,
    f = (s && a.slice(l, l + s.length) == s) || o == r.pos + l,
    m = e ? bracketedAligned(r) : null;
  return m ? (f ? r.column(m.from) : r.column(m.to)) : r.baseIndent + (f ? 0 : r.unit * n);
}
function continuedIndent({ except: r, units: e = 1 } = {}) {
  return (n) => {
    let s = r && r.test(n.textAfter);
    return n.baseIndent + (s ? 0 : e * n.unit);
  };
}
const DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((r) => {
    if (!r.docChanged || (!r.isUserEvent('input.type') && !r.isUserEvent('input.complete'))) return r;
    let e = r.startState.languageDataAt('indentOnInput', r.startState.selection.main.head);
    if (!e.length) return r;
    let n = r.newDoc,
      { head: s } = r.newSelection.main,
      o = n.lineAt(s);
    if (s > o.from + DontIndentBeyond) return r;
    let a = n.sliceString(o.from, s);
    if (!e.some((v) => v.test(a))) return r;
    let { state: l } = r,
      f = -1,
      m = [];
    for (let { head: v } of l.selection.ranges) {
      let I = l.doc.lineAt(v);
      if (I.from == f) continue;
      f = I.from;
      let L = getIndentation(l, I.from);
      if (L == null) continue;
      let V = /^\s*/.exec(I.text)[0],
        se = indentString(l, L);
      V != se && m.push({ from: I.from, to: I.from + V.length, insert: se });
    }
    return m.length ? [r, { changes: m, sequential: !0 }] : r;
  });
}
const foldService = Facet.define(),
  foldNodeProp = new NodeProp();
function foldInside(r) {
  let e = r.firstChild,
    n = r.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? r.to : n.from } : null;
}
function syntaxFolding(r, e, n) {
  let s = syntaxTree(r);
  if (s.length < n) return null;
  let o = s.resolveStack(n, 1),
    a = null;
  for (let l = o; l; l = l.next) {
    let f = l.node;
    if (f.to <= n || f.from > n) continue;
    if (a && f.from < e) break;
    let m = f.type.prop(foldNodeProp);
    if (m && (f.to < s.length - 50 || s.length == r.doc.length || !isUnfinished(f))) {
      let v = m(f, r);
      v && v.from <= n && v.from >= e && v.to > n && (a = v);
    }
  }
  return a;
}
function isUnfinished(r) {
  let e = r.lastChild;
  return e && e.to == r.to && e.type.isError;
}
function foldable(r, e, n) {
  for (let s of r.facet(foldService)) {
    let o = s(r, e, n);
    if (o) return o;
  }
  return syntaxFolding(r, e, n);
}
function mapRange(r, e) {
  let n = e.mapPos(r.from, 1),
    s = e.mapPos(r.to, -1);
  return n >= s ? void 0 : { from: n, to: s };
}
const foldEffect = StateEffect.define({ map: mapRange }),
  unfoldEffect = StateEffect.define({ map: mapRange });
function selectedLines(r) {
  let e = [];
  for (let { head: n } of r.state.selection.ranges) e.some((s) => s.from <= n && s.to >= n) || e.push(r.lineBlockAt(n));
  return e;
}
const foldState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(r, e) {
    r = r.map(e.changes);
    for (let n of e.effects)
      if (n.is(foldEffect) && !foldExists(r, n.value.from, n.value.to)) {
        let { preparePlaceholder: s } = e.state.facet(foldConfig),
          o = s ? Decoration.replace({ widget: new PreparedFoldWidget(s(e.state, n.value)) }) : foldWidget;
        r = r.update({ add: [o.range(n.value.from, n.value.to)] });
      } else
        n.is(unfoldEffect) &&
          (r = r.update({
            filter: (s, o) => n.value.from != s || n.value.to != o,
            filterFrom: n.value.from,
            filterTo: n.value.to,
          }));
    if (e.selection) {
      let n = !1,
        { head: s } = e.selection.main;
      r.between(s, s, (o, a) => {
        o < s && a > s && (n = !0);
      }),
        n && (r = r.update({ filterFrom: s, filterTo: s, filter: (o, a) => a <= s || o >= s }));
    }
    return r;
  },
  provide: (r) => EditorView.decorations.from(r),
  toJSON(r, e) {
    let n = [];
    return (
      r.between(0, e.doc.length, (s, o) => {
        n.push(s, o);
      }),
      n
    );
  },
  fromJSON(r) {
    if (!Array.isArray(r) || r.length % 2) throw new RangeError('Invalid JSON for fold state');
    let e = [];
    for (let n = 0; n < r.length; ) {
      let s = r[n++],
        o = r[n++];
      if (typeof s != 'number' || typeof o != 'number') throw new RangeError('Invalid JSON for fold state');
      e.push(foldWidget.range(s, o));
    }
    return Decoration.set(e, !0);
  },
});
function findFold(r, e, n) {
  var s;
  let o = null;
  return (
    (s = r.field(foldState, !1)) === null ||
      s === void 0 ||
      s.between(e, n, (a, l) => {
        (!o || o.from > a) && (o = { from: a, to: l });
      }),
    o
  );
}
function foldExists(r, e, n) {
  let s = !1;
  return (
    r.between(e, e, (o, a) => {
      o == e && a == n && (s = !0);
    }),
    s
  );
}
function maybeEnable(r, e) {
  return r.field(foldState, !1) ? e : e.concat(StateEffect.appendConfig.of(codeFolding()));
}
const foldCode = (r) => {
    for (let e of selectedLines(r)) {
      let n = foldable(r.state, e.from, e.to);
      if (n) return r.dispatch({ effects: maybeEnable(r.state, [foldEffect.of(n), announceFold(r, n)]) }), !0;
    }
    return !1;
  },
  unfoldCode = (r) => {
    if (!r.state.field(foldState, !1)) return !1;
    let e = [];
    for (let n of selectedLines(r)) {
      let s = findFold(r.state, n.from, n.to);
      s && e.push(unfoldEffect.of(s), announceFold(r, s, !1));
    }
    return e.length && r.dispatch({ effects: e }), e.length > 0;
  };
function announceFold(r, e, n = !0) {
  let s = r.state.doc.lineAt(e.from).number,
    o = r.state.doc.lineAt(e.to).number;
  return EditorView.announce.of(
    `${r.state.phrase(n ? 'Folded lines' : 'Unfolded lines')} ${s} ${r.state.phrase('to')} ${o}.`,
  );
}
const foldAll = (r) => {
    let { state: e } = r,
      n = [];
    for (let s = 0; s < e.doc.length; ) {
      let o = r.lineBlockAt(s),
        a = foldable(e, o.from, o.to);
      a && n.push(foldEffect.of(a)), (s = (a ? r.lineBlockAt(a.to) : o).to + 1);
    }
    return n.length && r.dispatch({ effects: maybeEnable(r.state, n) }), !!n.length;
  },
  unfoldAll = (r) => {
    let e = r.state.field(foldState, !1);
    if (!e || !e.size) return !1;
    let n = [];
    return (
      e.between(0, r.state.doc.length, (s, o) => {
        n.push(unfoldEffect.of({ from: s, to: o }));
      }),
      r.dispatch({ effects: n }),
      !0
    );
  },
  foldKeymap = [
    { key: 'Ctrl-Shift-[', mac: 'Cmd-Alt-[', run: foldCode },
    { key: 'Ctrl-Shift-]', mac: 'Cmd-Alt-]', run: unfoldCode },
    { key: 'Ctrl-Alt-[', run: foldAll },
    { key: 'Ctrl-Alt-]', run: unfoldAll },
  ],
  defaultConfig = { placeholderDOM: null, preparePlaceholder: null, placeholderText: '…' },
  foldConfig = Facet.define({
    combine(r) {
      return combineConfig(r, defaultConfig);
    },
  });
function codeFolding(r) {
  let e = [foldState, baseTheme$1$2];
  return r && e.push(foldConfig.of(r)), e;
}
function widgetToDOM(r, e) {
  let { state: n } = r,
    s = n.facet(foldConfig),
    o = (l) => {
      let f = r.lineBlockAt(r.posAtDOM(l.target)),
        m = findFold(r.state, f.from, f.to);
      m && r.dispatch({ effects: unfoldEffect.of(m) }), l.preventDefault();
    };
  if (s.placeholderDOM) return s.placeholderDOM(r, o, e);
  let a = document.createElement('span');
  return (
    (a.textContent = s.placeholderText),
    a.setAttribute('aria-label', n.phrase('folded code')),
    (a.title = n.phrase('unfold')),
    (a.className = 'cm-foldPlaceholder'),
    (a.onclick = o),
    a
  );
}
const foldWidget = Decoration.replace({
  widget: new (class extends WidgetType {
    toDOM(r) {
      return widgetToDOM(r, null);
    }
  })(),
});
class PreparedFoldWidget extends WidgetType {
  constructor(e) {
    super(), (this.value = e);
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return widgetToDOM(e, this.value);
  }
}
const foldGutterDefaults = {
  openText: '⌄',
  closedText: '›',
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1,
};
class FoldMarker extends GutterMarker {
  constructor(e, n) {
    super(), (this.config = e), (this.open = n);
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let n = document.createElement('span');
    return (
      (n.textContent = this.open ? this.config.openText : this.config.closedText),
      (n.title = e.state.phrase(this.open ? 'Fold line' : 'Unfold line')),
      n
    );
  }
}
function foldGutter(r = {}) {
  let e = Object.assign(Object.assign({}, foldGutterDefaults), r),
    n = new FoldMarker(e, !0),
    s = new FoldMarker(e, !1),
    o = ViewPlugin.fromClass(
      class {
        constructor(l) {
          (this.from = l.viewport.from), (this.markers = this.buildMarkers(l));
        }
        update(l) {
          (l.docChanged ||
            l.viewportChanged ||
            l.startState.facet(language) != l.state.facet(language) ||
            l.startState.field(foldState, !1) != l.state.field(foldState, !1) ||
            syntaxTree(l.startState) != syntaxTree(l.state) ||
            e.foldingChanged(l)) &&
            (this.markers = this.buildMarkers(l.view));
        }
        buildMarkers(l) {
          let f = new RangeSetBuilder();
          for (let m of l.viewportLineBlocks) {
            let v = findFold(l.state, m.from, m.to) ? s : foldable(l.state, m.from, m.to) ? n : null;
            v && f.add(m.from, m.from, v);
          }
          return f.finish();
        }
      },
    ),
    { domEventHandlers: a } = e;
  return [
    o,
    gutter({
      class: 'cm-foldGutter',
      markers(l) {
        var f;
        return ((f = l.plugin(o)) === null || f === void 0 ? void 0 : f.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, a), {
        click: (l, f, m) => {
          if (a.click && a.click(l, f, m)) return !0;
          let v = findFold(l.state, f.from, f.to);
          if (v) return l.dispatch({ effects: unfoldEffect.of(v) }), !0;
          let I = foldable(l.state, f.from, f.to);
          return I ? (l.dispatch({ effects: foldEffect.of(I) }), !0) : !1;
        },
      }),
    }),
    codeFolding(),
  ];
}
const baseTheme$1$2 = EditorView.baseTheme({
  '.cm-foldPlaceholder': {
    backgroundColor: '#eee',
    border: '1px solid #ddd',
    color: '#888',
    borderRadius: '.2em',
    margin: '0 1px',
    padding: '0 1px',
    cursor: 'pointer',
  },
  '.cm-foldGutter span': { padding: '0 1px', cursor: 'pointer' },
});
class HighlightStyle {
  constructor(e, n) {
    this.specs = e;
    let s;
    function o(f) {
      let m = StyleModule.newName();
      return ((s || (s = Object.create(null)))['.' + m] = f), m;
    }
    const a = typeof n.all == 'string' ? n.all : n.all ? o(n.all) : void 0,
      l = n.scope;
    (this.scope = l instanceof Language ? (f) => f.prop(languageDataProp) == l.data : l ? (f) => f == l : void 0),
      (this.style = tagHighlighter(
        e.map((f) => ({ tag: f.tag, class: f.class || o(Object.assign({}, f, { tag: null })) })),
        { all: a },
      ).style),
      (this.module = s ? new StyleModule(s) : null),
      (this.themeType = n.themeType);
  }
  static define(e, n) {
    return new HighlightStyle(e, n || {});
  }
}
const highlighterFacet = Facet.define(),
  fallbackHighlighter = Facet.define({
    combine(r) {
      return r.length ? [r[0]] : null;
    },
  });
function getHighlighters(r) {
  let e = r.facet(highlighterFacet);
  return e.length ? e : r.facet(fallbackHighlighter);
}
function syntaxHighlighting(r, e) {
  let n = [treeHighlighter],
    s;
  return (
    r instanceof HighlightStyle && (r.module && n.push(EditorView.styleModule.of(r.module)), (s = r.themeType)),
    e != null && e.fallback
      ? n.push(fallbackHighlighter.of(r))
      : s
      ? n.push(
          highlighterFacet.computeN([EditorView.darkTheme], (o) =>
            o.facet(EditorView.darkTheme) == (s == 'dark') ? [r] : [],
          ),
        )
      : n.push(highlighterFacet.of(r)),
    n
  );
}
class TreeHighlighter {
  constructor(e) {
    (this.markCache = Object.create(null)),
      (this.tree = syntaxTree(e.state)),
      (this.decorations = this.buildDeco(e, getHighlighters(e.state)));
  }
  update(e) {
    let n = syntaxTree(e.state),
      s = getHighlighters(e.state),
      o = s != getHighlighters(e.startState);
    n.length < e.view.viewport.to && !o && n.type == this.tree.type
      ? (this.decorations = this.decorations.map(e.changes))
      : (n != this.tree || e.viewportChanged || o) && ((this.tree = n), (this.decorations = this.buildDeco(e.view, s)));
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length) return Decoration.none;
    let s = new RangeSetBuilder();
    for (let { from: o, to: a } of e.visibleRanges)
      highlightTree(
        this.tree,
        n,
        (l, f, m) => {
          s.add(l, f, this.markCache[m] || (this.markCache[m] = Decoration.mark({ class: m })));
        },
        o,
        a,
      );
    return s.finish();
  }
}
const treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, { decorations: (r) => r.decorations })),
  defaultHighlightStyle = HighlightStyle.define([
    { tag: tags.meta, color: '#404740' },
    { tag: tags.link, textDecoration: 'underline' },
    { tag: tags.heading, textDecoration: 'underline', fontWeight: 'bold' },
    { tag: tags.emphasis, fontStyle: 'italic' },
    { tag: tags.strong, fontWeight: 'bold' },
    { tag: tags.strikethrough, textDecoration: 'line-through' },
    { tag: tags.keyword, color: '#708' },
    { tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName], color: '#219' },
    { tag: [tags.literal, tags.inserted], color: '#164' },
    { tag: [tags.string, tags.deleted], color: '#a11' },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], color: '#e40' },
    { tag: tags.definition(tags.variableName), color: '#00f' },
    { tag: tags.local(tags.variableName), color: '#30a' },
    { tag: [tags.typeName, tags.namespace], color: '#085' },
    { tag: tags.className, color: '#167' },
    { tag: [tags.special(tags.variableName), tags.macroName], color: '#256' },
    { tag: tags.definition(tags.propertyName), color: '#00c' },
    { tag: tags.comment, color: '#940' },
    { tag: tags.invalid, color: '#f00' },
  ]),
  baseTheme$3 = EditorView.baseTheme({
    '&.cm-focused .cm-matchingBracket': { backgroundColor: '#328c8252' },
    '&.cm-focused .cm-nonmatchingBracket': { backgroundColor: '#bb555544' },
  }),
  DefaultScanDist = 1e4,
  DefaultBrackets = '()[]{}',
  bracketMatchingConfig = Facet.define({
    combine(r) {
      return combineConfig(r, {
        afterCursor: !0,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch,
      });
    },
  }),
  matchingMark = Decoration.mark({ class: 'cm-matchingBracket' }),
  nonmatchingMark = Decoration.mark({ class: 'cm-nonmatchingBracket' });
function defaultRenderMatch(r) {
  let e = [],
    n = r.matched ? matchingMark : nonmatchingMark;
  return e.push(n.range(r.start.from, r.start.to)), r.end && e.push(n.range(r.end.from, r.end.to)), e;
}
const bracketMatchingState = StateField.define({
    create() {
      return Decoration.none;
    },
    update(r, e) {
      if (!e.docChanged && !e.selection) return r;
      let n = [],
        s = e.state.facet(bracketMatchingConfig);
      for (let o of e.state.selection.ranges) {
        if (!o.empty) continue;
        let a =
          matchBrackets(e.state, o.head, -1, s) ||
          (o.head > 0 && matchBrackets(e.state, o.head - 1, 1, s)) ||
          (s.afterCursor &&
            (matchBrackets(e.state, o.head, 1, s) ||
              (o.head < e.state.doc.length && matchBrackets(e.state, o.head + 1, -1, s))));
        a && (n = n.concat(s.renderMatch(a, e.state)));
      }
      return Decoration.set(n, !0);
    },
    provide: (r) => EditorView.decorations.from(r),
  }),
  bracketMatchingUnique = [bracketMatchingState, baseTheme$3];
function bracketMatching(r = {}) {
  return [bracketMatchingConfig.of(r), bracketMatchingUnique];
}
const bracketMatchingHandle = new NodeProp();
function matchingNodes(r, e, n) {
  let s = r.prop(e < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (s) return s;
  if (r.name.length == 1) {
    let o = n.indexOf(r.name);
    if (o > -1 && o % 2 == (e < 0 ? 1 : 0)) return [n[o + e]];
  }
  return null;
}
function findHandle(r) {
  let e = r.type.prop(bracketMatchingHandle);
  return e ? e(r.node) : r;
}
function matchBrackets(r, e, n, s = {}) {
  let o = s.maxScanDistance || DefaultScanDist,
    a = s.brackets || DefaultBrackets,
    l = syntaxTree(r),
    f = l.resolveInner(e, n);
  for (let m = f; m; m = m.parent) {
    let v = matchingNodes(m.type, n, a);
    if (v && m.from < m.to) {
      let I = findHandle(m);
      if (I && (n > 0 ? e >= I.from && e < I.to : e > I.from && e <= I.to))
        return matchMarkedBrackets(r, e, n, m, I, v, a);
    }
  }
  return matchPlainBrackets(r, e, n, l, f.type, o, a);
}
function matchMarkedBrackets(r, e, n, s, o, a, l) {
  let f = s.parent,
    m = { from: o.from, to: o.to },
    v = 0,
    I = f == null ? void 0 : f.cursor();
  if (I && (n < 0 ? I.childBefore(s.from) : I.childAfter(s.to)))
    do
      if (n < 0 ? I.to <= s.from : I.from >= s.to) {
        if (v == 0 && a.indexOf(I.type.name) > -1 && I.from < I.to) {
          let L = findHandle(I);
          return { start: m, end: L ? { from: L.from, to: L.to } : void 0, matched: !0 };
        } else if (matchingNodes(I.type, n, l)) v++;
        else if (matchingNodes(I.type, -n, l)) {
          if (v == 0) {
            let L = findHandle(I);
            return { start: m, end: L && L.from < L.to ? { from: L.from, to: L.to } : void 0, matched: !1 };
          }
          v--;
        }
      }
    while (n < 0 ? I.prevSibling() : I.nextSibling());
  return { start: m, matched: !1 };
}
function matchPlainBrackets(r, e, n, s, o, a, l) {
  let f = n < 0 ? r.sliceDoc(e - 1, e) : r.sliceDoc(e, e + 1),
    m = l.indexOf(f);
  if (m < 0 || (m % 2 == 0) != n > 0) return null;
  let v = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e },
    I = r.doc.iterRange(e, n > 0 ? r.doc.length : 0),
    L = 0;
  for (let V = 0; !I.next().done && V <= a; ) {
    let se = I.value;
    n < 0 && (V += se.length);
    let Ee = e + V * n;
    for (let ht = n > 0 ? 0 : se.length - 1, ar = n > 0 ? se.length : -1; ht != ar; ht += n) {
      let $i = l.indexOf(se[ht]);
      if (!($i < 0 || s.resolveInner(Ee + ht, 1).type != o))
        if (($i % 2 == 0) == n > 0) L++;
        else {
          if (L == 1) return { start: v, end: { from: Ee + ht, to: Ee + ht + 1 }, matched: $i >> 1 == m >> 1 };
          L--;
        }
    }
    n > 0 && (V += se.length);
  }
  return I.done ? { start: v, matched: !1 } : null;
}
const noTokens = Object.create(null),
  typeArray = [NodeType.none],
  warned = [],
  defaultTable = Object.create(null);
for (let [r, e] of [
  ['variable', 'variableName'],
  ['variable-2', 'variableName.special'],
  ['string-2', 'string.special'],
  ['def', 'variableName.definition'],
  ['tag', 'tagName'],
  ['attribute', 'attributeName'],
  ['type', 'typeName'],
  ['builtin', 'variableName.standard'],
  ['qualifier', 'modifier'],
  ['error', 'invalid'],
  ['header', 'heading'],
  ['property', 'propertyName'],
])
  defaultTable[r] = createTokenType(noTokens, e);
function warnForPart(r, e) {
  warned.indexOf(r) > -1 || (warned.push(r), console.warn(e));
}
function createTokenType(r, e) {
  let n = null;
  for (let a of e.split('.')) {
    let l = r[a] || tags[a];
    l
      ? typeof l == 'function'
        ? n
          ? (n = l(n))
          : warnForPart(a, `Modifier ${a} used at start of tag`)
        : n
        ? warnForPart(a, `Tag ${a} used as modifier`)
        : (n = l)
      : warnForPart(a, `Unknown highlighting tag ${a}`);
  }
  if (!n) return 0;
  let s = e.replace(/ /g, '_'),
    o = NodeType.define({ id: typeArray.length, name: s, props: [styleTags({ [s]: n })] });
  return typeArray.push(o), o.id;
}
const toggleComment = (r) => {
  let { state: e } = r,
    n = e.doc.lineAt(e.selection.main.from),
    s = getConfig(r.state, n.from);
  return s.line ? toggleLineComment(r) : s.block ? toggleBlockCommentByLine(r) : !1;
};
function command(r, e) {
  return ({ state: n, dispatch: s }) => {
    if (n.readOnly) return !1;
    let o = r(e, n);
    return o ? (s(n.update(o)), !0) : !1;
  };
}
const toggleLineComment = command(changeLineComment, 0),
  toggleBlockComment = command(changeBlockComment, 0),
  toggleBlockCommentByLine = command((r, e) => changeBlockComment(r, e, selectedLineRanges(e)), 0);
function getConfig(r, e) {
  let n = r.languageDataAt('commentTokens', e);
  return n.length ? n[0] : {};
}
const SearchMargin = 50;
function findBlockComment(r, { open: e, close: n }, s, o) {
  let a = r.sliceDoc(s - SearchMargin, s),
    l = r.sliceDoc(o, o + SearchMargin),
    f = /\s*$/.exec(a)[0].length,
    m = /^\s*/.exec(l)[0].length,
    v = a.length - f;
  if (a.slice(v - e.length, v) == e && l.slice(m, m + n.length) == n)
    return { open: { pos: s - f, margin: f && 1 }, close: { pos: o + m, margin: m && 1 } };
  let I, L;
  o - s <= 2 * SearchMargin
    ? (I = L = r.sliceDoc(s, o))
    : ((I = r.sliceDoc(s, s + SearchMargin)), (L = r.sliceDoc(o - SearchMargin, o)));
  let V = /^\s*/.exec(I)[0].length,
    se = /\s*$/.exec(L)[0].length,
    Ee = L.length - se - n.length;
  return I.slice(V, V + e.length) == e && L.slice(Ee, Ee + n.length) == n
    ? {
        open: { pos: s + V + e.length, margin: /\s/.test(I.charAt(V + e.length)) ? 1 : 0 },
        close: { pos: o - se - n.length, margin: /\s/.test(L.charAt(Ee - 1)) ? 1 : 0 },
      }
    : null;
}
function selectedLineRanges(r) {
  let e = [];
  for (let n of r.selection.ranges) {
    let s = r.doc.lineAt(n.from),
      o = n.to <= s.to ? s : r.doc.lineAt(n.to),
      a = e.length - 1;
    a >= 0 && e[a].to > s.from ? (e[a].to = o.to) : e.push({ from: s.from + /^\s*/.exec(s.text)[0].length, to: o.to });
  }
  return e;
}
function changeBlockComment(r, e, n = e.selection.ranges) {
  let s = n.map((a) => getConfig(e, a.from).block);
  if (!s.every((a) => a)) return null;
  let o = n.map((a, l) => findBlockComment(e, s[l], a.from, a.to));
  if (r != 2 && !o.every((a) => a))
    return {
      changes: e.changes(
        n.map((a, l) =>
          o[l]
            ? []
            : [
                { from: a.from, insert: s[l].open + ' ' },
                { from: a.to, insert: ' ' + s[l].close },
              ],
        ),
      ),
    };
  if (r != 1 && o.some((a) => a)) {
    let a = [];
    for (let l = 0, f; l < o.length; l++)
      if ((f = o[l])) {
        let m = s[l],
          { open: v, close: I } = f;
        a.push(
          { from: v.pos - m.open.length, to: v.pos + v.margin },
          { from: I.pos - I.margin, to: I.pos + m.close.length },
        );
      }
    return { changes: a };
  }
  return null;
}
function changeLineComment(r, e, n = e.selection.ranges) {
  let s = [],
    o = -1;
  for (let { from: a, to: l } of n) {
    let f = s.length,
      m = 1e9,
      v = getConfig(e, a).line;
    if (v) {
      for (let I = a; I <= l; ) {
        let L = e.doc.lineAt(I);
        if (L.from > o && (a == l || l > L.from)) {
          o = L.from;
          let V = /^\s*/.exec(L.text)[0].length,
            se = V == L.length,
            Ee = L.text.slice(V, V + v.length) == v ? V : -1;
          V < L.text.length && V < m && (m = V),
            s.push({ line: L, comment: Ee, token: v, indent: V, empty: se, single: !1 });
        }
        I = L.to + 1;
      }
      if (m < 1e9) for (let I = f; I < s.length; I++) s[I].indent < s[I].line.text.length && (s[I].indent = m);
      s.length == f + 1 && (s[f].single = !0);
    }
  }
  if (r != 2 && s.some((a) => a.comment < 0 && (!a.empty || a.single))) {
    let a = [];
    for (let { line: f, token: m, indent: v, empty: I, single: L } of s)
      (L || !I) && a.push({ from: f.from + v, insert: m + ' ' });
    let l = e.changes(a);
    return { changes: l, selection: e.selection.map(l, 1) };
  } else if (r != 1 && s.some((a) => a.comment >= 0)) {
    let a = [];
    for (let { line: l, comment: f, token: m } of s)
      if (f >= 0) {
        let v = l.from + f,
          I = v + m.length;
        l.text[I - l.from] == ' ' && I++, a.push({ from: v, to: I });
      }
    return { changes: a };
  }
  return null;
}
const fromHistory = Annotation.define(),
  isolateHistory = Annotation.define(),
  invertedEffects = Facet.define(),
  historyConfig = Facet.define({
    combine(r) {
      return combineConfig(
        r,
        { minDepth: 100, newGroupDelay: 500, joinToEvent: (e, n) => n },
        { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (e, n) => (s, o) => e(s, o) || n(s, o) },
      );
    },
  });
function changeEnd(r) {
  let e = 0;
  return r.iterChangedRanges((n, s) => (e = s)), e;
}
const historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(r, e) {
    let n = e.state.facet(historyConfig),
      s = e.annotation(fromHistory);
    if (s) {
      let m = e.docChanged ? EditorSelection.single(changeEnd(e.changes)) : void 0,
        v = HistEvent.fromTransaction(e, m),
        I = s.side,
        L = I == 0 ? r.undone : r.done;
      return (
        v ? (L = updateBranch(L, L.length, n.minDepth, v)) : (L = addSelection(L, e.startState.selection)),
        new HistoryState(I == 0 ? s.rest : L, I == 0 ? L : s.rest)
      );
    }
    let o = e.annotation(isolateHistory);
    if (((o == 'full' || o == 'before') && (r = r.isolate()), e.annotation(Transaction.addToHistory) === !1))
      return e.changes.empty ? r : r.addMapping(e.changes.desc);
    let a = HistEvent.fromTransaction(e),
      l = e.annotation(Transaction.time),
      f = e.annotation(Transaction.userEvent);
    return (
      a
        ? (r = r.addChanges(a, l, f, n, e))
        : e.selection && (r = r.addSelection(e.startState.selection, l, f, n.newGroupDelay)),
      (o == 'full' || o == 'after') && (r = r.isolate()),
      r
    );
  },
  toJSON(r) {
    return { done: r.done.map((e) => e.toJSON()), undone: r.undone.map((e) => e.toJSON()) };
  },
  fromJSON(r) {
    return new HistoryState(r.done.map(HistEvent.fromJSON), r.undone.map(HistEvent.fromJSON));
  },
});
function history$1(r = {}) {
  return [
    historyField_,
    historyConfig.of(r),
    EditorView.domEventHandlers({
      beforeinput(e, n) {
        let s = e.inputType == 'historyUndo' ? undo : e.inputType == 'historyRedo' ? redo : null;
        return s ? (e.preventDefault(), s(n)) : !1;
      },
    }),
  ];
}
function cmd(r, e) {
  return function ({ state: n, dispatch: s }) {
    if (!e && n.readOnly) return !1;
    let o = n.field(historyField_, !1);
    if (!o) return !1;
    let a = o.pop(r, n, e);
    return a ? (s(a), !0) : !1;
  };
}
const undo = cmd(0, !1),
  redo = cmd(1, !1),
  undoSelection = cmd(0, !0),
  redoSelection = cmd(1, !0);
class HistEvent {
  constructor(e, n, s, o, a) {
    (this.changes = e), (this.effects = n), (this.mapped = s), (this.startSelection = o), (this.selectionsAfter = a);
  }
  setSelAfter(e) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, s;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (s = this.startSelection) === null || s === void 0 ? void 0 : s.toJSON(),
      selectionsAfter: this.selectionsAfter.map((o) => o.toJSON()),
    };
  }
  static fromJSON(e) {
    return new HistEvent(
      e.changes && ChangeSet.fromJSON(e.changes),
      [],
      e.mapped && ChangeDesc.fromJSON(e.mapped),
      e.startSelection && EditorSelection.fromJSON(e.startSelection),
      e.selectionsAfter.map(EditorSelection.fromJSON),
    );
  }
  static fromTransaction(e, n) {
    let s = none$1;
    for (let o of e.startState.facet(invertedEffects)) {
      let a = o(e);
      a.length && (s = s.concat(a));
    }
    return !s.length && e.changes.empty
      ? null
      : new HistEvent(e.changes.invert(e.startState.doc), s, void 0, n || e.startState.selection, none$1);
  }
  static selection(e) {
    return new HistEvent(void 0, none$1, void 0, void 0, e);
  }
}
function updateBranch(r, e, n, s) {
  let o = e + 1 > n + 20 ? e - n - 1 : 0,
    a = r.slice(o, e);
  return a.push(s), a;
}
function isAdjacent(r, e) {
  let n = [],
    s = !1;
  return (
    r.iterChangedRanges((o, a) => n.push(o, a)),
    e.iterChangedRanges((o, a, l, f) => {
      for (let m = 0; m < n.length; ) {
        let v = n[m++],
          I = n[m++];
        f >= v && l <= I && (s = !0);
      }
    }),
    s
  );
}
function eqSelectionShape(r, e) {
  return r.ranges.length == e.ranges.length && r.ranges.filter((n, s) => n.empty != e.ranges[s].empty).length === 0;
}
function conc(r, e) {
  return r.length ? (e.length ? r.concat(e) : r) : e;
}
const none$1 = [],
  MaxSelectionsPerEvent = 200;
function addSelection(r, e) {
  if (r.length) {
    let n = r[r.length - 1],
      s = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - MaxSelectionsPerEvent));
    return s.length && s[s.length - 1].eq(e) ? r : (s.push(e), updateBranch(r, r.length - 1, 1e9, n.setSelAfter(s)));
  } else return [HistEvent.selection([e])];
}
function popSelection(r) {
  let e = r[r.length - 1],
    n = r.slice();
  return (n[r.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1))), n;
}
function addMappingToBranch(r, e) {
  if (!r.length) return r;
  let n = r.length,
    s = none$1;
  for (; n; ) {
    let o = mapEvent(r[n - 1], e, s);
    if ((o.changes && !o.changes.empty) || o.effects.length) {
      let a = r.slice(0, n);
      return (a[n - 1] = o), a;
    } else (e = o.mapped), n--, (s = o.selectionsAfter);
  }
  return s.length ? [HistEvent.selection(s)] : none$1;
}
function mapEvent(r, e, n) {
  let s = conc(r.selectionsAfter.length ? r.selectionsAfter.map((f) => f.map(e)) : none$1, n);
  if (!r.changes) return HistEvent.selection(s);
  let o = r.changes.map(e),
    a = e.mapDesc(r.changes, !0),
    l = r.mapped ? r.mapped.composeDesc(a) : a;
  return new HistEvent(o, StateEffect.mapEffects(r.effects, e), l, r.startSelection.map(a), s);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
  constructor(e, n, s = 0, o = void 0) {
    (this.done = e), (this.undone = n), (this.prevTime = s), (this.prevUserEvent = o);
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }
  addChanges(e, n, s, o, a) {
    let l = this.done,
      f = l[l.length - 1];
    return (
      f &&
      f.changes &&
      !f.changes.empty &&
      e.changes &&
      (!s || joinableUserEvent.test(s)) &&
      ((!f.selectionsAfter.length &&
        n - this.prevTime < o.newGroupDelay &&
        o.joinToEvent(a, isAdjacent(f.changes, e.changes))) ||
        s == 'input.type.compose')
        ? (l = updateBranch(
            l,
            l.length - 1,
            o.minDepth,
            new HistEvent(e.changes.compose(f.changes), conc(e.effects, f.effects), f.mapped, f.startSelection, none$1),
          ))
        : (l = updateBranch(l, l.length, o.minDepth, e)),
      new HistoryState(l, none$1, n, s)
    );
  }
  addSelection(e, n, s, o) {
    let a = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$1;
    return a.length > 0 &&
      n - this.prevTime < o &&
      s == this.prevUserEvent &&
      s &&
      /^select($|\.)/.test(s) &&
      eqSelectionShape(a[a.length - 1], e)
      ? this
      : new HistoryState(addSelection(this.done, e), this.undone, n, s);
  }
  addMapping(e) {
    return new HistoryState(
      addMappingToBranch(this.done, e),
      addMappingToBranch(this.undone, e),
      this.prevTime,
      this.prevUserEvent,
    );
  }
  pop(e, n, s) {
    let o = e == 0 ? this.done : this.undone;
    if (o.length == 0) return null;
    let a = o[o.length - 1];
    if (s && a.selectionsAfter.length)
      return n.update({
        selection: a.selectionsAfter[a.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side: e, rest: popSelection(o) }),
        userEvent: e == 0 ? 'select.undo' : 'select.redo',
        scrollIntoView: !0,
      });
    if (a.changes) {
      let l = o.length == 1 ? none$1 : o.slice(0, o.length - 1);
      return (
        a.mapped && (l = addMappingToBranch(l, a.mapped)),
        n.update({
          changes: a.changes,
          selection: a.startSelection,
          effects: a.effects,
          annotations: fromHistory.of({ side: e, rest: l }),
          filter: !1,
          userEvent: e == 0 ? 'undo' : 'redo',
          scrollIntoView: !0,
        })
      );
    } else return null;
  }
}
HistoryState.empty = new HistoryState(none$1, none$1);
const historyKeymap = [
  { key: 'Mod-z', run: undo, preventDefault: !0 },
  { key: 'Mod-y', mac: 'Mod-Shift-z', run: redo, preventDefault: !0 },
  { linux: 'Ctrl-Shift-z', run: redo, preventDefault: !0 },
  { key: 'Mod-u', run: undoSelection, preventDefault: !0 },
  { key: 'Alt-u', mac: 'Mod-Shift-u', run: redoSelection, preventDefault: !0 },
];
function updateSel(r, e) {
  return EditorSelection.create(r.ranges.map(e), r.mainIndex);
}
function setSel(r, e) {
  return r.update({ selection: e, scrollIntoView: !0, userEvent: 'select' });
}
function moveSel({ state: r, dispatch: e }, n) {
  let s = updateSel(r.selection, n);
  return s.eq(r.selection) ? !1 : (e(setSel(r, s)), !0);
}
function rangeEnd(r, e) {
  return EditorSelection.cursor(e ? r.to : r.from);
}
function cursorByChar(r, e) {
  return moveSel(r, (n) => (n.empty ? r.moveByChar(n, e) : rangeEnd(n, e)));
}
function ltrAtCursor(r) {
  return r.textDirectionAt(r.state.selection.main.head) == Direction.LTR;
}
const cursorCharLeft = (r) => cursorByChar(r, !ltrAtCursor(r)),
  cursorCharRight = (r) => cursorByChar(r, ltrAtCursor(r));
function cursorByGroup(r, e) {
  return moveSel(r, (n) => (n.empty ? r.moveByGroup(n, e) : rangeEnd(n, e)));
}
const cursorGroupLeft = (r) => cursorByGroup(r, !ltrAtCursor(r)),
  cursorGroupRight = (r) => cursorByGroup(r, ltrAtCursor(r));
function interestingNode(r, e, n) {
  if (e.type.prop(n)) return !0;
  let s = e.to - e.from;
  return (s && (s > 2 || /[^\s,.;:]/.test(r.sliceDoc(e.from, e.to)))) || e.firstChild;
}
function moveBySyntax(r, e, n) {
  let s = syntaxTree(r).resolveInner(e.head),
    o = n ? NodeProp.closedBy : NodeProp.openedBy;
  for (let m = e.head; ; ) {
    let v = n ? s.childAfter(m) : s.childBefore(m);
    if (!v) break;
    interestingNode(r, v, o) ? (s = v) : (m = n ? v.to : v.from);
  }
  let a = s.type.prop(o),
    l,
    f;
  return (
    a && (l = n ? matchBrackets(r, s.from, 1) : matchBrackets(r, s.to, -1)) && l.matched
      ? (f = n ? l.end.to : l.end.from)
      : (f = n ? s.to : s.from),
    EditorSelection.cursor(f, n ? -1 : 1)
  );
}
const cursorSyntaxLeft = (r) => moveSel(r, (e) => moveBySyntax(r.state, e, !ltrAtCursor(r))),
  cursorSyntaxRight = (r) => moveSel(r, (e) => moveBySyntax(r.state, e, ltrAtCursor(r)));
function cursorByLine(r, e) {
  return moveSel(r, (n) => {
    if (!n.empty) return rangeEnd(n, e);
    let s = r.moveVertically(n, e);
    return s.head != n.head ? s : r.moveToLineBoundary(n, e);
  });
}
const cursorLineUp = (r) => cursorByLine(r, !1),
  cursorLineDown = (r) => cursorByLine(r, !0);
function pageInfo(r) {
  let e = r.scrollDOM.clientHeight < r.scrollDOM.scrollHeight - 2,
    n = 0,
    s = 0,
    o;
  if (e) {
    for (let a of r.state.facet(EditorView.scrollMargins)) {
      let l = a(r);
      l != null && l.top && (n = Math.max(l == null ? void 0 : l.top, n)),
        l != null && l.bottom && (s = Math.max(l == null ? void 0 : l.bottom, s));
    }
    o = r.scrollDOM.clientHeight - n - s;
  } else o = (r.dom.ownerDocument.defaultView || window).innerHeight;
  return { marginTop: n, marginBottom: s, selfScroll: e, height: Math.max(r.defaultLineHeight, o - 5) };
}
function cursorByPage(r, e) {
  let n = pageInfo(r),
    { state: s } = r,
    o = updateSel(s.selection, (l) => (l.empty ? r.moveVertically(l, e, n.height) : rangeEnd(l, e)));
  if (o.eq(s.selection)) return !1;
  let a;
  if (n.selfScroll) {
    let l = r.coordsAtPos(s.selection.main.head),
      f = r.scrollDOM.getBoundingClientRect(),
      m = f.top + n.marginTop,
      v = f.bottom - n.marginBottom;
    l && l.top > m && l.bottom < v && (a = EditorView.scrollIntoView(o.main.head, { y: 'start', yMargin: l.top - m }));
  }
  return r.dispatch(setSel(s, o), { effects: a }), !0;
}
const cursorPageUp = (r) => cursorByPage(r, !1),
  cursorPageDown = (r) => cursorByPage(r, !0);
function moveByLineBoundary(r, e, n) {
  let s = r.lineBlockAt(e.head),
    o = r.moveToLineBoundary(e, n);
  if (
    (o.head == e.head && o.head != (n ? s.to : s.from) && (o = r.moveToLineBoundary(e, n, !1)),
    !n && o.head == s.from && s.length)
  ) {
    let a = /^\s*/.exec(r.state.sliceDoc(s.from, Math.min(s.from + 100, s.to)))[0].length;
    a && e.head != s.from + a && (o = EditorSelection.cursor(s.from + a));
  }
  return o;
}
const cursorLineBoundaryForward = (r) => moveSel(r, (e) => moveByLineBoundary(r, e, !0)),
  cursorLineBoundaryBackward = (r) => moveSel(r, (e) => moveByLineBoundary(r, e, !1)),
  cursorLineBoundaryLeft = (r) => moveSel(r, (e) => moveByLineBoundary(r, e, !ltrAtCursor(r))),
  cursorLineBoundaryRight = (r) => moveSel(r, (e) => moveByLineBoundary(r, e, ltrAtCursor(r))),
  cursorLineStart = (r) => moveSel(r, (e) => EditorSelection.cursor(r.lineBlockAt(e.head).from, 1)),
  cursorLineEnd = (r) => moveSel(r, (e) => EditorSelection.cursor(r.lineBlockAt(e.head).to, -1));
function toMatchingBracket(r, e, n) {
  let s = !1,
    o = updateSel(r.selection, (a) => {
      let l =
        matchBrackets(r, a.head, -1) ||
        matchBrackets(r, a.head, 1) ||
        (a.head > 0 && matchBrackets(r, a.head - 1, 1)) ||
        (a.head < r.doc.length && matchBrackets(r, a.head + 1, -1));
      if (!l || !l.end) return a;
      s = !0;
      let f = l.start.from == a.head ? l.end.to : l.end.from;
      return n ? EditorSelection.range(a.anchor, f) : EditorSelection.cursor(f);
    });
  return s ? (e(setSel(r, o)), !0) : !1;
}
const cursorMatchingBracket = ({ state: r, dispatch: e }) => toMatchingBracket(r, e, !1);
function extendSel(r, e) {
  let n = updateSel(r.state.selection, (s) => {
    let o = e(s);
    return EditorSelection.range(s.anchor, o.head, o.goalColumn, o.bidiLevel || void 0);
  });
  return n.eq(r.state.selection) ? !1 : (r.dispatch(setSel(r.state, n)), !0);
}
function selectByChar(r, e) {
  return extendSel(r, (n) => r.moveByChar(n, e));
}
const selectCharLeft = (r) => selectByChar(r, !ltrAtCursor(r)),
  selectCharRight = (r) => selectByChar(r, ltrAtCursor(r));
function selectByGroup(r, e) {
  return extendSel(r, (n) => r.moveByGroup(n, e));
}
const selectGroupLeft = (r) => selectByGroup(r, !ltrAtCursor(r)),
  selectGroupRight = (r) => selectByGroup(r, ltrAtCursor(r)),
  selectSyntaxLeft = (r) => extendSel(r, (e) => moveBySyntax(r.state, e, !ltrAtCursor(r))),
  selectSyntaxRight = (r) => extendSel(r, (e) => moveBySyntax(r.state, e, ltrAtCursor(r)));
function selectByLine(r, e) {
  return extendSel(r, (n) => r.moveVertically(n, e));
}
const selectLineUp = (r) => selectByLine(r, !1),
  selectLineDown = (r) => selectByLine(r, !0);
function selectByPage(r, e) {
  return extendSel(r, (n) => r.moveVertically(n, e, pageInfo(r).height));
}
const selectPageUp = (r) => selectByPage(r, !1),
  selectPageDown = (r) => selectByPage(r, !0),
  selectLineBoundaryForward = (r) => extendSel(r, (e) => moveByLineBoundary(r, e, !0)),
  selectLineBoundaryBackward = (r) => extendSel(r, (e) => moveByLineBoundary(r, e, !1)),
  selectLineBoundaryLeft = (r) => extendSel(r, (e) => moveByLineBoundary(r, e, !ltrAtCursor(r))),
  selectLineBoundaryRight = (r) => extendSel(r, (e) => moveByLineBoundary(r, e, ltrAtCursor(r))),
  selectLineStart = (r) => extendSel(r, (e) => EditorSelection.cursor(r.lineBlockAt(e.head).from)),
  selectLineEnd = (r) => extendSel(r, (e) => EditorSelection.cursor(r.lineBlockAt(e.head).to)),
  cursorDocStart = ({ state: r, dispatch: e }) => (e(setSel(r, { anchor: 0 })), !0),
  cursorDocEnd = ({ state: r, dispatch: e }) => (e(setSel(r, { anchor: r.doc.length })), !0),
  selectDocStart = ({ state: r, dispatch: e }) => (e(setSel(r, { anchor: r.selection.main.anchor, head: 0 })), !0),
  selectDocEnd = ({ state: r, dispatch: e }) => (
    e(setSel(r, { anchor: r.selection.main.anchor, head: r.doc.length })), !0
  ),
  selectAll = ({ state: r, dispatch: e }) => (
    e(r.update({ selection: { anchor: 0, head: r.doc.length }, userEvent: 'select' })), !0
  ),
  selectLine = ({ state: r, dispatch: e }) => {
    let n = selectedLineBlocks(r).map(({ from: s, to: o }) => EditorSelection.range(s, Math.min(o + 1, r.doc.length)));
    return e(r.update({ selection: EditorSelection.create(n), userEvent: 'select' })), !0;
  },
  selectParentSyntax = ({ state: r, dispatch: e }) => {
    let n = updateSel(r.selection, (s) => {
      var o;
      let a = syntaxTree(r).resolveStack(s.from, 1);
      for (let l = a; l; l = l.next) {
        let { node: f } = l;
        if (
          ((f.from < s.from && f.to >= s.to) || (f.to > s.to && f.from <= s.from)) &&
          !((o = f.parent) === null || o === void 0) &&
          o.parent
        )
          return EditorSelection.range(f.to, f.from);
      }
      return s;
    });
    return e(setSel(r, n)), !0;
  },
  simplifySelection = ({ state: r, dispatch: e }) => {
    let n = r.selection,
      s = null;
    return (
      n.ranges.length > 1
        ? (s = EditorSelection.create([n.main]))
        : n.main.empty || (s = EditorSelection.create([EditorSelection.cursor(n.main.head)])),
      s ? (e(setSel(r, s)), !0) : !1
    );
  };
function deleteBy(r, e) {
  if (r.state.readOnly) return !1;
  let n = 'delete.selection',
    { state: s } = r,
    o = s.changeByRange((a) => {
      let { from: l, to: f } = a;
      if (l == f) {
        let m = e(a);
        m < l
          ? ((n = 'delete.backward'), (m = skipAtomic(r, m, !1)))
          : m > l && ((n = 'delete.forward'), (m = skipAtomic(r, m, !0))),
          (l = Math.min(l, m)),
          (f = Math.max(f, m));
      } else (l = skipAtomic(r, l, !1)), (f = skipAtomic(r, f, !0));
      return l == f
        ? { range: a }
        : { changes: { from: l, to: f }, range: EditorSelection.cursor(l, l < a.head ? -1 : 1) };
    });
  return o.changes.empty
    ? !1
    : (r.dispatch(
        s.update(o, {
          scrollIntoView: !0,
          userEvent: n,
          effects: n == 'delete.selection' ? EditorView.announce.of(s.phrase('Selection deleted')) : void 0,
        }),
      ),
      !0);
}
function skipAtomic(r, e, n) {
  if (r instanceof EditorView)
    for (let s of r.state.facet(EditorView.atomicRanges).map((o) => o(r)))
      s.between(e, e, (o, a) => {
        o < e && a > e && (e = n ? a : o);
      });
  return e;
}
const deleteByChar = (r, e) =>
    deleteBy(r, (n) => {
      let s = n.from,
        { state: o } = r,
        a = o.doc.lineAt(s),
        l,
        f;
      if (!e && s > a.from && s < a.from + 200 && !/[^ \t]/.test((l = a.text.slice(0, s - a.from)))) {
        if (l[l.length - 1] == '	') return s - 1;
        let m = countColumn(l, o.tabSize),
          v = m % getIndentUnit(o) || getIndentUnit(o);
        for (let I = 0; I < v && l[l.length - 1 - I] == ' '; I++) s--;
        f = s;
      } else
        (f = findClusterBreak(a.text, s - a.from, e, e) + a.from),
          f == s && a.number != (e ? o.doc.lines : 1) && (f += e ? 1 : -1);
      return f;
    }),
  deleteCharBackward = (r) => deleteByChar(r, !1),
  deleteCharForward = (r) => deleteByChar(r, !0),
  deleteByGroup = (r, e) =>
    deleteBy(r, (n) => {
      let s = n.head,
        { state: o } = r,
        a = o.doc.lineAt(s),
        l = o.charCategorizer(s);
      for (let f = null; ; ) {
        if (s == (e ? a.to : a.from)) {
          s == n.head && a.number != (e ? o.doc.lines : 1) && (s += e ? 1 : -1);
          break;
        }
        let m = findClusterBreak(a.text, s - a.from, e) + a.from,
          v = a.text.slice(Math.min(s, m) - a.from, Math.max(s, m) - a.from),
          I = l(v);
        if (f != null && I != f) break;
        (v != ' ' || s != n.head) && (f = I), (s = m);
      }
      return s;
    }),
  deleteGroupBackward = (r) => deleteByGroup(r, !1),
  deleteGroupForward = (r) => deleteByGroup(r, !0),
  deleteToLineEnd = (r) =>
    deleteBy(r, (e) => {
      let n = r.lineBlockAt(e.head).to;
      return e.head < n ? n : Math.min(r.state.doc.length, e.head + 1);
    }),
  deleteLineBoundaryBackward = (r) =>
    deleteBy(r, (e) => {
      let n = r.moveToLineBoundary(e, !1).head;
      return e.head > n ? n : Math.max(0, e.head - 1);
    }),
  deleteLineBoundaryForward = (r) =>
    deleteBy(r, (e) => {
      let n = r.moveToLineBoundary(e, !0).head;
      return e.head < n ? n : Math.min(r.state.doc.length, e.head + 1);
    }),
  splitLine = ({ state: r, dispatch: e }) => {
    if (r.readOnly) return !1;
    let n = r.changeByRange((s) => ({
      changes: { from: s.from, to: s.to, insert: Text.of(['', '']) },
      range: EditorSelection.cursor(s.from),
    }));
    return e(r.update(n, { scrollIntoView: !0, userEvent: 'input' })), !0;
  },
  transposeChars = ({ state: r, dispatch: e }) => {
    if (r.readOnly) return !1;
    let n = r.changeByRange((s) => {
      if (!s.empty || s.from == 0 || s.from == r.doc.length) return { range: s };
      let o = s.from,
        a = r.doc.lineAt(o),
        l = o == a.from ? o - 1 : findClusterBreak(a.text, o - a.from, !1) + a.from,
        f = o == a.to ? o + 1 : findClusterBreak(a.text, o - a.from, !0) + a.from;
      return {
        changes: { from: l, to: f, insert: r.doc.slice(o, f).append(r.doc.slice(l, o)) },
        range: EditorSelection.cursor(f),
      };
    });
    return n.changes.empty ? !1 : (e(r.update(n, { scrollIntoView: !0, userEvent: 'move.character' })), !0);
  };
function selectedLineBlocks(r) {
  let e = [],
    n = -1;
  for (let s of r.selection.ranges) {
    let o = r.doc.lineAt(s.from),
      a = r.doc.lineAt(s.to);
    if ((!s.empty && s.to == a.from && (a = r.doc.lineAt(s.to - 1)), n >= o.number)) {
      let l = e[e.length - 1];
      (l.to = a.to), l.ranges.push(s);
    } else e.push({ from: o.from, to: a.to, ranges: [s] });
    n = a.number + 1;
  }
  return e;
}
function moveLine(r, e, n) {
  if (r.readOnly) return !1;
  let s = [],
    o = [];
  for (let a of selectedLineBlocks(r)) {
    if (n ? a.to == r.doc.length : a.from == 0) continue;
    let l = r.doc.lineAt(n ? a.to + 1 : a.from - 1),
      f = l.length + 1;
    if (n) {
      s.push({ from: a.to, to: l.to }, { from: a.from, insert: l.text + r.lineBreak });
      for (let m of a.ranges)
        o.push(EditorSelection.range(Math.min(r.doc.length, m.anchor + f), Math.min(r.doc.length, m.head + f)));
    } else {
      s.push({ from: l.from, to: a.from }, { from: a.to, insert: r.lineBreak + l.text });
      for (let m of a.ranges) o.push(EditorSelection.range(m.anchor - f, m.head - f));
    }
  }
  return s.length
    ? (e(
        r.update({
          changes: s,
          scrollIntoView: !0,
          selection: EditorSelection.create(o, r.selection.mainIndex),
          userEvent: 'move.line',
        }),
      ),
      !0)
    : !1;
}
const moveLineUp = ({ state: r, dispatch: e }) => moveLine(r, e, !1),
  moveLineDown = ({ state: r, dispatch: e }) => moveLine(r, e, !0);
function copyLine(r, e, n) {
  if (r.readOnly) return !1;
  let s = [];
  for (let o of selectedLineBlocks(r))
    n
      ? s.push({ from: o.from, insert: r.doc.slice(o.from, o.to) + r.lineBreak })
      : s.push({ from: o.to, insert: r.lineBreak + r.doc.slice(o.from, o.to) });
  return e(r.update({ changes: s, scrollIntoView: !0, userEvent: 'input.copyline' })), !0;
}
const copyLineUp = ({ state: r, dispatch: e }) => copyLine(r, e, !1),
  copyLineDown = ({ state: r, dispatch: e }) => copyLine(r, e, !0),
  deleteLine = (r) => {
    if (r.state.readOnly) return !1;
    let { state: e } = r,
      n = e.changes(
        selectedLineBlocks(e).map(({ from: o, to: a }) => (o > 0 ? o-- : a < e.doc.length && a++, { from: o, to: a })),
      ),
      s = updateSel(e.selection, (o) => r.moveVertically(o, !0)).map(n);
    return r.dispatch({ changes: n, selection: s, scrollIntoView: !0, userEvent: 'delete.line' }), !0;
  };
function isBetweenBrackets(r, e) {
  if (/\(\)|\[\]|\{\}/.test(r.sliceDoc(e - 1, e + 1))) return { from: e, to: e };
  let n = syntaxTree(r).resolveInner(e),
    s = n.childBefore(e),
    o = n.childAfter(e),
    a;
  return s &&
    o &&
    s.to <= e &&
    o.from >= e &&
    (a = s.type.prop(NodeProp.closedBy)) &&
    a.indexOf(o.name) > -1 &&
    r.doc.lineAt(s.to).from == r.doc.lineAt(o.from).from &&
    !/\S/.test(r.sliceDoc(s.to, o.from))
    ? { from: s.to, to: o.from }
    : null;
}
const insertNewlineAndIndent = newlineAndIndent(!1),
  insertBlankLine = newlineAndIndent(!0);
function newlineAndIndent(r) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly) return !1;
    let s = e.changeByRange((o) => {
      let { from: a, to: l } = o,
        f = e.doc.lineAt(a),
        m = !r && a == l && isBetweenBrackets(e, a);
      r && (a = l = (l <= f.to ? f : e.doc.lineAt(l)).to);
      let v = new IndentContext(e, { simulateBreak: a, simulateDoubleBreak: !!m }),
        I = getIndentation(v, a);
      for (
        I == null && (I = countColumn(/^\s*/.exec(e.doc.lineAt(a).text)[0], e.tabSize));
        l < f.to && /\s/.test(f.text[l - f.from]);

      )
        l++;
      m ? ({ from: a, to: l } = m) : a > f.from && a < f.from + 100 && !/\S/.test(f.text.slice(0, a)) && (a = f.from);
      let L = ['', indentString(e, I)];
      return (
        m && L.push(indentString(e, v.lineIndent(f.from, -1))),
        { changes: { from: a, to: l, insert: Text.of(L) }, range: EditorSelection.cursor(a + 1 + L[1].length) }
      );
    });
    return n(e.update(s, { scrollIntoView: !0, userEvent: 'input' })), !0;
  };
}
function changeBySelectedLine(r, e) {
  let n = -1;
  return r.changeByRange((s) => {
    let o = [];
    for (let l = s.from; l <= s.to; ) {
      let f = r.doc.lineAt(l);
      f.number > n && (s.empty || s.to > f.from) && (e(f, o, s), (n = f.number)), (l = f.to + 1);
    }
    let a = r.changes(o);
    return { changes: o, range: EditorSelection.range(a.mapPos(s.anchor, 1), a.mapPos(s.head, 1)) };
  });
}
const indentSelection = ({ state: r, dispatch: e }) => {
    if (r.readOnly) return !1;
    let n = Object.create(null),
      s = new IndentContext(r, {
        overrideIndentation: (a) => {
          let l = n[a];
          return l ?? -1;
        },
      }),
      o = changeBySelectedLine(r, (a, l, f) => {
        let m = getIndentation(s, a.from);
        if (m == null) return;
        /\S/.test(a.text) || (m = 0);
        let v = /^\s*/.exec(a.text)[0],
          I = indentString(r, m);
        (v != I || f.from < a.from + v.length) &&
          ((n[a.from] = m), l.push({ from: a.from, to: a.from + v.length, insert: I }));
      });
    return o.changes.empty || e(r.update(o, { userEvent: 'indent' })), !0;
  },
  indentMore = ({ state: r, dispatch: e }) =>
    r.readOnly
      ? !1
      : (e(
          r.update(
            changeBySelectedLine(r, (n, s) => {
              s.push({ from: n.from, insert: r.facet(indentUnit) });
            }),
            { userEvent: 'input.indent' },
          ),
        ),
        !0),
  indentLess = ({ state: r, dispatch: e }) =>
    r.readOnly
      ? !1
      : (e(
          r.update(
            changeBySelectedLine(r, (n, s) => {
              let o = /^\s*/.exec(n.text)[0];
              if (!o) return;
              let a = countColumn(o, r.tabSize),
                l = 0,
                f = indentString(r, Math.max(0, a - getIndentUnit(r)));
              for (; l < o.length && l < f.length && o.charCodeAt(l) == f.charCodeAt(l); ) l++;
              s.push({ from: n.from + l, to: n.from + o.length, insert: f.slice(l) });
            }),
            { userEvent: 'delete.dedent' },
          ),
        ),
        !0),
  emacsStyleKeymap = [
    { key: 'Ctrl-b', run: cursorCharLeft, shift: selectCharLeft, preventDefault: !0 },
    { key: 'Ctrl-f', run: cursorCharRight, shift: selectCharRight },
    { key: 'Ctrl-p', run: cursorLineUp, shift: selectLineUp },
    { key: 'Ctrl-n', run: cursorLineDown, shift: selectLineDown },
    { key: 'Ctrl-a', run: cursorLineStart, shift: selectLineStart },
    { key: 'Ctrl-e', run: cursorLineEnd, shift: selectLineEnd },
    { key: 'Ctrl-d', run: deleteCharForward },
    { key: 'Ctrl-h', run: deleteCharBackward },
    { key: 'Ctrl-k', run: deleteToLineEnd },
    { key: 'Ctrl-Alt-h', run: deleteGroupBackward },
    { key: 'Ctrl-o', run: splitLine },
    { key: 'Ctrl-t', run: transposeChars },
    { key: 'Ctrl-v', run: cursorPageDown },
  ],
  standardKeymap = [
    { key: 'ArrowLeft', run: cursorCharLeft, shift: selectCharLeft, preventDefault: !0 },
    { key: 'Mod-ArrowLeft', mac: 'Alt-ArrowLeft', run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: !0 },
    { mac: 'Cmd-ArrowLeft', run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: !0 },
    { key: 'ArrowRight', run: cursorCharRight, shift: selectCharRight, preventDefault: !0 },
    {
      key: 'Mod-ArrowRight',
      mac: 'Alt-ArrowRight',
      run: cursorGroupRight,
      shift: selectGroupRight,
      preventDefault: !0,
    },
    { mac: 'Cmd-ArrowRight', run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: !0 },
    { key: 'ArrowUp', run: cursorLineUp, shift: selectLineUp, preventDefault: !0 },
    { mac: 'Cmd-ArrowUp', run: cursorDocStart, shift: selectDocStart },
    { mac: 'Ctrl-ArrowUp', run: cursorPageUp, shift: selectPageUp },
    { key: 'ArrowDown', run: cursorLineDown, shift: selectLineDown, preventDefault: !0 },
    { mac: 'Cmd-ArrowDown', run: cursorDocEnd, shift: selectDocEnd },
    { mac: 'Ctrl-ArrowDown', run: cursorPageDown, shift: selectPageDown },
    { key: 'PageUp', run: cursorPageUp, shift: selectPageUp },
    { key: 'PageDown', run: cursorPageDown, shift: selectPageDown },
    { key: 'Home', run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: !0 },
    { key: 'Mod-Home', run: cursorDocStart, shift: selectDocStart },
    { key: 'End', run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: !0 },
    { key: 'Mod-End', run: cursorDocEnd, shift: selectDocEnd },
    { key: 'Enter', run: insertNewlineAndIndent },
    { key: 'Mod-a', run: selectAll },
    { key: 'Backspace', run: deleteCharBackward, shift: deleteCharBackward },
    { key: 'Delete', run: deleteCharForward },
    { key: 'Mod-Backspace', mac: 'Alt-Backspace', run: deleteGroupBackward },
    { key: 'Mod-Delete', mac: 'Alt-Delete', run: deleteGroupForward },
    { mac: 'Mod-Backspace', run: deleteLineBoundaryBackward },
    { mac: 'Mod-Delete', run: deleteLineBoundaryForward },
  ].concat(emacsStyleKeymap.map((r) => ({ mac: r.key, run: r.run, shift: r.shift }))),
  defaultKeymap = [
    { key: 'Alt-ArrowLeft', mac: 'Ctrl-ArrowLeft', run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: 'Alt-ArrowRight', mac: 'Ctrl-ArrowRight', run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: 'Alt-ArrowUp', run: moveLineUp },
    { key: 'Shift-Alt-ArrowUp', run: copyLineUp },
    { key: 'Alt-ArrowDown', run: moveLineDown },
    { key: 'Shift-Alt-ArrowDown', run: copyLineDown },
    { key: 'Escape', run: simplifySelection },
    { key: 'Mod-Enter', run: insertBlankLine },
    { key: 'Alt-l', mac: 'Ctrl-l', run: selectLine },
    { key: 'Mod-i', run: selectParentSyntax, preventDefault: !0 },
    { key: 'Mod-[', run: indentLess },
    { key: 'Mod-]', run: indentMore },
    { key: 'Mod-Alt-\\', run: indentSelection },
    { key: 'Shift-Mod-k', run: deleteLine },
    { key: 'Shift-Mod-\\', run: cursorMatchingBracket },
    { key: 'Mod-/', run: toggleComment },
    { key: 'Alt-A', run: toggleBlockComment },
  ].concat(standardKeymap),
  indentWithTab = { key: 'Tab', run: indentMore, shift: indentLess };
function crelt() {
  var r = arguments[0];
  typeof r == 'string' && (r = document.createElement(r));
  var e = 1,
    n = arguments[1];
  if (n && typeof n == 'object' && n.nodeType == null && !Array.isArray(n)) {
    for (var s in n)
      if (Object.prototype.hasOwnProperty.call(n, s)) {
        var o = n[s];
        typeof o == 'string' ? r.setAttribute(s, o) : o != null && (r[s] = o);
      }
    e++;
  }
  for (; e < arguments.length; e++) add(r, arguments[e]);
  return r;
}
function add(r, e) {
  if (typeof e == 'string') r.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null) r.appendChild(e);
    else if (Array.isArray(e)) for (var n = 0; n < e.length; n++) add(r, e[n]);
    else throw new RangeError('Unsupported child node: ' + e);
}
const basicNormalize = typeof String.prototype.normalize == 'function' ? (r) => r.normalize('NFKD') : (r) => r;
class SearchCursor {
  constructor(e, n, s = 0, o = e.length, a, l) {
    (this.test = l),
      (this.value = { from: 0, to: 0 }),
      (this.done = !1),
      (this.matches = []),
      (this.buffer = ''),
      (this.bufferPos = 0),
      (this.iter = e.iterRange(s, o)),
      (this.bufferStart = s),
      (this.normalize = a ? (f) => a(basicNormalize(f)) : basicNormalize),
      (this.query = this.normalize(n));
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (((this.bufferStart += this.buffer.length), this.iter.next(), this.iter.done)) return -1;
      (this.bufferPos = 0), (this.buffer = this.iter.value);
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  next() {
    for (; this.matches.length; ) this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (;;) {
      let e = this.peek();
      if (e < 0) return (this.done = !0), this;
      let n = fromCodePoint(e),
        s = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(e);
      let o = this.normalize(n);
      for (let a = 0, l = s; ; a++) {
        let f = o.charCodeAt(a),
          m = this.match(f, l);
        if (a == o.length - 1) {
          if (m) return (this.value = m), this;
          break;
        }
        l == s && a < n.length && n.charCodeAt(a) == f && l++;
      }
    }
  }
  match(e, n) {
    let s = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let a = this.matches[o],
        l = !1;
      this.query.charCodeAt(a) == e &&
        (a == this.query.length - 1 ? (s = { from: this.matches[o + 1], to: n + 1 }) : (this.matches[o]++, (l = !0))),
        l || (this.matches.splice(o, 2), (o -= 2));
    }
    return (
      this.query.charCodeAt(0) == e &&
        (this.query.length == 1 ? (s = { from: n, to: n + 1 }) : this.matches.push(1, n)),
      s && this.test && !this.test(s.from, s.to, this.buffer, this.bufferStart) && (s = null),
      s
    );
  }
}
typeof Symbol < 'u' &&
  (SearchCursor.prototype[Symbol.iterator] = function () {
    return this;
  });
const empty = { from: -1, to: -1, match: /.*/.exec('') },
  baseFlags = 'gm' + (/x/.unicode == null ? '' : 'u');
class RegExpCursor {
  constructor(e, n, s, o = 0, a = e.length) {
    if (
      ((this.text = e),
      (this.to = a),
      (this.curLine = ''),
      (this.done = !1),
      (this.value = empty),
      /\\[sWDnr]|\n|\r|\[\^/.test(n))
    )
      return new MultilineRegExpCursor(e, n, s, o, a);
    (this.re = new RegExp(n, baseFlags + (s != null && s.ignoreCase ? 'i' : ''))),
      (this.test = s == null ? void 0 : s.test),
      (this.iter = e.iter());
    let l = e.lineAt(o);
    (this.curLineStart = l.from), (this.matchPos = toCharEnd(e, o)), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e),
      this.iter.lineBreak
        ? (this.curLine = '')
        : ((this.curLine = this.iter.value),
          this.curLineStart + this.curLine.length > this.to &&
            (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)),
          this.iter.next());
  }
  nextLine() {
    (this.curLineStart = this.curLineStart + this.curLine.length + 1),
      this.curLineStart > this.to ? (this.curLine = '') : this.getLine(0);
  }
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let s = this.curLineStart + n.index,
          o = s + n[0].length;
        if (
          ((this.matchPos = toCharEnd(this.text, o + (s == o ? 1 : 0))),
          s == this.curLineStart + this.curLine.length && this.nextLine(),
          (s < o || s > this.value.to) && (!this.test || this.test(s, o, n)))
        )
          return (this.value = { from: s, to: o, match: n }), this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) this.nextLine(), (e = 0);
      else return (this.done = !0), this;
    }
  }
}
const flattened = new WeakMap();
class FlattenedDoc {
  constructor(e, n) {
    (this.from = e), (this.text = n);
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, s) {
    let o = flattened.get(e);
    if (!o || o.from >= s || o.to <= n) {
      let f = new FlattenedDoc(n, e.sliceString(n, s));
      return flattened.set(e, f), f;
    }
    if (o.from == n && o.to == s) return o;
    let { text: a, from: l } = o;
    return (
      l > n && ((a = e.sliceString(n, l) + a), (l = n)),
      o.to < s && (a += e.sliceString(o.to, s)),
      flattened.set(e, new FlattenedDoc(l, a)),
      new FlattenedDoc(n, a.slice(n - l, s - l))
    );
  }
}
class MultilineRegExpCursor {
  constructor(e, n, s, o, a) {
    (this.text = e),
      (this.to = a),
      (this.done = !1),
      (this.value = empty),
      (this.matchPos = toCharEnd(e, o)),
      (this.re = new RegExp(n, baseFlags + (s != null && s.ignoreCase ? 'i' : ''))),
      (this.test = s == null ? void 0 : s.test),
      (this.flat = FlattenedDoc.get(e, o, this.chunkEnd(o + 5e3)));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (;;) {
      let e = (this.re.lastIndex = this.matchPos - this.flat.from),
        n = this.re.exec(this.flat.text);
      if ((n && !n[0] && n.index == e && ((this.re.lastIndex = e + 1), (n = this.re.exec(this.flat.text))), n)) {
        let s = this.flat.from + n.index,
          o = s + n[0].length;
        if (
          (this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) &&
          (!this.test || this.test(s, o, n))
        )
          return (
            (this.value = { from: s, to: o, match: n }),
            (this.matchPos = toCharEnd(this.text, o + (s == o ? 1 : 0))),
            this
          );
      }
      if (this.flat.to == this.to) return (this.done = !0), this;
      this.flat = FlattenedDoc.get(
        this.text,
        this.flat.from,
        this.chunkEnd(this.flat.from + this.flat.text.length * 2),
      );
    }
  }
}
typeof Symbol < 'u' &&
  (RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =
    function () {
      return this;
    });
function validRegExp(r) {
  try {
    return new RegExp(r, baseFlags), !0;
  } catch {
    return !1;
  }
}
function toCharEnd(r, e) {
  if (e >= r.length) return e;
  let n = r.lineAt(e),
    s;
  for (; e < n.to && (s = n.text.charCodeAt(e - n.from)) >= 56320 && s < 57344; ) e++;
  return e;
}
function createLineDialog(r) {
  let e = String(r.state.doc.lineAt(r.state.selection.main.head).number),
    n = crelt('input', { class: 'cm-textfield', name: 'line', value: e }),
    s = crelt(
      'form',
      {
        class: 'cm-gotoLine',
        onkeydown: (a) => {
          a.keyCode == 27
            ? (a.preventDefault(), r.dispatch({ effects: dialogEffect.of(!1) }), r.focus())
            : a.keyCode == 13 && (a.preventDefault(), o());
        },
        onsubmit: (a) => {
          a.preventDefault(), o();
        },
      },
      crelt('label', r.state.phrase('Go to line'), ': ', n),
      ' ',
      crelt('button', { class: 'cm-button', type: 'submit' }, r.state.phrase('go')),
    );
  function o() {
    let a = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!a) return;
    let { state: l } = r,
      f = l.doc.lineAt(l.selection.main.head),
      [, m, v, I, L] = a,
      V = I ? +I.slice(1) : 0,
      se = v ? +v : f.number;
    if (v && L) {
      let ar = se / 100;
      m && (ar = ar * (m == '-' ? -1 : 1) + f.number / l.doc.lines), (se = Math.round(l.doc.lines * ar));
    } else v && m && (se = se * (m == '-' ? -1 : 1) + f.number);
    let Ee = l.doc.line(Math.max(1, Math.min(l.doc.lines, se))),
      ht = EditorSelection.cursor(Ee.from + Math.max(0, Math.min(V, Ee.length)));
    r.dispatch({ effects: [dialogEffect.of(!1), EditorView.scrollIntoView(ht.from, { y: 'center' })], selection: ht }),
      r.focus();
  }
  return { dom: s };
}
const dialogEffect = StateEffect.define(),
  dialogField = StateField.define({
    create() {
      return !0;
    },
    update(r, e) {
      for (let n of e.effects) n.is(dialogEffect) && (r = n.value);
      return r;
    },
    provide: (r) => showPanel.from(r, (e) => (e ? createLineDialog : null)),
  }),
  gotoLine = (r) => {
    let e = getPanel(r, createLineDialog);
    if (!e) {
      let n = [dialogEffect.of(!0)];
      r.state.field(dialogField, !1) == null && n.push(StateEffect.appendConfig.of([dialogField, baseTheme$1$1])),
        r.dispatch({ effects: n }),
        (e = getPanel(r, createLineDialog));
    }
    return e && e.dom.querySelector('input').select(), !0;
  },
  baseTheme$1$1 = EditorView.baseTheme({
    '.cm-panel.cm-gotoLine': { 'padding': '2px 6px 4px', '& label': { fontSize: '80%' } },
  }),
  defaultHighlightOptions = { highlightWordAroundCursor: !1, minSelectionLength: 1, maxMatches: 100, wholeWords: !1 },
  highlightConfig = Facet.define({
    combine(r) {
      return combineConfig(r, defaultHighlightOptions, {
        highlightWordAroundCursor: (e, n) => e || n,
        minSelectionLength: Math.min,
        maxMatches: Math.min,
      });
    },
  });
function highlightSelectionMatches(r) {
  let e = [defaultTheme, matchHighlighter];
  return r && e.push(highlightConfig.of(r)), e;
}
const matchDeco = Decoration.mark({ class: 'cm-selectionMatch' }),
  mainMatchDeco = Decoration.mark({ class: 'cm-selectionMatch cm-selectionMatch-main' });
function insideWordBoundaries(r, e, n, s) {
  return (
    (n == 0 || r(e.sliceDoc(n - 1, n)) != CharCategory.Word) &&
    (s == e.doc.length || r(e.sliceDoc(s, s + 1)) != CharCategory.Word)
  );
}
function insideWord(r, e, n, s) {
  return r(e.sliceDoc(n, n + 1)) == CharCategory.Word && r(e.sliceDoc(s - 1, s)) == CharCategory.Word;
}
const matchHighlighter = ViewPlugin.fromClass(
    class {
      constructor(r) {
        this.decorations = this.getDeco(r);
      }
      update(r) {
        (r.selectionSet || r.docChanged || r.viewportChanged) && (this.decorations = this.getDeco(r.view));
      }
      getDeco(r) {
        let e = r.state.facet(highlightConfig),
          { state: n } = r,
          s = n.selection;
        if (s.ranges.length > 1) return Decoration.none;
        let o = s.main,
          a,
          l = null;
        if (o.empty) {
          if (!e.highlightWordAroundCursor) return Decoration.none;
          let m = n.wordAt(o.head);
          if (!m) return Decoration.none;
          (l = n.charCategorizer(o.head)), (a = n.sliceDoc(m.from, m.to));
        } else {
          let m = o.to - o.from;
          if (m < e.minSelectionLength || m > 200) return Decoration.none;
          if (e.wholeWords) {
            if (
              ((a = n.sliceDoc(o.from, o.to)),
              (l = n.charCategorizer(o.head)),
              !(insideWordBoundaries(l, n, o.from, o.to) && insideWord(l, n, o.from, o.to)))
            )
              return Decoration.none;
          } else if (((a = n.sliceDoc(o.from, o.to).trim()), !a)) return Decoration.none;
        }
        let f = [];
        for (let m of r.visibleRanges) {
          let v = new SearchCursor(n.doc, a, m.from, m.to);
          for (; !v.next().done; ) {
            let { from: I, to: L } = v.value;
            if (
              (!l || insideWordBoundaries(l, n, I, L)) &&
              (o.empty && I <= o.from && L >= o.to
                ? f.push(mainMatchDeco.range(I, L))
                : (I >= o.to || L <= o.from) && f.push(matchDeco.range(I, L)),
              f.length > e.maxMatches)
            )
              return Decoration.none;
          }
        }
        return Decoration.set(f);
      }
    },
    { decorations: (r) => r.decorations },
  ),
  defaultTheme = EditorView.baseTheme({
    '.cm-selectionMatch': { backgroundColor: '#99ff7780' },
    '.cm-searchMatch .cm-selectionMatch': { backgroundColor: 'transparent' },
  }),
  selectWord = ({ state: r, dispatch: e }) => {
    let { selection: n } = r,
      s = EditorSelection.create(
        n.ranges.map((o) => r.wordAt(o.head) || EditorSelection.cursor(o.head)),
        n.mainIndex,
      );
    return s.eq(n) ? !1 : (e(r.update({ selection: s })), !0);
  };
function findNextOccurrence(r, e) {
  let { main: n, ranges: s } = r.selection,
    o = r.wordAt(n.head),
    a = o && o.from == n.from && o.to == n.to;
  for (let l = !1, f = new SearchCursor(r.doc, e, s[s.length - 1].to); ; )
    if ((f.next(), f.done)) {
      if (l) return null;
      (f = new SearchCursor(r.doc, e, 0, Math.max(0, s[s.length - 1].from - 1))), (l = !0);
    } else {
      if (l && s.some((m) => m.from == f.value.from)) continue;
      if (a) {
        let m = r.wordAt(f.value.from);
        if (!m || m.from != f.value.from || m.to != f.value.to) continue;
      }
      return f.value;
    }
}
const selectNextOccurrence = ({ state: r, dispatch: e }) => {
    let { ranges: n } = r.selection;
    if (n.some((a) => a.from === a.to)) return selectWord({ state: r, dispatch: e });
    let s = r.sliceDoc(n[0].from, n[0].to);
    if (r.selection.ranges.some((a) => r.sliceDoc(a.from, a.to) != s)) return !1;
    let o = findNextOccurrence(r, s);
    return o
      ? (e(
          r.update({
            selection: r.selection.addRange(EditorSelection.range(o.from, o.to), !1),
            effects: EditorView.scrollIntoView(o.to),
          }),
        ),
        !0)
      : !1;
  },
  searchConfigFacet = Facet.define({
    combine(r) {
      return combineConfig(r, {
        top: !1,
        caseSensitive: !1,
        literal: !1,
        regexp: !1,
        wholeWord: !1,
        createPanel: (e) => new SearchPanel(e),
        scrollToMatch: (e) => EditorView.scrollIntoView(e),
      });
    },
  });
class SearchQuery {
  constructor(e) {
    (this.search = e.search),
      (this.caseSensitive = !!e.caseSensitive),
      (this.literal = !!e.literal),
      (this.regexp = !!e.regexp),
      (this.replace = e.replace || ''),
      (this.valid = !!this.search && (!this.regexp || validRegExp(this.search))),
      (this.unquoted = this.unquote(this.search)),
      (this.wholeWord = !!e.wholeWord);
  }
  unquote(e) {
    return this.literal
      ? e
      : e.replace(/\\([nrt\\])/g, (n, s) =>
          s == 'n'
            ? `
`
            : s == 'r'
            ? '\r'
            : s == 't'
            ? '	'
            : '\\',
        );
  }
  eq(e) {
    return (
      this.search == e.search &&
      this.replace == e.replace &&
      this.caseSensitive == e.caseSensitive &&
      this.regexp == e.regexp &&
      this.wholeWord == e.wholeWord
    );
  }
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  getCursor(e, n = 0, s) {
    let o = e.doc ? e : EditorState.create({ doc: e });
    return s == null && (s = o.doc.length), this.regexp ? regexpCursor(this, o, n, s) : stringCursor(this, o, n, s);
  }
}
class QueryType {
  constructor(e) {
    this.spec = e;
  }
}
function stringCursor(r, e, n, s) {
  return new SearchCursor(
    e.doc,
    r.unquoted,
    n,
    s,
    r.caseSensitive ? void 0 : (o) => o.toLowerCase(),
    r.wholeWord ? stringWordTest(e.doc, e.charCategorizer(e.selection.main.head)) : void 0,
  );
}
function stringWordTest(r, e) {
  return (n, s, o, a) => (
    (a > n || a + o.length < s) && ((a = Math.max(0, n - 2)), (o = r.sliceString(a, Math.min(r.length, s + 2)))),
    (e(charBefore(o, n - a)) != CharCategory.Word || e(charAfter(o, n - a)) != CharCategory.Word) &&
      (e(charAfter(o, s - a)) != CharCategory.Word || e(charBefore(o, s - a)) != CharCategory.Word)
  );
}
class StringQuery extends QueryType {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, s) {
    let o = stringCursor(this.spec, e, s, e.doc.length).nextOverlapping();
    return o.done && (o = stringCursor(this.spec, e, 0, n).nextOverlapping()), o.done ? null : o.value;
  }
  prevMatchInRange(e, n, s) {
    for (let o = s; ; ) {
      let a = Math.max(n, o - 1e4 - this.spec.unquoted.length),
        l = stringCursor(this.spec, e, a, o),
        f = null;
      for (; !l.nextOverlapping().done; ) f = l.value;
      if (f) return f;
      if (a == n) return null;
      o -= 1e4;
    }
  }
  prevMatch(e, n, s) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, s, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let s = stringCursor(this.spec, e, 0, e.doc.length),
      o = [];
    for (; !s.next().done; ) {
      if (o.length >= n) return null;
      o.push(s.value);
    }
    return o;
  }
  highlight(e, n, s, o) {
    let a = stringCursor(
      this.spec,
      e,
      Math.max(0, n - this.spec.unquoted.length),
      Math.min(s + this.spec.unquoted.length, e.doc.length),
    );
    for (; !a.next().done; ) o(a.value.from, a.value.to);
  }
}
function regexpCursor(r, e, n, s) {
  return new RegExpCursor(
    e.doc,
    r.search,
    {
      ignoreCase: !r.caseSensitive,
      test: r.wholeWord ? regexpWordTest(e.charCategorizer(e.selection.main.head)) : void 0,
    },
    n,
    s,
  );
}
function charBefore(r, e) {
  return r.slice(findClusterBreak(r, e, !1), e);
}
function charAfter(r, e) {
  return r.slice(e, findClusterBreak(r, e));
}
function regexpWordTest(r) {
  return (e, n, s) =>
    !s[0].length ||
    ((r(charBefore(s.input, s.index)) != CharCategory.Word || r(charAfter(s.input, s.index)) != CharCategory.Word) &&
      (r(charAfter(s.input, s.index + s[0].length)) != CharCategory.Word ||
        r(charBefore(s.input, s.index + s[0].length)) != CharCategory.Word));
}
class RegExpQuery extends QueryType {
  nextMatch(e, n, s) {
    let o = regexpCursor(this.spec, e, s, e.doc.length).next();
    return o.done && (o = regexpCursor(this.spec, e, 0, n).next()), o.done ? null : o.value;
  }
  prevMatchInRange(e, n, s) {
    for (let o = 1; ; o++) {
      let a = Math.max(n, s - o * 1e4),
        l = regexpCursor(this.spec, e, a, s),
        f = null;
      for (; !l.next().done; ) f = l.value;
      if (f && (a == n || f.from > a + 10)) return f;
      if (a == n) return null;
    }
  }
  prevMatch(e, n, s) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, s, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(
      this.spec.replace.replace(/\$([$&\d+])/g, (n, s) =>
        s == '$' ? '$' : s == '&' ? e.match[0] : s != '0' && +s < e.match.length ? e.match[s] : n,
      ),
    );
  }
  matchAll(e, n) {
    let s = regexpCursor(this.spec, e, 0, e.doc.length),
      o = [];
    for (; !s.next().done; ) {
      if (o.length >= n) return null;
      o.push(s.value);
    }
    return o;
  }
  highlight(e, n, s, o) {
    let a = regexpCursor(this.spec, e, Math.max(0, n - 250), Math.min(s + 250, e.doc.length));
    for (; !a.next().done; ) o(a.value.from, a.value.to);
  }
}
const setSearchQuery = StateEffect.define(),
  togglePanel$1 = StateEffect.define(),
  searchState = StateField.define({
    create(r) {
      return new SearchState(defaultQuery(r).create(), null);
    },
    update(r, e) {
      for (let n of e.effects)
        n.is(setSearchQuery)
          ? (r = new SearchState(n.value.create(), r.panel))
          : n.is(togglePanel$1) && (r = new SearchState(r.query, n.value ? createSearchPanel : null));
      return r;
    },
    provide: (r) => showPanel.from(r, (e) => e.panel),
  });
class SearchState {
  constructor(e, n) {
    (this.query = e), (this.panel = n);
  }
}
const matchMark = Decoration.mark({ class: 'cm-searchMatch' }),
  selectedMatchMark = Decoration.mark({ class: 'cm-searchMatch cm-searchMatch-selected' }),
  searchHighlighter = ViewPlugin.fromClass(
    class {
      constructor(r) {
        (this.view = r), (this.decorations = this.highlight(r.state.field(searchState)));
      }
      update(r) {
        let e = r.state.field(searchState);
        (e != r.startState.field(searchState) || r.docChanged || r.selectionSet || r.viewportChanged) &&
          (this.decorations = this.highlight(e));
      }
      highlight({ query: r, panel: e }) {
        if (!e || !r.spec.valid) return Decoration.none;
        let { view: n } = this,
          s = new RangeSetBuilder();
        for (let o = 0, a = n.visibleRanges, l = a.length; o < l; o++) {
          let { from: f, to: m } = a[o];
          for (; o < l - 1 && m > a[o + 1].from - 2 * 250; ) m = a[++o].to;
          r.highlight(n.state, f, m, (v, I) => {
            let L = n.state.selection.ranges.some((V) => V.from == v && V.to == I);
            s.add(v, I, L ? selectedMatchMark : matchMark);
          });
        }
        return s.finish();
      }
    },
    { decorations: (r) => r.decorations },
  );
function searchCommand(r) {
  return (e) => {
    let n = e.state.field(searchState, !1);
    return n && n.query.spec.valid ? r(e, n) : openSearchPanel(e);
  };
}
const findNext = searchCommand((r, { query: e }) => {
    let { to: n } = r.state.selection.main,
      s = e.nextMatch(r.state, n, n);
    if (!s) return !1;
    let o = EditorSelection.single(s.from, s.to),
      a = r.state.facet(searchConfigFacet);
    return (
      r.dispatch({
        selection: o,
        effects: [announceMatch(r, s), a.scrollToMatch(o.main, r)],
        userEvent: 'select.search',
      }),
      selectSearchInput(r),
      !0
    );
  }),
  findPrevious = searchCommand((r, { query: e }) => {
    let { state: n } = r,
      { from: s } = n.selection.main,
      o = e.prevMatch(n, s, s);
    if (!o) return !1;
    let a = EditorSelection.single(o.from, o.to),
      l = r.state.facet(searchConfigFacet);
    return (
      r.dispatch({
        selection: a,
        effects: [announceMatch(r, o), l.scrollToMatch(a.main, r)],
        userEvent: 'select.search',
      }),
      selectSearchInput(r),
      !0
    );
  }),
  selectMatches = searchCommand((r, { query: e }) => {
    let n = e.matchAll(r.state, 1e3);
    return !n || !n.length
      ? !1
      : (r.dispatch({
          selection: EditorSelection.create(n.map((s) => EditorSelection.range(s.from, s.to))),
          userEvent: 'select.search.matches',
        }),
        !0);
  }),
  selectSelectionMatches = ({ state: r, dispatch: e }) => {
    let n = r.selection;
    if (n.ranges.length > 1 || n.main.empty) return !1;
    let { from: s, to: o } = n.main,
      a = [],
      l = 0;
    for (let f = new SearchCursor(r.doc, r.sliceDoc(s, o)); !f.next().done; ) {
      if (a.length > 1e3) return !1;
      f.value.from == s && (l = a.length), a.push(EditorSelection.range(f.value.from, f.value.to));
    }
    return e(r.update({ selection: EditorSelection.create(a, l), userEvent: 'select.search.matches' })), !0;
  },
  replaceNext = searchCommand((r, { query: e }) => {
    let { state: n } = r,
      { from: s, to: o } = n.selection.main;
    if (n.readOnly) return !1;
    let a = e.nextMatch(n, s, s);
    if (!a) return !1;
    let l = [],
      f,
      m,
      v = [];
    if (
      (a.from == s &&
        a.to == o &&
        ((m = n.toText(e.getReplacement(a))),
        l.push({ from: a.from, to: a.to, insert: m }),
        (a = e.nextMatch(n, a.from, a.to)),
        v.push(EditorView.announce.of(n.phrase('replaced match on line $', n.doc.lineAt(s).number) + '.'))),
      a)
    ) {
      let I = l.length == 0 || l[0].from >= a.to ? 0 : a.to - a.from - m.length;
      (f = EditorSelection.single(a.from - I, a.to - I)),
        v.push(announceMatch(r, a)),
        v.push(n.facet(searchConfigFacet).scrollToMatch(f.main, r));
    }
    return r.dispatch({ changes: l, selection: f, effects: v, userEvent: 'input.replace' }), !0;
  }),
  replaceAll = searchCommand((r, { query: e }) => {
    if (r.state.readOnly) return !1;
    let n = e.matchAll(r.state, 1e9).map((o) => {
      let { from: a, to: l } = o;
      return { from: a, to: l, insert: e.getReplacement(o) };
    });
    if (!n.length) return !1;
    let s = r.state.phrase('replaced $ matches', n.length) + '.';
    return r.dispatch({ changes: n, effects: EditorView.announce.of(s), userEvent: 'input.replace.all' }), !0;
  });
function createSearchPanel(r) {
  return r.state.facet(searchConfigFacet).createPanel(r);
}
function defaultQuery(r, e) {
  var n, s, o, a, l;
  let f = r.selection.main,
    m = f.empty || f.to > f.from + 100 ? '' : r.sliceDoc(f.from, f.to);
  if (e && !m) return e;
  let v = r.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : v.literal)
      ? m
      : m.replace(/\n/g, '\\n'),
    caseSensitive: (s = e == null ? void 0 : e.caseSensitive) !== null && s !== void 0 ? s : v.caseSensitive,
    literal: (o = e == null ? void 0 : e.literal) !== null && o !== void 0 ? o : v.literal,
    regexp: (a = e == null ? void 0 : e.regexp) !== null && a !== void 0 ? a : v.regexp,
    wholeWord: (l = e == null ? void 0 : e.wholeWord) !== null && l !== void 0 ? l : v.wholeWord,
  });
}
function getSearchInput(r) {
  let e = getPanel(r, createSearchPanel);
  return e && e.dom.querySelector('[main-field]');
}
function selectSearchInput(r) {
  let e = getSearchInput(r);
  e && e == r.root.activeElement && e.select();
}
const openSearchPanel = (r) => {
    let e = r.state.field(searchState, !1);
    if (e && e.panel) {
      let n = getSearchInput(r);
      if (n && n != r.root.activeElement) {
        let s = defaultQuery(r.state, e.query.spec);
        s.valid && r.dispatch({ effects: setSearchQuery.of(s) }), n.focus(), n.select();
      }
    } else
      r.dispatch({
        effects: [
          togglePanel$1.of(!0),
          e ? setSearchQuery.of(defaultQuery(r.state, e.query.spec)) : StateEffect.appendConfig.of(searchExtensions),
        ],
      });
    return !0;
  },
  closeSearchPanel = (r) => {
    let e = r.state.field(searchState, !1);
    if (!e || !e.panel) return !1;
    let n = getPanel(r, createSearchPanel);
    return n && n.dom.contains(r.root.activeElement) && r.focus(), r.dispatch({ effects: togglePanel$1.of(!1) }), !0;
  },
  searchKeymap = [
    { key: 'Mod-f', run: openSearchPanel, scope: 'editor search-panel' },
    { key: 'F3', run: findNext, shift: findPrevious, scope: 'editor search-panel', preventDefault: !0 },
    { key: 'Mod-g', run: findNext, shift: findPrevious, scope: 'editor search-panel', preventDefault: !0 },
    { key: 'Escape', run: closeSearchPanel, scope: 'editor search-panel' },
    { key: 'Mod-Shift-l', run: selectSelectionMatches },
    { key: 'Alt-g', run: gotoLine },
    { key: 'Mod-d', run: selectNextOccurrence, preventDefault: !0 },
  ];
class SearchPanel {
  constructor(e) {
    this.view = e;
    let n = (this.query = e.state.field(searchState).query.spec);
    (this.commit = this.commit.bind(this)),
      (this.searchField = crelt('input', {
        'value': n.search,
        'placeholder': phrase(e, 'Find'),
        'aria-label': phrase(e, 'Find'),
        'class': 'cm-textfield',
        'name': 'search',
        'form': '',
        'main-field': 'true',
        'onchange': this.commit,
        'onkeyup': this.commit,
      })),
      (this.replaceField = crelt('input', {
        'value': n.replace,
        'placeholder': phrase(e, 'Replace'),
        'aria-label': phrase(e, 'Replace'),
        'class': 'cm-textfield',
        'name': 'replace',
        'form': '',
        'onchange': this.commit,
        'onkeyup': this.commit,
      })),
      (this.caseField = crelt('input', {
        type: 'checkbox',
        name: 'case',
        form: '',
        checked: n.caseSensitive,
        onchange: this.commit,
      })),
      (this.reField = crelt('input', {
        type: 'checkbox',
        name: 're',
        form: '',
        checked: n.regexp,
        onchange: this.commit,
      })),
      (this.wordField = crelt('input', {
        type: 'checkbox',
        name: 'word',
        form: '',
        checked: n.wholeWord,
        onchange: this.commit,
      }));
    function s(o, a, l) {
      return crelt('button', { class: 'cm-button', name: o, onclick: a, type: 'button' }, l);
    }
    this.dom = crelt('div', { onkeydown: (o) => this.keydown(o), class: 'cm-search' }, [
      this.searchField,
      s('next', () => findNext(e), [phrase(e, 'next')]),
      s('prev', () => findPrevious(e), [phrase(e, 'previous')]),
      s('select', () => selectMatches(e), [phrase(e, 'all')]),
      crelt('label', null, [this.caseField, phrase(e, 'match case')]),
      crelt('label', null, [this.reField, phrase(e, 'regexp')]),
      crelt('label', null, [this.wordField, phrase(e, 'by word')]),
      ...(e.state.readOnly
        ? []
        : [
            crelt('br'),
            this.replaceField,
            s('replace', () => replaceNext(e), [phrase(e, 'replace')]),
            s('replaceAll', () => replaceAll(e), [phrase(e, 'replace all')]),
          ]),
      crelt(
        'button',
        { 'name': 'close', 'onclick': () => closeSearchPanel(e), 'aria-label': phrase(e, 'close'), 'type': 'button' },
        ['×'],
      ),
    ]);
  }
  commit() {
    let e = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value,
    });
    e.eq(this.query) || ((this.query = e), this.view.dispatch({ effects: setSearchQuery.of(e) }));
  }
  keydown(e) {
    runScopeHandlers(this.view, e, 'search-panel')
      ? e.preventDefault()
      : e.keyCode == 13 && e.target == this.searchField
      ? (e.preventDefault(), (e.shiftKey ? findPrevious : findNext)(this.view))
      : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), replaceNext(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let s of n.effects) s.is(setSearchQuery) && !s.value.eq(this.query) && this.setQuery(s.value);
  }
  setQuery(e) {
    (this.query = e),
      (this.searchField.value = e.search),
      (this.replaceField.value = e.replace),
      (this.caseField.checked = e.caseSensitive),
      (this.reField.checked = e.regexp),
      (this.wordField.checked = e.wholeWord);
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
}
function phrase(r, e) {
  return r.state.phrase(e);
}
const AnnounceMargin = 30,
  Break = /[\s\.,:;?!]/;
function announceMatch(r, { from: e, to: n }) {
  let s = r.state.doc.lineAt(e),
    o = r.state.doc.lineAt(n).to,
    a = Math.max(s.from, e - AnnounceMargin),
    l = Math.min(o, n + AnnounceMargin),
    f = r.state.sliceDoc(a, l);
  if (a != s.from) {
    for (let m = 0; m < AnnounceMargin; m++)
      if (!Break.test(f[m + 1]) && Break.test(f[m])) {
        f = f.slice(m);
        break;
      }
  }
  if (l != o) {
    for (let m = f.length - 1; m > f.length - AnnounceMargin; m--)
      if (!Break.test(f[m - 1]) && Break.test(f[m])) {
        f = f.slice(0, m);
        break;
      }
  }
  return EditorView.announce.of(`${r.state.phrase('current match')}. ${f} ${r.state.phrase('on line')} ${s.number}.`);
}
const baseTheme$2 = EditorView.baseTheme({
    '.cm-panel.cm-search': {
      'padding': '2px 6px 4px',
      'position': 'relative',
      '& [name=close]': {
        position: 'absolute',
        top: '0',
        right: '4px',
        backgroundColor: 'inherit',
        border: 'none',
        font: 'inherit',
        padding: 0,
        margin: 0,
      },
      '& input, & button, & label': { margin: '.2em .6em .2em 0' },
      '& input[type=checkbox]': { marginRight: '.2em' },
      '& label': { fontSize: '80%', whiteSpace: 'pre' },
    },
    '&light .cm-searchMatch': { backgroundColor: '#ffff0054' },
    '&dark .cm-searchMatch': { backgroundColor: '#00ffff8a' },
    '&light .cm-searchMatch-selected': { backgroundColor: '#ff6a0054' },
    '&dark .cm-searchMatch-selected': { backgroundColor: '#ff00ff8a' },
  }),
  searchExtensions = [searchState, Prec.low(searchHighlighter), baseTheme$2];
class CompletionContext {
  constructor(e, n, s) {
    (this.state = e), (this.pos = n), (this.explicit = s), (this.abortListeners = []);
  }
  tokenBefore(e) {
    let n = syntaxTree(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; ) n = n.parent;
    return n ? { from: n.from, to: this.pos, text: this.state.sliceDoc(n.from, this.pos), type: n.type } : null;
  }
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos),
      s = Math.max(n.from, this.pos - 250),
      o = n.text.slice(s - n.from, this.pos - n.from),
      a = o.search(ensureAnchor(e, !1));
    return a < 0 ? null : { from: s + a, to: this.pos, text: o.slice(a) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(e, n) {
    e == 'abort' && this.abortListeners && this.abortListeners.push(n);
  }
}
function toSet(r) {
  let e = Object.keys(r).join(''),
    n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, '')), `[${n ? '\\w' : ''}${e.replace(/[^\w\s]/g, '\\$&')}]`;
}
function prefixMatch(r) {
  let e = Object.create(null),
    n = Object.create(null);
  for (let { label: o } of r) {
    e[o[0]] = !0;
    for (let a = 1; a < o.length; a++) n[o[a]] = !0;
  }
  let s = toSet(e) + toSet(n) + '*$';
  return [new RegExp('^' + s), new RegExp(s)];
}
function completeFromList(r) {
  let e = r.map((o) => (typeof o == 'string' ? { label: o } : o)),
    [n, s] = e.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(e);
  return (o) => {
    let a = o.matchBefore(s);
    return a || o.explicit ? { from: a ? a.from : o.pos, options: e, validFor: n } : null;
  };
}
class Option {
  constructor(e, n, s, o) {
    (this.completion = e), (this.source = n), (this.match = s), (this.score = o);
  }
}
function cur(r) {
  return r.selection.main.from;
}
function ensureAnchor(r, e) {
  var n;
  let { source: s } = r,
    o = e && s[0] != '^',
    a = s[s.length - 1] != '$';
  return !o && !a
    ? r
    : new RegExp(
        `${o ? '^' : ''}(?:${s})${a ? '$' : ''}`,
        (n = r.flags) !== null && n !== void 0 ? n : r.ignoreCase ? 'i' : '',
      );
}
const pickedCompletion = Annotation.define();
function insertCompletionText(r, e, n, s) {
  let { main: o } = r.selection,
    a = n - o.from,
    l = s - o.from;
  return Object.assign(
    Object.assign(
      {},
      r.changeByRange((f) =>
        f != o && n != s && r.sliceDoc(f.from + a, f.from + l) != r.sliceDoc(n, s)
          ? { range: f }
          : {
              changes: { from: f.from + a, to: s == o.from ? f.to : f.from + l, insert: e },
              range: EditorSelection.cursor(f.from + a + e.length),
            },
      ),
    ),
    { scrollIntoView: !0, userEvent: 'input.complete' },
  );
}
const SourceCache = new WeakMap();
function asSource(r) {
  if (!Array.isArray(r)) return r;
  let e = SourceCache.get(r);
  return e || SourceCache.set(r, (e = completeFromList(r))), e;
}
const startCompletionEffect = StateEffect.define(),
  closeCompletionEffect = StateEffect.define();
class FuzzyMatcher {
  constructor(e) {
    (this.pattern = e),
      (this.chars = []),
      (this.folded = []),
      (this.any = []),
      (this.precise = []),
      (this.byWord = []),
      (this.score = 0),
      (this.matched = []);
    for (let n = 0; n < e.length; ) {
      let s = codePointAt(e, n),
        o = codePointSize(s);
      this.chars.push(s);
      let a = e.slice(n, n + o),
        l = a.toUpperCase();
      this.folded.push(codePointAt(l == a ? a.toLowerCase() : l, 0)), (n += o);
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return (this.score = e), (this.matched = n), !0;
  }
  match(e) {
    if (this.pattern.length == 0) return this.ret(-100, []);
    if (e.length < this.pattern.length) return !1;
    let { chars: n, folded: s, any: o, precise: a, byWord: l } = this;
    if (n.length == 1) {
      let tl = codePointAt(e, 0),
        Wi = codePointSize(tl),
        hl = Wi == e.length ? 0 : -100;
      if (tl != n[0])
        if (tl == s[0]) hl += -200;
        else return !1;
      return this.ret(hl, [0, Wi]);
    }
    let f = e.indexOf(this.pattern);
    if (f == 0) return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let m = n.length,
      v = 0;
    if (f < 0) {
      for (let tl = 0, Wi = Math.min(e.length, 200); tl < Wi && v < m; ) {
        let hl = codePointAt(e, tl);
        (hl == n[v] || hl == s[v]) && (o[v++] = tl), (tl += codePointSize(hl));
      }
      if (v < m) return !1;
    }
    let I = 0,
      L = 0,
      V = !1,
      se = 0,
      Ee = -1,
      ht = -1,
      ar = /[a-z]/.test(e),
      $i = !0;
    for (let tl = 0, Wi = Math.min(e.length, 200), hl = 0; tl < Wi && L < m; ) {
      let fl = codePointAt(e, tl);
      f < 0 &&
        (I < m && fl == n[I] && (a[I++] = tl),
        se < m && (fl == n[se] || fl == s[se] ? (se == 0 && (Ee = tl), (ht = tl + 1), se++) : (se = 0)));
      let dl,
        Al =
          fl < 255
            ? (fl >= 48 && fl <= 57) || (fl >= 97 && fl <= 122)
              ? 2
              : fl >= 65 && fl <= 90
              ? 1
              : 0
            : (dl = fromCodePoint(fl)) != dl.toLowerCase()
            ? 1
            : dl != dl.toUpperCase()
            ? 2
            : 0;
      (!tl || (Al == 1 && ar) || (hl == 0 && Al != 0)) &&
        (n[L] == fl || (s[L] == fl && (V = !0)) ? (l[L++] = tl) : l.length && ($i = !1)),
        (hl = Al),
        (tl += codePointSize(fl));
    }
    return L == m && l[0] == 0 && $i
      ? this.result(-100 + (V ? -200 : 0), l, e)
      : se == m && Ee == 0
      ? this.ret(-200 - e.length + (ht == e.length ? 0 : -100), [0, ht])
      : f > -1
      ? this.ret(-700 - e.length, [f, f + this.pattern.length])
      : se == m
      ? this.ret(-200 + -700 - e.length, [Ee, ht])
      : L == m
      ? this.result(-100 + (V ? -200 : 0) + -700 + ($i ? 0 : -1100), l, e)
      : n.length == 2
      ? !1
      : this.result((o[0] ? -700 : 0) + -200 + -1100, o, e);
  }
  result(e, n, s) {
    let o = [],
      a = 0;
    for (let l of n) {
      let f = l + (this.astral ? codePointSize(codePointAt(s, l)) : 1);
      a && o[a - 1] == l ? (o[a - 1] = f) : ((o[a++] = l), (o[a++] = f));
    }
    return this.ret(e - s.length, o);
  }
}
const completionConfig = Facet.define({
  combine(r) {
    return combineConfig(
      r,
      {
        activateOnTyping: !0,
        selectOnOpen: !0,
        override: null,
        closeOnBlur: !0,
        maxRenderedOptions: 100,
        defaultKeymap: !0,
        tooltipClass: () => '',
        optionClass: () => '',
        aboveCursor: !1,
        icons: !0,
        addToOptions: [],
        positionInfo: defaultPositionInfo,
        compareCompletions: (e, n) => e.label.localeCompare(n.label),
        interactionDelay: 75,
        updateSyncTime: 100,
      },
      {
        defaultKeymap: (e, n) => e && n,
        closeOnBlur: (e, n) => e && n,
        icons: (e, n) => e && n,
        tooltipClass: (e, n) => (s) => joinClass(e(s), n(s)),
        optionClass: (e, n) => (s) => joinClass(e(s), n(s)),
        addToOptions: (e, n) => e.concat(n),
      },
    );
  },
});
function joinClass(r, e) {
  return r ? (e ? r + ' ' + e : r) : e;
}
function defaultPositionInfo(r, e, n, s, o, a) {
  let l = r.textDirection == Direction.RTL,
    f = l,
    m = !1,
    v = 'top',
    I,
    L,
    V = e.left - o.left,
    se = o.right - e.right,
    Ee = s.right - s.left,
    ht = s.bottom - s.top;
  if ((f && V < Math.min(Ee, se) ? (f = !1) : !f && se < Math.min(Ee, V) && (f = !0), Ee <= (f ? V : se)))
    (I = Math.max(o.top, Math.min(n.top, o.bottom - ht)) - e.top), (L = Math.min(400, f ? V : se));
  else {
    (m = !0), (L = Math.min(400, (l ? e.right : o.right - e.left) - 30));
    let tl = o.bottom - e.bottom;
    tl >= ht || tl > e.top ? (I = n.bottom - e.top) : ((v = 'bottom'), (I = e.bottom - n.top));
  }
  let ar = (e.bottom - e.top) / a.offsetHeight,
    $i = (e.right - e.left) / a.offsetWidth;
  return {
    style: `${v}: ${I / ar}px; max-width: ${L / $i}px`,
    class: 'cm-completionInfo-' + (m ? (l ? 'left-narrow' : 'right-narrow') : f ? 'left' : 'right'),
  };
}
function optionContent(r) {
  let e = r.addToOptions.slice();
  return (
    r.icons &&
      e.push({
        render(n) {
          let s = document.createElement('div');
          return (
            s.classList.add('cm-completionIcon'),
            n.type && s.classList.add(...n.type.split(/\s+/g).map((o) => 'cm-completionIcon-' + o)),
            s.setAttribute('aria-hidden', 'true'),
            s
          );
        },
        position: 20,
      }),
    e.push(
      {
        render(n, s, o) {
          let a = document.createElement('span');
          a.className = 'cm-completionLabel';
          let l = n.displayLabel || n.label,
            f = 0;
          for (let m = 0; m < o.length; ) {
            let v = o[m++],
              I = o[m++];
            v > f && a.appendChild(document.createTextNode(l.slice(f, v)));
            let L = a.appendChild(document.createElement('span'));
            L.appendChild(document.createTextNode(l.slice(v, I))), (L.className = 'cm-completionMatchedText'), (f = I);
          }
          return f < l.length && a.appendChild(document.createTextNode(l.slice(f))), a;
        },
        position: 50,
      },
      {
        render(n) {
          if (!n.detail) return null;
          let s = document.createElement('span');
          return (s.className = 'cm-completionDetail'), (s.textContent = n.detail), s;
        },
        position: 80,
      },
    ),
    e.sort((n, s) => n.position - s.position).map((n) => n.render)
  );
}
function rangeAroundSelected(r, e, n) {
  if (r <= n) return { from: 0, to: r };
  if ((e < 0 && (e = 0), e <= r >> 1)) {
    let o = Math.floor(e / n);
    return { from: o * n, to: (o + 1) * n };
  }
  let s = Math.floor((r - e) / n);
  return { from: r - (s + 1) * n, to: r - s * n };
}
class CompletionTooltip {
  constructor(e, n, s) {
    (this.view = e),
      (this.stateField = n),
      (this.applyCompletion = s),
      (this.info = null),
      (this.infoDestroy = null),
      (this.placeInfoReq = { read: () => this.measureInfo(), write: (m) => this.placeInfo(m), key: this }),
      (this.space = null),
      (this.currentClass = '');
    let o = e.state.field(n),
      { options: a, selected: l } = o.open,
      f = e.state.facet(completionConfig);
    (this.optionContent = optionContent(f)),
      (this.optionClass = f.optionClass),
      (this.tooltipClass = f.tooltipClass),
      (this.range = rangeAroundSelected(a.length, l, f.maxRenderedOptions)),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-tooltip-autocomplete'),
      this.updateTooltipClass(e.state),
      this.dom.addEventListener('mousedown', (m) => {
        let { options: v } = e.state.field(n).open;
        for (let I = m.target, L; I && I != this.dom; I = I.parentNode)
          if (I.nodeName == 'LI' && (L = /-(\d+)$/.exec(I.id)) && +L[1] < v.length) {
            this.applyCompletion(e, v[+L[1]]), m.preventDefault();
            return;
          }
      }),
      this.dom.addEventListener('focusout', (m) => {
        let v = e.state.field(this.stateField, !1);
        v &&
          v.tooltip &&
          e.state.facet(completionConfig).closeOnBlur &&
          m.relatedTarget != e.contentDOM &&
          e.dispatch({ effects: closeCompletionEffect.of(null) });
      }),
      this.showOptions(a, o.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(),
      (this.list = this.dom.appendChild(this.createListBox(e, n, this.range))),
      this.list.addEventListener('scroll', () => {
        this.info && this.view.requestMeasure(this.placeInfoReq);
      });
  }
  update(e) {
    var n;
    let s = e.state.field(this.stateField),
      o = e.startState.field(this.stateField);
    if ((this.updateTooltipClass(e.state), s != o)) {
      let { options: a, selected: l, disabled: f } = s.open;
      (!o.open || o.open.options != a) &&
        ((this.range = rangeAroundSelected(a.length, l, e.state.facet(completionConfig).maxRenderedOptions)),
        this.showOptions(a, s.id)),
        this.updateSel(),
        f != ((n = o.open) === null || n === void 0 ? void 0 : n.disabled) &&
          this.dom.classList.toggle('cm-tooltip-autocomplete-disabled', !!f);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let s of this.currentClass.split(' ')) s && this.dom.classList.remove(s);
      for (let s of n.split(' ')) s && this.dom.classList.add(s);
      this.currentClass = n;
    }
  }
  positioned(e) {
    (this.space = e), this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField),
      n = e.open;
    if (
      (((n.selected > -1 && n.selected < this.range.from) || n.selected >= this.range.to) &&
        ((this.range = rangeAroundSelected(
          n.options.length,
          n.selected,
          this.view.state.facet(completionConfig).maxRenderedOptions,
        )),
        this.showOptions(n.options, e.id)),
      this.updateSelectedOption(n.selected))
    ) {
      this.destroyInfo();
      let { completion: s } = n.options[n.selected],
        { info: o } = s;
      if (!o) return;
      let a = typeof o == 'string' ? document.createTextNode(o) : o(s);
      if (!a) return;
      'then' in a
        ? a
            .then((l) => {
              l && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(l, s);
            })
            .catch((l) => logException(this.view.state, l, 'completion info'))
        : this.addInfoPane(a, s);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let s = (this.info = document.createElement('div'));
    if (((s.className = 'cm-tooltip cm-completionInfo'), e.nodeType != null))
      s.appendChild(e), (this.infoDestroy = null);
    else {
      let { dom: o, destroy: a } = e;
      s.appendChild(o), (this.infoDestroy = a || null);
    }
    this.dom.appendChild(s), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let s = this.list.firstChild, o = this.range.from; s; s = s.nextSibling, o++)
      s.nodeName != 'LI' || !s.id
        ? o--
        : o == e
        ? s.hasAttribute('aria-selected') || (s.setAttribute('aria-selected', 'true'), (n = s))
        : s.hasAttribute('aria-selected') && s.removeAttribute('aria-selected');
    return n && scrollIntoView(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector('[aria-selected]');
    if (!e || !this.info) return null;
    let n = this.dom.getBoundingClientRect(),
      s = this.info.getBoundingClientRect(),
      o = e.getBoundingClientRect(),
      a = this.space;
    if (!a) {
      let l = this.dom.ownerDocument.defaultView || window;
      a = { left: 0, top: 0, right: l.innerWidth, bottom: l.innerHeight };
    }
    return o.top > Math.min(a.bottom, n.bottom) - 10 || o.bottom < Math.max(a.top, n.top) + 10
      ? null
      : this.view.state.facet(completionConfig).positionInfo(this.view, n, o, s, a, this.dom);
  }
  placeInfo(e) {
    this.info &&
      (e
        ? (e.style && (this.info.style.cssText = e.style),
          (this.info.className = 'cm-tooltip cm-completionInfo ' + (e.class || '')))
        : (this.info.style.cssText = 'top: -1e6px'));
  }
  createListBox(e, n, s) {
    const o = document.createElement('ul');
    (o.id = n),
      o.setAttribute('role', 'listbox'),
      o.setAttribute('aria-expanded', 'true'),
      o.setAttribute('aria-label', this.view.state.phrase('Completions'));
    let a = null;
    for (let l = s.from; l < s.to; l++) {
      let { completion: f, match: m } = e[l],
        { section: v } = f;
      if (v) {
        let V = typeof v == 'string' ? v : v.name;
        if (V != a && (l > s.from || s.from == 0))
          if (((a = V), typeof v != 'string' && v.header)) o.appendChild(v.header(v));
          else {
            let se = o.appendChild(document.createElement('completion-section'));
            se.textContent = V;
          }
      }
      const I = o.appendChild(document.createElement('li'));
      (I.id = n + '-' + l), I.setAttribute('role', 'option');
      let L = this.optionClass(f);
      L && (I.className = L);
      for (let V of this.optionContent) {
        let se = V(f, this.view.state, m);
        se && I.appendChild(se);
      }
    }
    return (
      s.from && o.classList.add('cm-completionListIncompleteTop'),
      s.to < e.length && o.classList.add('cm-completionListIncompleteBottom'),
      o
    );
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), (this.info = null));
  }
  destroy() {
    this.destroyInfo();
  }
}
function completionTooltip(r, e) {
  return (n) => new CompletionTooltip(n, r, e);
}
function scrollIntoView(r, e) {
  let n = r.getBoundingClientRect(),
    s = e.getBoundingClientRect(),
    o = n.height / r.offsetHeight;
  s.top < n.top
    ? (r.scrollTop -= (n.top - s.top) / o)
    : s.bottom > n.bottom && (r.scrollTop += (s.bottom - n.bottom) / o);
}
function score(r) {
  return (r.boost || 0) * 100 + (r.apply ? 10 : 0) + (r.info ? 5 : 0) + (r.type ? 1 : 0);
}
function sortOptions(r, e) {
  let n = [],
    s = null,
    o = (m) => {
      n.push(m);
      let { section: v } = m.completion;
      if (v) {
        s || (s = []);
        let I = typeof v == 'string' ? v : v.name;
        s.some((L) => L.name == I) || s.push(typeof v == 'string' ? { name: I } : v);
      }
    };
  for (let m of r)
    if (m.hasResult()) {
      let v = m.result.getMatch;
      if (m.result.filter === !1)
        for (let I of m.result.options) o(new Option(I, m.source, v ? v(I) : [], 1e9 - n.length));
      else {
        let I = new FuzzyMatcher(e.sliceDoc(m.from, m.to));
        for (let L of m.result.options)
          if (I.match(L.label)) {
            let V = L.displayLabel ? (v ? v(L, I.matched) : []) : I.matched;
            o(new Option(L, m.source, V, I.score + (L.boost || 0)));
          }
      }
    }
  if (s) {
    let m = Object.create(null),
      v = 0,
      I = (L, V) => {
        var se, Ee;
        return (
          ((se = L.rank) !== null && se !== void 0 ? se : 1e9) - ((Ee = V.rank) !== null && Ee !== void 0 ? Ee : 1e9) ||
          (L.name < V.name ? -1 : 1)
        );
      };
    for (let L of s.sort(I)) (v -= 1e5), (m[L.name] = v);
    for (let L of n) {
      let { section: V } = L.completion;
      V && (L.score += m[typeof V == 'string' ? V : V.name]);
    }
  }
  let a = [],
    l = null,
    f = e.facet(completionConfig).compareCompletions;
  for (let m of n.sort((v, I) => I.score - v.score || f(v.completion, I.completion))) {
    let v = m.completion;
    !l ||
    l.label != v.label ||
    l.detail != v.detail ||
    (l.type != null && v.type != null && l.type != v.type) ||
    l.apply != v.apply ||
    l.boost != v.boost
      ? a.push(m)
      : score(m.completion) > score(l) && (a[a.length - 1] = m),
      (l = m.completion);
  }
  return a;
}
class CompletionDialog {
  constructor(e, n, s, o, a, l) {
    (this.options = e),
      (this.attrs = n),
      (this.tooltip = s),
      (this.timestamp = o),
      (this.selected = a),
      (this.disabled = l);
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length
      ? this
      : new CompletionDialog(this.options, makeAttrs(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, s, o, a) {
    let l = sortOptions(e, n);
    if (!l.length)
      return o && e.some((m) => m.state == 1)
        ? new CompletionDialog(o.options, o.attrs, o.tooltip, o.timestamp, o.selected, !0)
        : null;
    let f = n.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (o && o.selected != f && o.selected != -1) {
      let m = o.options[o.selected].completion;
      for (let v = 0; v < l.length; v++)
        if (l[v].completion == m) {
          f = v;
          break;
        }
    }
    return new CompletionDialog(
      l,
      makeAttrs(s, f),
      {
        pos: e.reduce((m, v) => (v.hasResult() ? Math.min(m, v.from) : m), 1e8),
        create: createTooltip,
        above: a.aboveCursor,
      },
      o ? o.timestamp : Date.now(),
      f,
      !1,
    );
  }
  map(e) {
    return new CompletionDialog(
      this.options,
      this.attrs,
      Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }),
      this.timestamp,
      this.selected,
      this.disabled,
    );
  }
}
class CompletionState {
  constructor(e, n, s) {
    (this.active = e), (this.id = n), (this.open = s);
  }
  static start() {
    return new CompletionState(none, 'cm-ac-' + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e,
      s = n.facet(completionConfig),
      a = (s.override || n.languageDataAt('autocomplete', cur(n)).map(asSource)).map((f) =>
        (
          this.active.find((v) => v.source == f) || new ActiveSource(f, this.active.some((v) => v.state != 0) ? 1 : 0)
        ).update(e, s),
      );
    a.length == this.active.length && a.every((f, m) => f == this.active[m]) && (a = this.active);
    let l = this.open;
    l && e.docChanged && (l = l.map(e.changes)),
      e.selection ||
      a.some((f) => f.hasResult() && e.changes.touchesRange(f.from, f.to)) ||
      !sameResults(a, this.active)
        ? (l = CompletionDialog.build(a, n, this.id, l, s))
        : l && l.disabled && !a.some((f) => f.state == 1) && (l = null),
      !l &&
        a.every((f) => f.state != 1) &&
        a.some((f) => f.hasResult()) &&
        (a = a.map((f) => (f.hasResult() ? new ActiveSource(f.source, 0) : f)));
    for (let f of e.effects) f.is(setSelectedEffect) && (l = l && l.setSelected(f.value, this.id));
    return a == this.active && l == this.open ? this : new CompletionState(a, this.id, l);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : baseAttrs;
  }
}
function sameResults(r, e) {
  if (r == e) return !0;
  for (let n = 0, s = 0; ; ) {
    for (; n < r.length && !r[n].hasResult; ) n++;
    for (; s < e.length && !e[s].hasResult; ) s++;
    let o = n == r.length,
      a = s == e.length;
    if (o || a) return o == a;
    if (r[n++].result != e[s++].result) return !1;
  }
}
const baseAttrs = { 'aria-autocomplete': 'list' };
function makeAttrs(r, e) {
  let n = { 'aria-autocomplete': 'list', 'aria-haspopup': 'listbox', 'aria-controls': r };
  return e > -1 && (n['aria-activedescendant'] = r + '-' + e), n;
}
const none = [];
function getUserEvent(r) {
  return r.isUserEvent('input.type') ? 'input' : r.isUserEvent('delete.backward') ? 'delete' : null;
}
class ActiveSource {
  constructor(e, n, s = -1) {
    (this.source = e), (this.state = n), (this.explicitPos = s);
  }
  hasResult() {
    return !1;
  }
  update(e, n) {
    let s = getUserEvent(e),
      o = this;
    s
      ? (o = o.handleUserEvent(e, s, n))
      : e.docChanged
      ? (o = o.handleChange(e))
      : e.selection && o.state != 0 && (o = new ActiveSource(o.source, 0));
    for (let a of e.effects)
      if (a.is(startCompletionEffect)) o = new ActiveSource(o.source, 1, a.value ? cur(e.state) : -1);
      else if (a.is(closeCompletionEffect)) o = new ActiveSource(o.source, 0);
      else if (a.is(setActiveEffect)) for (let l of a.value) l.source == o.source && (o = l);
    return o;
  }
  handleUserEvent(e, n, s) {
    return n == 'delete' || !s.activateOnTyping ? this.map(e.changes) : new ActiveSource(this.source, 1);
  }
  handleChange(e) {
    return e.changes.touchesRange(cur(e.startState)) ? new ActiveSource(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0
      ? this
      : new ActiveSource(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class ActiveResult extends ActiveSource {
  constructor(e, n, s, o, a) {
    super(e, 2, n), (this.result = s), (this.from = o), (this.to = a);
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, n, s) {
    var o;
    let a = e.changes.mapPos(this.from),
      l = e.changes.mapPos(this.to, 1),
      f = cur(e.state);
    if ((this.explicitPos < 0 ? f <= a : f < this.from) || f > l || (n == 'delete' && cur(e.startState) == this.from))
      return new ActiveSource(this.source, n == 'input' && s.activateOnTyping ? 1 : 0);
    let m = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos),
      v;
    return checkValid(this.result.validFor, e.state, a, l)
      ? new ActiveResult(this.source, m, this.result, a, l)
      : this.result.update && (v = this.result.update(this.result, a, l, new CompletionContext(e.state, f, m >= 0)))
      ? new ActiveResult(this.source, m, v, v.from, (o = v.to) !== null && o !== void 0 ? o : cur(e.state))
      : new ActiveSource(this.source, 1, m);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty
      ? this
      : new ActiveResult(
          this.source,
          this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos),
          this.result,
          e.mapPos(this.from),
          e.mapPos(this.to, 1),
        );
  }
}
function checkValid(r, e, n, s) {
  if (!r) return !1;
  let o = e.sliceDoc(n, s);
  return typeof r == 'function' ? r(o, n, s, e) : ensureAnchor(r, !0).test(o);
}
const setActiveEffect = StateEffect.define({
    map(r, e) {
      return r.map((n) => n.map(e));
    },
  }),
  setSelectedEffect = StateEffect.define(),
  completionState = StateField.define({
    create() {
      return CompletionState.start();
    },
    update(r, e) {
      return r.update(e);
    },
    provide: (r) => [showTooltip.from(r, (e) => e.tooltip), EditorView.contentAttributes.from(r, (e) => e.attrs)],
  });
function applyCompletion(r, e) {
  const n = e.completion.apply || e.completion.label;
  let s = r.state.field(completionState).active.find((o) => o.source == e.source);
  return s instanceof ActiveResult
    ? (typeof n == 'string'
        ? r.dispatch(
            Object.assign(Object.assign({}, insertCompletionText(r.state, n, s.from, s.to)), {
              annotations: pickedCompletion.of(e.completion),
            }),
          )
        : n(r, e.completion, s.from, s.to),
      !0)
    : !1;
}
const createTooltip = completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(r, e = 'option') {
  return (n) => {
    let s = n.state.field(completionState, !1);
    if (
      !s ||
      !s.open ||
      s.open.disabled ||
      Date.now() - s.open.timestamp < n.state.facet(completionConfig).interactionDelay
    )
      return !1;
    let o = 1,
      a;
    e == 'page' &&
      (a = getTooltip(n, s.open.tooltip)) &&
      (o = Math.max(2, Math.floor(a.dom.offsetHeight / a.dom.querySelector('li').offsetHeight) - 1));
    let { length: l } = s.open.options,
      f = s.open.selected > -1 ? s.open.selected + o * (r ? 1 : -1) : r ? 0 : l - 1;
    return (
      f < 0 ? (f = e == 'page' ? 0 : l - 1) : f >= l && (f = e == 'page' ? l - 1 : 0),
      n.dispatch({ effects: setSelectedEffect.of(f) }),
      !0
    );
  };
}
const acceptCompletion = (r) => {
    let e = r.state.field(completionState, !1);
    return r.state.readOnly ||
      !e ||
      !e.open ||
      e.open.selected < 0 ||
      e.open.disabled ||
      Date.now() - e.open.timestamp < r.state.facet(completionConfig).interactionDelay
      ? !1
      : applyCompletion(r, e.open.options[e.open.selected]);
  },
  startCompletion = (r) =>
    r.state.field(completionState, !1) ? (r.dispatch({ effects: startCompletionEffect.of(!0) }), !0) : !1,
  closeCompletion = (r) => {
    let e = r.state.field(completionState, !1);
    return !e || !e.active.some((n) => n.state != 0)
      ? !1
      : (r.dispatch({ effects: closeCompletionEffect.of(null) }), !0);
  };
class RunningQuery {
  constructor(e, n) {
    (this.active = e), (this.context = n), (this.time = Date.now()), (this.updates = []), (this.done = void 0);
  }
}
const MaxUpdateCount = 50,
  MinAbortTime = 1e3,
  completionPlugin = ViewPlugin.fromClass(
    class {
      constructor(r) {
        (this.view = r),
          (this.debounceUpdate = -1),
          (this.running = []),
          (this.debounceAccept = -1),
          (this.composing = 0);
        for (let e of r.state.field(completionState).active) e.state == 1 && this.startQuery(e);
      }
      update(r) {
        let e = r.state.field(completionState);
        if (!r.selectionSet && !r.docChanged && r.startState.field(completionState) == e) return;
        let n = r.transactions.some((s) => (s.selection || s.docChanged) && !getUserEvent(s));
        for (let s = 0; s < this.running.length; s++) {
          let o = this.running[s];
          if (n || (o.updates.length + r.transactions.length > MaxUpdateCount && Date.now() - o.time > MinAbortTime)) {
            for (let a of o.context.abortListeners)
              try {
                a();
              } catch (l) {
                logException(this.view.state, l);
              }
            (o.context.abortListeners = null), this.running.splice(s--, 1);
          } else o.updates.push(...r.transactions);
        }
        if (
          (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
          (this.debounceUpdate = e.active.some(
            (s) => s.state == 1 && !this.running.some((o) => o.active.source == s.source),
          )
            ? setTimeout(() => this.startUpdate(), 50)
            : -1),
          this.composing != 0)
        )
          for (let s of r.transactions)
            getUserEvent(s) == 'input'
              ? (this.composing = 2)
              : this.composing == 2 && s.selection && (this.composing = 3);
      }
      startUpdate() {
        this.debounceUpdate = -1;
        let { state: r } = this.view,
          e = r.field(completionState);
        for (let n of e.active)
          n.state == 1 && !this.running.some((s) => s.active.source == n.source) && this.startQuery(n);
      }
      startQuery(r) {
        let { state: e } = this.view,
          n = cur(e),
          s = new CompletionContext(e, n, r.explicitPos == n),
          o = new RunningQuery(r, s);
        this.running.push(o),
          Promise.resolve(r.source(s)).then(
            (a) => {
              o.context.aborted || ((o.done = a || null), this.scheduleAccept());
            },
            (a) => {
              this.view.dispatch({ effects: closeCompletionEffect.of(null) }), logException(this.view.state, a);
            },
          );
      }
      scheduleAccept() {
        this.running.every((r) => r.done !== void 0)
          ? this.accept()
          : this.debounceAccept < 0 &&
            (this.debounceAccept = setTimeout(
              () => this.accept(),
              this.view.state.facet(completionConfig).updateSyncTime,
            ));
      }
      accept() {
        var r;
        this.debounceAccept > -1 && clearTimeout(this.debounceAccept), (this.debounceAccept = -1);
        let e = [],
          n = this.view.state.facet(completionConfig);
        for (let s = 0; s < this.running.length; s++) {
          let o = this.running[s];
          if (o.done === void 0) continue;
          if ((this.running.splice(s--, 1), o.done)) {
            let l = new ActiveResult(
              o.active.source,
              o.active.explicitPos,
              o.done,
              o.done.from,
              (r = o.done.to) !== null && r !== void 0
                ? r
                : cur(o.updates.length ? o.updates[0].startState : this.view.state),
            );
            for (let f of o.updates) l = l.update(f, n);
            if (l.hasResult()) {
              e.push(l);
              continue;
            }
          }
          let a = this.view.state.field(completionState).active.find((l) => l.source == o.active.source);
          if (a && a.state == 1)
            if (o.done == null) {
              let l = new ActiveSource(o.active.source, 0);
              for (let f of o.updates) l = l.update(f, n);
              l.state != 1 && e.push(l);
            } else this.startQuery(a);
        }
        e.length && this.view.dispatch({ effects: setActiveEffect.of(e) });
      }
    },
    {
      eventHandlers: {
        blur(r) {
          let e = this.view.state.field(completionState, !1);
          if (e && e.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
            let n = e.open && getTooltip(this.view, e.open.tooltip);
            (!n || !n.dom.contains(r.relatedTarget)) && this.view.dispatch({ effects: closeCompletionEffect.of(null) });
          }
        },
        compositionstart() {
          this.composing = 1;
        },
        compositionend() {
          this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(!1) }), 20),
            (this.composing = 0);
        },
      },
    },
  ),
  baseTheme$1 = EditorView.baseTheme({
    '.cm-tooltip.cm-tooltip-autocomplete': {
      '& > ul': {
        'fontFamily': 'monospace',
        'whiteSpace': 'nowrap',
        'overflow': 'hidden auto',
        'maxWidth_fallback': '700px',
        'maxWidth': 'min(700px, 95vw)',
        'minWidth': '250px',
        'maxHeight': '10em',
        'height': '100%',
        'listStyle': 'none',
        'margin': 0,
        'padding': 0,
        '& > li, & > completion-section': { padding: '1px 3px', lineHeight: 1.2 },
        '& > li': { overflowX: 'hidden', textOverflow: 'ellipsis', cursor: 'pointer' },
        '& > completion-section': {
          display: 'list-item',
          borderBottom: '1px solid silver',
          paddingLeft: '0.5em',
          opacity: 0.7,
        },
      },
    },
    '&light .cm-tooltip-autocomplete ul li[aria-selected]': { background: '#17c', color: 'white' },
    '&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]': { background: '#777' },
    '&dark .cm-tooltip-autocomplete ul li[aria-selected]': { background: '#347', color: 'white' },
    '&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]': { background: '#444' },
    '.cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after': {
      content: '"···"',
      opacity: 0.5,
      display: 'block',
      textAlign: 'center',
    },
    '.cm-tooltip.cm-completionInfo': {
      position: 'absolute',
      padding: '3px 9px',
      width: 'max-content',
      maxWidth: '400px',
      boxSizing: 'border-box',
    },
    '.cm-completionInfo.cm-completionInfo-left': { right: '100%' },
    '.cm-completionInfo.cm-completionInfo-right': { left: '100%' },
    '.cm-completionInfo.cm-completionInfo-left-narrow': { right: '30px' },
    '.cm-completionInfo.cm-completionInfo-right-narrow': { left: '30px' },
    '&light .cm-snippetField': { backgroundColor: '#00000022' },
    '&dark .cm-snippetField': { backgroundColor: '#ffffff22' },
    '.cm-snippetFieldPosition': {
      verticalAlign: 'text-top',
      width: 0,
      height: '1.15em',
      display: 'inline-block',
      margin: '0 -0.7px -.7em',
      borderLeft: '1.4px dotted #888',
    },
    '.cm-completionMatchedText': { textDecoration: 'underline' },
    '.cm-completionDetail': { marginLeft: '0.5em', fontStyle: 'italic' },
    '.cm-completionIcon': {
      fontSize: '90%',
      width: '.8em',
      display: 'inline-block',
      textAlign: 'center',
      paddingRight: '.6em',
      opacity: '0.6',
      boxSizing: 'content-box',
    },
    '.cm-completionIcon-function, .cm-completionIcon-method': { '&:after': { content: "'ƒ'" } },
    '.cm-completionIcon-class': { '&:after': { content: "'○'" } },
    '.cm-completionIcon-interface': { '&:after': { content: "'◌'" } },
    '.cm-completionIcon-variable': { '&:after': { content: "'𝑥'" } },
    '.cm-completionIcon-constant': { '&:after': { content: "'𝐶'" } },
    '.cm-completionIcon-type': { '&:after': { content: "'𝑡'" } },
    '.cm-completionIcon-enum': { '&:after': { content: "'∪'" } },
    '.cm-completionIcon-property': { '&:after': { content: "'□'" } },
    '.cm-completionIcon-keyword': { '&:after': { content: "'🔑︎'" } },
    '.cm-completionIcon-namespace': { '&:after': { content: "'▢'" } },
    '.cm-completionIcon-text': { '&:after': { content: "'abc'", fontSize: '50%', verticalAlign: 'middle' } },
  }),
  defaults = { brackets: ['(', '[', '{', "'", '"'], before: ')]}:;>', stringPrefixes: [] },
  closeBracketEffect = StateEffect.define({
    map(r, e) {
      let n = e.mapPos(r, -1, MapMode.TrackAfter);
      return n ?? void 0;
    },
  }),
  closedBracket = new (class extends RangeValue {})();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(r, e) {
    if (e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head).from,
        s = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      n != e.changes.mapPos(s, -1) && (r = RangeSet.empty);
    }
    r = r.map(e.changes);
    for (let n of e.effects)
      n.is(closeBracketEffect) && (r = r.update({ add: [closedBracket.range(n.value, n.value + 1)] }));
    return r;
  },
});
function closeBrackets() {
  return [inputHandler, bracketState];
}
const definedClosing = '()[]{}<>';
function closing(r) {
  for (let e = 0; e < definedClosing.length; e += 2)
    if (definedClosing.charCodeAt(e) == r) return definedClosing.charAt(e + 1);
  return fromCodePoint(r < 128 ? r : r + 1);
}
function config(r, e) {
  return r.languageDataAt('closeBrackets', e)[0] || defaults;
}
const android = typeof navigator == 'object' && /Android\b/.test(navigator.userAgent),
  inputHandler = EditorView.inputHandler.of((r, e, n, s) => {
    if ((android ? r.composing : r.compositionStarted) || r.state.readOnly) return !1;
    let o = r.state.selection.main;
    if (s.length > 2 || (s.length == 2 && codePointSize(codePointAt(s, 0)) == 1) || e != o.from || n != o.to) return !1;
    let a = insertBracket(r.state, s);
    return a ? (r.dispatch(a), !0) : !1;
  }),
  deleteBracketPair = ({ state: r, dispatch: e }) => {
    if (r.readOnly) return !1;
    let s = config(r, r.selection.main.head).brackets || defaults.brackets,
      o = null,
      a = r.changeByRange((l) => {
        if (l.empty) {
          let f = prevChar(r.doc, l.head);
          for (let m of s)
            if (m == f && nextChar(r.doc, l.head) == closing(codePointAt(m, 0)))
              return {
                changes: { from: l.head - m.length, to: l.head + m.length },
                range: EditorSelection.cursor(l.head - m.length),
              };
        }
        return { range: (o = l) };
      });
    return o || e(r.update(a, { scrollIntoView: !0, userEvent: 'delete.backward' })), !o;
  },
  closeBracketsKeymap = [{ key: 'Backspace', run: deleteBracketPair }];
function insertBracket(r, e) {
  let n = config(r, r.selection.main.head),
    s = n.brackets || defaults.brackets;
  for (let o of s) {
    let a = closing(codePointAt(o, 0));
    if (e == o)
      return a == o ? handleSame(r, o, s.indexOf(o + o + o) > -1, n) : handleOpen(r, o, a, n.before || defaults.before);
    if (e == a && closedBracketAt(r, r.selection.main.from)) return handleClose(r, o, a);
  }
  return null;
}
function closedBracketAt(r, e) {
  let n = !1;
  return (
    r.field(bracketState).between(0, r.doc.length, (s) => {
      s == e && (n = !0);
    }),
    n
  );
}
function nextChar(r, e) {
  let n = r.sliceString(e, e + 2);
  return n.slice(0, codePointSize(codePointAt(n, 0)));
}
function prevChar(r, e) {
  let n = r.sliceString(e - 2, e);
  return codePointSize(codePointAt(n, 0)) == n.length ? n : n.slice(1);
}
function handleOpen(r, e, n, s) {
  let o = null,
    a = r.changeByRange((l) => {
      if (!l.empty)
        return {
          changes: [
            { insert: e, from: l.from },
            { insert: n, from: l.to },
          ],
          effects: closeBracketEffect.of(l.to + e.length),
          range: EditorSelection.range(l.anchor + e.length, l.head + e.length),
        };
      let f = nextChar(r.doc, l.head);
      return !f || /\s/.test(f) || s.indexOf(f) > -1
        ? {
            changes: { insert: e + n, from: l.head },
            effects: closeBracketEffect.of(l.head + e.length),
            range: EditorSelection.cursor(l.head + e.length),
          }
        : { range: (o = l) };
    });
  return o ? null : r.update(a, { scrollIntoView: !0, userEvent: 'input.type' });
}
function handleClose(r, e, n) {
  let s = null,
    o = r.changeByRange((a) =>
      a.empty && nextChar(r.doc, a.head) == n
        ? {
            changes: { from: a.head, to: a.head + n.length, insert: n },
            range: EditorSelection.cursor(a.head + n.length),
          }
        : (s = { range: a }),
    );
  return s ? null : r.update(o, { scrollIntoView: !0, userEvent: 'input.type' });
}
function handleSame(r, e, n, s) {
  let o = s.stringPrefixes || defaults.stringPrefixes,
    a = null,
    l = r.changeByRange((f) => {
      if (!f.empty)
        return {
          changes: [
            { insert: e, from: f.from },
            { insert: e, from: f.to },
          ],
          effects: closeBracketEffect.of(f.to + e.length),
          range: EditorSelection.range(f.anchor + e.length, f.head + e.length),
        };
      let m = f.head,
        v = nextChar(r.doc, m),
        I;
      if (v == e) {
        if (nodeStart(r, m))
          return {
            changes: { insert: e + e, from: m },
            effects: closeBracketEffect.of(m + e.length),
            range: EditorSelection.cursor(m + e.length),
          };
        if (closedBracketAt(r, m)) {
          let V = n && r.sliceDoc(m, m + e.length * 3) == e + e + e ? e + e + e : e;
          return { changes: { from: m, to: m + V.length, insert: V }, range: EditorSelection.cursor(m + V.length) };
        }
      } else {
        if (
          n &&
          r.sliceDoc(m - 2 * e.length, m) == e + e &&
          (I = canStartStringAt(r, m - 2 * e.length, o)) > -1 &&
          nodeStart(r, I)
        )
          return {
            changes: { insert: e + e + e + e, from: m },
            effects: closeBracketEffect.of(m + e.length),
            range: EditorSelection.cursor(m + e.length),
          };
        if (
          r.charCategorizer(m)(v) != CharCategory.Word &&
          canStartStringAt(r, m, o) > -1 &&
          !probablyInString(r, m, e, o)
        )
          return {
            changes: { insert: e + e, from: m },
            effects: closeBracketEffect.of(m + e.length),
            range: EditorSelection.cursor(m + e.length),
          };
      }
      return { range: (a = f) };
    });
  return a ? null : r.update(l, { scrollIntoView: !0, userEvent: 'input.type' });
}
function nodeStart(r, e) {
  let n = syntaxTree(r).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function probablyInString(r, e, n, s) {
  let o = syntaxTree(r).resolveInner(e, -1),
    a = s.reduce((l, f) => Math.max(l, f.length), 0);
  for (let l = 0; l < 5; l++) {
    let f = r.sliceDoc(o.from, Math.min(o.to, o.from + n.length + a)),
      m = f.indexOf(n);
    if (!m || (m > -1 && s.indexOf(f.slice(0, m)) > -1)) {
      let I = o.firstChild;
      for (; I && I.from == o.from && I.to - I.from > n.length + m; ) {
        if (r.sliceDoc(I.to - n.length, I.to) == n) return !1;
        I = I.firstChild;
      }
      return !0;
    }
    let v = o.to == e && o.parent;
    if (!v) break;
    o = v;
  }
  return !1;
}
function canStartStringAt(r, e, n) {
  let s = r.charCategorizer(e);
  if (s(r.sliceDoc(e - 1, e)) != CharCategory.Word) return e;
  for (let o of n) {
    let a = e - o.length;
    if (r.sliceDoc(a, e) == o && s(r.sliceDoc(a - 1, a)) != CharCategory.Word) return a;
  }
  return -1;
}
function autocompletion(r = {}) {
  return [completionState, completionConfig.of(r), completionPlugin, completionKeymapExt, baseTheme$1];
}
const completionKeymap = [
    { key: 'Ctrl-Space', run: startCompletion },
    { key: 'Escape', run: closeCompletion },
    { key: 'ArrowDown', run: moveCompletionSelection(!0) },
    { key: 'ArrowUp', run: moveCompletionSelection(!1) },
    { key: 'PageDown', run: moveCompletionSelection(!0, 'page') },
    { key: 'PageUp', run: moveCompletionSelection(!1, 'page') },
    { key: 'Enter', run: acceptCompletion },
  ],
  completionKeymapExt = Prec.highest(
    keymap.computeN([completionConfig], (r) => (r.facet(completionConfig).defaultKeymap ? [completionKeymap] : [])),
  );
class SelectedDiagnostic {
  constructor(e, n, s) {
    (this.from = e), (this.to = n), (this.diagnostic = s);
  }
}
class LintState {
  constructor(e, n, s) {
    (this.diagnostics = e), (this.panel = n), (this.selected = s);
  }
  static init(e, n, s) {
    let o = e,
      a = s.facet(lintConfig).markerFilter;
    a && (o = a(o));
    let l = Decoration.set(
      o.map((f) =>
        f.from == f.to || (f.from == f.to - 1 && s.doc.lineAt(f.from).to == f.from)
          ? Decoration.widget({ widget: new DiagnosticWidget(f), diagnostic: f }).range(f.from)
          : Decoration.mark({
              attributes: { class: 'cm-lintRange cm-lintRange-' + f.severity + (f.markClass ? ' ' + f.markClass : '') },
              diagnostic: f,
            }).range(f.from, f.to),
      ),
      !0,
    );
    return new LintState(l, n, findDiagnostic(l));
  }
}
function findDiagnostic(r, e = null, n = 0) {
  let s = null;
  return (
    r.between(n, 1e9, (o, a, { spec: l }) => {
      if (!(e && l.diagnostic != e)) return (s = new SelectedDiagnostic(o, a, l.diagnostic)), !1;
    }),
    s
  );
}
function hideTooltip(r, e) {
  let n = r.startState.doc.lineAt(e.pos);
  return !!(r.effects.some((s) => s.is(setDiagnosticsEffect)) || r.changes.touchesRange(n.from, n.to));
}
function maybeEnableLint(r, e) {
  return r.field(lintState, !1) ? e : e.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(r, e) {
  return { effects: maybeEnableLint(r, [setDiagnosticsEffect.of(e)]) };
}
const setDiagnosticsEffect = StateEffect.define(),
  togglePanel = StateEffect.define(),
  movePanelSelection = StateEffect.define(),
  lintState = StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(r, e) {
      if (e.docChanged) {
        let n = r.diagnostics.map(e.changes),
          s = null;
        if (r.selected) {
          let o = e.changes.mapPos(r.selected.from, 1);
          s = findDiagnostic(n, r.selected.diagnostic, o) || findDiagnostic(n, null, o);
        }
        r = new LintState(n, r.panel, s);
      }
      for (let n of e.effects)
        n.is(setDiagnosticsEffect)
          ? (r = LintState.init(n.value, r.panel, e.state))
          : n.is(togglePanel)
          ? (r = new LintState(r.diagnostics, n.value ? LintPanel.open : null, r.selected))
          : n.is(movePanelSelection) && (r = new LintState(r.diagnostics, r.panel, n.value));
      return r;
    },
    provide: (r) => [showPanel.from(r, (e) => e.panel), EditorView.decorations.from(r, (e) => e.diagnostics)],
  }),
  activeMark = Decoration.mark({ class: 'cm-lintRange cm-lintRange-active' });
function lintTooltip(r, e, n) {
  let { diagnostics: s } = r.state.field(lintState),
    o = [],
    a = 2e8,
    l = 0;
  s.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (m, v, { spec: I }) => {
    e >= m &&
      e <= v &&
      (m == v || ((e > m || n > 0) && (e < v || n < 0))) &&
      (o.push(I.diagnostic), (a = Math.min(m, a)), (l = Math.max(v, l)));
  });
  let f = r.state.facet(lintConfig).tooltipFilter;
  return (
    f && (o = f(o)),
    o.length
      ? {
          pos: a,
          end: l,
          above: r.state.doc.lineAt(a).to < l,
          create() {
            return { dom: diagnosticsTooltip(r, o) };
          },
        }
      : null
  );
}
function diagnosticsTooltip(r, e) {
  return crelt(
    'ul',
    { class: 'cm-tooltip-lint' },
    e.map((n) => renderDiagnostic(r, n, !1)),
  );
}
const openLintPanel = (r) => {
    let e = r.state.field(lintState, !1);
    (!e || !e.panel) && r.dispatch({ effects: maybeEnableLint(r.state, [togglePanel.of(!0)]) });
    let n = getPanel(r, LintPanel.open);
    return n && n.dom.querySelector('.cm-panel-lint ul').focus(), !0;
  },
  closeLintPanel = (r) => {
    let e = r.state.field(lintState, !1);
    return !e || !e.panel ? !1 : (r.dispatch({ effects: togglePanel.of(!1) }), !0);
  },
  nextDiagnostic = (r) => {
    let e = r.state.field(lintState, !1);
    if (!e) return !1;
    let n = r.state.selection.main,
      s = e.diagnostics.iter(n.to + 1);
    return !s.value && ((s = e.diagnostics.iter(0)), !s.value || (s.from == n.from && s.to == n.to))
      ? !1
      : (r.dispatch({ selection: { anchor: s.from, head: s.to }, scrollIntoView: !0 }), !0);
  },
  lintKeymap = [
    { key: 'Mod-Shift-m', run: openLintPanel, preventDefault: !0 },
    { key: 'F8', run: nextDiagnostic },
  ],
  lintPlugin = ViewPlugin.fromClass(
    class {
      constructor(r) {
        (this.view = r), (this.timeout = -1), (this.set = !0);
        let { delay: e } = r.state.facet(lintConfig);
        (this.lintTime = Date.now() + e), (this.run = this.run.bind(this)), (this.timeout = setTimeout(this.run, e));
      }
      run() {
        let r = Date.now();
        if (r < this.lintTime - 10) this.timeout = setTimeout(this.run, this.lintTime - r);
        else {
          this.set = !1;
          let { state: e } = this.view,
            { sources: n } = e.facet(lintConfig);
          Promise.all(n.map((s) => Promise.resolve(s(this.view)))).then(
            (s) => {
              let o = s.reduce((a, l) => a.concat(l));
              this.view.state.doc == e.doc && this.view.dispatch(setDiagnostics(this.view.state, o));
            },
            (s) => {
              logException(this.view.state, s);
            },
          );
        }
      }
      update(r) {
        let e = r.state.facet(lintConfig);
        (r.docChanged || e != r.startState.facet(lintConfig) || (e.needsRefresh && e.needsRefresh(r))) &&
          ((this.lintTime = Date.now() + e.delay),
          this.set || ((this.set = !0), (this.timeout = setTimeout(this.run, e.delay))));
      }
      force() {
        this.set && ((this.lintTime = Date.now()), this.run());
      }
      destroy() {
        clearTimeout(this.timeout);
      }
    },
  ),
  lintConfig = Facet.define({
    combine(r) {
      return Object.assign(
        { sources: r.map((e) => e.source) },
        combineConfig(
          r.map((e) => e.config),
          { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null },
          { needsRefresh: (e, n) => (e ? (n ? (s) => e(s) || n(s) : e) : n) },
        ),
      );
    },
  });
function linter(r, e = {}) {
  return [lintConfig.of({ source: r, config: e }), lintPlugin, lintExtensions];
}
function assignKeys(r) {
  let e = [];
  if (r)
    e: for (let { name: n } of r) {
      for (let s = 0; s < n.length; s++) {
        let o = n[s];
        if (/[a-zA-Z]/.test(o) && !e.some((a) => a.toLowerCase() == o.toLowerCase())) {
          e.push(o);
          continue e;
        }
      }
      e.push('');
    }
  return e;
}
function renderDiagnostic(r, e, n) {
  var s;
  let o = n ? assignKeys(e.actions) : [];
  return crelt(
    'li',
    { class: 'cm-diagnostic cm-diagnostic-' + e.severity },
    crelt('span', { class: 'cm-diagnosticText' }, e.renderMessage ? e.renderMessage() : e.message),
    (s = e.actions) === null || s === void 0
      ? void 0
      : s.map((a, l) => {
          let f = !1,
            m = (V) => {
              if ((V.preventDefault(), f)) return;
              f = !0;
              let se = findDiagnostic(r.state.field(lintState).diagnostics, e);
              se && a.apply(r, se.from, se.to);
            },
            { name: v } = a,
            I = o[l] ? v.indexOf(o[l]) : -1,
            L = I < 0 ? v : [v.slice(0, I), crelt('u', v.slice(I, I + 1)), v.slice(I + 1)];
          return crelt(
            'button',
            {
              'type': 'button',
              'class': 'cm-diagnosticAction',
              'onclick': m,
              'onmousedown': m,
              'aria-label': ` Action: ${v}${I < 0 ? '' : ` (access key "${o[l]})"`}.`,
            },
            L,
          );
        }),
    e.source && crelt('div', { class: 'cm-diagnosticSource' }, e.source),
  );
}
class DiagnosticWidget extends WidgetType {
  constructor(e) {
    super(), (this.diagnostic = e);
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt('span', { class: 'cm-lintPoint cm-lintPoint-' + this.diagnostic.severity });
  }
}
class PanelItem {
  constructor(e, n) {
    (this.diagnostic = n),
      (this.id = 'item_' + Math.floor(Math.random() * 4294967295).toString(16)),
      (this.dom = renderDiagnostic(e, n, !0)),
      (this.dom.id = this.id),
      this.dom.setAttribute('role', 'option');
  }
}
class LintPanel {
  constructor(e) {
    (this.view = e), (this.items = []);
    let n = (o) => {
        if (o.keyCode == 27) closeLintPanel(this.view), this.view.focus();
        else if (o.keyCode == 38 || o.keyCode == 33)
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        else if (o.keyCode == 40 || o.keyCode == 34) this.moveSelection((this.selectedIndex + 1) % this.items.length);
        else if (o.keyCode == 36) this.moveSelection(0);
        else if (o.keyCode == 35) this.moveSelection(this.items.length - 1);
        else if (o.keyCode == 13) this.view.focus();
        else if (o.keyCode >= 65 && o.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic: a } = this.items[this.selectedIndex],
            l = assignKeys(a.actions);
          for (let f = 0; f < l.length; f++)
            if (l[f].toUpperCase().charCodeAt(0) == o.keyCode) {
              let m = findDiagnostic(this.view.state.field(lintState).diagnostics, a);
              m && a.actions[f].apply(e, m.from, m.to);
            }
        } else return;
        o.preventDefault();
      },
      s = (o) => {
        for (let a = 0; a < this.items.length; a++) this.items[a].dom.contains(o.target) && this.moveSelection(a);
      };
    (this.list = crelt('ul', {
      'tabIndex': 0,
      'role': 'listbox',
      'aria-label': this.view.state.phrase('Diagnostics'),
      'onkeydown': n,
      'onclick': s,
    })),
      (this.dom = crelt(
        'div',
        { class: 'cm-panel-lint' },
        this.list,
        crelt(
          'button',
          {
            'type': 'button',
            'name': 'close',
            'aria-label': this.view.state.phrase('close'),
            'onclick': () => closeLintPanel(this.view),
          },
          '×',
        ),
      )),
      this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(lintState).selected;
    if (!e) return -1;
    for (let n = 0; n < this.items.length; n++) if (this.items[n].diagnostic == e.diagnostic) return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(lintState),
      s = 0,
      o = !1,
      a = null;
    for (
      e.between(0, this.view.state.doc.length, (l, f, { spec: m }) => {
        let v = -1,
          I;
        for (let L = s; L < this.items.length; L++)
          if (this.items[L].diagnostic == m.diagnostic) {
            v = L;
            break;
          }
        v < 0
          ? ((I = new PanelItem(this.view, m.diagnostic)), this.items.splice(s, 0, I), (o = !0))
          : ((I = this.items[v]), v > s && (this.items.splice(s, v - s), (o = !0))),
          n && I.diagnostic == n.diagnostic
            ? I.dom.hasAttribute('aria-selected') || (I.dom.setAttribute('aria-selected', 'true'), (a = I))
            : I.dom.hasAttribute('aria-selected') && I.dom.removeAttribute('aria-selected'),
          s++;
      });
      s < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0);

    )
      (o = !0), this.items.pop();
    this.items.length == 0 &&
      (this.items.push(
        new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: 'info',
          message: this.view.state.phrase('No diagnostics'),
        }),
      ),
      (o = !0)),
      a
        ? (this.list.setAttribute('aria-activedescendant', a.id),
          this.view.requestMeasure({
            key: this,
            read: () => ({ sel: a.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
            write: ({ sel: l, panel: f }) => {
              let m = f.height / this.list.offsetHeight;
              l.top < f.top
                ? (this.list.scrollTop -= (f.top - l.top) / m)
                : l.bottom > f.bottom && (this.list.scrollTop += (l.bottom - f.bottom) / m);
            },
          }))
        : this.selectedIndex < 0 && this.list.removeAttribute('aria-activedescendant'),
      o && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let s = e;
      (e = s.nextSibling), s.remove();
    }
    for (let s of this.items)
      if (s.dom.parentNode == this.list) {
        for (; e != s.dom; ) n();
        e = s.dom.nextSibling;
      } else this.list.insertBefore(s.dom, e);
    for (; e; ) n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0) return;
    let n = this.view.state.field(lintState),
      s = findDiagnostic(n.diagnostics, this.items[e].diagnostic);
    s &&
      this.view.dispatch({
        selection: { anchor: s.from, head: s.to },
        scrollIntoView: !0,
        effects: movePanelSelection.of(s),
      });
  }
  static open(e) {
    return new LintPanel(e);
  }
}
function svg(r, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(r)}</svg>')`;
}
function underline(r) {
  return svg(
    `<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${r}" fill="none" stroke-width=".7"/>`,
    'width="6" height="3"',
  );
}
const baseTheme = EditorView.baseTheme({
    '.cm-diagnostic': { padding: '3px 6px 3px 8px', marginLeft: '-1px', display: 'block', whiteSpace: 'pre-wrap' },
    '.cm-diagnostic-error': { borderLeft: '5px solid #d11' },
    '.cm-diagnostic-warning': { borderLeft: '5px solid orange' },
    '.cm-diagnostic-info': { borderLeft: '5px solid #999' },
    '.cm-diagnostic-hint': { borderLeft: '5px solid #66d' },
    '.cm-diagnosticAction': {
      font: 'inherit',
      border: 'none',
      padding: '2px 4px',
      backgroundColor: '#444',
      color: 'white',
      borderRadius: '3px',
      marginLeft: '8px',
      cursor: 'pointer',
    },
    '.cm-diagnosticSource': { fontSize: '70%', opacity: 0.7 },
    '.cm-lintRange': { backgroundPosition: 'left bottom', backgroundRepeat: 'repeat-x', paddingBottom: '0.7px' },
    '.cm-lintRange-error': { backgroundImage: underline('#d11') },
    '.cm-lintRange-warning': { backgroundImage: underline('orange') },
    '.cm-lintRange-info': { backgroundImage: underline('#999') },
    '.cm-lintRange-hint': { backgroundImage: underline('#66d') },
    '.cm-lintRange-active': { backgroundColor: '#ffdd9980' },
    '.cm-tooltip-lint': { padding: 0, margin: 0 },
    '.cm-lintPoint': {
      'position': 'relative',
      '&:after': {
        content: '""',
        position: 'absolute',
        bottom: 0,
        left: '-2px',
        borderLeft: '3px solid transparent',
        borderRight: '3px solid transparent',
        borderBottom: '4px solid #d11',
      },
    },
    '.cm-lintPoint-warning': { '&:after': { borderBottomColor: 'orange' } },
    '.cm-lintPoint-info': { '&:after': { borderBottomColor: '#999' } },
    '.cm-lintPoint-hint': { '&:after': { borderBottomColor: '#66d' } },
    '.cm-panel.cm-panel-lint': {
      'position': 'relative',
      '& ul': {
        'maxHeight': '100px',
        'overflowY': 'auto',
        '& [aria-selected]': { 'backgroundColor': '#ddd', '& u': { textDecoration: 'underline' } },
        '&:focus [aria-selected]': {
          background_fallback: '#bdf',
          backgroundColor: 'Highlight',
          color_fallback: 'white',
          color: 'HighlightText',
        },
        '& u': { textDecoration: 'none' },
        'padding': 0,
        'margin': 0,
      },
      '& [name=close]': {
        position: 'absolute',
        top: '0',
        right: '2px',
        background: 'inherit',
        border: 'none',
        font: 'inherit',
        padding: 0,
        margin: 0,
      },
    },
  }),
  lintExtensions = [
    lintState,
    EditorView.decorations.compute([lintState], (r) => {
      let { selected: e, panel: n } = r.field(lintState);
      return !e || !n || e.from == e.to ? Decoration.none : Decoration.set([activeMark.range(e.from, e.to)]);
    }),
    hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
    baseTheme,
  ],
  basicSetup = (() => [
    lineNumbers(),
    highlightActiveLineGutter(),
    highlightSpecialChars(),
    history$1(),
    foldGutter(),
    drawSelection(),
    dropCursor(),
    EditorState.allowMultipleSelections.of(!0),
    indentOnInput(),
    syntaxHighlighting(defaultHighlightStyle, { fallback: !0 }),
    bracketMatching(),
    closeBrackets(),
    autocompletion(),
    rectangularSelection(),
    crosshairCursor(),
    highlightActiveLine(),
    highlightSelectionMatches(),
    keymap.of([
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...completionKeymap,
      ...lintKeymap,
    ]),
  ])();
/*!
 * VueCodemirror v6.1.1
 * Copyright (c) Surmon. All rights reserved.
 * Released under the MIT License.
 * Surmon
 */ var h = Object.freeze({
    autofocus: !1,
    disabled: !1,
    indentWithTab: !0,
    tabSize: 2,
    placeholder: '',
    autoDestroy: !0,
    extensions: [basicSetup],
  }),
  y = Symbol('vue-codemirror-global-config'),
  O,
  j = function (r) {
    var e = r.onUpdate,
      n = r.onChange,
      s = r.onFocus,
      o = r.onBlur,
      a = (function (l, f) {
        var m = {};
        for (var v in l) Object.prototype.hasOwnProperty.call(l, v) && f.indexOf(v) < 0 && (m[v] = l[v]);
        if (l != null && typeof Object.getOwnPropertySymbols == 'function') {
          var I = 0;
          for (v = Object.getOwnPropertySymbols(l); I < v.length; I++)
            f.indexOf(v[I]) < 0 && Object.prototype.propertyIsEnumerable.call(l, v[I]) && (m[v[I]] = l[v[I]]);
        }
        return m;
      })(r, ['onUpdate', 'onChange', 'onFocus', 'onBlur']);
    return EditorState.create({
      doc: a.doc,
      selection: a.selection,
      extensions: (Array.isArray(a.extensions) ? a.extensions : [a.extensions]).concat([
        EditorView.updateListener.of(function (l) {
          e(l), l.docChanged && n(l.state.doc.toString(), l), l.focusChanged && (l.view.hasFocus ? s(l) : o(l));
        }),
      ]),
    });
  },
  S = function (r) {
    var e = new Compartment();
    return {
      compartment: e,
      run: function (n) {
        e.get(r.state)
          ? r.dispatch({ effects: e.reconfigure(n) })
          : r.dispatch({ effects: StateEffect.appendConfig.of(e.of(n)) });
      },
    };
  },
  x = function (r, e) {
    var n = S(r),
      s = n.compartment,
      o = n.run;
    return function (a) {
      var l = s.get(r.state);
      o(a ?? l !== e ? e : []);
    };
  },
  C = { type: Boolean, default: void 0 },
  D = {
    autofocus: C,
    disabled: C,
    indentWithTab: C,
    tabSize: Number,
    placeholder: String,
    style: Object,
    autoDestroy: C,
    phrases: Object,
    root: Object,
    extensions: Array,
    selection: Object,
  },
  U = { modelValue: { type: String, default: '' } },
  w = Object.assign(Object.assign({}, D), U);
(function (r) {
  (r.Change = 'change'),
    (r.Update = 'update'),
    (r.Focus = 'focus'),
    (r.Blur = 'blur'),
    (r.Ready = 'ready'),
    (r.ModelUpdate = 'update:modelValue');
})(O || (O = {}));
var z = {};
(z[O.Change] = function (r, e) {
  return !0;
}),
  (z[O.Update] = function (r) {
    return !0;
  }),
  (z[O.Focus] = function (r) {
    return !0;
  }),
  (z[O.Blur] = function (r) {
    return !0;
  }),
  (z[O.Ready] = function (r) {
    return !0;
  });
var B = {};
B[O.ModelUpdate] = z[O.Change];
var F = Object.assign(Object.assign({}, z), B),
  P = defineComponent({
    name: 'VueCodemirror',
    props: Object.assign({}, w),
    emits: Object.assign({}, F),
    setup: function (r, e) {
      var n = shallowRef(),
        s = shallowRef(),
        o = shallowRef(),
        a = Object.assign(Object.assign({}, h), inject(y, {})),
        l = computed(function () {
          var f = {};
          return (
            Object.keys(toRaw(r)).forEach(function (m) {
              var v;
              m !== 'modelValue' && (f[m] = (v = r[m]) !== null && v !== void 0 ? v : a[m]);
            }),
            f
          );
        });
      return (
        onMounted(function () {
          var f;
          (s.value = j({
            doc: r.modelValue,
            selection: l.value.selection,
            extensions: (f = a.extensions) !== null && f !== void 0 ? f : [],
            onFocus: function (v) {
              return e.emit(O.Focus, v);
            },
            onBlur: function (v) {
              return e.emit(O.Blur, v);
            },
            onUpdate: function (v) {
              return e.emit(O.Update, v);
            },
            onChange: function (v, I) {
              v !== r.modelValue && (e.emit(O.Change, v, I), e.emit(O.ModelUpdate, v, I));
            },
          })),
            (o.value = (function (v) {
              return new EditorView(Object.assign({}, v));
            })({ state: s.value, parent: n.value, root: l.value.root }));
          var m = (function (v) {
            var I = function () {
                return v.state.doc.toString();
              },
              L = S(v).run,
              V = x(v, [EditorView.editable.of(!1), EditorState.readOnly.of(!0)]),
              se = x(v, keymap.of([indentWithTab])),
              Ee = S(v).run,
              ht = S(v).run,
              ar = S(v).run,
              $i = S(v).run;
            return {
              focus: function () {
                return v.focus();
              },
              getDoc: I,
              setDoc: function (tl) {
                tl !== I() && v.dispatch({ changes: { from: 0, to: v.state.doc.length, insert: tl } });
              },
              reExtensions: L,
              toggleDisabled: V,
              toggleIndentWithTab: se,
              setTabSize: function (tl) {
                Ee([EditorState.tabSize.of(tl), indentUnit.of(' '.repeat(tl))]);
              },
              setPhrases: function (tl) {
                ht([EditorState.phrases.of(tl)]);
              },
              setPlaceholder: function (tl) {
                ar(placeholder(tl));
              },
              setStyle: function (tl) {
                tl === void 0 && (tl = {}), $i(EditorView.theme({ '&': Object.assign({}, tl) }));
              },
            };
          })(o.value);
          watch(
            function () {
              return r.modelValue;
            },
            function (v) {
              v !== m.getDoc() && m.setDoc(v);
            },
          ),
            watch(
              function () {
                return r.extensions;
              },
              function (v) {
                return m.reExtensions(v || []);
              },
              { immediate: !0 },
            ),
            watch(
              function () {
                return l.value.disabled;
              },
              function (v) {
                return m.toggleDisabled(v);
              },
              { immediate: !0 },
            ),
            watch(
              function () {
                return l.value.indentWithTab;
              },
              function (v) {
                return m.toggleIndentWithTab(v);
              },
              { immediate: !0 },
            ),
            watch(
              function () {
                return l.value.tabSize;
              },
              function (v) {
                return m.setTabSize(v);
              },
              { immediate: !0 },
            ),
            watch(
              function () {
                return l.value.phrases;
              },
              function (v) {
                return m.setPhrases(v || {});
              },
              { immediate: !0 },
            ),
            watch(
              function () {
                return l.value.placeholder;
              },
              function (v) {
                return m.setPlaceholder(v);
              },
              { immediate: !0 },
            ),
            watch(
              function () {
                return l.value.style;
              },
              function (v) {
                return m.setStyle(v);
              },
              { immediate: !0 },
            ),
            l.value.autofocus && m.focus(),
            e.emit(O.Ready, { state: s.value, view: o.value, container: n.value });
        }),
        onBeforeUnmount(function () {
          l.value.autoDestroy &&
            o.value &&
            (function (f) {
              f.destroy();
            })(o.value);
        }),
        function () {
          return h$1('div', { class: 'v-codemirror', style: { display: 'contents' }, ref: n });
        }
      );
    },
  }),
  T = P,
  Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  ID_Start =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,
  ID_Continue =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
  unicode = { Space_Separator, ID_Start, ID_Continue },
  util = {
    isSpaceSeparator(r) {
      return typeof r == 'string' && unicode.Space_Separator.test(r);
    },
    isIdStartChar(r) {
      return (
        typeof r == 'string' &&
        ((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || r === '$' || r === '_' || unicode.ID_Start.test(r))
      );
    },
    isIdContinueChar(r) {
      return (
        typeof r == 'string' &&
        ((r >= 'a' && r <= 'z') ||
          (r >= 'A' && r <= 'Z') ||
          (r >= '0' && r <= '9') ||
          r === '$' ||
          r === '_' ||
          r === '‌' ||
          r === '‍' ||
          unicode.ID_Continue.test(r))
      );
    },
    isDigit(r) {
      return typeof r == 'string' && /[0-9]/.test(r);
    },
    isHexDigit(r) {
      return typeof r == 'string' && /[0-9A-Fa-f]/.test(r);
    },
  };
let source, parseState, stack, pos, line, column, token, key, root;
var parse = function (e, n) {
  (source = String(e)),
    (parseState = 'start'),
    (stack = []),
    (pos = 0),
    (line = 1),
    (column = 0),
    (token = void 0),
    (key = void 0),
    (root = void 0);
  do (token = lex()), parseStates[parseState]();
  while (token.type !== 'eof');
  return typeof n == 'function' ? internalize({ '': root }, '', n) : root;
};
function internalize(r, e, n) {
  const s = r[e];
  if (s != null && typeof s == 'object')
    if (Array.isArray(s))
      for (let o = 0; o < s.length; o++) {
        const a = String(o),
          l = internalize(s, a, n);
        l === void 0
          ? delete s[a]
          : Object.defineProperty(s, a, { value: l, writable: !0, enumerable: !0, configurable: !0 });
      }
    else
      for (const o in s) {
        const a = internalize(s, o, n);
        a === void 0
          ? delete s[o]
          : Object.defineProperty(s, o, { value: a, writable: !0, enumerable: !0, configurable: !0 });
      }
  return n.call(r, e, s);
}
let lexState, buffer, doubleQuote, sign, c;
function lex() {
  for (lexState = 'default', buffer = '', doubleQuote = !1, sign = 1; ; ) {
    c = peek();
    const r = lexStates[lexState]();
    if (r) return r;
  }
}
function peek() {
  if (source[pos]) return String.fromCodePoint(source.codePointAt(pos));
}
function read() {
  const r = peek();
  return (
    r ===
    `
`
      ? (line++, (column = 0))
      : r
      ? (column += r.length)
      : column++,
    r && (pos += r.length),
    r
  );
}
const lexStates = {
  default() {
    switch (c) {
      case '	':
      case '\v':
      case '\f':
      case ' ':
      case ' ':
      case '\uFEFF':
      case `
`:
      case '\r':
      case '\u2028':
      case '\u2029':
        read();
        return;
      case '/':
        read(), (lexState = 'comment');
        return;
      case void 0:
        return read(), newToken('eof');
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case '*':
        read(), (lexState = 'multiLineComment');
        return;
      case '/':
        read(), (lexState = 'singleLineComment');
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case '*':
        read(), (lexState = 'multiLineCommentAsterisk');
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case '*':
        read();
        return;
      case '/':
        read(), (lexState = 'default');
        return;
      case void 0:
        throw invalidChar(read());
    }
    read(), (lexState = 'multiLineComment');
  },
  singleLineComment() {
    switch (c) {
      case `
`:
      case '\r':
      case '\u2028':
      case '\u2029':
        read(), (lexState = 'default');
        return;
      case void 0:
        return read(), newToken('eof');
    }
    read();
  },
  value() {
    switch (c) {
      case '{':
      case '[':
        return newToken('punctuator', read());
      case 'n':
        return read(), literal('ull'), newToken('null', null);
      case 't':
        return read(), literal('rue'), newToken('boolean', !0);
      case 'f':
        return read(), literal('alse'), newToken('boolean', !1);
      case '-':
      case '+':
        read() === '-' && (sign = -1), (lexState = 'sign');
        return;
      case '.':
        (buffer = read()), (lexState = 'decimalPointLeading');
        return;
      case '0':
        (buffer = read()), (lexState = 'zero');
        return;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        (buffer = read()), (lexState = 'decimalInteger');
        return;
      case 'I':
        return read(), literal('nfinity'), newToken('numeric', 1 / 0);
      case 'N':
        return read(), literal('aN'), newToken('numeric', NaN);
      case '"':
      case "'":
        (doubleQuote = read() === '"'), (buffer = ''), (lexState = 'string');
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== 'u') throw invalidChar(read());
    read();
    const r = unicodeEscape();
    switch (r) {
      case '$':
      case '_':
        break;
      default:
        if (!util.isIdStartChar(r)) throw invalidIdentifier();
        break;
    }
    (buffer += r), (lexState = 'identifierName');
  },
  identifierName() {
    switch (c) {
      case '$':
      case '_':
      case '‌':
      case '‍':
        buffer += read();
        return;
      case '\\':
        read(), (lexState = 'identifierNameEscape');
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken('identifier', buffer);
  },
  identifierNameEscape() {
    if (c !== 'u') throw invalidChar(read());
    read();
    const r = unicodeEscape();
    switch (r) {
      case '$':
      case '_':
      case '‌':
      case '‍':
        break;
      default:
        if (!util.isIdContinueChar(r)) throw invalidIdentifier();
        break;
    }
    (buffer += r), (lexState = 'identifierName');
  },
  sign() {
    switch (c) {
      case '.':
        (buffer = read()), (lexState = 'decimalPointLeading');
        return;
      case '0':
        (buffer = read()), (lexState = 'zero');
        return;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        (buffer = read()), (lexState = 'decimalInteger');
        return;
      case 'I':
        return read(), literal('nfinity'), newToken('numeric', sign * (1 / 0));
      case 'N':
        return read(), literal('aN'), newToken('numeric', NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case '.':
        (buffer += read()), (lexState = 'decimalPoint');
        return;
      case 'e':
      case 'E':
        (buffer += read()), (lexState = 'decimalExponent');
        return;
      case 'x':
      case 'X':
        (buffer += read()), (lexState = 'hexadecimal');
        return;
    }
    return newToken('numeric', sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case '.':
        (buffer += read()), (lexState = 'decimalPoint');
        return;
      case 'e':
      case 'E':
        (buffer += read()), (lexState = 'decimalExponent');
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken('numeric', sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      (buffer += read()), (lexState = 'decimalFraction');
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case 'e':
      case 'E':
        (buffer += read()), (lexState = 'decimalExponent');
        return;
    }
    if (util.isDigit(c)) {
      (buffer += read()), (lexState = 'decimalFraction');
      return;
    }
    return newToken('numeric', sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case 'e':
      case 'E':
        (buffer += read()), (lexState = 'decimalExponent');
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken('numeric', sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case '+':
      case '-':
        (buffer += read()), (lexState = 'decimalExponentSign');
        return;
    }
    if (util.isDigit(c)) {
      (buffer += read()), (lexState = 'decimalExponentInteger');
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      (buffer += read()), (lexState = 'decimalExponentInteger');
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken('numeric', sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      (buffer += read()), (lexState = 'hexadecimalInteger');
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken('numeric', sign * Number(buffer));
  },
  string() {
    switch (c) {
      case '\\':
        read(), (buffer += escape());
        return;
      case '"':
        if (doubleQuote) return read(), newToken('string', buffer);
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) return read(), newToken('string', buffer);
        buffer += read();
        return;
      case `
`:
      case '\r':
        throw invalidChar(read());
      case '\u2028':
      case '\u2029':
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case '{':
      case '[':
        return newToken('punctuator', read());
    }
    lexState = 'value';
  },
  beforePropertyName() {
    switch (c) {
      case '$':
      case '_':
        (buffer = read()), (lexState = 'identifierName');
        return;
      case '\\':
        read(), (lexState = 'identifierNameStartEscape');
        return;
      case '}':
        return newToken('punctuator', read());
      case '"':
      case "'":
        (doubleQuote = read() === '"'), (lexState = 'string');
        return;
    }
    if (util.isIdStartChar(c)) {
      (buffer += read()), (lexState = 'identifierName');
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ':') return newToken('punctuator', read());
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = 'value';
  },
  afterPropertyValue() {
    switch (c) {
      case ',':
      case '}':
        return newToken('punctuator', read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === ']') return newToken('punctuator', read());
    lexState = 'value';
  },
  afterArrayValue() {
    switch (c) {
      case ',':
      case ']':
        return newToken('punctuator', read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  },
};
function newToken(r, e) {
  return { type: r, value: e, line, column };
}
function literal(r) {
  for (const e of r) {
    if (peek() !== e) throw invalidChar(read());
    read();
  }
}
function escape() {
  switch (peek()) {
    case 'b':
      return read(), '\b';
    case 'f':
      return read(), '\f';
    case 'n':
      return (
        read(),
        `
`
      );
    case 'r':
      return read(), '\r';
    case 't':
      return read(), '	';
    case 'v':
      return read(), '\v';
    case '0':
      if ((read(), util.isDigit(peek()))) throw invalidChar(read());
      return '\0';
    case 'x':
      return read(), hexEscape();
    case 'u':
      return read(), unicodeEscape();
    case `
`:
    case '\u2028':
    case '\u2029':
      return read(), '';
    case '\r':
      return (
        read(),
        peek() ===
          `
` && read(),
        ''
      );
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let r = '',
    e = peek();
  if (!util.isHexDigit(e) || ((r += read()), (e = peek()), !util.isHexDigit(e))) throw invalidChar(read());
  return (r += read()), String.fromCodePoint(parseInt(r, 16));
}
function unicodeEscape() {
  let r = '',
    e = 4;
  for (; e-- > 0; ) {
    const n = peek();
    if (!util.isHexDigit(n)) throw invalidChar(read());
    r += read();
  }
  return String.fromCodePoint(parseInt(r, 16));
}
const parseStates = {
  start() {
    if (token.type === 'eof') throw invalidEOF();
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case 'identifier':
      case 'string':
        (key = token.value), (parseState = 'afterPropertyName');
        return;
      case 'punctuator':
        pop();
        return;
      case 'eof':
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === 'eof') throw invalidEOF();
    parseState = 'beforePropertyValue';
  },
  beforePropertyValue() {
    if (token.type === 'eof') throw invalidEOF();
    push();
  },
  beforeArrayValue() {
    if (token.type === 'eof') throw invalidEOF();
    if (token.type === 'punctuator' && token.value === ']') {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === 'eof') throw invalidEOF();
    switch (token.value) {
      case ',':
        parseState = 'beforePropertyName';
        return;
      case '}':
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === 'eof') throw invalidEOF();
    switch (token.value) {
      case ',':
        parseState = 'beforeArrayValue';
        return;
      case ']':
        pop();
    }
  },
  end() {},
};
function push() {
  let r;
  switch (token.type) {
    case 'punctuator':
      switch (token.value) {
        case '{':
          r = {};
          break;
        case '[':
          r = [];
          break;
      }
      break;
    case 'null':
    case 'boolean':
    case 'numeric':
    case 'string':
      r = token.value;
      break;
  }
  if (root === void 0) root = r;
  else {
    const e = stack[stack.length - 1];
    Array.isArray(e)
      ? e.push(r)
      : Object.defineProperty(e, key, { value: r, writable: !0, enumerable: !0, configurable: !0 });
  }
  if (r !== null && typeof r == 'object')
    stack.push(r), Array.isArray(r) ? (parseState = 'beforeArrayValue') : (parseState = 'beforePropertyName');
  else {
    const e = stack[stack.length - 1];
    e == null
      ? (parseState = 'end')
      : Array.isArray(e)
      ? (parseState = 'afterArrayValue')
      : (parseState = 'afterPropertyValue');
  }
}
function pop() {
  stack.pop();
  const r = stack[stack.length - 1];
  r == null
    ? (parseState = 'end')
    : Array.isArray(r)
    ? (parseState = 'afterArrayValue')
    : (parseState = 'afterPropertyValue');
}
function invalidChar(r) {
  return syntaxError(
    r === void 0
      ? `JSON5: invalid end of input at ${line}:${column}`
      : `JSON5: invalid character '${formatChar(r)}' at ${line}:${column}`,
  );
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  return (column -= 5), syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(r) {
  console.warn(`JSON5: '${formatChar(r)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(r) {
  const e = {
    "'": "\\'",
    '"': '\\"',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '	': '\\t',
    '\v': '\\v',
    '\0': '\\0',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029',
  };
  if (e[r]) return e[r];
  if (r < ' ') {
    const n = r.charCodeAt(0).toString(16);
    return '\\x' + ('00' + n).substring(n.length);
  }
  return r;
}
function syntaxError(r) {
  const e = new SyntaxError(r);
  return (e.lineNumber = line), (e.columnNumber = column), e;
}
var stringify = function (e, n, s) {
  const o = [];
  let a = '',
    l,
    f,
    m = '',
    v;
  if (
    (n != null && typeof n == 'object' && !Array.isArray(n) && ((s = n.space), (v = n.quote), (n = n.replacer)),
    typeof n == 'function')
  )
    f = n;
  else if (Array.isArray(n)) {
    l = [];
    for (const ht of n) {
      let ar;
      typeof ht == 'string'
        ? (ar = ht)
        : (typeof ht == 'number' || ht instanceof String || ht instanceof Number) && (ar = String(ht)),
        ar !== void 0 && l.indexOf(ar) < 0 && l.push(ar);
    }
  }
  return (
    s instanceof Number ? (s = Number(s)) : s instanceof String && (s = String(s)),
    typeof s == 'number'
      ? s > 0 && ((s = Math.min(10, Math.floor(s))), (m = '          '.substr(0, s)))
      : typeof s == 'string' && (m = s.substr(0, 10)),
    I('', { '': e })
  );
  function I(ht, ar) {
    let $i = ar[ht];
    switch (
      ($i != null &&
        (typeof $i.toJSON5 == 'function'
          ? ($i = $i.toJSON5(ht))
          : typeof $i.toJSON == 'function' && ($i = $i.toJSON(ht))),
      f && ($i = f.call(ar, ht, $i)),
      $i instanceof Number
        ? ($i = Number($i))
        : $i instanceof String
        ? ($i = String($i))
        : $i instanceof Boolean && ($i = $i.valueOf()),
      $i)
    ) {
      case null:
        return 'null';
      case !0:
        return 'true';
      case !1:
        return 'false';
    }
    if (typeof $i == 'string') return L($i);
    if (typeof $i == 'number') return String($i);
    if (typeof $i == 'object') return Array.isArray($i) ? Ee($i) : V($i);
  }
  function L(ht) {
    const ar = { "'": 0.1, '"': 0.2 },
      $i = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '	': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029',
      };
    let tl = '';
    for (let hl = 0; hl < ht.length; hl++) {
      const fl = ht[hl];
      switch (fl) {
        case "'":
        case '"':
          ar[fl]++, (tl += fl);
          continue;
        case '\0':
          if (util.isDigit(ht[hl + 1])) {
            tl += '\\x00';
            continue;
          }
      }
      if ($i[fl]) {
        tl += $i[fl];
        continue;
      }
      if (fl < ' ') {
        let dl = fl.charCodeAt(0).toString(16);
        tl += '\\x' + ('00' + dl).substring(dl.length);
        continue;
      }
      tl += fl;
    }
    const Wi = v || Object.keys(ar).reduce((hl, fl) => (ar[hl] < ar[fl] ? hl : fl));
    return (tl = tl.replace(new RegExp(Wi, 'g'), $i[Wi])), Wi + tl + Wi;
  }
  function V(ht) {
    if (o.indexOf(ht) >= 0) throw TypeError('Converting circular structure to JSON5');
    o.push(ht);
    let ar = a;
    a = a + m;
    let $i = l || Object.keys(ht),
      tl = [];
    for (const hl of $i) {
      const fl = I(hl, ht);
      if (fl !== void 0) {
        let dl = se(hl) + ':';
        m !== '' && (dl += ' '), (dl += fl), tl.push(dl);
      }
    }
    let Wi;
    if (tl.length === 0) Wi = '{}';
    else {
      let hl;
      if (m === '') (hl = tl.join(',')), (Wi = '{' + hl + '}');
      else {
        let fl =
          `,
` + a;
        (hl = tl.join(fl)),
          (Wi =
            `{
` +
            a +
            hl +
            `,
` +
            ar +
            '}');
      }
    }
    return o.pop(), (a = ar), Wi;
  }
  function se(ht) {
    if (ht.length === 0) return L(ht);
    const ar = String.fromCodePoint(ht.codePointAt(0));
    if (!util.isIdStartChar(ar)) return L(ht);
    for (let $i = ar.length; $i < ht.length; $i++)
      if (!util.isIdContinueChar(String.fromCodePoint(ht.codePointAt($i)))) return L(ht);
    return ht;
  }
  function Ee(ht) {
    if (o.indexOf(ht) >= 0) throw TypeError('Converting circular structure to JSON5');
    o.push(ht);
    let ar = a;
    a = a + m;
    let $i = [];
    for (let Wi = 0; Wi < ht.length; Wi++) {
      const hl = I(String(Wi), ht);
      $i.push(hl !== void 0 ? hl : 'null');
    }
    let tl;
    if ($i.length === 0) tl = '[]';
    else if (m === '') tl = '[' + $i.join(',') + ']';
    else {
      let Wi =
          `,
` + a,
        hl = $i.join(Wi);
      tl =
        `[
` +
        a +
        hl +
        `,
` +
        ar +
        ']';
    }
    return o.pop(), (a = ar), tl;
  }
};
const JSON5 = { parse, stringify };
var lib = JSON5;
class Stack {
  constructor(e, n, s, o, a, l, f, m, v, I = 0, L) {
    (this.p = e),
      (this.stack = n),
      (this.state = s),
      (this.reducePos = o),
      (this.pos = a),
      (this.score = l),
      (this.buffer = f),
      (this.bufferBase = m),
      (this.curContext = v),
      (this.lookAhead = I),
      (this.parent = L);
  }
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${
      this.score ? '!' + this.score : ''
    }`;
  }
  static start(e, n, s = 0) {
    let o = e.parser.context;
    return new Stack(e, [], n, s, s, 0, [], 0, o ? new StackContext(o, o.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), (this.state = e);
  }
  reduce(e) {
    var n;
    let s = e >> 19,
      o = e & 65535,
      { parser: a } = this.p,
      l = a.dynamicPrecedence(o);
    if ((l && (this.score += l), s == 0)) {
      this.pushState(a.getGoto(this.state, o, !0), this.reducePos),
        o < a.minRepeatTerm && this.storeNode(o, this.reducePos, this.reducePos, 4, !0),
        this.reduceContext(o, this.reducePos);
      return;
    }
    let f = this.stack.length - (s - 1) * 3 - (e & 262144 ? 6 : 0),
      m = f ? this.stack[f - 2] : this.p.ranges[0].from,
      v = this.reducePos - m;
    v >= 2e3 &&
      !(!((n = this.p.parser.nodeSet.types[o]) === null || n === void 0) && n.isAnonymous) &&
      (m == this.p.lastBigReductionStart
        ? (this.p.bigReductionCount++, (this.p.lastBigReductionSize = v))
        : this.p.lastBigReductionSize < v &&
          ((this.p.bigReductionCount = 1), (this.p.lastBigReductionStart = m), (this.p.lastBigReductionSize = v)));
    let I = f ? this.stack[f - 1] : 0,
      L = this.bufferBase + this.buffer.length - I;
    if (o < a.minRepeatTerm || e & 131072) {
      let V = a.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(o, m, V, L + 4, !0);
    }
    if (e & 262144) this.state = this.stack[f];
    else {
      let V = this.stack[f - 3];
      this.state = a.getGoto(V, o, !0);
    }
    for (; this.stack.length > f; ) this.stack.pop();
    this.reduceContext(o, m);
  }
  storeNode(e, n, s, o = 4, a = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let l = this,
        f = this.buffer.length;
      if (
        (f == 0 && l.parent && ((f = l.bufferBase - l.parent.bufferBase), (l = l.parent)),
        f > 0 && l.buffer[f - 4] == 0 && l.buffer[f - 1] > -1)
      ) {
        if (n == s) return;
        if (l.buffer[f - 2] >= n) {
          l.buffer[f - 2] = s;
          return;
        }
      }
    }
    if (!a || this.pos == s) this.buffer.push(e, n, s, o);
    else {
      let l = this.buffer.length;
      if (l > 0 && this.buffer[l - 4] != 0)
        for (; l > 0 && this.buffer[l - 2] > s; )
          (this.buffer[l] = this.buffer[l - 4]),
            (this.buffer[l + 1] = this.buffer[l - 3]),
            (this.buffer[l + 2] = this.buffer[l - 2]),
            (this.buffer[l + 3] = this.buffer[l - 1]),
            (l -= 4),
            o > 4 && (o -= 4);
      (this.buffer[l] = e), (this.buffer[l + 1] = n), (this.buffer[l + 2] = s), (this.buffer[l + 3] = o);
    }
  }
  shift(e, n, s, o) {
    if (e & 131072) this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      (this.pos = o), this.shiftContext(n, s), n <= this.p.parser.maxNode && this.buffer.push(n, s, o, 4);
    else {
      let a = e,
        { parser: l } = this.p;
      (o > this.pos || n <= l.maxNode) && ((this.pos = o), l.stateFlag(a, 1) || (this.reducePos = o)),
        this.pushState(a, s),
        this.shiftContext(n, s),
        n <= l.maxNode && this.buffer.push(n, s, o, 4);
    }
  }
  apply(e, n, s, o) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, s, o);
  }
  useNode(e, n) {
    let s = this.p.reused.length - 1;
    (s < 0 || this.p.reused[s] != e) && (this.p.reused.push(e), s++);
    let o = this.pos;
    (this.reducePos = this.pos = o + e.length),
      this.pushState(n, o),
      this.buffer.push(s, o, this.reducePos, -1),
      this.curContext &&
        this.updateContext(
          this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)),
        );
  }
  split() {
    let e = this,
      n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; ) n -= 4;
    let s = e.buffer.slice(n),
      o = e.bufferBase + n;
    for (; e && o == e.bufferBase; ) e = e.parent;
    return new Stack(
      this.p,
      this.stack.slice(),
      this.state,
      this.reducePos,
      this.pos,
      this.score,
      s,
      o,
      this.curContext,
      this.lookAhead,
      e,
    );
  }
  recoverByDelete(e, n) {
    let s = e <= this.p.parser.maxNode;
    s && this.storeNode(e, this.pos, n, 4),
      this.storeNode(0, this.pos, n, s ? 8 : 4),
      (this.pos = this.reducePos = n),
      (this.score -= 190);
  }
  canShift(e) {
    for (let n = new SimulatedStack(this); ; ) {
      let s = this.p.parser.stateSlot(n.state, 4) || this.p.parser.hasAction(n.state, e);
      if (s == 0) return !1;
      if (!(s & 65536)) return !0;
      n.reduce(s);
    }
  }
  recoverByInsert(e) {
    if (this.stack.length >= 300) return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let o = [];
      for (let a = 0, l; a < n.length; a += 2)
        (l = n[a + 1]) != this.state && this.p.parser.hasAction(l, e) && o.push(n[a], l);
      if (this.stack.length < 120)
        for (let a = 0; o.length < 8 && a < n.length; a += 2) {
          let l = n[a + 1];
          o.some((f, m) => m & 1 && f == l) || o.push(n[a], l);
        }
      n = o;
    }
    let s = [];
    for (let o = 0; o < n.length && s.length < 4; o += 2) {
      let a = n[o + 1];
      if (a == this.state) continue;
      let l = this.split();
      l.pushState(a, this.pos),
        l.storeNode(0, l.pos, l.pos, 4, !0),
        l.shiftContext(n[o], this.pos),
        (l.reducePos = this.pos),
        (l.score -= 200),
        s.push(l);
    }
    return s;
  }
  forceReduce() {
    let { parser: e } = this.p,
      n = e.stateSlot(this.state, 5);
    if (!(n & 65536)) return !1;
    if (!e.validAction(this.state, n)) {
      let s = n >> 19,
        o = n & 65535,
        a = this.stack.length - s * 3;
      if (a < 0 || e.getGoto(this.stack[a], o, !1) < 0) {
        let l = this.findForcedReduction();
        if (l == null) return !1;
        n = l;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), (this.score -= 100);
    }
    return (this.reducePos = this.pos), this.reduce(n), !0;
  }
  findForcedReduction() {
    let { parser: e } = this.p,
      n = [],
      s = (o, a) => {
        if (!n.includes(o))
          return (
            n.push(o),
            e.allActions(o, (l) => {
              if (!(l & 393216))
                if (l & 65536) {
                  let f = (l >> 19) - a;
                  if (f > 1) {
                    let m = l & 65535,
                      v = this.stack.length - f * 3;
                    if (v >= 0 && e.getGoto(this.stack[v], m, !1) >= 0) return (f << 19) | 65536 | m;
                  }
                } else {
                  let f = s(l, a + 1);
                  if (f != null) return f;
                }
            })
          );
      };
    return s(this.state, 0);
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3) return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(this.state, 1)] == 65535 && !e.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), (this.state = this.stack[0]), (this.stack.length = 0);
  }
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length) return !1;
    for (let n = 0; n < this.stack.length; n += 3) if (this.stack[n] != e.stack[n]) return !1;
    return !0;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext &&
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext &&
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new StackContext(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), (this.curContext = n);
    }
  }
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), (this.lookAhead = e));
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class StackContext {
  constructor(e, n) {
    (this.tracker = e), (this.context = n), (this.hash = e.strict ? e.hash(n) : 0);
  }
}
class SimulatedStack {
  constructor(e) {
    (this.start = e), (this.state = e.state), (this.stack = e.stack), (this.base = this.stack.length);
  }
  reduce(e) {
    let n = e & 65535,
      s = e >> 19;
    s == 0
      ? (this.stack == this.start.stack && (this.stack = this.stack.slice()),
        this.stack.push(this.state, 0, 0),
        (this.base += 3))
      : (this.base -= (s - 1) * 3);
    let o = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = o;
  }
}
class StackBufferCursor {
  constructor(e, n, s) {
    (this.stack = e), (this.pos = n), (this.index = s), (this.buffer = e.buffer), this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new StackBufferCursor(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && ((this.index = this.stack.bufferBase - e.bufferBase), (this.stack = e), (this.buffer = e.buffer));
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    (this.index -= 4), (this.pos -= 4), this.index == 0 && this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
}
function decodeArray(r, e = Uint16Array) {
  if (typeof r != 'string') return r;
  let n = null;
  for (let s = 0, o = 0; s < r.length; ) {
    let a = 0;
    for (;;) {
      let l = r.charCodeAt(s++),
        f = !1;
      if (l == 126) {
        a = 65535;
        break;
      }
      l >= 92 && l--, l >= 34 && l--;
      let m = l - 32;
      if ((m >= 46 && ((m -= 46), (f = !0)), (a += m), f)) break;
      a *= 46;
    }
    n ? (n[o++] = a) : (n = new e(a));
  }
  return n;
}
class CachedToken {
  constructor() {
    (this.start = -1),
      (this.value = -1),
      (this.end = -1),
      (this.extended = -1),
      (this.lookAhead = 0),
      (this.mask = 0),
      (this.context = 0);
  }
}
const nullToken = new CachedToken();
class InputStream {
  constructor(e, n) {
    (this.input = e),
      (this.ranges = n),
      (this.chunk = ''),
      (this.chunkOff = 0),
      (this.chunk2 = ''),
      (this.chunk2Pos = 0),
      (this.next = -1),
      (this.token = nullToken),
      (this.rangeIndex = 0),
      (this.pos = this.chunkPos = n[0].from),
      (this.range = n[0]),
      (this.end = n[n.length - 1].to),
      this.readNext();
  }
  resolveOffset(e, n) {
    let s = this.range,
      o = this.rangeIndex,
      a = this.pos + e;
    for (; a < s.from; ) {
      if (!o) return null;
      let l = this.ranges[--o];
      (a -= s.from - l.to), (s = l);
    }
    for (; n < 0 ? a > s.to : a >= s.to; ) {
      if (o == this.ranges.length - 1) return null;
      let l = this.ranges[++o];
      (a += l.from - s.to), (s = l);
    }
    return a;
  }
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to) return e;
    for (let n of this.ranges) if (n.to > e) return Math.max(e, n.from);
    return this.end;
  }
  peek(e) {
    let n = this.chunkOff + e,
      s,
      o;
    if (n >= 0 && n < this.chunk.length) (s = this.pos + e), (o = this.chunk.charCodeAt(n));
    else {
      let a = this.resolveOffset(e, 1);
      if (a == null) return -1;
      if (((s = a), s >= this.chunk2Pos && s < this.chunk2Pos + this.chunk2.length))
        o = this.chunk2.charCodeAt(s - this.chunk2Pos);
      else {
        let l = this.rangeIndex,
          f = this.range;
        for (; f.to <= s; ) f = this.ranges[++l];
        (this.chunk2 = this.input.chunk((this.chunk2Pos = s))),
          s + this.chunk2.length > f.to && (this.chunk2 = this.chunk2.slice(0, f.to - s)),
          (o = this.chunk2.charCodeAt(0));
      }
    }
    return s >= this.token.lookAhead && (this.token.lookAhead = s + 1), o;
  }
  acceptToken(e, n = 0) {
    let s = n ? this.resolveOffset(n, -1) : this.pos;
    if (s == null || s < this.token.start) throw new RangeError('Token end out of bounds');
    (this.token.value = e), (this.token.end = s);
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      (this.chunk = this.chunk2),
        (this.chunkPos = this.chunk2Pos),
        (this.chunk2 = e),
        (this.chunk2Pos = n),
        (this.chunkOff = this.pos - this.chunkPos);
    } else {
      (this.chunk2 = this.chunk), (this.chunk2Pos = this.chunkPos);
      let e = this.input.chunk(this.pos),
        n = this.pos + e.length;
      (this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e),
        (this.chunkPos = this.pos),
        (this.chunkOff = 0);
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length)
      ? (this.next = -1)
      : (this.next = this.chunk.charCodeAt(this.chunkOff));
  }
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
      (e -= this.range.to - this.pos), (this.range = this.ranges[++this.rangeIndex]), (this.pos = this.range.from);
    }
    return (this.pos += e), this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return (
      (this.pos = this.chunkPos = this.end),
      (this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]),
      (this.chunk = ''),
      (this.next = -1)
    );
  }
  reset(e, n) {
    if (
      (n
        ? ((this.token = n), (n.start = e), (n.lookAhead = e + 1), (n.value = n.extended = -1))
        : (this.token = nullToken),
      this.pos != e)
    ) {
      if (((this.pos = e), e == this.end)) return this.setDone(), this;
      for (; e < this.range.from; ) this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; ) this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length
        ? (this.chunkOff = e - this.chunkPos)
        : ((this.chunk = ''), (this.chunkOff = 0)),
        this.readNext();
    }
    return this;
  }
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to) return this.input.read(e, n);
    let s = '';
    for (let o of this.ranges) {
      if (o.from >= n) break;
      o.to > e && (s += this.input.read(Math.max(o.from, e), Math.min(o.to, n)));
    }
    return s;
  }
}
class TokenGroup {
  constructor(e, n) {
    (this.data = e), (this.id = n);
  }
  token(e, n) {
    let { parser: s } = n.p;
    readToken(this.data, e, n, this.id, s.data, s.tokenPrecTable);
  }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = !1;
TokenGroup.prototype.fallback = TokenGroup.prototype.extend = !1;
function readToken(r, e, n, s, o, a) {
  let l = 0,
    f = 1 << s,
    { dialect: m } = n.p.parser;
  e: for (; f & r[l]; ) {
    let v = r[l + 1];
    for (let se = l + 3; se < v; se += 2)
      if ((r[se + 1] & f) > 0) {
        let Ee = r[se];
        if (m.allows(Ee) && (e.token.value == -1 || e.token.value == Ee || overrides(Ee, e.token.value, o, a))) {
          e.acceptToken(Ee);
          break;
        }
      }
    let I = e.next,
      L = 0,
      V = r[l + 2];
    if (e.next < 0 && V > L && r[v + V * 3 - 3] == 65535 && r[v + V * 3 - 3] == 65535) {
      l = r[v + V * 3 - 1];
      continue e;
    }
    for (; L < V; ) {
      let se = (L + V) >> 1,
        Ee = v + se + (se << 1),
        ht = r[Ee],
        ar = r[Ee + 1] || 65536;
      if (I < ht) V = se;
      else if (I >= ar) L = se + 1;
      else {
        (l = r[Ee + 2]), e.advance();
        continue e;
      }
    }
    break;
  }
}
function findOffset(r, e, n) {
  for (let s = e, o; (o = r[s]) != 65535; s++) if (o == n) return s - e;
  return -1;
}
function overrides(r, e, n, s) {
  let o = findOffset(n, s, e);
  return o < 0 || findOffset(n, s, r) < o;
}
const verbose = typeof process < 'u' && process.env && /\bparse\b/.test({}.LOG);
let stackIDs = null;
function cutAt(r, e, n) {
  let s = r.cursor(IterMode.IncludeAnonymous);
  for (s.moveTo(e); ; )
    if (!(n < 0 ? s.childBefore(e) : s.childAfter(e)))
      for (;;) {
        if ((n < 0 ? s.to < e : s.from > e) && !s.type.isError)
          return n < 0 ? Math.max(0, Math.min(s.to - 1, e - 25)) : Math.min(r.length, Math.max(s.from + 1, e + 25));
        if (n < 0 ? s.prevSibling() : s.nextSibling()) break;
        if (!s.parent()) return n < 0 ? 0 : r.length;
      }
}
class FragmentCursor {
  constructor(e, n) {
    (this.fragments = e),
      (this.nodeSet = n),
      (this.i = 0),
      (this.fragment = null),
      (this.safeFrom = -1),
      (this.safeTo = -1),
      (this.trees = []),
      (this.start = []),
      (this.index = []),
      this.nextFragment();
  }
  nextFragment() {
    let e = (this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]);
    if (e) {
      for (
        this.safeFrom = e.openStart ? cutAt(e.tree, e.from + e.offset, 1) - e.offset : e.from,
          this.safeTo = e.openEnd ? cutAt(e.tree, e.to + e.offset, -1) - e.offset : e.to;
        this.trees.length;

      )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), (this.nextStart = this.safeFrom);
    } else this.nextStart = 1e9;
  }
  nodeAt(e) {
    if (e < this.nextStart) return null;
    for (; this.fragment && this.safeTo <= e; ) this.nextFragment();
    if (!this.fragment) return null;
    for (;;) {
      let n = this.trees.length - 1;
      if (n < 0) return this.nextFragment(), null;
      let s = this.trees[n],
        o = this.index[n];
      if (o == s.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let a = s.children[o],
        l = this.start[n] + s.positions[o];
      if (l > e) return (this.nextStart = l), null;
      if (a instanceof Tree) {
        if (l == e) {
          if (l < this.safeFrom) return null;
          let f = l + a.length;
          if (f <= this.safeTo) {
            let m = a.prop(NodeProp.lookAhead);
            if (!m || f + m < this.fragment.to) return a;
          }
        }
        this.index[n]++,
          l + a.length >= Math.max(this.safeFrom, e) && (this.trees.push(a), this.start.push(l), this.index.push(0));
      } else this.index[n]++, (this.nextStart = l + a.length);
    }
  }
}
class TokenCache {
  constructor(e, n) {
    (this.stream = n),
      (this.tokens = []),
      (this.mainToken = null),
      (this.actions = []),
      (this.tokens = e.tokenizers.map((s) => new CachedToken()));
  }
  getActions(e) {
    let n = 0,
      s = null,
      { parser: o } = e.p,
      { tokenizers: a } = o,
      l = o.stateSlot(e.state, 3),
      f = e.curContext ? e.curContext.hash : 0,
      m = 0;
    for (let v = 0; v < a.length; v++) {
      if (!((1 << v) & l)) continue;
      let I = a[v],
        L = this.tokens[v];
      if (
        !(s && !I.fallback) &&
        ((I.contextual || L.start != e.pos || L.mask != l || L.context != f) &&
          (this.updateCachedToken(L, I, e), (L.mask = l), (L.context = f)),
        L.lookAhead > L.end + 25 && (m = Math.max(L.lookAhead, m)),
        L.value != 0)
      ) {
        let V = n;
        if (
          (L.extended > -1 && (n = this.addActions(e, L.extended, L.end, n)),
          (n = this.addActions(e, L.value, L.end, n)),
          !I.extend && ((s = L), n > V))
        )
          break;
      }
    }
    for (; this.actions.length > n; ) this.actions.pop();
    return (
      m && e.setLookAhead(m),
      !s &&
        e.pos == this.stream.end &&
        ((s = new CachedToken()),
        (s.value = e.p.parser.eofTerm),
        (s.start = s.end = e.pos),
        (n = this.addActions(e, s.value, s.end, n))),
      (this.mainToken = s),
      this.actions
    );
  }
  getMainToken(e) {
    if (this.mainToken) return this.mainToken;
    let n = new CachedToken(),
      { pos: s, p: o } = e;
    return (
      (n.start = s), (n.end = Math.min(s + 1, o.stream.end)), (n.value = s == o.stream.end ? o.parser.eofTerm : 0), n
    );
  }
  updateCachedToken(e, n, s) {
    let o = this.stream.clipPos(s.pos);
    if ((n.token(this.stream.reset(o, e), s), e.value > -1)) {
      let { parser: a } = s.p;
      for (let l = 0; l < a.specialized.length; l++)
        if (a.specialized[l] == e.value) {
          let f = a.specializers[l](this.stream.read(e.start, e.end), s);
          if (f >= 0 && s.p.parser.dialect.allows(f >> 1)) {
            f & 1 ? (e.extended = f >> 1) : (e.value = f >> 1);
            break;
          }
        }
    } else (e.value = 0), (e.end = this.stream.clipPos(o + 1));
  }
  putAction(e, n, s, o) {
    for (let a = 0; a < o; a += 3) if (this.actions[a] == e) return o;
    return (this.actions[o++] = e), (this.actions[o++] = n), (this.actions[o++] = s), o;
  }
  addActions(e, n, s, o) {
    let { state: a } = e,
      { parser: l } = e.p,
      { data: f } = l;
    for (let m = 0; m < 2; m++)
      for (let v = l.stateSlot(a, m ? 2 : 1); ; v += 3) {
        if (f[v] == 65535)
          if (f[v + 1] == 1) v = pair(f, v + 2);
          else {
            o == 0 && f[v + 1] == 2 && (o = this.putAction(pair(f, v + 2), n, s, o));
            break;
          }
        f[v] == n && (o = this.putAction(pair(f, v + 1), n, s, o));
      }
    return o;
  }
}
class Parse {
  constructor(e, n, s, o) {
    (this.parser = e),
      (this.input = n),
      (this.ranges = o),
      (this.recovering = 0),
      (this.nextStackID = 9812),
      (this.minStackPos = 0),
      (this.reused = []),
      (this.stoppedAt = null),
      (this.lastBigReductionStart = -1),
      (this.lastBigReductionSize = 0),
      (this.bigReductionCount = 0),
      (this.stream = new InputStream(n, o)),
      (this.tokens = new TokenCache(e, this.stream)),
      (this.topTerm = e.top[1]);
    let { from: a } = o[0];
    (this.stacks = [Stack.start(this, e.top[0], a)]),
      (this.fragments = s.length && this.stream.end - a > e.bufferLength * 4 ? new FragmentCursor(s, e.nodeSet) : null);
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let e = this.stacks,
      n = this.minStackPos,
      s = (this.stacks = []),
      o,
      a;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [l] = e;
      for (; l.forceReduce() && l.stack.length && l.stack[l.stack.length - 2] >= this.lastBigReductionStart; );
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let l = 0; l < e.length; l++) {
      let f = e[l];
      for (;;) {
        if (((this.tokens.mainToken = null), f.pos > n)) s.push(f);
        else {
          if (this.advanceStack(f, s, e)) continue;
          {
            o || ((o = []), (a = [])), o.push(f);
            let m = this.tokens.getMainToken(f);
            a.push(m.value, m.end);
          }
        }
        break;
      }
    }
    if (!s.length) {
      let l = o && findFinished(o);
      if (l) return verbose && console.log('Finish with ' + this.stackID(l)), this.stackToTree(l);
      if (this.parser.strict)
        throw (
          (verbose &&
            o &&
            console.log(
              'Stuck with token ' + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : 'none'),
            ),
          new SyntaxError('No parse at ' + n))
        );
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && o) {
      let l = this.stoppedAt != null && o[0].pos > this.stoppedAt ? o[0] : this.runRecovery(o, a, s);
      if (l) return verbose && console.log('Force-finish ' + this.stackID(l)), this.stackToTree(l.forceAll());
    }
    if (this.recovering) {
      let l = this.recovering == 1 ? 1 : this.recovering * 3;
      if (s.length > l) for (s.sort((f, m) => m.score - f.score); s.length > l; ) s.pop();
      s.some((f) => f.reducePos > n) && this.recovering--;
    } else if (s.length > 1) {
      e: for (let l = 0; l < s.length - 1; l++) {
        let f = s[l];
        for (let m = l + 1; m < s.length; m++) {
          let v = s[m];
          if (f.sameState(v) || (f.buffer.length > 500 && v.buffer.length > 500))
            if ((f.score - v.score || f.buffer.length - v.buffer.length) > 0) s.splice(m--, 1);
            else {
              s.splice(l--, 1);
              continue e;
            }
        }
      }
      s.length > 12 && s.splice(12, s.length - 12);
    }
    this.minStackPos = s[0].pos;
    for (let l = 1; l < s.length; l++) s[l].pos < this.minStackPos && (this.minStackPos = s[l].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  advanceStack(e, n, s) {
    let o = e.pos,
      { parser: a } = this,
      l = verbose ? this.stackID(e) + ' -> ' : '';
    if (this.stoppedAt != null && o > this.stoppedAt) return e.forceReduce() ? e : null;
    if (this.fragments) {
      let v = e.curContext && e.curContext.tracker.strict,
        I = v ? e.curContext.hash : 0;
      for (let L = this.fragments.nodeAt(o); L; ) {
        let V = this.parser.nodeSet.types[L.type.id] == L.type ? a.getGoto(e.state, L.type.id) : -1;
        if (V > -1 && L.length && (!v || (L.prop(NodeProp.contextHash) || 0) == I))
          return (
            e.useNode(L, V), verbose && console.log(l + this.stackID(e) + ` (via reuse of ${a.getName(L.type.id)})`), !0
          );
        if (!(L instanceof Tree) || L.children.length == 0 || L.positions[0] > 0) break;
        let se = L.children[0];
        if (se instanceof Tree && L.positions[0] == 0) L = se;
        else break;
      }
    }
    let f = a.stateSlot(e.state, 4);
    if (f > 0)
      return (
        e.reduce(f), verbose && console.log(l + this.stackID(e) + ` (via always-reduce ${a.getName(f & 65535)})`), !0
      );
    if (e.stack.length >= 9e3) for (; e.stack.length > 6e3 && e.forceReduce(); );
    let m = this.tokens.getActions(e);
    for (let v = 0; v < m.length; ) {
      let I = m[v++],
        L = m[v++],
        V = m[v++],
        se = v == m.length || !s,
        Ee = se ? e : e.split(),
        ht = this.tokens.mainToken;
      if (
        (Ee.apply(I, L, ht ? ht.start : Ee.pos, V),
        verbose &&
          console.log(
            l +
              this.stackID(Ee) +
              ` (via ${I & 65536 ? `reduce of ${a.getName(I & 65535)}` : 'shift'} for ${a.getName(L)} @ ${o}${
                Ee == e ? '' : ', split'
              })`,
          ),
        se)
      )
        return !0;
      Ee.pos > o ? n.push(Ee) : s.push(Ee);
    }
    return !1;
  }
  advanceFully(e, n) {
    let s = e.pos;
    for (;;) {
      if (!this.advanceStack(e, null, null)) return !1;
      if (e.pos > s) return pushStackDedup(e, n), !0;
    }
  }
  runRecovery(e, n, s) {
    let o = null,
      a = !1;
    for (let l = 0; l < e.length; l++) {
      let f = e[l],
        m = n[l << 1],
        v = n[(l << 1) + 1],
        I = verbose ? this.stackID(f) + ' -> ' : '';
      if (
        f.deadEnd &&
        (a ||
          ((a = !0),
          f.restart(),
          verbose && console.log(I + this.stackID(f) + ' (restarted)'),
          this.advanceFully(f, s)))
      )
        continue;
      let L = f.split(),
        V = I;
      for (
        let se = 0;
        L.forceReduce() &&
        se < 10 &&
        (verbose && console.log(V + this.stackID(L) + ' (via force-reduce)'), !this.advanceFully(L, s));
        se++
      )
        verbose && (V = this.stackID(L) + ' -> ');
      for (let se of f.recoverByInsert(m))
        verbose && console.log(I + this.stackID(se) + ' (via recover-insert)'), this.advanceFully(se, s);
      this.stream.end > f.pos
        ? (v == f.pos && (v++, (m = 0)),
          f.recoverByDelete(m, v),
          verbose && console.log(I + this.stackID(f) + ` (via recover-delete ${this.parser.getName(m)})`),
          pushStackDedup(f, s))
        : (!o || o.score < f.score) && (o = f);
    }
    return o;
  }
  stackToTree(e) {
    return (
      e.close(),
      Tree.build({
        buffer: StackBufferCursor.create(e),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: e.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm,
      })
    );
  }
  stackID(e) {
    let n = (stackIDs || (stackIDs = new WeakMap())).get(e);
    return n || stackIDs.set(e, (n = String.fromCodePoint(this.nextStackID++))), n + e;
  }
}
function pushStackDedup(r, e) {
  for (let n = 0; n < e.length; n++) {
    let s = e[n];
    if (s.pos == r.pos && s.sameState(r)) {
      e[n].score < r.score && (e[n] = r);
      return;
    }
  }
  e.push(r);
}
class Dialect {
  constructor(e, n, s) {
    (this.source = e), (this.flags = n), (this.disabled = s);
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
class LRParser extends Parser {
  constructor(e) {
    if ((super(), (this.wrappers = []), e.version != 14))
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(' ');
    this.minRepeatTerm = n.length;
    for (let f = 0; f < e.repeatNodeCount; f++) n.push('');
    let s = Object.keys(e.topRules).map((f) => e.topRules[f][1]),
      o = [];
    for (let f = 0; f < n.length; f++) o.push([]);
    function a(f, m, v) {
      o[f].push([m, m.deserialize(String(v))]);
    }
    if (e.nodeProps)
      for (let f of e.nodeProps) {
        let m = f[0];
        typeof m == 'string' && (m = NodeProp[m]);
        for (let v = 1; v < f.length; ) {
          let I = f[v++];
          if (I >= 0) a(I, m, f[v++]);
          else {
            let L = f[v + -I];
            for (let V = -I; V > 0; V--) a(f[v++], m, L);
            v++;
          }
        }
      }
    (this.nodeSet = new NodeSet(
      n.map((f, m) =>
        NodeType.define({
          name: m >= this.minRepeatTerm ? void 0 : f,
          id: m,
          props: o[m],
          top: s.indexOf(m) > -1,
          error: m == 0,
          skipped: e.skippedNodes && e.skippedNodes.indexOf(m) > -1,
        }),
      ),
    )),
      e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)),
      (this.strict = !1),
      (this.bufferLength = DefaultBufferLength);
    let l = decodeArray(e.tokenData);
    (this.context = e.context),
      (this.specializerSpecs = e.specialized || []),
      (this.specialized = new Uint16Array(this.specializerSpecs.length));
    for (let f = 0; f < this.specializerSpecs.length; f++) this.specialized[f] = this.specializerSpecs[f].term;
    (this.specializers = this.specializerSpecs.map(getSpecializer)),
      (this.states = decodeArray(e.states, Uint32Array)),
      (this.data = decodeArray(e.stateData)),
      (this.goto = decodeArray(e.goto)),
      (this.maxTerm = e.maxTerm),
      (this.tokenizers = e.tokenizers.map((f) => (typeof f == 'number' ? new TokenGroup(l, f) : f))),
      (this.topRules = e.topRules),
      (this.dialects = e.dialects || {}),
      (this.dynamicPrecedences = e.dynamicPrecedences || null),
      (this.tokenPrecTable = e.tokenPrec),
      (this.termNames = e.termNames || null),
      (this.maxNode = this.nodeSet.types.length - 1),
      (this.dialect = this.parseDialect()),
      (this.top = this.topRules[Object.keys(this.topRules)[0]]);
  }
  createParse(e, n, s) {
    let o = new Parse(this, e, n, s);
    for (let a of this.wrappers) o = a(o, e, n, s);
    return o;
  }
  getGoto(e, n, s = !1) {
    let o = this.goto;
    if (n >= o[0]) return -1;
    for (let a = o[n + 1]; ; ) {
      let l = o[a++],
        f = l & 1,
        m = o[a++];
      if (f && s) return m;
      for (let v = a + (l >> 1); a < v; a++) if (o[a] == e) return m;
      if (f) return -1;
    }
  }
  hasAction(e, n) {
    let s = this.data;
    for (let o = 0; o < 2; o++)
      for (let a = this.stateSlot(e, o ? 2 : 1), l; ; a += 3) {
        if ((l = s[a]) == 65535)
          if (s[a + 1] == 1) l = s[(a = pair(s, a + 2))];
          else {
            if (s[a + 1] == 2) return pair(s, a + 2);
            break;
          }
        if (l == n || l == 0) return pair(s, a + 1);
      }
    return 0;
  }
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  stateFlag(e, n) {
    return (this.stateSlot(e, 0) & n) > 0;
  }
  validAction(e, n) {
    return !!this.allActions(e, (s) => (s == n ? !0 : null));
  }
  allActions(e, n) {
    let s = this.stateSlot(e, 4),
      o = s ? n(s) : void 0;
    for (let a = this.stateSlot(e, 1); o == null; a += 3) {
      if (this.data[a] == 65535)
        if (this.data[a + 1] == 1) a = pair(this.data, a + 2);
        else break;
      o = n(pair(this.data, a + 1));
    }
    return o;
  }
  nextStates(e) {
    let n = [];
    for (let s = this.stateSlot(e, 1); ; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1) s = pair(this.data, s + 2);
        else break;
      if (!(this.data[s + 2] & 1)) {
        let o = this.data[s + 1];
        n.some((a, l) => l & 1 && a == o) || n.push(this.data[s], o);
      }
    }
    return n;
  }
  configure(e) {
    let n = Object.assign(Object.create(LRParser.prototype), this);
    if ((e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top)) {
      let s = this.topRules[e.top];
      if (!s) throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = s;
    }
    return (
      e.tokenizers &&
        (n.tokenizers = this.tokenizers.map((s) => {
          let o = e.tokenizers.find((a) => a.from == s);
          return o ? o.to : s;
        })),
      e.specializers &&
        ((n.specializers = this.specializers.slice()),
        (n.specializerSpecs = this.specializerSpecs.map((s, o) => {
          let a = e.specializers.find((f) => f.from == s.external);
          if (!a) return s;
          let l = Object.assign(Object.assign({}, s), { external: a.to });
          return (n.specializers[o] = getSpecializer(l)), l;
        }))),
      e.contextTracker && (n.context = e.contextTracker),
      e.dialect && (n.dialect = this.parseDialect(e.dialect)),
      e.strict != null && (n.strict = e.strict),
      e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)),
      e.bufferLength != null && (n.bufferLength = e.bufferLength),
      n
    );
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(e) {
    return this.termNames ? this.termNames[e] : String((e <= this.maxNode && this.nodeSet.types[e].name) || e);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  parseDialect(e) {
    let n = Object.keys(this.dialects),
      s = n.map(() => !1);
    if (e)
      for (let a of e.split(' ')) {
        let l = n.indexOf(a);
        l >= 0 && (s[l] = !0);
      }
    let o = null;
    for (let a = 0; a < n.length; a++)
      if (!s[a])
        for (let l = this.dialects[n[a]], f; (f = this.data[l++]) != 65535; )
          (o || (o = new Uint8Array(this.maxTerm + 1)))[f] = 1;
    return new Dialect(e, s, o);
  }
  static deserialize(e) {
    return new LRParser(e);
  }
}
function pair(r, e) {
  return r[e] | (r[e + 1] << 16);
}
function findFinished(r) {
  let e = null;
  for (let n of r) {
    let s = n.p.stoppedAt;
    (n.pos == n.p.stream.end || (s != null && n.pos > s)) &&
      n.p.parser.stateFlag(n.state, 2) &&
      (!e || e.score < n.score) &&
      (e = n);
  }
  return e;
}
function getSpecializer(r) {
  if (r.external) {
    let e = r.extend ? 1 : 0;
    return (n, s) => (r.external(n, s) << 1) | e;
  }
  return r.get;
}
const parser = LRParser.deserialize({
  version: 14,
  states:
    "%WO`QPOOOwQQO'#CbO!SQPO'#ChOOQO'#Cj'#CjOOQO'#Ct'#CtQOQPOOOOQO'#Cd'#CdO!ZQPO'#CcOOQO,58|,58|O!`QPO,58|OOQO,59S,59SO!hQPO,59SO`QPO,58}O!pQQO1G.hO!{QPO1G.hOOQO1G.h1G.hO#TQPO1G.nO#[QPO1G.nOOQO1G.n1G.nOOQO1G.i1G.iOOQO,59Y,59YOOQO7+$S7+$SO#dQQO7+$SOOQO-E6l-E6lOOQO,59Z,59ZOOQO7+$Y7+$YO#oQPO7+$YOOQO-E6m-E6mOOQO<<Gn<<GnPzQQO'#CnOOQO<<Gt<<GtP`QPO'#Co",
  stateData:
    '#x~OPOSQOSfOSgOS~OTPOZQO]SO_SO`SOaSOiRO~OSWOiUOjUO~OYYO~P`OX[O~OS_Ok]O~OYbOk`O~OSeOiUOjUO~OSeOkfO~OYiO~P`OYiOkjO~OSlOiUOjUO~OYnO~P`Oj~',
  goto: '!liPPPPPPjrzPPPjPjPPP!Q!WPPPP!^]SOQ[`joQXPVd]fmXVP]fmQ^XRg^QaZRkaQTOQZQQc[Vh`jo',
  nodeNames:
    '⚠ LineComment BlockComment File } { Object Property PropertyName PropertyColon ] [ Array Number String Null True False',
  maxTerm: 27,
  nodeProps: [
    ['openedBy', 4, '{', 10, '['],
    ['closedBy', 5, '}', 11, ']'],
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 2,
  tokenData:
    ">X~R!TXY$bYZ%YZ[$b[]$b]^%Ypq$brs%_tu&owx'W{|(c|},O}!O(c!O!P(r!P!Q,T!Q!R)l!R![*l![!]-d!c!k&o!k!l-i!l!p&o!p!q2g!q!}&o!}#O3p#P#Q3u#R#S&o#T#Y&o#Y#Z3z#Z#b&o#b#c6z#c#h&o#h#i9`#i#o&o#o#p;t#q#r;y$f$g$b$g#BY&o#BY#BZ<O#BZ$IS&o$IS$I_<O$I_$I|&o$I|$I}=n$I}$JO=n$JO$JT&o$JT$JU<O$JU$KV&o$KV$KW<O$KW&FU&o&FU&FV<O&FV?HT&o?HT?HU<O?HU~&o~$gZf~XY$bZ[$b[]$bpq$b$f$g$b#BY#BZ$b$IS$I_$b$JT$JU$b$KV$KW$b&FU&FV$b?HT?HU$b~%_Og~~%bTOr%_rs%qs#O%_#O#P%v#P~%_~%vOi~~%y[YZ%_]^%_rs%_#O#P%_#U#V%_#Y#Z%_#b#c%_#f#g%_#h#i%_#j#k%_$I|$I}%_$I}$JO%_Q&tUjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&o~'ZTOw'Wwx%qx#O'W#O#P'j#P~'W~'m[YZ'W]^'Wwx'W#O#P'W#U#V'W#Y#Z'W#b#c'W#f#g'W#h#i'W#j#k'W$I|$I}'W$I}$JO'WP(fS!O!P(r!Q!R)l!R![*l!k!l*}P(wR]P!Q![(r!g!h)Q#X#Y)QP)TR{|)^}!O)^!Q![)dP)aP!Q![)dP)iP]P!Q![)dP)qT]P!O!P(r!g!h)Q!z!{*Q#X#Y)Q#l#m*QP*TR!Q![*^!c!i*^#T#Z*^P*cR]P!Q![*^!c!i*^#T#Z*^P*qS]P!O!P(r!Q![*l!g!h)Q#X#Y)QP+QP#b#c+TP+WP#Y#Z+ZP+^P#]#^+aP+dP#b#c+gP+jP#]#^+mP+pP#h#i+sP+vP#m#n+yP,OO]P~,TOk~~,WQz{,^!P!Q-R~,aROz,^z{,j{~,^~,mTOz,^z{,j{!P,^!P!Q,|!Q~,^~-ROQ~~-WSP~OY-RZ]-R^$I|-R$JO~-R~-iOX~R-nWjQtu&o!Q![&o!c!}&o#R#S&o#T#b&o#b#c.W#c#o&o$g~&oR.]WjQtu&o!Q![&o!c!}&o#R#S&o#T#Y&o#Y#Z.u#Z#o&o$g~&oR.zWjQtu&o!Q![&o!c!}&o#R#S&o#T#]&o#]#^/d#^#o&o$g~&oR/iWjQtu&o!Q![&o!c!}&o#R#S&o#T#b&o#b#c0R#c#o&o$g~&oR0WWjQtu&o!Q![&o!c!}&o#R#S&o#T#]&o#]#^0p#^#o&o$g~&oR0uWjQtu&o!Q![&o!c!}&o#R#S&o#T#h&o#h#i1_#i#o&o$g~&oR1dWjQtu&o!Q![&o!c!}&o#R#S&o#T#m&o#m#n1|#n#o&o$g~&oR2TU]PjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&oR2lVjQtu&o!Q![&o!c!}&o#R#S&o#T#U3R#U#o&o$g~&oR3WWjQtu&o!Q![&o!c!p&o!p!q1|!q!}&o#R#S&o#T#o&o$g~&o~3uOZ~~3zOY~R4PVjQtu&o!Q![&o!c!}&o#R#S&o#T#U4f#U#o&o$g~&oR4kWjQtu&o!Q![&o!c!}&o#R#S&o#T#`&o#`#a5T#a#o&o$g~&oR5YWjQtu&o!Q![&o!c!}&o#R#S&o#T#g&o#g#h5r#h#o&o$g~&oR5wWjQtu&o!Q![&o!c!}&o#R#S&o#T#X&o#X#Y6a#Y#o&o$g~&oR6hUaPjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&oR7PWjQtu&o!Q![&o!c!}&o#R#S&o#T#i&o#i#j7i#j#o&o$g~&oR7nWjQtu&o!Q![&o!c!}&o#R#S&o#T#`&o#`#a8W#a#o&o$g~&oR8]WjQtu&o!Q![&o!c!}&o#R#S&o#T#`&o#`#a8u#a#o&o$g~&oR8|U_PjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&oR9eWjQtu&o!Q![&o!c!}&o#R#S&o#T#f&o#f#g9}#g#o&o$g~&oR:SWjQtu&o!Q![&o!c!}&o#R#S&o#T#i&o#i#j:l#j#o&o$g~&oR:qWjQtu&o!Q![&o!c!}&o#R#S&o#T#X&o#X#Y;Z#Y#o&o$g~&oR;bU`PjQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&o~;yOT~~<OOS~~<Vgf~jQXY$bZ[$b[]$bpq$btu&o!Q![&o!c!}&o#R#S&o#T#o&o$f$g$b$g#BY&o#BY#BZ<O#BZ$IS&o$IS$I_<O$I_$JT&o$JT$JU<O$JU$KV&o$KV$KW<O$KW&FU&o&FU&FV<O&FV?HT&o?HT?HU<O?HU~&o~=uUg~jQtu&o!Q![&o!c!}&o#R#S&o#T#o&o$g~&o",
  tokenizers: [0, 1],
  topRules: { File: [0, 3] },
  tokenPrec: 130,
});
function stripQuotes(r) {
  let e = r[0],
    n = r[r.length - 1];
  return ((e === "'" && n === "'") || (e === '"' && n === '"')) && (r = r.slice(1, -1)), r;
}
function propertyKey(r, e) {
  if (e.name !== 'Property') return null;
  let n = e.getChild('PropertyName');
  return n ? stripQuotes(r.sliceDoc(n.from, n.to)) : null;
}
function getParentProperty(r) {
  var e;
  let n = (e = r.parent) === null || e === void 0 ? void 0 : e.cursor();
  if (!n) return null;
  for (; n.node.name !== 'Property' && n.node.name !== 'Array'; ) if (!n.parent()) return null;
  return n.node;
}
function getPathAtNode(r, e) {
  let n = [];
  for (;;) {
    let s = getParentProperty(e);
    if (!s) break;
    if (s.name === 'Array') {
      let o = e.from,
        a = s.firstChild,
        l = 0;
      for (; a && a.to < o; ) (a = validNodeLookRight(a.nextSibling)), (l += 1);
      n.unshift(l);
    } else {
      let o = propertyKey(r, s);
      o && n.unshift(o);
    }
    e = s;
  }
  return n;
}
function validNodeLookRight(r) {
  for (; r && /Comment/.test(r.name); ) r = r.nextSibling;
  return r;
}
function nodeAtCursor(r, e) {
  let s = syntaxTree(r).resolveInner(e, -1);
  for (; s; ) {
    let o = s.childBefore(e);
    if (!o) break;
    s = o;
  }
  return s;
}
const json5Language = LRLanguage.define({
  parser: parser.configure({
    props: [
      indentNodeProp.add({
        Object: continuedIndent({ except: /^\s*\}/ }),
        Array: continuedIndent({ except: /^\s*\]/ }),
      }),
      foldNodeProp.add({ 'Object Array': foldInside }),
      styleTags({
        'String': tags.string,
        'PropertyName!': tags.propertyName,
        'Number': tags.number,
        'True False': tags.bool,
        'Null': tags.null,
        'LineComment': tags.lineComment,
        'BlockComment': tags.blockComment,
        ', PropertyColon': tags.separator,
        '[ ]': tags.squareBracket,
        '{ }': tags.brace,
      }),
    ],
  }),
  languageData: {
    closeBrackets: { brackets: ['[', '{', '"', "'"] },
    indentOnInput: /^\s*[}\]]$/,
    commentTokens: { line: '//', block: { open: '/*', clone: '*/' } },
  },
});
function json5() {
  return new LanguageSupport(json5Language, [json5ParseCache.extension, jsonCursorPath.extension]);
}
function handleParseError(r, e) {
  let n = 0;
  return (
    'lineNumber' in e &&
      'columnNumber' in e &&
      (n = Math.min(r.line(e.lineNumber).from + e.columnNumber - 1, r.length)),
    [{ from: n, to: n, message: e.message, severity: 'error' }]
  );
}
function json5ParseLinter(r) {
  return (e) => {
    var n, s;
    let o = e.state.doc,
      a = e.state.field(json5ParseCache, !1);
    if (a) {
      if (a.err) return handleParseError(o, a.err);
      if (a.obj !== void 0) return (n = r == null ? void 0 : r(e, a.obj)) !== null && n !== void 0 ? n : [];
    }
    try {
      let l = lib.parse(o.toString());
      return (s = r == null ? void 0 : r(e, l)) !== null && s !== void 0 ? s : [];
    } catch (l) {
      return handleParseError(o, l);
    }
  };
}
const json5ParseCache = StateField.define({
    create() {
      return null;
    },
    update(r, e) {
      if (!e.docChanged) return r;
      try {
        return { err: null, obj: lib.parse(e.newDoc.toString()) };
      } catch (n) {
        return { err: n, obj: r == null ? void 0 : r.obj };
      }
    },
  }),
  jsonCursorPath = StateField.define({
    create() {
      return { path: null, node: null };
    },
    update(r, e) {
      let n = e.state.selection.main.to,
        s = nodeAtCursor(e.state, n),
        o = s ? getPathAtNode(e.state, s) : null;
      return { path: o ?? null, node: s };
    },
  });
var mock = { exports: {} };
(function (module, exports) {
  (function (e, n) {
    module.exports = n();
  })(commonjsGlobal, function () {
    return (function (r) {
      var e = {};
      function n(s) {
        if (e[s]) return e[s].exports;
        var o = (e[s] = { exports: {}, id: s, loaded: !1 });
        return r[s].call(o.exports, o, o.exports, n), (o.loaded = !0), o.exports;
      }
      return (n.m = r), (n.c = e), (n.p = ''), n(0);
    })([
      function (r, e, n) {
        var s = n(1),
          o = n(3),
          a = n(5),
          l = n(20),
          f = n(23),
          m = n(25),
          v;
        typeof window < 'u' && (v = n(27));
        /*!
    Mock - 模拟请求 & 模拟数据
    https://github.com/nuysoft/Mock
    墨智 mozhi.gyy@taobao.com nuysoft@gmail.com
*/ var I = {
          Handler: s,
          Random: a,
          Util: o,
          XHR: v,
          RE: l,
          toJSONSchema: f,
          valid: m,
          heredoc: o.heredoc,
          setup: function (L) {
            return v.setup(L);
          },
          _mocked: {},
        };
        (I.version = '1.0.1-beta3'),
          v && (v.Mock = I),
          (I.mock = function (L, V, se) {
            return arguments.length === 1
              ? s.gen(L)
              : (arguments.length === 2 && ((se = V), (V = void 0)),
                v && (window.XMLHttpRequest = v),
                (I._mocked[L + (V || '')] = { rurl: L, rtype: V, template: se }),
                I);
          }),
          (r.exports = I);
      },
      function (module, exports, __webpack_require__) {
        var Constant = __webpack_require__(2),
          Util = __webpack_require__(3),
          Parser = __webpack_require__(4),
          Random = __webpack_require__(5),
          RE = __webpack_require__(20),
          Handler = { extend: Util.extend };
        (Handler.gen = function (r, e, n) {
          (e = e == null ? '' : e + ''),
            (n = n || {}),
            (n = {
              path: n.path || [Constant.GUID],
              templatePath: n.templatePath || [Constant.GUID++],
              currentContext: n.currentContext,
              templateCurrentContext: n.templateCurrentContext || r,
              root: n.root || n.currentContext,
              templateRoot: n.templateRoot || n.templateCurrentContext || r,
            });
          var s = Parser.parse(e),
            o = Util.type(r),
            a;
          return Handler[o]
            ? ((a = Handler[o]({
                type: o,
                template: r,
                name: e,
                parsedName: e && e.replace(Constant.RE_KEY, '$1'),
                rule: s,
                context: n,
              })),
              n.root || (n.root = a),
              a)
            : r;
        }),
          Handler.extend({
            array: function (r) {
              var e = [],
                n,
                s;
              if (r.template.length === 0) return e;
              if (r.rule.parameters)
                if (r.rule.min === 1 && r.rule.max === void 0)
                  r.context.path.push(r.name),
                    r.context.templatePath.push(r.name),
                    (e = Random.pick(
                      Handler.gen(r.template, void 0, {
                        path: r.context.path,
                        templatePath: r.context.templatePath,
                        currentContext: e,
                        templateCurrentContext: r.template,
                        root: r.context.root || e,
                        templateRoot: r.context.templateRoot || r.template,
                      }),
                    )),
                    r.context.path.pop(),
                    r.context.templatePath.pop();
                else if (r.rule.parameters[2])
                  (r.template.__order_index = r.template.__order_index || 0),
                    r.context.path.push(r.name),
                    r.context.templatePath.push(r.name),
                    (e = Handler.gen(r.template, void 0, {
                      path: r.context.path,
                      templatePath: r.context.templatePath,
                      currentContext: e,
                      templateCurrentContext: r.template,
                      root: r.context.root || e,
                      templateRoot: r.context.templateRoot || r.template,
                    })[r.template.__order_index % r.template.length]),
                    (r.template.__order_index += +r.rule.parameters[2]),
                    r.context.path.pop(),
                    r.context.templatePath.pop();
                else
                  for (n = 0; n < r.rule.count; n++)
                    for (s = 0; s < r.template.length; s++)
                      r.context.path.push(e.length),
                        r.context.templatePath.push(s),
                        e.push(
                          Handler.gen(r.template[s], e.length, {
                            path: r.context.path,
                            templatePath: r.context.templatePath,
                            currentContext: e,
                            templateCurrentContext: r.template,
                            root: r.context.root || e,
                            templateRoot: r.context.templateRoot || r.template,
                          }),
                        ),
                        r.context.path.pop(),
                        r.context.templatePath.pop();
              else
                for (n = 0; n < r.template.length; n++)
                  r.context.path.push(n),
                    r.context.templatePath.push(n),
                    e.push(
                      Handler.gen(r.template[n], n, {
                        path: r.context.path,
                        templatePath: r.context.templatePath,
                        currentContext: e,
                        templateCurrentContext: r.template,
                        root: r.context.root || e,
                        templateRoot: r.context.templateRoot || r.template,
                      }),
                    ),
                    r.context.path.pop(),
                    r.context.templatePath.pop();
              return e;
            },
            object: function (r) {
              var e = {},
                n,
                s,
                o,
                a,
                l,
                f;
              if (r.rule.min != null)
                for (
                  n = Util.keys(r.template), n = Random.shuffle(n), n = n.slice(0, r.rule.count), f = 0;
                  f < n.length;
                  f++
                )
                  (o = n[f]),
                    (a = o.replace(Constant.RE_KEY, '$1')),
                    r.context.path.push(a),
                    r.context.templatePath.push(o),
                    (e[a] = Handler.gen(r.template[o], o, {
                      path: r.context.path,
                      templatePath: r.context.templatePath,
                      currentContext: e,
                      templateCurrentContext: r.template,
                      root: r.context.root || e,
                      templateRoot: r.context.templateRoot || r.template,
                    })),
                    r.context.path.pop(),
                    r.context.templatePath.pop();
              else {
                (n = []), (s = []);
                for (o in r.template) (typeof r.template[o] == 'function' ? s : n).push(o);
                for (n = n.concat(s), f = 0; f < n.length; f++)
                  (o = n[f]),
                    (a = o.replace(Constant.RE_KEY, '$1')),
                    r.context.path.push(a),
                    r.context.templatePath.push(o),
                    (e[a] = Handler.gen(r.template[o], o, {
                      path: r.context.path,
                      templatePath: r.context.templatePath,
                      currentContext: e,
                      templateCurrentContext: r.template,
                      root: r.context.root || e,
                      templateRoot: r.context.templateRoot || r.template,
                    })),
                    r.context.path.pop(),
                    r.context.templatePath.pop(),
                    (l = o.match(Constant.RE_KEY)),
                    l && l[2] && Util.type(r.template[o]) === 'number' && (r.template[o] += parseInt(l[2], 10));
              }
              return e;
            },
            number: function (r) {
              var e, n;
              if (r.rule.decimal) {
                for (
                  r.template += '',
                    n = r.template.split('.'),
                    n[0] = r.rule.range ? r.rule.count : n[0],
                    n[1] = (n[1] || '').slice(0, r.rule.dcount);
                  n[1].length < r.rule.dcount;

                )
                  n[1] += n[1].length < r.rule.dcount - 1 ? Random.character('number') : Random.character('123456789');
                e = parseFloat(n.join('.'), 10);
              } else e = r.rule.range && !r.rule.parameters[2] ? r.rule.count : r.template;
              return e;
            },
            boolean: function (r) {
              var e;
              return (e = r.rule.parameters ? Random.bool(r.rule.min, r.rule.max, r.template) : r.template), e;
            },
            string: function (r) {
              var e = '',
                n,
                s,
                o,
                a;
              if (r.template.length) {
                for (r.rule.count == null && (e += r.template), n = 0; n < r.rule.count; n++) e += r.template;
                for (s = e.match(Constant.RE_PLACEHOLDER) || [], n = 0; n < s.length; n++) {
                  if (((o = s[n]), /^\\/.test(o))) {
                    s.splice(n--, 1);
                    continue;
                  }
                  if (
                    ((a = Handler.placeholder(o, r.context.currentContext, r.context.templateCurrentContext, r)),
                    s.length === 1 && o === e && typeof a != typeof e)
                  ) {
                    e = a;
                    break;
                  }
                  e = e.replace(o, a);
                }
              } else e = r.rule.range ? Random.string(r.rule.count) : r.template;
              return e;
            },
            function: function (r) {
              return r.template.call(r.context.currentContext, r);
            },
            regexp: function (r) {
              var e = '';
              r.rule.count == null && (e += r.template.source);
              for (var n = 0; n < r.rule.count; n++) e += r.template.source;
              return RE.Handler.gen(RE.Parser.parse(e));
            },
          }),
          Handler.extend({
            _all: function () {
              var r = {};
              for (var e in Random) r[e.toLowerCase()] = e;
              return r;
            },
            placeholder: function (placeholder, obj, templateContext, options) {
              Constant.RE_PLACEHOLDER.exec('');
              var parts = Constant.RE_PLACEHOLDER.exec(placeholder),
                key = parts && parts[1],
                lkey = key && key.toLowerCase(),
                okey = this._all()[lkey],
                params = (parts && parts[2]) || '',
                pathParts = this.splitPathToArray(key);
              try {
                params = eval('(function(){ return [].splice.call(arguments, 0 ) })(' + params + ')');
              } catch (r) {
                params = parts[2].split(/,\s*/);
              }
              if (obj && key in obj) return obj[key];
              if (key.charAt(0) === '/' || pathParts.length > 1) return this.getValueByKeyPath(key, options);
              if (
                templateContext &&
                typeof templateContext == 'object' &&
                key in templateContext &&
                placeholder !== templateContext[key]
              )
                return (
                  (templateContext[key] = Handler.gen(templateContext[key], key, {
                    currentContext: obj,
                    templateCurrentContext: templateContext,
                  })),
                  templateContext[key]
                );
              if (!(key in Random) && !(lkey in Random) && !(okey in Random)) return placeholder;
              for (var i = 0; i < params.length; i++)
                Constant.RE_PLACEHOLDER.exec(''),
                  Constant.RE_PLACEHOLDER.test(params[i]) &&
                    (params[i] = Handler.placeholder(params[i], obj, templateContext, options));
              var handle = Random[key] || Random[lkey] || Random[okey];
              switch (Util.type(handle)) {
                case 'array':
                  return Random.pick(handle);
                case 'function':
                  handle.options = options;
                  var re = handle.apply(Random, params);
                  return re === void 0 && (re = ''), delete handle.options, re;
              }
            },
            getValueByKeyPath: function (r, e) {
              var n = r,
                s = this.splitPathToArray(r),
                o = [];
              r.charAt(0) === '/'
                ? (o = [e.context.path[0]].concat(this.normalizePath(s)))
                : s.length > 1 && ((o = e.context.path.slice(0)), o.pop(), (o = this.normalizePath(o.concat(s))));
              try {
                r = s[s.length - 1];
                for (var a = e.context.root, l = e.context.templateRoot, f = 1; f < o.length - 1; f++)
                  (a = a[o[f]]), (l = l[o[f]]);
                if (a && r in a) return a[r];
                if (l && typeof l == 'object' && r in l && n !== l[r])
                  return (l[r] = Handler.gen(l[r], r, { currentContext: a, templateCurrentContext: l })), l[r];
              } catch {}
              return '@' + s.join('/');
            },
            normalizePath: function (r) {
              for (var e = [], n = 0; n < r.length; n++)
                switch (r[n]) {
                  case '..':
                    e.pop();
                    break;
                  case '.':
                    break;
                  default:
                    e.push(r[n]);
                }
              return e;
            },
            splitPathToArray: function (r) {
              var e = r.split(/\/+/);
              return e[e.length - 1] || (e = e.slice(0, -1)), e[0] || (e = e.slice(1)), e;
            },
          }),
          (module.exports = Handler);
      },
      function (r, e) {
        r.exports = {
          GUID: 1,
          RE_KEY: /(.+)\|(?:\+(\d+)|([\+\-]?\d+-?[\+\-]?\d*)?(?:\.(\d+-?\d*))?)/,
          RE_RANGE: /([\+\-]?\d+)-?([\+\-]?\d+)?/,
          RE_PLACEHOLDER: /\\*@([^@#%&()\?\s]+)(?:\((.*?)\))?/g,
        };
      },
      function (r, e) {
        var n = {};
        (n.extend = function () {
          var o = arguments[0] || {},
            a = 1,
            l = arguments.length,
            f,
            m,
            v,
            I,
            L;
          for (l === 1 && ((o = this), (a = 0)); a < l; a++)
            if (((f = arguments[a]), !!f))
              for (m in f)
                (v = o[m]),
                  (I = f[m]),
                  o !== I &&
                    I !== void 0 &&
                    (n.isArray(I) || n.isObject(I)
                      ? (n.isArray(I) && (L = v && n.isArray(v) ? v : []),
                        n.isObject(I) && (L = v && n.isObject(v) ? v : {}),
                        (o[m] = n.extend(L, I)))
                      : (o[m] = I));
          return o;
        }),
          (n.each = function (o, a, l) {
            var f, m;
            if (this.type(o) === 'number') for (f = 0; f < o; f++) a(f, f);
            else if (o.length === +o.length) for (f = 0; f < o.length && a.call(l, o[f], f, o) !== !1; f++);
            else for (m in o) if (a.call(l, o[m], m, o) === !1) break;
          }),
          (n.type = function (o) {
            return o == null
              ? String(o)
              : Object.prototype.toString
                  .call(o)
                  .match(/\[object (\w+)\]/)[1]
                  .toLowerCase();
          }),
          n.each('String Object Array RegExp Function'.split(' '), function (s) {
            n['is' + s] = function (o) {
              return n.type(o) === s.toLowerCase();
            };
          }),
          (n.isObjectOrArray = function (s) {
            return n.isObject(s) || n.isArray(s);
          }),
          (n.isNumeric = function (s) {
            return !isNaN(parseFloat(s)) && isFinite(s);
          }),
          (n.keys = function (s) {
            var o = [];
            for (var a in s) s.hasOwnProperty(a) && o.push(a);
            return o;
          }),
          (n.values = function (s) {
            var o = [];
            for (var a in s) s.hasOwnProperty(a) && o.push(s[a]);
            return o;
          }),
          (n.heredoc = function (o) {
            return o
              .toString()
              .replace(/^[^\/]+\/\*!?/, '')
              .replace(/\*\/[^\/]+$/, '')
              .replace(/^[\s\xA0]+/, '')
              .replace(/[\s\xA0]+$/, '');
          }),
          (n.noop = function () {}),
          (r.exports = n);
      },
      function (r, e, n) {
        var s = n(2),
          o = n(5);
        r.exports = {
          parse: function (a) {
            a = a == null ? '' : a + '';
            var l = (a || '').match(s.RE_KEY),
              f = l && l[3] && l[3].match(s.RE_RANGE),
              m = f && f[1] && parseInt(f[1], 10),
              v = f && f[2] && parseInt(f[2], 10),
              I = f ? (f[2] ? o.integer(m, v) : parseInt(f[1], 10)) : void 0,
              L = l && l[4] && l[4].match(s.RE_RANGE),
              V = L && L[1] && parseInt(L[1], 10),
              se = L && L[2] && parseInt(L[2], 10),
              Ee = L ? (!L[2] && parseInt(L[1], 10)) || o.integer(V, se) : void 0,
              ht = { parameters: l, range: f, min: m, max: v, count: I, decimal: L, dmin: V, dmax: se, dcount: Ee };
            for (var ar in ht) if (ht[ar] != null) return ht;
            return {};
          },
        };
      },
      function (r, e, n) {
        var s = n(3),
          o = { extend: s.extend };
        o.extend(n(6)),
          o.extend(n(7)),
          o.extend(n(8)),
          o.extend(n(10)),
          o.extend(n(13)),
          o.extend(n(15)),
          o.extend(n(16)),
          o.extend(n(17)),
          o.extend(n(14)),
          o.extend(n(19)),
          (r.exports = o);
      },
      function (r, e) {
        r.exports = {
          boolean: function (n, s, o) {
            return o !== void 0
              ? ((n = typeof n < 'u' && !isNaN(n) ? parseInt(n, 10) : 1),
                (s = typeof s < 'u' && !isNaN(s) ? parseInt(s, 10) : 1),
                Math.random() > (1 / (n + s)) * n ? !o : o)
              : Math.random() >= 0.5;
          },
          bool: function (n, s, o) {
            return this.boolean(n, s, o);
          },
          natural: function (n, s) {
            return (
              (n = typeof n < 'u' ? parseInt(n, 10) : 0),
              (s = typeof s < 'u' ? parseInt(s, 10) : 9007199254740992),
              Math.round(Math.random() * (s - n)) + n
            );
          },
          integer: function (n, s) {
            return (
              (n = typeof n < 'u' ? parseInt(n, 10) : -9007199254740992),
              (s = typeof s < 'u' ? parseInt(s, 10) : 9007199254740992),
              Math.round(Math.random() * (s - n)) + n
            );
          },
          int: function (n, s) {
            return this.integer(n, s);
          },
          float: function (n, s, o, a) {
            (o = o === void 0 ? 0 : o),
              (o = Math.max(Math.min(o, 17), 0)),
              (a = a === void 0 ? 17 : a),
              (a = Math.max(Math.min(a, 17), 0));
            for (var l = this.integer(n, s) + '.', f = 0, m = this.natural(o, a); f < m; f++)
              l += f < m - 1 ? this.character('number') : this.character('123456789');
            return parseFloat(l, 10);
          },
          character: function (n) {
            var s = {
              lower: 'abcdefghijklmnopqrstuvwxyz',
              upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
              number: '0123456789',
              symbol: '!@#$%^&*()[]',
            };
            return (
              (s.alpha = s.lower + s.upper),
              (s.undefined = s.lower + s.upper + s.number + s.symbol),
              (n = s[('' + n).toLowerCase()] || n),
              n.charAt(this.natural(0, n.length - 1))
            );
          },
          char: function (n) {
            return this.character(n);
          },
          string: function (n, s, o) {
            var a;
            switch (arguments.length) {
              case 0:
                a = this.natural(3, 7);
                break;
              case 1:
                (a = n), (n = void 0);
                break;
              case 2:
                typeof arguments[0] == 'string' ? (a = s) : ((a = this.natural(n, s)), (n = void 0));
                break;
              case 3:
                a = this.natural(s, o);
                break;
            }
            for (var l = '', f = 0; f < a; f++) l += this.character(n);
            return l;
          },
          str: function () {
            return this.string.apply(this, arguments);
          },
          range: function (n, s, o) {
            arguments.length <= 1 && ((s = n || 0), (n = 0)), (o = arguments[2] || 1), (n = +n), (s = +s), (o = +o);
            for (var a = Math.max(Math.ceil((s - n) / o), 0), l = 0, f = new Array(a); l < a; ) (f[l++] = n), (n += o);
            return f;
          },
        };
      },
      function (r, e) {
        var n = {
          yyyy: 'getFullYear',
          yy: function (s) {
            return ('' + s.getFullYear()).slice(2);
          },
          y: 'yy',
          MM: function (s) {
            var o = s.getMonth() + 1;
            return o < 10 ? '0' + o : o;
          },
          M: function (s) {
            return s.getMonth() + 1;
          },
          dd: function (s) {
            var o = s.getDate();
            return o < 10 ? '0' + o : o;
          },
          d: 'getDate',
          HH: function (s) {
            var o = s.getHours();
            return o < 10 ? '0' + o : o;
          },
          H: 'getHours',
          hh: function (s) {
            var o = s.getHours() % 12;
            return o < 10 ? '0' + o : o;
          },
          h: function (s) {
            return s.getHours() % 12;
          },
          mm: function (s) {
            var o = s.getMinutes();
            return o < 10 ? '0' + o : o;
          },
          m: 'getMinutes',
          ss: function (s) {
            var o = s.getSeconds();
            return o < 10 ? '0' + o : o;
          },
          s: 'getSeconds',
          SS: function (s) {
            var o = s.getMilliseconds();
            return (o < 10 && '00' + o) || (o < 100 && '0' + o) || o;
          },
          S: 'getMilliseconds',
          A: function (s) {
            return s.getHours() < 12 ? 'AM' : 'PM';
          },
          a: function (s) {
            return s.getHours() < 12 ? 'am' : 'pm';
          },
          T: 'getTime',
        };
        r.exports = {
          _patternLetters: n,
          _rformat: new RegExp(
            (function () {
              var s = [];
              for (var o in n) s.push(o);
              return '(' + s.join('|') + ')';
            })(),
            'g',
          ),
          _formatDate: function (s, o) {
            return o.replace(this._rformat, function a(l, f) {
              return typeof n[f] == 'function' ? n[f](s) : n[f] in n ? a(l, n[f]) : s[n[f]]();
            });
          },
          _randomDate: function (s, o) {
            return (
              (s = s === void 0 ? new Date(0) : s),
              (o = o === void 0 ? new Date() : o),
              new Date(Math.random() * (o.getTime() - s.getTime()))
            );
          },
          date: function (s) {
            return (s = s || 'yyyy-MM-dd'), this._formatDate(this._randomDate(), s);
          },
          time: function (s) {
            return (s = s || 'HH:mm:ss'), this._formatDate(this._randomDate(), s);
          },
          datetime: function (s) {
            return (s = s || 'yyyy-MM-dd HH:mm:ss'), this._formatDate(this._randomDate(), s);
          },
          now: function (s, o) {
            arguments.length === 1 && (/year|month|day|hour|minute|second|week/.test(s) || ((o = s), (s = ''))),
              (s = (s || '').toLowerCase()),
              (o = o || 'yyyy-MM-dd HH:mm:ss');
            var a = new Date();
            switch (s) {
              case 'year':
                a.setMonth(0);
              case 'month':
                a.setDate(1);
              case 'week':
              case 'day':
                a.setHours(0);
              case 'hour':
                a.setMinutes(0);
              case 'minute':
                a.setSeconds(0);
              case 'second':
                a.setMilliseconds(0);
            }
            switch (s) {
              case 'week':
                a.setDate(a.getDate() - a.getDay());
            }
            return this._formatDate(a, o);
          },
        };
      },
      function (r, e, n) {
        (function (s) {
          s.exports = {
            _adSize: [
              '300x250',
              '250x250',
              '240x400',
              '336x280',
              '180x150',
              '720x300',
              '468x60',
              '234x60',
              '88x31',
              '120x90',
              '120x60',
              '120x240',
              '125x125',
              '728x90',
              '160x600',
              '120x600',
              '300x600',
            ],
            _screenSize: [
              '320x200',
              '320x240',
              '640x480',
              '800x480',
              '800x480',
              '1024x600',
              '1024x768',
              '1280x800',
              '1440x900',
              '1920x1200',
              '2560x1600',
            ],
            _videoSize: ['720x480', '768x576', '1280x720', '1920x1080'],
            image: function (o, a, l, f, m) {
              return (
                arguments.length === 4 && ((m = f), (f = void 0)),
                arguments.length === 3 && ((m = l), (l = void 0)),
                o || (o = this.pick(this._adSize)),
                a && ~a.indexOf('#') && (a = a.slice(1)),
                l && ~l.indexOf('#') && (l = l.slice(1)),
                'http://dummyimage.com/' +
                  o +
                  (a ? '/' + a : '') +
                  (l ? '/' + l : '') +
                  (f ? '.' + f : '') +
                  (m ? '&text=' + m : '')
              );
            },
            img: function () {
              return this.image.apply(this, arguments);
            },
            _brandColors: {
              '4ormat': '#fb0a2a',
              '500px': '#02adea',
              'About.me (blue)': '#00405d',
              'About.me (yellow)': '#ffcc33',
              'Addvocate': '#ff6138',
              'Adobe': '#ff0000',
              'Aim': '#fcd20b',
              'Amazon': '#e47911',
              'Android': '#a4c639',
              "Angie's List": '#7fbb00',
              'AOL': '#0060a3',
              'Atlassian': '#003366',
              'Behance': '#053eff',
              'Big Cartel': '#97b538',
              'bitly': '#ee6123',
              'Blogger': '#fc4f08',
              'Boeing': '#0039a6',
              'Booking.com': '#003580',
              'Carbonmade': '#613854',
              'Cheddar': '#ff7243',
              'Code School': '#3d4944',
              'Delicious': '#205cc0',
              'Dell': '#3287c1',
              'Designmoo': '#e54a4f',
              'Deviantart': '#4e6252',
              'Designer News': '#2d72da',
              'Devour': '#fd0001',
              'DEWALT': '#febd17',
              'Disqus (blue)': '#59a3fc',
              'Disqus (orange)': '#db7132',
              'Dribbble': '#ea4c89',
              'Dropbox': '#3d9ae8',
              'Drupal': '#0c76ab',
              'Dunked': '#2a323a',
              'eBay': '#89c507',
              'Ember': '#f05e1b',
              'Engadget': '#00bdf6',
              'Envato': '#528036',
              'Etsy': '#eb6d20',
              'Evernote': '#5ba525',
              'Fab.com': '#dd0017',
              'Facebook': '#3b5998',
              'Firefox': '#e66000',
              'Flickr (blue)': '#0063dc',
              'Flickr (pink)': '#ff0084',
              'Forrst': '#5b9a68',
              'Foursquare': '#25a0ca',
              'Garmin': '#007cc3',
              'GetGlue': '#2d75a2',
              'Gimmebar': '#f70078',
              'GitHub': '#171515',
              'Google Blue': '#0140ca',
              'Google Green': '#16a61e',
              'Google Red': '#dd1812',
              'Google Yellow': '#fcca03',
              'Google+': '#dd4b39',
              'Grooveshark': '#f77f00',
              'Groupon': '#82b548',
              'Hacker News': '#ff6600',
              'HelloWallet': '#0085ca',
              'Heroku (light)': '#c7c5e6',
              'Heroku (dark)': '#6567a5',
              'HootSuite': '#003366',
              'Houzz': '#73ba37',
              'HTML5': '#ec6231',
              'IKEA': '#ffcc33',
              'IMDb': '#f3ce13',
              'Instagram': '#3f729b',
              'Intel': '#0071c5',
              'Intuit': '#365ebf',
              'Kickstarter': '#76cc1e',
              'kippt': '#e03500',
              'Kodery': '#00af81',
              'LastFM': '#c3000d',
              'LinkedIn': '#0e76a8',
              'Livestream': '#cf0005',
              'Lumo': '#576396',
              'Mixpanel': '#a086d3',
              'Meetup': '#e51937',
              'Nokia': '#183693',
              'NVIDIA': '#76b900',
              'Opera': '#cc0f16',
              'Path': '#e41f11',
              'PayPal (dark)': '#1e477a',
              'PayPal (light)': '#3b7bbf',
              'Pinboard': '#0000e6',
              'Pinterest': '#c8232c',
              'PlayStation': '#665cbe',
              'Pocket': '#ee4056',
              'Prezi': '#318bff',
              'Pusha': '#0f71b4',
              'Quora': '#a82400',
              'QUOTE.fm': '#66ceff',
              'Rdio': '#008fd5',
              'Readability': '#9c0000',
              'Red Hat': '#cc0000',
              'Resource': '#7eb400',
              'Rockpack': '#0ba6ab',
              'Roon': '#62b0d9',
              'RSS': '#ee802f',
              'Salesforce': '#1798c1',
              'Samsung': '#0c4da2',
              'Shopify': '#96bf48',
              'Skype': '#00aff0',
              'Snagajob': '#f47a20',
              'Softonic': '#008ace',
              'SoundCloud': '#ff7700',
              'Space Box': '#f86960',
              'Spotify': '#81b71a',
              'Sprint': '#fee100',
              'Squarespace': '#121212',
              'StackOverflow': '#ef8236',
              'Staples': '#cc0000',
              'Status Chart': '#d7584f',
              'Stripe': '#008cdd',
              'StudyBlue': '#00afe1',
              'StumbleUpon': '#f74425',
              'T-Mobile': '#ea0a8e',
              'Technorati': '#40a800',
              'The Next Web': '#ef4423',
              'Treehouse': '#5cb868',
              'Trulia': '#5eab1f',
              'Tumblr': '#34526f',
              'Twitch.tv': '#6441a5',
              'Twitter': '#00acee',
              'TYPO3': '#ff8700',
              'Ubuntu': '#dd4814',
              'Ustream': '#3388ff',
              'Verizon': '#ef1d1d',
              'Vimeo': '#86c9ef',
              'Vine': '#00a478',
              'Virb': '#06afd8',
              'Virgin Media': '#cc0000',
              'Wooga': '#5b009c',
              'WordPress (blue)': '#21759b',
              'WordPress (orange)': '#d54e21',
              'WordPress (grey)': '#464646',
              'Wunderlist': '#2b88d9',
              'XBOX': '#9bc848',
              'XING': '#126567',
              'Yahoo!': '#720e9e',
              'Yandex': '#ffcc00',
              'Yelp': '#c41200',
              'YouTube': '#c4302b',
              'Zalongo': '#5498dc',
              'Zendesk': '#78a300',
              'Zerply': '#9dcc7a',
              'Zootool': '#5e8b1d',
            },
            _brandNames: function () {
              var o = [];
              for (var a in this._brandColors) o.push(a);
              return o;
            },
            dataImage: function (o, a) {
              var l;
              if (typeof document < 'u') l = document.createElement('canvas');
              else {
                var f = s.require('canvas');
                l = new f();
              }
              var m = l && l.getContext && l.getContext('2d');
              if (!l || !m) return '';
              o || (o = this.pick(this._adSize)), (a = a !== void 0 ? a : o), (o = o.split('x'));
              var v = parseInt(o[0], 10),
                I = parseInt(o[1], 10),
                L = this._brandColors[this.pick(this._brandNames())],
                V = '#FFF',
                se = 14,
                Ee = 'sans-serif';
              return (
                (l.width = v),
                (l.height = I),
                (m.textAlign = 'center'),
                (m.textBaseline = 'middle'),
                (m.fillStyle = L),
                m.fillRect(0, 0, v, I),
                (m.fillStyle = V),
                (m.font = 'bold ' + se + 'px ' + Ee),
                m.fillText(a, v / 2, I / 2, v),
                l.toDataURL('image/png')
              );
            },
          };
        }).call(e, n(9)(r));
      },
      function (r, e) {
        r.exports = function (n) {
          return (
            n.webpackPolyfill ||
              ((n.deprecate = function () {}), (n.paths = []), (n.children = []), (n.webpackPolyfill = 1)),
            n
          );
        };
      },
      function (r, e, n) {
        var s = n(11),
          o = n(12);
        r.exports = {
          color: function (a) {
            return a || o[a] ? o[a].nicer : this.hex();
          },
          hex: function () {
            var a = this._goldenRatioColor(),
              l = s.hsv2rgb(a),
              f = s.rgb2hex(l[0], l[1], l[2]);
            return f;
          },
          rgb: function () {
            var a = this._goldenRatioColor(),
              l = s.hsv2rgb(a);
            return 'rgb(' + parseInt(l[0], 10) + ', ' + parseInt(l[1], 10) + ', ' + parseInt(l[2], 10) + ')';
          },
          rgba: function () {
            var a = this._goldenRatioColor(),
              l = s.hsv2rgb(a);
            return (
              'rgba(' +
              parseInt(l[0], 10) +
              ', ' +
              parseInt(l[1], 10) +
              ', ' +
              parseInt(l[2], 10) +
              ', ' +
              Math.random().toFixed(2) +
              ')'
            );
          },
          hsl: function () {
            var a = this._goldenRatioColor(),
              l = s.hsv2hsl(a);
            return 'hsl(' + parseInt(l[0], 10) + ', ' + parseInt(l[1], 10) + ', ' + parseInt(l[2], 10) + ')';
          },
          _goldenRatioColor: function (a, l) {
            return (
              (this._goldenRatio = 0.618033988749895),
              (this._hue = this._hue || Math.random()),
              (this._hue += this._goldenRatio),
              (this._hue %= 1),
              typeof a != 'number' && (a = 0.5),
              typeof l != 'number' && (l = 0.95),
              [this._hue * 360, a * 100, l * 100]
            );
          },
        };
      },
      function (r, e) {
        r.exports = {
          rgb2hsl: function (s) {
            var o = s[0] / 255,
              a = s[1] / 255,
              l = s[2] / 255,
              f = Math.min(o, a, l),
              m = Math.max(o, a, l),
              v = m - f,
              I,
              L,
              V;
            return (
              m == f
                ? (I = 0)
                : o == m
                ? (I = (a - l) / v)
                : a == m
                ? (I = 2 + (l - o) / v)
                : l == m && (I = 4 + (o - a) / v),
              (I = Math.min(I * 60, 360)),
              I < 0 && (I += 360),
              (V = (f + m) / 2),
              m == f ? (L = 0) : V <= 0.5 ? (L = v / (m + f)) : (L = v / (2 - m - f)),
              [I, L * 100, V * 100]
            );
          },
          rgb2hsv: function (s) {
            var o = s[0],
              a = s[1],
              l = s[2],
              f = Math.min(o, a, l),
              m = Math.max(o, a, l),
              v = m - f,
              I,
              L,
              V;
            return (
              m === 0 ? (L = 0) : (L = ((v / m) * 1e3) / 10),
              m == f
                ? (I = 0)
                : o == m
                ? (I = (a - l) / v)
                : a == m
                ? (I = 2 + (l - o) / v)
                : l == m && (I = 4 + (o - a) / v),
              (I = Math.min(I * 60, 360)),
              I < 0 && (I += 360),
              (V = ((m / 255) * 1e3) / 10),
              [I, L, V]
            );
          },
          hsl2rgb: function (s) {
            var o = s[0] / 360,
              a = s[1] / 100,
              l = s[2] / 100,
              f,
              m,
              v,
              I,
              L;
            if (a === 0) return (L = l * 255), [L, L, L];
            l < 0.5 ? (m = l * (1 + a)) : (m = l + a - l * a), (f = 2 * l - m), (I = [0, 0, 0]);
            for (var V = 0; V < 3; V++)
              (v = o + (1 / 3) * -(V - 1)),
                v < 0 && v++,
                v > 1 && v--,
                6 * v < 1
                  ? (L = f + (m - f) * 6 * v)
                  : 2 * v < 1
                  ? (L = m)
                  : 3 * v < 2
                  ? (L = f + (m - f) * (2 / 3 - v) * 6)
                  : (L = f),
                (I[V] = L * 255);
            return I;
          },
          hsl2hsv: function (s) {
            var o = s[0],
              a = s[1] / 100,
              l = s[2] / 100,
              f,
              m;
            return (
              (l *= 2), (a *= l <= 1 ? l : 2 - l), (m = (l + a) / 2), (f = (2 * a) / (l + a)), [o, f * 100, m * 100]
            );
          },
          hsv2rgb: function (s) {
            var o = s[0] / 60,
              a = s[1] / 100,
              l = s[2] / 100,
              f = Math.floor(o) % 6,
              m = o - Math.floor(o),
              v = 255 * l * (1 - a),
              I = 255 * l * (1 - a * m),
              L = 255 * l * (1 - a * (1 - m));
            switch (((l = 255 * l), f)) {
              case 0:
                return [l, L, v];
              case 1:
                return [I, l, v];
              case 2:
                return [v, l, L];
              case 3:
                return [v, I, l];
              case 4:
                return [L, v, l];
              case 5:
                return [l, v, I];
            }
          },
          hsv2hsl: function (s) {
            var o = s[0],
              a = s[1] / 100,
              l = s[2] / 100,
              f,
              m;
            return (m = (2 - a) * l), (f = a * l), (f /= m <= 1 ? m : 2 - m), (m /= 2), [o, f * 100, m * 100];
          },
          rgb2hex: function (n, s, o) {
            return '#' + (((((256 + n) << 8) | s) << 8) | o).toString(16).slice(1);
          },
          hex2rgb: function (n) {
            return (
              (n = ('0x' + n.slice(1).replace(n.length > 4 ? n : /./g, '$&$&')) | 0), [n >> 16, (n >> 8) & 255, n & 255]
            );
          },
        };
      },
      function (r, e) {
        r.exports = {
          navy: { value: '#000080', nicer: '#001F3F' },
          blue: { value: '#0000ff', nicer: '#0074D9' },
          aqua: { value: '#00ffff', nicer: '#7FDBFF' },
          teal: { value: '#008080', nicer: '#39CCCC' },
          olive: { value: '#008000', nicer: '#3D9970' },
          green: { value: '#008000', nicer: '#2ECC40' },
          lime: { value: '#00ff00', nicer: '#01FF70' },
          yellow: { value: '#ffff00', nicer: '#FFDC00' },
          orange: { value: '#ffa500', nicer: '#FF851B' },
          red: { value: '#ff0000', nicer: '#FF4136' },
          maroon: { value: '#800000', nicer: '#85144B' },
          fuchsia: { value: '#ff00ff', nicer: '#F012BE' },
          purple: { value: '#800080', nicer: '#B10DC9' },
          silver: { value: '#c0c0c0', nicer: '#DDDDDD' },
          gray: { value: '#808080', nicer: '#AAAAAA' },
          black: { value: '#000000', nicer: '#111111' },
          white: { value: '#FFFFFF', nicer: '#FFFFFF' },
        };
      },
      function (r, e, n) {
        var s = n(6),
          o = n(14);
        function a(l, f, m, v) {
          return m === void 0 ? s.natural(l, f) : v === void 0 ? m : s.natural(parseInt(m, 10), parseInt(v, 10));
        }
        r.exports = {
          paragraph: function (l, f) {
            for (var m = a(3, 7, l, f), v = [], I = 0; I < m; I++) v.push(this.sentence());
            return v.join(' ');
          },
          cparagraph: function (l, f) {
            for (var m = a(3, 7, l, f), v = [], I = 0; I < m; I++) v.push(this.csentence());
            return v.join('');
          },
          sentence: function (l, f) {
            for (var m = a(12, 18, l, f), v = [], I = 0; I < m; I++) v.push(this.word());
            return o.capitalize(v.join(' ')) + '.';
          },
          csentence: function (l, f) {
            for (var m = a(12, 18, l, f), v = [], I = 0; I < m; I++) v.push(this.cword());
            return v.join('') + '。';
          },
          word: function (l, f) {
            for (var m = a(3, 10, l, f), v = '', I = 0; I < m; I++) v += s.character('lower');
            return v;
          },
          cword: function (l, f, m) {
            var v =
                '的一是在不了有和人这中大为上个国我以要他时来用们生到作地于出就分对成会可主发年动同工也能下过子说产种面而方后多定行学法所民得经十三之进着等部度家电力里如水化高自二理起小物现实加量都两体制机当使点从业本去把性好应开它合还因由其些然前外天政四日那社义事平形相全表间样与关各重新线内数正心反你明看原又么利比或但质气第向道命此变条只没结解问意建月公无系军很情者最立代想已通并提直题党程展五果料象员革位入常文总次品式活设及管特件长求老头基资边流路级少图山统接知较将组见计别她手角期根论运农指几九区强放决西被干做必战先回则任取据处队南给色光门即保治北造百规热领七海口东导器压志世金增争济阶油思术极交受联什认六共权收证改清己美再采转更单风切打白教速花带安场身车例真务具万每目至达走积示议声报斗完类八离华名确才科张信马节话米整空元况今集温传土许步群广石记需段研界拉林律叫且究观越织装影算低持音众书布复容儿须际商非验连断深难近矿千周委素技备半办青省列习响约支般史感劳便团往酸历市克何除消构府称太准精值号率族维划选标写存候毛亲快效斯院查江型眼王按格养易置派层片始却专状育厂京识适属圆包火住调满县局照参红细引听该铁价严龙飞',
              I;
            switch (arguments.length) {
              case 0:
                (l = v), (I = 1);
                break;
              case 1:
                typeof arguments[0] == 'string' ? (I = 1) : ((I = l), (l = v));
                break;
              case 2:
                typeof arguments[0] == 'string' ? (I = f) : ((I = this.natural(l, f)), (l = v));
                break;
              case 3:
                I = this.natural(f, m);
                break;
            }
            for (var L = '', V = 0; V < I; V++) L += l.charAt(this.natural(0, l.length - 1));
            return L;
          },
          title: function (l, f) {
            for (var m = a(3, 7, l, f), v = [], I = 0; I < m; I++) v.push(this.capitalize(this.word()));
            return v.join(' ');
          },
          ctitle: function (l, f) {
            for (var m = a(3, 7, l, f), v = [], I = 0; I < m; I++) v.push(this.cword());
            return v.join('');
          },
        };
      },
      function (r, e, n) {
        var s = n(3);
        r.exports = {
          capitalize: function (o) {
            return (o + '').charAt(0).toUpperCase() + (o + '').substr(1);
          },
          upper: function (o) {
            return (o + '').toUpperCase();
          },
          lower: function (o) {
            return (o + '').toLowerCase();
          },
          pick: function (a, l, f) {
            return (
              s.isArray(a)
                ? (l === void 0 && (l = 1), f === void 0 && (f = l))
                : ((a = [].slice.call(arguments)), (l = 1), (f = 1)),
              l === 1 && f === 1 ? a[this.natural(0, a.length - 1)] : this.shuffle(a, l, f)
            );
          },
          shuffle: function (a, l, f) {
            a = a || [];
            for (var m = a.slice(0), v = [], I = 0, L = m.length, V = 0; V < L; V++)
              (I = this.natural(0, m.length - 1)), v.push(m[I]), m.splice(I, 1);
            switch (arguments.length) {
              case 0:
              case 1:
                return v;
              case 2:
                f = l;
              case 3:
                return (l = parseInt(l, 10)), (f = parseInt(f, 10)), v.slice(0, this.natural(l, f));
            }
          },
          order: function o(a) {
            (o.cache = o.cache || {}), arguments.length > 1 && (a = [].slice.call(arguments, 0));
            var l = o.options,
              f = l.context.templatePath.join('.'),
              m = (o.cache[f] = o.cache[f] || { index: 0, array: a });
            return m.array[m.index++ % m.array.length];
          },
        };
      },
      function (r, e) {
        r.exports = {
          first: function () {
            var n = [
              'James',
              'John',
              'Robert',
              'Michael',
              'William',
              'David',
              'Richard',
              'Charles',
              'Joseph',
              'Thomas',
              'Christopher',
              'Daniel',
              'Paul',
              'Mark',
              'Donald',
              'George',
              'Kenneth',
              'Steven',
              'Edward',
              'Brian',
              'Ronald',
              'Anthony',
              'Kevin',
              'Jason',
              'Matthew',
              'Gary',
              'Timothy',
              'Jose',
              'Larry',
              'Jeffrey',
              'Frank',
              'Scott',
              'Eric',
            ].concat([
              'Mary',
              'Patricia',
              'Linda',
              'Barbara',
              'Elizabeth',
              'Jennifer',
              'Maria',
              'Susan',
              'Margaret',
              'Dorothy',
              'Lisa',
              'Nancy',
              'Karen',
              'Betty',
              'Helen',
              'Sandra',
              'Donna',
              'Carol',
              'Ruth',
              'Sharon',
              'Michelle',
              'Laura',
              'Sarah',
              'Kimberly',
              'Deborah',
              'Jessica',
              'Shirley',
              'Cynthia',
              'Angela',
              'Melissa',
              'Brenda',
              'Amy',
              'Anna',
            ]);
            return this.pick(n);
          },
          last: function () {
            var n = [
              'Smith',
              'Johnson',
              'Williams',
              'Brown',
              'Jones',
              'Miller',
              'Davis',
              'Garcia',
              'Rodriguez',
              'Wilson',
              'Martinez',
              'Anderson',
              'Taylor',
              'Thomas',
              'Hernandez',
              'Moore',
              'Martin',
              'Jackson',
              'Thompson',
              'White',
              'Lopez',
              'Lee',
              'Gonzalez',
              'Harris',
              'Clark',
              'Lewis',
              'Robinson',
              'Walker',
              'Perez',
              'Hall',
              'Young',
              'Allen',
            ];
            return this.pick(n);
          },
          name: function (n) {
            return this.first() + ' ' + (n ? this.first() + ' ' : '') + this.last();
          },
          cfirst: function () {
            var n =
              '王 李 张 刘 陈 杨 赵 黄 周 吴 徐 孙 胡 朱 高 林 何 郭 马 罗 梁 宋 郑 谢 韩 唐 冯 于 董 萧 程 曹 袁 邓 许 傅 沈 曾 彭 吕 苏 卢 蒋 蔡 贾 丁 魏 薛 叶 阎 余 潘 杜 戴 夏 锺 汪 田 任 姜 范 方 石 姚 谭 廖 邹 熊 金 陆 郝 孔 白 崔 康 毛 邱 秦 江 史 顾 侯 邵 孟 龙 万 段 雷 钱 汤 尹 黎 易 常 武 乔 贺 赖 龚 文'.split(
                ' ',
              );
            return this.pick(n);
          },
          clast: function () {
            var n = '伟 芳 娜 秀英 敏 静 丽 强 磊 军 洋 勇 艳 杰 娟 涛 明 超 秀兰 霞 平 刚 桂英'.split(' ');
            return this.pick(n);
          },
          cname: function () {
            return this.cfirst() + this.clast();
          },
        };
      },
      function (r, e) {
        r.exports = {
          url: function (n, s) {
            return (n || this.protocol()) + '://' + (s || this.domain()) + '/' + this.word();
          },
          protocol: function () {
            return this.pick('http ftp gopher mailto mid cid news nntp prospero telnet rlogin tn3270 wais'.split(' '));
          },
          domain: function (n) {
            return this.word() + '.' + (n || this.tld());
          },
          tld: function () {
            return this.pick(
              'com net org edu gov int mil cn com.cn net.cn gov.cn org.cn 中国 中国互联.公司 中国互联.网络 tel biz cc tv info name hk mobi asia cd travel pro museum coop aero ad ae af ag ai al am an ao aq ar as at au aw az ba bb bd be bf bg bh bi bj bm bn bo br bs bt bv bw by bz ca cc cf cg ch ci ck cl cm cn co cq cr cu cv cx cy cz de dj dk dm do dz ec ee eg eh es et ev fi fj fk fm fo fr ga gb gd ge gf gh gi gl gm gn gp gr gt gu gw gy hk hm hn hr ht hu id ie il in io iq ir is it jm jo jp ke kg kh ki km kn kp kr kw ky kz la lb lc li lk lr ls lt lu lv ly ma mc md mg mh ml mm mn mo mp mq mr ms mt mv mw mx my mz na nc ne nf ng ni nl no np nr nt nu nz om qa pa pe pf pg ph pk pl pm pn pr pt pw py re ro ru rw sa sb sc sd se sg sh si sj sk sl sm sn so sr st su sy sz tc td tf tg th tj tk tm tn to tp tr tt tv tw tz ua ug uk us uy va vc ve vg vn vu wf ws ye yu za zm zr zw'.split(
                ' ',
              ),
            );
          },
          email: function (n) {
            return this.character('lower') + '.' + this.word() + '@' + (n || this.word() + '.' + this.tld());
          },
          ip: function () {
            return (
              this.natural(0, 255) +
              '.' +
              this.natural(0, 255) +
              '.' +
              this.natural(0, 255) +
              '.' +
              this.natural(0, 255)
            );
          },
        };
      },
      function (r, e, n) {
        var s = n(18),
          o = ['东北', '华北', '华东', '华中', '华南', '西南', '西北'];
        r.exports = {
          region: function () {
            return this.pick(o);
          },
          province: function () {
            return this.pick(s).name;
          },
          city: function (a) {
            var l = this.pick(s),
              f = this.pick(l.children);
            return a ? [l.name, f.name].join(' ') : f.name;
          },
          county: function (a) {
            var l = this.pick(s),
              f = this.pick(l.children),
              m = this.pick(f.children) || { name: '-' };
            return a ? [l.name, f.name, m.name].join(' ') : m.name;
          },
          zip: function (a) {
            for (var l = '', f = 0; f < (a || 6); f++) l += this.natural(0, 9);
            return l;
          },
        };
      },
      function (r, e) {
        var n = {
          11e4: '北京',
          110100: '北京市',
          110101: '东城区',
          110102: '西城区',
          110105: '朝阳区',
          110106: '丰台区',
          110107: '石景山区',
          110108: '海淀区',
          110109: '门头沟区',
          110111: '房山区',
          110112: '通州区',
          110113: '顺义区',
          110114: '昌平区',
          110115: '大兴区',
          110116: '怀柔区',
          110117: '平谷区',
          110228: '密云县',
          110229: '延庆县',
          110230: '其它区',
          12e4: '天津',
          120100: '天津市',
          120101: '和平区',
          120102: '河东区',
          120103: '河西区',
          120104: '南开区',
          120105: '河北区',
          120106: '红桥区',
          120110: '东丽区',
          120111: '西青区',
          120112: '津南区',
          120113: '北辰区',
          120114: '武清区',
          120115: '宝坻区',
          120116: '滨海新区',
          120221: '宁河县',
          120223: '静海县',
          120225: '蓟县',
          120226: '其它区',
          13e4: '河北省',
          130100: '石家庄市',
          130102: '长安区',
          130103: '桥东区',
          130104: '桥西区',
          130105: '新华区',
          130107: '井陉矿区',
          130108: '裕华区',
          130121: '井陉县',
          130123: '正定县',
          130124: '栾城县',
          130125: '行唐县',
          130126: '灵寿县',
          130127: '高邑县',
          130128: '深泽县',
          130129: '赞皇县',
          130130: '无极县',
          130131: '平山县',
          130132: '元氏县',
          130133: '赵县',
          130181: '辛集市',
          130182: '藁城市',
          130183: '晋州市',
          130184: '新乐市',
          130185: '鹿泉市',
          130186: '其它区',
          130200: '唐山市',
          130202: '路南区',
          130203: '路北区',
          130204: '古冶区',
          130205: '开平区',
          130207: '丰南区',
          130208: '丰润区',
          130223: '滦县',
          130224: '滦南县',
          130225: '乐亭县',
          130227: '迁西县',
          130229: '玉田县',
          130230: '曹妃甸区',
          130281: '遵化市',
          130283: '迁安市',
          130284: '其它区',
          130300: '秦皇岛市',
          130302: '海港区',
          130303: '山海关区',
          130304: '北戴河区',
          130321: '青龙满族自治县',
          130322: '昌黎县',
          130323: '抚宁县',
          130324: '卢龙县',
          130398: '其它区',
          130400: '邯郸市',
          130402: '邯山区',
          130403: '丛台区',
          130404: '复兴区',
          130406: '峰峰矿区',
          130421: '邯郸县',
          130423: '临漳县',
          130424: '成安县',
          130425: '大名县',
          130426: '涉县',
          130427: '磁县',
          130428: '肥乡县',
          130429: '永年县',
          130430: '邱县',
          130431: '鸡泽县',
          130432: '广平县',
          130433: '馆陶县',
          130434: '魏县',
          130435: '曲周县',
          130481: '武安市',
          130482: '其它区',
          130500: '邢台市',
          130502: '桥东区',
          130503: '桥西区',
          130521: '邢台县',
          130522: '临城县',
          130523: '内丘县',
          130524: '柏乡县',
          130525: '隆尧县',
          130526: '任县',
          130527: '南和县',
          130528: '宁晋县',
          130529: '巨鹿县',
          130530: '新河县',
          130531: '广宗县',
          130532: '平乡县',
          130533: '威县',
          130534: '清河县',
          130535: '临西县',
          130581: '南宫市',
          130582: '沙河市',
          130583: '其它区',
          130600: '保定市',
          130602: '新市区',
          130603: '北市区',
          130604: '南市区',
          130621: '满城县',
          130622: '清苑县',
          130623: '涞水县',
          130624: '阜平县',
          130625: '徐水县',
          130626: '定兴县',
          130627: '唐县',
          130628: '高阳县',
          130629: '容城县',
          130630: '涞源县',
          130631: '望都县',
          130632: '安新县',
          130633: '易县',
          130634: '曲阳县',
          130635: '蠡县',
          130636: '顺平县',
          130637: '博野县',
          130638: '雄县',
          130681: '涿州市',
          130682: '定州市',
          130683: '安国市',
          130684: '高碑店市',
          130699: '其它区',
          130700: '张家口市',
          130702: '桥东区',
          130703: '桥西区',
          130705: '宣化区',
          130706: '下花园区',
          130721: '宣化县',
          130722: '张北县',
          130723: '康保县',
          130724: '沽源县',
          130725: '尚义县',
          130726: '蔚县',
          130727: '阳原县',
          130728: '怀安县',
          130729: '万全县',
          130730: '怀来县',
          130731: '涿鹿县',
          130732: '赤城县',
          130733: '崇礼县',
          130734: '其它区',
          130800: '承德市',
          130802: '双桥区',
          130803: '双滦区',
          130804: '鹰手营子矿区',
          130821: '承德县',
          130822: '兴隆县',
          130823: '平泉县',
          130824: '滦平县',
          130825: '隆化县',
          130826: '丰宁满族自治县',
          130827: '宽城满族自治县',
          130828: '围场满族蒙古族自治县',
          130829: '其它区',
          130900: '沧州市',
          130902: '新华区',
          130903: '运河区',
          130921: '沧县',
          130922: '青县',
          130923: '东光县',
          130924: '海兴县',
          130925: '盐山县',
          130926: '肃宁县',
          130927: '南皮县',
          130928: '吴桥县',
          130929: '献县',
          130930: '孟村回族自治县',
          130981: '泊头市',
          130982: '任丘市',
          130983: '黄骅市',
          130984: '河间市',
          130985: '其它区',
          131e3: '廊坊市',
          131002: '安次区',
          131003: '广阳区',
          131022: '固安县',
          131023: '永清县',
          131024: '香河县',
          131025: '大城县',
          131026: '文安县',
          131028: '大厂回族自治县',
          131081: '霸州市',
          131082: '三河市',
          131083: '其它区',
          131100: '衡水市',
          131102: '桃城区',
          131121: '枣强县',
          131122: '武邑县',
          131123: '武强县',
          131124: '饶阳县',
          131125: '安平县',
          131126: '故城县',
          131127: '景县',
          131128: '阜城县',
          131181: '冀州市',
          131182: '深州市',
          131183: '其它区',
          14e4: '山西省',
          140100: '太原市',
          140105: '小店区',
          140106: '迎泽区',
          140107: '杏花岭区',
          140108: '尖草坪区',
          140109: '万柏林区',
          140110: '晋源区',
          140121: '清徐县',
          140122: '阳曲县',
          140123: '娄烦县',
          140181: '古交市',
          140182: '其它区',
          140200: '大同市',
          140202: '城区',
          140203: '矿区',
          140211: '南郊区',
          140212: '新荣区',
          140221: '阳高县',
          140222: '天镇县',
          140223: '广灵县',
          140224: '灵丘县',
          140225: '浑源县',
          140226: '左云县',
          140227: '大同县',
          140228: '其它区',
          140300: '阳泉市',
          140302: '城区',
          140303: '矿区',
          140311: '郊区',
          140321: '平定县',
          140322: '盂县',
          140323: '其它区',
          140400: '长治市',
          140421: '长治县',
          140423: '襄垣县',
          140424: '屯留县',
          140425: '平顺县',
          140426: '黎城县',
          140427: '壶关县',
          140428: '长子县',
          140429: '武乡县',
          140430: '沁县',
          140431: '沁源县',
          140481: '潞城市',
          140482: '城区',
          140483: '郊区',
          140485: '其它区',
          140500: '晋城市',
          140502: '城区',
          140521: '沁水县',
          140522: '阳城县',
          140524: '陵川县',
          140525: '泽州县',
          140581: '高平市',
          140582: '其它区',
          140600: '朔州市',
          140602: '朔城区',
          140603: '平鲁区',
          140621: '山阴县',
          140622: '应县',
          140623: '右玉县',
          140624: '怀仁县',
          140625: '其它区',
          140700: '晋中市',
          140702: '榆次区',
          140721: '榆社县',
          140722: '左权县',
          140723: '和顺县',
          140724: '昔阳县',
          140725: '寿阳县',
          140726: '太谷县',
          140727: '祁县',
          140728: '平遥县',
          140729: '灵石县',
          140781: '介休市',
          140782: '其它区',
          140800: '运城市',
          140802: '盐湖区',
          140821: '临猗县',
          140822: '万荣县',
          140823: '闻喜县',
          140824: '稷山县',
          140825: '新绛县',
          140826: '绛县',
          140827: '垣曲县',
          140828: '夏县',
          140829: '平陆县',
          140830: '芮城县',
          140881: '永济市',
          140882: '河津市',
          140883: '其它区',
          140900: '忻州市',
          140902: '忻府区',
          140921: '定襄县',
          140922: '五台县',
          140923: '代县',
          140924: '繁峙县',
          140925: '宁武县',
          140926: '静乐县',
          140927: '神池县',
          140928: '五寨县',
          140929: '岢岚县',
          140930: '河曲县',
          140931: '保德县',
          140932: '偏关县',
          140981: '原平市',
          140982: '其它区',
          141e3: '临汾市',
          141002: '尧都区',
          141021: '曲沃县',
          141022: '翼城县',
          141023: '襄汾县',
          141024: '洪洞县',
          141025: '古县',
          141026: '安泽县',
          141027: '浮山县',
          141028: '吉县',
          141029: '乡宁县',
          141030: '大宁县',
          141031: '隰县',
          141032: '永和县',
          141033: '蒲县',
          141034: '汾西县',
          141081: '侯马市',
          141082: '霍州市',
          141083: '其它区',
          141100: '吕梁市',
          141102: '离石区',
          141121: '文水县',
          141122: '交城县',
          141123: '兴县',
          141124: '临县',
          141125: '柳林县',
          141126: '石楼县',
          141127: '岚县',
          141128: '方山县',
          141129: '中阳县',
          141130: '交口县',
          141181: '孝义市',
          141182: '汾阳市',
          141183: '其它区',
          15e4: '内蒙古自治区',
          150100: '呼和浩特市',
          150102: '新城区',
          150103: '回民区',
          150104: '玉泉区',
          150105: '赛罕区',
          150121: '土默特左旗',
          150122: '托克托县',
          150123: '和林格尔县',
          150124: '清水河县',
          150125: '武川县',
          150126: '其它区',
          150200: '包头市',
          150202: '东河区',
          150203: '昆都仑区',
          150204: '青山区',
          150205: '石拐区',
          150206: '白云鄂博矿区',
          150207: '九原区',
          150221: '土默特右旗',
          150222: '固阳县',
          150223: '达尔罕茂明安联合旗',
          150224: '其它区',
          150300: '乌海市',
          150302: '海勃湾区',
          150303: '海南区',
          150304: '乌达区',
          150305: '其它区',
          150400: '赤峰市',
          150402: '红山区',
          150403: '元宝山区',
          150404: '松山区',
          150421: '阿鲁科尔沁旗',
          150422: '巴林左旗',
          150423: '巴林右旗',
          150424: '林西县',
          150425: '克什克腾旗',
          150426: '翁牛特旗',
          150428: '喀喇沁旗',
          150429: '宁城县',
          150430: '敖汉旗',
          150431: '其它区',
          150500: '通辽市',
          150502: '科尔沁区',
          150521: '科尔沁左翼中旗',
          150522: '科尔沁左翼后旗',
          150523: '开鲁县',
          150524: '库伦旗',
          150525: '奈曼旗',
          150526: '扎鲁特旗',
          150581: '霍林郭勒市',
          150582: '其它区',
          150600: '鄂尔多斯市',
          150602: '东胜区',
          150621: '达拉特旗',
          150622: '准格尔旗',
          150623: '鄂托克前旗',
          150624: '鄂托克旗',
          150625: '杭锦旗',
          150626: '乌审旗',
          150627: '伊金霍洛旗',
          150628: '其它区',
          150700: '呼伦贝尔市',
          150702: '海拉尔区',
          150703: '扎赉诺尔区',
          150721: '阿荣旗',
          150722: '莫力达瓦达斡尔族自治旗',
          150723: '鄂伦春自治旗',
          150724: '鄂温克族自治旗',
          150725: '陈巴尔虎旗',
          150726: '新巴尔虎左旗',
          150727: '新巴尔虎右旗',
          150781: '满洲里市',
          150782: '牙克石市',
          150783: '扎兰屯市',
          150784: '额尔古纳市',
          150785: '根河市',
          150786: '其它区',
          150800: '巴彦淖尔市',
          150802: '临河区',
          150821: '五原县',
          150822: '磴口县',
          150823: '乌拉特前旗',
          150824: '乌拉特中旗',
          150825: '乌拉特后旗',
          150826: '杭锦后旗',
          150827: '其它区',
          150900: '乌兰察布市',
          150902: '集宁区',
          150921: '卓资县',
          150922: '化德县',
          150923: '商都县',
          150924: '兴和县',
          150925: '凉城县',
          150926: '察哈尔右翼前旗',
          150927: '察哈尔右翼中旗',
          150928: '察哈尔右翼后旗',
          150929: '四子王旗',
          150981: '丰镇市',
          150982: '其它区',
          152200: '兴安盟',
          152201: '乌兰浩特市',
          152202: '阿尔山市',
          152221: '科尔沁右翼前旗',
          152222: '科尔沁右翼中旗',
          152223: '扎赉特旗',
          152224: '突泉县',
          152225: '其它区',
          152500: '锡林郭勒盟',
          152501: '二连浩特市',
          152502: '锡林浩特市',
          152522: '阿巴嘎旗',
          152523: '苏尼特左旗',
          152524: '苏尼特右旗',
          152525: '东乌珠穆沁旗',
          152526: '西乌珠穆沁旗',
          152527: '太仆寺旗',
          152528: '镶黄旗',
          152529: '正镶白旗',
          152530: '正蓝旗',
          152531: '多伦县',
          152532: '其它区',
          152900: '阿拉善盟',
          152921: '阿拉善左旗',
          152922: '阿拉善右旗',
          152923: '额济纳旗',
          152924: '其它区',
          21e4: '辽宁省',
          210100: '沈阳市',
          210102: '和平区',
          210103: '沈河区',
          210104: '大东区',
          210105: '皇姑区',
          210106: '铁西区',
          210111: '苏家屯区',
          210112: '东陵区',
          210113: '新城子区',
          210114: '于洪区',
          210122: '辽中县',
          210123: '康平县',
          210124: '法库县',
          210181: '新民市',
          210184: '沈北新区',
          210185: '其它区',
          210200: '大连市',
          210202: '中山区',
          210203: '西岗区',
          210204: '沙河口区',
          210211: '甘井子区',
          210212: '旅顺口区',
          210213: '金州区',
          210224: '长海县',
          210281: '瓦房店市',
          210282: '普兰店市',
          210283: '庄河市',
          210298: '其它区',
          210300: '鞍山市',
          210302: '铁东区',
          210303: '铁西区',
          210304: '立山区',
          210311: '千山区',
          210321: '台安县',
          210323: '岫岩满族自治县',
          210381: '海城市',
          210382: '其它区',
          210400: '抚顺市',
          210402: '新抚区',
          210403: '东洲区',
          210404: '望花区',
          210411: '顺城区',
          210421: '抚顺县',
          210422: '新宾满族自治县',
          210423: '清原满族自治县',
          210424: '其它区',
          210500: '本溪市',
          210502: '平山区',
          210503: '溪湖区',
          210504: '明山区',
          210505: '南芬区',
          210521: '本溪满族自治县',
          210522: '桓仁满族自治县',
          210523: '其它区',
          210600: '丹东市',
          210602: '元宝区',
          210603: '振兴区',
          210604: '振安区',
          210624: '宽甸满族自治县',
          210681: '东港市',
          210682: '凤城市',
          210683: '其它区',
          210700: '锦州市',
          210702: '古塔区',
          210703: '凌河区',
          210711: '太和区',
          210726: '黑山县',
          210727: '义县',
          210781: '凌海市',
          210782: '北镇市',
          210783: '其它区',
          210800: '营口市',
          210802: '站前区',
          210803: '西市区',
          210804: '鲅鱼圈区',
          210811: '老边区',
          210881: '盖州市',
          210882: '大石桥市',
          210883: '其它区',
          210900: '阜新市',
          210902: '海州区',
          210903: '新邱区',
          210904: '太平区',
          210905: '清河门区',
          210911: '细河区',
          210921: '阜新蒙古族自治县',
          210922: '彰武县',
          210923: '其它区',
          211e3: '辽阳市',
          211002: '白塔区',
          211003: '文圣区',
          211004: '宏伟区',
          211005: '弓长岭区',
          211011: '太子河区',
          211021: '辽阳县',
          211081: '灯塔市',
          211082: '其它区',
          211100: '盘锦市',
          211102: '双台子区',
          211103: '兴隆台区',
          211121: '大洼县',
          211122: '盘山县',
          211123: '其它区',
          211200: '铁岭市',
          211202: '银州区',
          211204: '清河区',
          211221: '铁岭县',
          211223: '西丰县',
          211224: '昌图县',
          211281: '调兵山市',
          211282: '开原市',
          211283: '其它区',
          211300: '朝阳市',
          211302: '双塔区',
          211303: '龙城区',
          211321: '朝阳县',
          211322: '建平县',
          211324: '喀喇沁左翼蒙古族自治县',
          211381: '北票市',
          211382: '凌源市',
          211383: '其它区',
          211400: '葫芦岛市',
          211402: '连山区',
          211403: '龙港区',
          211404: '南票区',
          211421: '绥中县',
          211422: '建昌县',
          211481: '兴城市',
          211482: '其它区',
          22e4: '吉林省',
          220100: '长春市',
          220102: '南关区',
          220103: '宽城区',
          220104: '朝阳区',
          220105: '二道区',
          220106: '绿园区',
          220112: '双阳区',
          220122: '农安县',
          220181: '九台市',
          220182: '榆树市',
          220183: '德惠市',
          220188: '其它区',
          220200: '吉林市',
          220202: '昌邑区',
          220203: '龙潭区',
          220204: '船营区',
          220211: '丰满区',
          220221: '永吉县',
          220281: '蛟河市',
          220282: '桦甸市',
          220283: '舒兰市',
          220284: '磐石市',
          220285: '其它区',
          220300: '四平市',
          220302: '铁西区',
          220303: '铁东区',
          220322: '梨树县',
          220323: '伊通满族自治县',
          220381: '公主岭市',
          220382: '双辽市',
          220383: '其它区',
          220400: '辽源市',
          220402: '龙山区',
          220403: '西安区',
          220421: '东丰县',
          220422: '东辽县',
          220423: '其它区',
          220500: '通化市',
          220502: '东昌区',
          220503: '二道江区',
          220521: '通化县',
          220523: '辉南县',
          220524: '柳河县',
          220581: '梅河口市',
          220582: '集安市',
          220583: '其它区',
          220600: '白山市',
          220602: '浑江区',
          220621: '抚松县',
          220622: '靖宇县',
          220623: '长白朝鲜族自治县',
          220625: '江源区',
          220681: '临江市',
          220682: '其它区',
          220700: '松原市',
          220702: '宁江区',
          220721: '前郭尔罗斯蒙古族自治县',
          220722: '长岭县',
          220723: '乾安县',
          220724: '扶余市',
          220725: '其它区',
          220800: '白城市',
          220802: '洮北区',
          220821: '镇赉县',
          220822: '通榆县',
          220881: '洮南市',
          220882: '大安市',
          220883: '其它区',
          222400: '延边朝鲜族自治州',
          222401: '延吉市',
          222402: '图们市',
          222403: '敦化市',
          222404: '珲春市',
          222405: '龙井市',
          222406: '和龙市',
          222424: '汪清县',
          222426: '安图县',
          222427: '其它区',
          23e4: '黑龙江省',
          230100: '哈尔滨市',
          230102: '道里区',
          230103: '南岗区',
          230104: '道外区',
          230106: '香坊区',
          230108: '平房区',
          230109: '松北区',
          230111: '呼兰区',
          230123: '依兰县',
          230124: '方正县',
          230125: '宾县',
          230126: '巴彦县',
          230127: '木兰县',
          230128: '通河县',
          230129: '延寿县',
          230181: '阿城区',
          230182: '双城市',
          230183: '尚志市',
          230184: '五常市',
          230186: '其它区',
          230200: '齐齐哈尔市',
          230202: '龙沙区',
          230203: '建华区',
          230204: '铁锋区',
          230205: '昂昂溪区',
          230206: '富拉尔基区',
          230207: '碾子山区',
          230208: '梅里斯达斡尔族区',
          230221: '龙江县',
          230223: '依安县',
          230224: '泰来县',
          230225: '甘南县',
          230227: '富裕县',
          230229: '克山县',
          230230: '克东县',
          230231: '拜泉县',
          230281: '讷河市',
          230282: '其它区',
          230300: '鸡西市',
          230302: '鸡冠区',
          230303: '恒山区',
          230304: '滴道区',
          230305: '梨树区',
          230306: '城子河区',
          230307: '麻山区',
          230321: '鸡东县',
          230381: '虎林市',
          230382: '密山市',
          230383: '其它区',
          230400: '鹤岗市',
          230402: '向阳区',
          230403: '工农区',
          230404: '南山区',
          230405: '兴安区',
          230406: '东山区',
          230407: '兴山区',
          230421: '萝北县',
          230422: '绥滨县',
          230423: '其它区',
          230500: '双鸭山市',
          230502: '尖山区',
          230503: '岭东区',
          230505: '四方台区',
          230506: '宝山区',
          230521: '集贤县',
          230522: '友谊县',
          230523: '宝清县',
          230524: '饶河县',
          230525: '其它区',
          230600: '大庆市',
          230602: '萨尔图区',
          230603: '龙凤区',
          230604: '让胡路区',
          230605: '红岗区',
          230606: '大同区',
          230621: '肇州县',
          230622: '肇源县',
          230623: '林甸县',
          230624: '杜尔伯特蒙古族自治县',
          230625: '其它区',
          230700: '伊春市',
          230702: '伊春区',
          230703: '南岔区',
          230704: '友好区',
          230705: '西林区',
          230706: '翠峦区',
          230707: '新青区',
          230708: '美溪区',
          230709: '金山屯区',
          230710: '五营区',
          230711: '乌马河区',
          230712: '汤旺河区',
          230713: '带岭区',
          230714: '乌伊岭区',
          230715: '红星区',
          230716: '上甘岭区',
          230722: '嘉荫县',
          230781: '铁力市',
          230782: '其它区',
          230800: '佳木斯市',
          230803: '向阳区',
          230804: '前进区',
          230805: '东风区',
          230811: '郊区',
          230822: '桦南县',
          230826: '桦川县',
          230828: '汤原县',
          230833: '抚远县',
          230881: '同江市',
          230882: '富锦市',
          230883: '其它区',
          230900: '七台河市',
          230902: '新兴区',
          230903: '桃山区',
          230904: '茄子河区',
          230921: '勃利县',
          230922: '其它区',
          231e3: '牡丹江市',
          231002: '东安区',
          231003: '阳明区',
          231004: '爱民区',
          231005: '西安区',
          231024: '东宁县',
          231025: '林口县',
          231081: '绥芬河市',
          231083: '海林市',
          231084: '宁安市',
          231085: '穆棱市',
          231086: '其它区',
          231100: '黑河市',
          231102: '爱辉区',
          231121: '嫩江县',
          231123: '逊克县',
          231124: '孙吴县',
          231181: '北安市',
          231182: '五大连池市',
          231183: '其它区',
          231200: '绥化市',
          231202: '北林区',
          231221: '望奎县',
          231222: '兰西县',
          231223: '青冈县',
          231224: '庆安县',
          231225: '明水县',
          231226: '绥棱县',
          231281: '安达市',
          231282: '肇东市',
          231283: '海伦市',
          231284: '其它区',
          232700: '大兴安岭地区',
          232702: '松岭区',
          232703: '新林区',
          232704: '呼中区',
          232721: '呼玛县',
          232722: '塔河县',
          232723: '漠河县',
          232724: '加格达奇区',
          232725: '其它区',
          31e4: '上海',
          310100: '上海市',
          310101: '黄浦区',
          310104: '徐汇区',
          310105: '长宁区',
          310106: '静安区',
          310107: '普陀区',
          310108: '闸北区',
          310109: '虹口区',
          310110: '杨浦区',
          310112: '闵行区',
          310113: '宝山区',
          310114: '嘉定区',
          310115: '浦东新区',
          310116: '金山区',
          310117: '松江区',
          310118: '青浦区',
          310120: '奉贤区',
          310230: '崇明县',
          310231: '其它区',
          32e4: '江苏省',
          320100: '南京市',
          320102: '玄武区',
          320104: '秦淮区',
          320105: '建邺区',
          320106: '鼓楼区',
          320111: '浦口区',
          320113: '栖霞区',
          320114: '雨花台区',
          320115: '江宁区',
          320116: '六合区',
          320124: '溧水区',
          320125: '高淳区',
          320126: '其它区',
          320200: '无锡市',
          320202: '崇安区',
          320203: '南长区',
          320204: '北塘区',
          320205: '锡山区',
          320206: '惠山区',
          320211: '滨湖区',
          320281: '江阴市',
          320282: '宜兴市',
          320297: '其它区',
          320300: '徐州市',
          320302: '鼓楼区',
          320303: '云龙区',
          320305: '贾汪区',
          320311: '泉山区',
          320321: '丰县',
          320322: '沛县',
          320323: '铜山区',
          320324: '睢宁县',
          320381: '新沂市',
          320382: '邳州市',
          320383: '其它区',
          320400: '常州市',
          320402: '天宁区',
          320404: '钟楼区',
          320405: '戚墅堰区',
          320411: '新北区',
          320412: '武进区',
          320481: '溧阳市',
          320482: '金坛市',
          320483: '其它区',
          320500: '苏州市',
          320505: '虎丘区',
          320506: '吴中区',
          320507: '相城区',
          320508: '姑苏区',
          320581: '常熟市',
          320582: '张家港市',
          320583: '昆山市',
          320584: '吴江区',
          320585: '太仓市',
          320596: '其它区',
          320600: '南通市',
          320602: '崇川区',
          320611: '港闸区',
          320612: '通州区',
          320621: '海安县',
          320623: '如东县',
          320681: '启东市',
          320682: '如皋市',
          320684: '海门市',
          320694: '其它区',
          320700: '连云港市',
          320703: '连云区',
          320705: '新浦区',
          320706: '海州区',
          320721: '赣榆县',
          320722: '东海县',
          320723: '灌云县',
          320724: '灌南县',
          320725: '其它区',
          320800: '淮安市',
          320802: '清河区',
          320803: '淮安区',
          320804: '淮阴区',
          320811: '清浦区',
          320826: '涟水县',
          320829: '洪泽县',
          320830: '盱眙县',
          320831: '金湖县',
          320832: '其它区',
          320900: '盐城市',
          320902: '亭湖区',
          320903: '盐都区',
          320921: '响水县',
          320922: '滨海县',
          320923: '阜宁县',
          320924: '射阳县',
          320925: '建湖县',
          320981: '东台市',
          320982: '大丰市',
          320983: '其它区',
          321e3: '扬州市',
          321002: '广陵区',
          321003: '邗江区',
          321023: '宝应县',
          321081: '仪征市',
          321084: '高邮市',
          321088: '江都区',
          321093: '其它区',
          321100: '镇江市',
          321102: '京口区',
          321111: '润州区',
          321112: '丹徒区',
          321181: '丹阳市',
          321182: '扬中市',
          321183: '句容市',
          321184: '其它区',
          321200: '泰州市',
          321202: '海陵区',
          321203: '高港区',
          321281: '兴化市',
          321282: '靖江市',
          321283: '泰兴市',
          321284: '姜堰区',
          321285: '其它区',
          321300: '宿迁市',
          321302: '宿城区',
          321311: '宿豫区',
          321322: '沭阳县',
          321323: '泗阳县',
          321324: '泗洪县',
          321325: '其它区',
          33e4: '浙江省',
          330100: '杭州市',
          330102: '上城区',
          330103: '下城区',
          330104: '江干区',
          330105: '拱墅区',
          330106: '西湖区',
          330108: '滨江区',
          330109: '萧山区',
          330110: '余杭区',
          330122: '桐庐县',
          330127: '淳安县',
          330182: '建德市',
          330183: '富阳市',
          330185: '临安市',
          330186: '其它区',
          330200: '宁波市',
          330203: '海曙区',
          330204: '江东区',
          330205: '江北区',
          330206: '北仑区',
          330211: '镇海区',
          330212: '鄞州区',
          330225: '象山县',
          330226: '宁海县',
          330281: '余姚市',
          330282: '慈溪市',
          330283: '奉化市',
          330284: '其它区',
          330300: '温州市',
          330302: '鹿城区',
          330303: '龙湾区',
          330304: '瓯海区',
          330322: '洞头县',
          330324: '永嘉县',
          330326: '平阳县',
          330327: '苍南县',
          330328: '文成县',
          330329: '泰顺县',
          330381: '瑞安市',
          330382: '乐清市',
          330383: '其它区',
          330400: '嘉兴市',
          330402: '南湖区',
          330411: '秀洲区',
          330421: '嘉善县',
          330424: '海盐县',
          330481: '海宁市',
          330482: '平湖市',
          330483: '桐乡市',
          330484: '其它区',
          330500: '湖州市',
          330502: '吴兴区',
          330503: '南浔区',
          330521: '德清县',
          330522: '长兴县',
          330523: '安吉县',
          330524: '其它区',
          330600: '绍兴市',
          330602: '越城区',
          330621: '绍兴县',
          330624: '新昌县',
          330681: '诸暨市',
          330682: '上虞市',
          330683: '嵊州市',
          330684: '其它区',
          330700: '金华市',
          330702: '婺城区',
          330703: '金东区',
          330723: '武义县',
          330726: '浦江县',
          330727: '磐安县',
          330781: '兰溪市',
          330782: '义乌市',
          330783: '东阳市',
          330784: '永康市',
          330785: '其它区',
          330800: '衢州市',
          330802: '柯城区',
          330803: '衢江区',
          330822: '常山县',
          330824: '开化县',
          330825: '龙游县',
          330881: '江山市',
          330882: '其它区',
          330900: '舟山市',
          330902: '定海区',
          330903: '普陀区',
          330921: '岱山县',
          330922: '嵊泗县',
          330923: '其它区',
          331e3: '台州市',
          331002: '椒江区',
          331003: '黄岩区',
          331004: '路桥区',
          331021: '玉环县',
          331022: '三门县',
          331023: '天台县',
          331024: '仙居县',
          331081: '温岭市',
          331082: '临海市',
          331083: '其它区',
          331100: '丽水市',
          331102: '莲都区',
          331121: '青田县',
          331122: '缙云县',
          331123: '遂昌县',
          331124: '松阳县',
          331125: '云和县',
          331126: '庆元县',
          331127: '景宁畲族自治县',
          331181: '龙泉市',
          331182: '其它区',
          34e4: '安徽省',
          340100: '合肥市',
          340102: '瑶海区',
          340103: '庐阳区',
          340104: '蜀山区',
          340111: '包河区',
          340121: '长丰县',
          340122: '肥东县',
          340123: '肥西县',
          340192: '其它区',
          340200: '芜湖市',
          340202: '镜湖区',
          340203: '弋江区',
          340207: '鸠江区',
          340208: '三山区',
          340221: '芜湖县',
          340222: '繁昌县',
          340223: '南陵县',
          340224: '其它区',
          340300: '蚌埠市',
          340302: '龙子湖区',
          340303: '蚌山区',
          340304: '禹会区',
          340311: '淮上区',
          340321: '怀远县',
          340322: '五河县',
          340323: '固镇县',
          340324: '其它区',
          340400: '淮南市',
          340402: '大通区',
          340403: '田家庵区',
          340404: '谢家集区',
          340405: '八公山区',
          340406: '潘集区',
          340421: '凤台县',
          340422: '其它区',
          340500: '马鞍山市',
          340503: '花山区',
          340504: '雨山区',
          340506: '博望区',
          340521: '当涂县',
          340522: '其它区',
          340600: '淮北市',
          340602: '杜集区',
          340603: '相山区',
          340604: '烈山区',
          340621: '濉溪县',
          340622: '其它区',
          340700: '铜陵市',
          340702: '铜官山区',
          340703: '狮子山区',
          340711: '郊区',
          340721: '铜陵县',
          340722: '其它区',
          340800: '安庆市',
          340802: '迎江区',
          340803: '大观区',
          340811: '宜秀区',
          340822: '怀宁县',
          340823: '枞阳县',
          340824: '潜山县',
          340825: '太湖县',
          340826: '宿松县',
          340827: '望江县',
          340828: '岳西县',
          340881: '桐城市',
          340882: '其它区',
          341e3: '黄山市',
          341002: '屯溪区',
          341003: '黄山区',
          341004: '徽州区',
          341021: '歙县',
          341022: '休宁县',
          341023: '黟县',
          341024: '祁门县',
          341025: '其它区',
          341100: '滁州市',
          341102: '琅琊区',
          341103: '南谯区',
          341122: '来安县',
          341124: '全椒县',
          341125: '定远县',
          341126: '凤阳县',
          341181: '天长市',
          341182: '明光市',
          341183: '其它区',
          341200: '阜阳市',
          341202: '颍州区',
          341203: '颍东区',
          341204: '颍泉区',
          341221: '临泉县',
          341222: '太和县',
          341225: '阜南县',
          341226: '颍上县',
          341282: '界首市',
          341283: '其它区',
          341300: '宿州市',
          341302: '埇桥区',
          341321: '砀山县',
          341322: '萧县',
          341323: '灵璧县',
          341324: '泗县',
          341325: '其它区',
          341400: '巢湖市',
          341421: '庐江县',
          341422: '无为县',
          341423: '含山县',
          341424: '和县',
          341500: '六安市',
          341502: '金安区',
          341503: '裕安区',
          341521: '寿县',
          341522: '霍邱县',
          341523: '舒城县',
          341524: '金寨县',
          341525: '霍山县',
          341526: '其它区',
          341600: '亳州市',
          341602: '谯城区',
          341621: '涡阳县',
          341622: '蒙城县',
          341623: '利辛县',
          341624: '其它区',
          341700: '池州市',
          341702: '贵池区',
          341721: '东至县',
          341722: '石台县',
          341723: '青阳县',
          341724: '其它区',
          341800: '宣城市',
          341802: '宣州区',
          341821: '郎溪县',
          341822: '广德县',
          341823: '泾县',
          341824: '绩溪县',
          341825: '旌德县',
          341881: '宁国市',
          341882: '其它区',
          35e4: '福建省',
          350100: '福州市',
          350102: '鼓楼区',
          350103: '台江区',
          350104: '仓山区',
          350105: '马尾区',
          350111: '晋安区',
          350121: '闽侯县',
          350122: '连江县',
          350123: '罗源县',
          350124: '闽清县',
          350125: '永泰县',
          350128: '平潭县',
          350181: '福清市',
          350182: '长乐市',
          350183: '其它区',
          350200: '厦门市',
          350203: '思明区',
          350205: '海沧区',
          350206: '湖里区',
          350211: '集美区',
          350212: '同安区',
          350213: '翔安区',
          350214: '其它区',
          350300: '莆田市',
          350302: '城厢区',
          350303: '涵江区',
          350304: '荔城区',
          350305: '秀屿区',
          350322: '仙游县',
          350323: '其它区',
          350400: '三明市',
          350402: '梅列区',
          350403: '三元区',
          350421: '明溪县',
          350423: '清流县',
          350424: '宁化县',
          350425: '大田县',
          350426: '尤溪县',
          350427: '沙县',
          350428: '将乐县',
          350429: '泰宁县',
          350430: '建宁县',
          350481: '永安市',
          350482: '其它区',
          350500: '泉州市',
          350502: '鲤城区',
          350503: '丰泽区',
          350504: '洛江区',
          350505: '泉港区',
          350521: '惠安县',
          350524: '安溪县',
          350525: '永春县',
          350526: '德化县',
          350527: '金门县',
          350581: '石狮市',
          350582: '晋江市',
          350583: '南安市',
          350584: '其它区',
          350600: '漳州市',
          350602: '芗城区',
          350603: '龙文区',
          350622: '云霄县',
          350623: '漳浦县',
          350624: '诏安县',
          350625: '长泰县',
          350626: '东山县',
          350627: '南靖县',
          350628: '平和县',
          350629: '华安县',
          350681: '龙海市',
          350682: '其它区',
          350700: '南平市',
          350702: '延平区',
          350721: '顺昌县',
          350722: '浦城县',
          350723: '光泽县',
          350724: '松溪县',
          350725: '政和县',
          350781: '邵武市',
          350782: '武夷山市',
          350783: '建瓯市',
          350784: '建阳市',
          350785: '其它区',
          350800: '龙岩市',
          350802: '新罗区',
          350821: '长汀县',
          350822: '永定县',
          350823: '上杭县',
          350824: '武平县',
          350825: '连城县',
          350881: '漳平市',
          350882: '其它区',
          350900: '宁德市',
          350902: '蕉城区',
          350921: '霞浦县',
          350922: '古田县',
          350923: '屏南县',
          350924: '寿宁县',
          350925: '周宁县',
          350926: '柘荣县',
          350981: '福安市',
          350982: '福鼎市',
          350983: '其它区',
          36e4: '江西省',
          360100: '南昌市',
          360102: '东湖区',
          360103: '西湖区',
          360104: '青云谱区',
          360105: '湾里区',
          360111: '青山湖区',
          360121: '南昌县',
          360122: '新建县',
          360123: '安义县',
          360124: '进贤县',
          360128: '其它区',
          360200: '景德镇市',
          360202: '昌江区',
          360203: '珠山区',
          360222: '浮梁县',
          360281: '乐平市',
          360282: '其它区',
          360300: '萍乡市',
          360302: '安源区',
          360313: '湘东区',
          360321: '莲花县',
          360322: '上栗县',
          360323: '芦溪县',
          360324: '其它区',
          360400: '九江市',
          360402: '庐山区',
          360403: '浔阳区',
          360421: '九江县',
          360423: '武宁县',
          360424: '修水县',
          360425: '永修县',
          360426: '德安县',
          360427: '星子县',
          360428: '都昌县',
          360429: '湖口县',
          360430: '彭泽县',
          360481: '瑞昌市',
          360482: '其它区',
          360483: '共青城市',
          360500: '新余市',
          360502: '渝水区',
          360521: '分宜县',
          360522: '其它区',
          360600: '鹰潭市',
          360602: '月湖区',
          360622: '余江县',
          360681: '贵溪市',
          360682: '其它区',
          360700: '赣州市',
          360702: '章贡区',
          360721: '赣县',
          360722: '信丰县',
          360723: '大余县',
          360724: '上犹县',
          360725: '崇义县',
          360726: '安远县',
          360727: '龙南县',
          360728: '定南县',
          360729: '全南县',
          360730: '宁都县',
          360731: '于都县',
          360732: '兴国县',
          360733: '会昌县',
          360734: '寻乌县',
          360735: '石城县',
          360781: '瑞金市',
          360782: '南康市',
          360783: '其它区',
          360800: '吉安市',
          360802: '吉州区',
          360803: '青原区',
          360821: '吉安县',
          360822: '吉水县',
          360823: '峡江县',
          360824: '新干县',
          360825: '永丰县',
          360826: '泰和县',
          360827: '遂川县',
          360828: '万安县',
          360829: '安福县',
          360830: '永新县',
          360881: '井冈山市',
          360882: '其它区',
          360900: '宜春市',
          360902: '袁州区',
          360921: '奉新县',
          360922: '万载县',
          360923: '上高县',
          360924: '宜丰县',
          360925: '靖安县',
          360926: '铜鼓县',
          360981: '丰城市',
          360982: '樟树市',
          360983: '高安市',
          360984: '其它区',
          361e3: '抚州市',
          361002: '临川区',
          361021: '南城县',
          361022: '黎川县',
          361023: '南丰县',
          361024: '崇仁县',
          361025: '乐安县',
          361026: '宜黄县',
          361027: '金溪县',
          361028: '资溪县',
          361029: '东乡县',
          361030: '广昌县',
          361031: '其它区',
          361100: '上饶市',
          361102: '信州区',
          361121: '上饶县',
          361122: '广丰县',
          361123: '玉山县',
          361124: '铅山县',
          361125: '横峰县',
          361126: '弋阳县',
          361127: '余干县',
          361128: '鄱阳县',
          361129: '万年县',
          361130: '婺源县',
          361181: '德兴市',
          361182: '其它区',
          37e4: '山东省',
          370100: '济南市',
          370102: '历下区',
          370103: '市中区',
          370104: '槐荫区',
          370105: '天桥区',
          370112: '历城区',
          370113: '长清区',
          370124: '平阴县',
          370125: '济阳县',
          370126: '商河县',
          370181: '章丘市',
          370182: '其它区',
          370200: '青岛市',
          370202: '市南区',
          370203: '市北区',
          370211: '黄岛区',
          370212: '崂山区',
          370213: '李沧区',
          370214: '城阳区',
          370281: '胶州市',
          370282: '即墨市',
          370283: '平度市',
          370285: '莱西市',
          370286: '其它区',
          370300: '淄博市',
          370302: '淄川区',
          370303: '张店区',
          370304: '博山区',
          370305: '临淄区',
          370306: '周村区',
          370321: '桓台县',
          370322: '高青县',
          370323: '沂源县',
          370324: '其它区',
          370400: '枣庄市',
          370402: '市中区',
          370403: '薛城区',
          370404: '峄城区',
          370405: '台儿庄区',
          370406: '山亭区',
          370481: '滕州市',
          370482: '其它区',
          370500: '东营市',
          370502: '东营区',
          370503: '河口区',
          370521: '垦利县',
          370522: '利津县',
          370523: '广饶县',
          370591: '其它区',
          370600: '烟台市',
          370602: '芝罘区',
          370611: '福山区',
          370612: '牟平区',
          370613: '莱山区',
          370634: '长岛县',
          370681: '龙口市',
          370682: '莱阳市',
          370683: '莱州市',
          370684: '蓬莱市',
          370685: '招远市',
          370686: '栖霞市',
          370687: '海阳市',
          370688: '其它区',
          370700: '潍坊市',
          370702: '潍城区',
          370703: '寒亭区',
          370704: '坊子区',
          370705: '奎文区',
          370724: '临朐县',
          370725: '昌乐县',
          370781: '青州市',
          370782: '诸城市',
          370783: '寿光市',
          370784: '安丘市',
          370785: '高密市',
          370786: '昌邑市',
          370787: '其它区',
          370800: '济宁市',
          370802: '市中区',
          370811: '任城区',
          370826: '微山县',
          370827: '鱼台县',
          370828: '金乡县',
          370829: '嘉祥县',
          370830: '汶上县',
          370831: '泗水县',
          370832: '梁山县',
          370881: '曲阜市',
          370882: '兖州市',
          370883: '邹城市',
          370884: '其它区',
          370900: '泰安市',
          370902: '泰山区',
          370903: '岱岳区',
          370921: '宁阳县',
          370923: '东平县',
          370982: '新泰市',
          370983: '肥城市',
          370984: '其它区',
          371e3: '威海市',
          371002: '环翠区',
          371081: '文登市',
          371082: '荣成市',
          371083: '乳山市',
          371084: '其它区',
          371100: '日照市',
          371102: '东港区',
          371103: '岚山区',
          371121: '五莲县',
          371122: '莒县',
          371123: '其它区',
          371200: '莱芜市',
          371202: '莱城区',
          371203: '钢城区',
          371204: '其它区',
          371300: '临沂市',
          371302: '兰山区',
          371311: '罗庄区',
          371312: '河东区',
          371321: '沂南县',
          371322: '郯城县',
          371323: '沂水县',
          371324: '苍山县',
          371325: '费县',
          371326: '平邑县',
          371327: '莒南县',
          371328: '蒙阴县',
          371329: '临沭县',
          371330: '其它区',
          371400: '德州市',
          371402: '德城区',
          371421: '陵县',
          371422: '宁津县',
          371423: '庆云县',
          371424: '临邑县',
          371425: '齐河县',
          371426: '平原县',
          371427: '夏津县',
          371428: '武城县',
          371481: '乐陵市',
          371482: '禹城市',
          371483: '其它区',
          371500: '聊城市',
          371502: '东昌府区',
          371521: '阳谷县',
          371522: '莘县',
          371523: '茌平县',
          371524: '东阿县',
          371525: '冠县',
          371526: '高唐县',
          371581: '临清市',
          371582: '其它区',
          371600: '滨州市',
          371602: '滨城区',
          371621: '惠民县',
          371622: '阳信县',
          371623: '无棣县',
          371624: '沾化县',
          371625: '博兴县',
          371626: '邹平县',
          371627: '其它区',
          371700: '菏泽市',
          371702: '牡丹区',
          371721: '曹县',
          371722: '单县',
          371723: '成武县',
          371724: '巨野县',
          371725: '郓城县',
          371726: '鄄城县',
          371727: '定陶县',
          371728: '东明县',
          371729: '其它区',
          41e4: '河南省',
          410100: '郑州市',
          410102: '中原区',
          410103: '二七区',
          410104: '管城回族区',
          410105: '金水区',
          410106: '上街区',
          410108: '惠济区',
          410122: '中牟县',
          410181: '巩义市',
          410182: '荥阳市',
          410183: '新密市',
          410184: '新郑市',
          410185: '登封市',
          410188: '其它区',
          410200: '开封市',
          410202: '龙亭区',
          410203: '顺河回族区',
          410204: '鼓楼区',
          410205: '禹王台区',
          410211: '金明区',
          410221: '杞县',
          410222: '通许县',
          410223: '尉氏县',
          410224: '开封县',
          410225: '兰考县',
          410226: '其它区',
          410300: '洛阳市',
          410302: '老城区',
          410303: '西工区',
          410304: '瀍河回族区',
          410305: '涧西区',
          410306: '吉利区',
          410307: '洛龙区',
          410322: '孟津县',
          410323: '新安县',
          410324: '栾川县',
          410325: '嵩县',
          410326: '汝阳县',
          410327: '宜阳县',
          410328: '洛宁县',
          410329: '伊川县',
          410381: '偃师市',
          410400: '平顶山市',
          410402: '新华区',
          410403: '卫东区',
          410404: '石龙区',
          410411: '湛河区',
          410421: '宝丰县',
          410422: '叶县',
          410423: '鲁山县',
          410425: '郏县',
          410481: '舞钢市',
          410482: '汝州市',
          410483: '其它区',
          410500: '安阳市',
          410502: '文峰区',
          410503: '北关区',
          410505: '殷都区',
          410506: '龙安区',
          410522: '安阳县',
          410523: '汤阴县',
          410526: '滑县',
          410527: '内黄县',
          410581: '林州市',
          410582: '其它区',
          410600: '鹤壁市',
          410602: '鹤山区',
          410603: '山城区',
          410611: '淇滨区',
          410621: '浚县',
          410622: '淇县',
          410623: '其它区',
          410700: '新乡市',
          410702: '红旗区',
          410703: '卫滨区',
          410704: '凤泉区',
          410711: '牧野区',
          410721: '新乡县',
          410724: '获嘉县',
          410725: '原阳县',
          410726: '延津县',
          410727: '封丘县',
          410728: '长垣县',
          410781: '卫辉市',
          410782: '辉县市',
          410783: '其它区',
          410800: '焦作市',
          410802: '解放区',
          410803: '中站区',
          410804: '马村区',
          410811: '山阳区',
          410821: '修武县',
          410822: '博爱县',
          410823: '武陟县',
          410825: '温县',
          410881: '济源市',
          410882: '沁阳市',
          410883: '孟州市',
          410884: '其它区',
          410900: '濮阳市',
          410902: '华龙区',
          410922: '清丰县',
          410923: '南乐县',
          410926: '范县',
          410927: '台前县',
          410928: '濮阳县',
          410929: '其它区',
          411e3: '许昌市',
          411002: '魏都区',
          411023: '许昌县',
          411024: '鄢陵县',
          411025: '襄城县',
          411081: '禹州市',
          411082: '长葛市',
          411083: '其它区',
          411100: '漯河市',
          411102: '源汇区',
          411103: '郾城区',
          411104: '召陵区',
          411121: '舞阳县',
          411122: '临颍县',
          411123: '其它区',
          411200: '三门峡市',
          411202: '湖滨区',
          411221: '渑池县',
          411222: '陕县',
          411224: '卢氏县',
          411281: '义马市',
          411282: '灵宝市',
          411283: '其它区',
          411300: '南阳市',
          411302: '宛城区',
          411303: '卧龙区',
          411321: '南召县',
          411322: '方城县',
          411323: '西峡县',
          411324: '镇平县',
          411325: '内乡县',
          411326: '淅川县',
          411327: '社旗县',
          411328: '唐河县',
          411329: '新野县',
          411330: '桐柏县',
          411381: '邓州市',
          411382: '其它区',
          411400: '商丘市',
          411402: '梁园区',
          411403: '睢阳区',
          411421: '民权县',
          411422: '睢县',
          411423: '宁陵县',
          411424: '柘城县',
          411425: '虞城县',
          411426: '夏邑县',
          411481: '永城市',
          411482: '其它区',
          411500: '信阳市',
          411502: '浉河区',
          411503: '平桥区',
          411521: '罗山县',
          411522: '光山县',
          411523: '新县',
          411524: '商城县',
          411525: '固始县',
          411526: '潢川县',
          411527: '淮滨县',
          411528: '息县',
          411529: '其它区',
          411600: '周口市',
          411602: '川汇区',
          411621: '扶沟县',
          411622: '西华县',
          411623: '商水县',
          411624: '沈丘县',
          411625: '郸城县',
          411626: '淮阳县',
          411627: '太康县',
          411628: '鹿邑县',
          411681: '项城市',
          411682: '其它区',
          411700: '驻马店市',
          411702: '驿城区',
          411721: '西平县',
          411722: '上蔡县',
          411723: '平舆县',
          411724: '正阳县',
          411725: '确山县',
          411726: '泌阳县',
          411727: '汝南县',
          411728: '遂平县',
          411729: '新蔡县',
          411730: '其它区',
          42e4: '湖北省',
          420100: '武汉市',
          420102: '江岸区',
          420103: '江汉区',
          420104: '硚口区',
          420105: '汉阳区',
          420106: '武昌区',
          420107: '青山区',
          420111: '洪山区',
          420112: '东西湖区',
          420113: '汉南区',
          420114: '蔡甸区',
          420115: '江夏区',
          420116: '黄陂区',
          420117: '新洲区',
          420118: '其它区',
          420200: '黄石市',
          420202: '黄石港区',
          420203: '西塞山区',
          420204: '下陆区',
          420205: '铁山区',
          420222: '阳新县',
          420281: '大冶市',
          420282: '其它区',
          420300: '十堰市',
          420302: '茅箭区',
          420303: '张湾区',
          420321: '郧县',
          420322: '郧西县',
          420323: '竹山县',
          420324: '竹溪县',
          420325: '房县',
          420381: '丹江口市',
          420383: '其它区',
          420500: '宜昌市',
          420502: '西陵区',
          420503: '伍家岗区',
          420504: '点军区',
          420505: '猇亭区',
          420506: '夷陵区',
          420525: '远安县',
          420526: '兴山县',
          420527: '秭归县',
          420528: '长阳土家族自治县',
          420529: '五峰土家族自治县',
          420581: '宜都市',
          420582: '当阳市',
          420583: '枝江市',
          420584: '其它区',
          420600: '襄阳市',
          420602: '襄城区',
          420606: '樊城区',
          420607: '襄州区',
          420624: '南漳县',
          420625: '谷城县',
          420626: '保康县',
          420682: '老河口市',
          420683: '枣阳市',
          420684: '宜城市',
          420685: '其它区',
          420700: '鄂州市',
          420702: '梁子湖区',
          420703: '华容区',
          420704: '鄂城区',
          420705: '其它区',
          420800: '荆门市',
          420802: '东宝区',
          420804: '掇刀区',
          420821: '京山县',
          420822: '沙洋县',
          420881: '钟祥市',
          420882: '其它区',
          420900: '孝感市',
          420902: '孝南区',
          420921: '孝昌县',
          420922: '大悟县',
          420923: '云梦县',
          420981: '应城市',
          420982: '安陆市',
          420984: '汉川市',
          420985: '其它区',
          421e3: '荆州市',
          421002: '沙市区',
          421003: '荆州区',
          421022: '公安县',
          421023: '监利县',
          421024: '江陵县',
          421081: '石首市',
          421083: '洪湖市',
          421087: '松滋市',
          421088: '其它区',
          421100: '黄冈市',
          421102: '黄州区',
          421121: '团风县',
          421122: '红安县',
          421123: '罗田县',
          421124: '英山县',
          421125: '浠水县',
          421126: '蕲春县',
          421127: '黄梅县',
          421181: '麻城市',
          421182: '武穴市',
          421183: '其它区',
          421200: '咸宁市',
          421202: '咸安区',
          421221: '嘉鱼县',
          421222: '通城县',
          421223: '崇阳县',
          421224: '通山县',
          421281: '赤壁市',
          421283: '其它区',
          421300: '随州市',
          421302: '曾都区',
          421321: '随县',
          421381: '广水市',
          421382: '其它区',
          422800: '恩施土家族苗族自治州',
          422801: '恩施市',
          422802: '利川市',
          422822: '建始县',
          422823: '巴东县',
          422825: '宣恩县',
          422826: '咸丰县',
          422827: '来凤县',
          422828: '鹤峰县',
          422829: '其它区',
          429004: '仙桃市',
          429005: '潜江市',
          429006: '天门市',
          429021: '神农架林区',
          43e4: '湖南省',
          430100: '长沙市',
          430102: '芙蓉区',
          430103: '天心区',
          430104: '岳麓区',
          430105: '开福区',
          430111: '雨花区',
          430121: '长沙县',
          430122: '望城区',
          430124: '宁乡县',
          430181: '浏阳市',
          430182: '其它区',
          430200: '株洲市',
          430202: '荷塘区',
          430203: '芦淞区',
          430204: '石峰区',
          430211: '天元区',
          430221: '株洲县',
          430223: '攸县',
          430224: '茶陵县',
          430225: '炎陵县',
          430281: '醴陵市',
          430282: '其它区',
          430300: '湘潭市',
          430302: '雨湖区',
          430304: '岳塘区',
          430321: '湘潭县',
          430381: '湘乡市',
          430382: '韶山市',
          430383: '其它区',
          430400: '衡阳市',
          430405: '珠晖区',
          430406: '雁峰区',
          430407: '石鼓区',
          430408: '蒸湘区',
          430412: '南岳区',
          430421: '衡阳县',
          430422: '衡南县',
          430423: '衡山县',
          430424: '衡东县',
          430426: '祁东县',
          430481: '耒阳市',
          430482: '常宁市',
          430483: '其它区',
          430500: '邵阳市',
          430502: '双清区',
          430503: '大祥区',
          430511: '北塔区',
          430521: '邵东县',
          430522: '新邵县',
          430523: '邵阳县',
          430524: '隆回县',
          430525: '洞口县',
          430527: '绥宁县',
          430528: '新宁县',
          430529: '城步苗族自治县',
          430581: '武冈市',
          430582: '其它区',
          430600: '岳阳市',
          430602: '岳阳楼区',
          430603: '云溪区',
          430611: '君山区',
          430621: '岳阳县',
          430623: '华容县',
          430624: '湘阴县',
          430626: '平江县',
          430681: '汨罗市',
          430682: '临湘市',
          430683: '其它区',
          430700: '常德市',
          430702: '武陵区',
          430703: '鼎城区',
          430721: '安乡县',
          430722: '汉寿县',
          430723: '澧县',
          430724: '临澧县',
          430725: '桃源县',
          430726: '石门县',
          430781: '津市市',
          430782: '其它区',
          430800: '张家界市',
          430802: '永定区',
          430811: '武陵源区',
          430821: '慈利县',
          430822: '桑植县',
          430823: '其它区',
          430900: '益阳市',
          430902: '资阳区',
          430903: '赫山区',
          430921: '南县',
          430922: '桃江县',
          430923: '安化县',
          430981: '沅江市',
          430982: '其它区',
          431e3: '郴州市',
          431002: '北湖区',
          431003: '苏仙区',
          431021: '桂阳县',
          431022: '宜章县',
          431023: '永兴县',
          431024: '嘉禾县',
          431025: '临武县',
          431026: '汝城县',
          431027: '桂东县',
          431028: '安仁县',
          431081: '资兴市',
          431082: '其它区',
          431100: '永州市',
          431102: '零陵区',
          431103: '冷水滩区',
          431121: '祁阳县',
          431122: '东安县',
          431123: '双牌县',
          431124: '道县',
          431125: '江永县',
          431126: '宁远县',
          431127: '蓝山县',
          431128: '新田县',
          431129: '江华瑶族自治县',
          431130: '其它区',
          431200: '怀化市',
          431202: '鹤城区',
          431221: '中方县',
          431222: '沅陵县',
          431223: '辰溪县',
          431224: '溆浦县',
          431225: '会同县',
          431226: '麻阳苗族自治县',
          431227: '新晃侗族自治县',
          431228: '芷江侗族自治县',
          431229: '靖州苗族侗族自治县',
          431230: '通道侗族自治县',
          431281: '洪江市',
          431282: '其它区',
          431300: '娄底市',
          431302: '娄星区',
          431321: '双峰县',
          431322: '新化县',
          431381: '冷水江市',
          431382: '涟源市',
          431383: '其它区',
          433100: '湘西土家族苗族自治州',
          433101: '吉首市',
          433122: '泸溪县',
          433123: '凤凰县',
          433124: '花垣县',
          433125: '保靖县',
          433126: '古丈县',
          433127: '永顺县',
          433130: '龙山县',
          433131: '其它区',
          44e4: '广东省',
          440100: '广州市',
          440103: '荔湾区',
          440104: '越秀区',
          440105: '海珠区',
          440106: '天河区',
          440111: '白云区',
          440112: '黄埔区',
          440113: '番禺区',
          440114: '花都区',
          440115: '南沙区',
          440116: '萝岗区',
          440183: '增城市',
          440184: '从化市',
          440189: '其它区',
          440200: '韶关市',
          440203: '武江区',
          440204: '浈江区',
          440205: '曲江区',
          440222: '始兴县',
          440224: '仁化县',
          440229: '翁源县',
          440232: '乳源瑶族自治县',
          440233: '新丰县',
          440281: '乐昌市',
          440282: '南雄市',
          440283: '其它区',
          440300: '深圳市',
          440303: '罗湖区',
          440304: '福田区',
          440305: '南山区',
          440306: '宝安区',
          440307: '龙岗区',
          440308: '盐田区',
          440309: '其它区',
          440320: '光明新区',
          440321: '坪山新区',
          440322: '大鹏新区',
          440323: '龙华新区',
          440400: '珠海市',
          440402: '香洲区',
          440403: '斗门区',
          440404: '金湾区',
          440488: '其它区',
          440500: '汕头市',
          440507: '龙湖区',
          440511: '金平区',
          440512: '濠江区',
          440513: '潮阳区',
          440514: '潮南区',
          440515: '澄海区',
          440523: '南澳县',
          440524: '其它区',
          440600: '佛山市',
          440604: '禅城区',
          440605: '南海区',
          440606: '顺德区',
          440607: '三水区',
          440608: '高明区',
          440609: '其它区',
          440700: '江门市',
          440703: '蓬江区',
          440704: '江海区',
          440705: '新会区',
          440781: '台山市',
          440783: '开平市',
          440784: '鹤山市',
          440785: '恩平市',
          440786: '其它区',
          440800: '湛江市',
          440802: '赤坎区',
          440803: '霞山区',
          440804: '坡头区',
          440811: '麻章区',
          440823: '遂溪县',
          440825: '徐闻县',
          440881: '廉江市',
          440882: '雷州市',
          440883: '吴川市',
          440884: '其它区',
          440900: '茂名市',
          440902: '茂南区',
          440903: '茂港区',
          440923: '电白县',
          440981: '高州市',
          440982: '化州市',
          440983: '信宜市',
          440984: '其它区',
          441200: '肇庆市',
          441202: '端州区',
          441203: '鼎湖区',
          441223: '广宁县',
          441224: '怀集县',
          441225: '封开县',
          441226: '德庆县',
          441283: '高要市',
          441284: '四会市',
          441285: '其它区',
          441300: '惠州市',
          441302: '惠城区',
          441303: '惠阳区',
          441322: '博罗县',
          441323: '惠东县',
          441324: '龙门县',
          441325: '其它区',
          441400: '梅州市',
          441402: '梅江区',
          441421: '梅县',
          441422: '大埔县',
          441423: '丰顺县',
          441424: '五华县',
          441426: '平远县',
          441427: '蕉岭县',
          441481: '兴宁市',
          441482: '其它区',
          441500: '汕尾市',
          441502: '城区',
          441521: '海丰县',
          441523: '陆河县',
          441581: '陆丰市',
          441582: '其它区',
          441600: '河源市',
          441602: '源城区',
          441621: '紫金县',
          441622: '龙川县',
          441623: '连平县',
          441624: '和平县',
          441625: '东源县',
          441626: '其它区',
          441700: '阳江市',
          441702: '江城区',
          441721: '阳西县',
          441723: '阳东县',
          441781: '阳春市',
          441782: '其它区',
          441800: '清远市',
          441802: '清城区',
          441821: '佛冈县',
          441823: '阳山县',
          441825: '连山壮族瑶族自治县',
          441826: '连南瑶族自治县',
          441827: '清新区',
          441881: '英德市',
          441882: '连州市',
          441883: '其它区',
          441900: '东莞市',
          442e3: '中山市',
          442101: '东沙群岛',
          445100: '潮州市',
          445102: '湘桥区',
          445121: '潮安区',
          445122: '饶平县',
          445186: '其它区',
          445200: '揭阳市',
          445202: '榕城区',
          445221: '揭东区',
          445222: '揭西县',
          445224: '惠来县',
          445281: '普宁市',
          445285: '其它区',
          445300: '云浮市',
          445302: '云城区',
          445321: '新兴县',
          445322: '郁南县',
          445323: '云安县',
          445381: '罗定市',
          445382: '其它区',
          45e4: '广西壮族自治区',
          450100: '南宁市',
          450102: '兴宁区',
          450103: '青秀区',
          450105: '江南区',
          450107: '西乡塘区',
          450108: '良庆区',
          450109: '邕宁区',
          450122: '武鸣县',
          450123: '隆安县',
          450124: '马山县',
          450125: '上林县',
          450126: '宾阳县',
          450127: '横县',
          450128: '其它区',
          450200: '柳州市',
          450202: '城中区',
          450203: '鱼峰区',
          450204: '柳南区',
          450205: '柳北区',
          450221: '柳江县',
          450222: '柳城县',
          450223: '鹿寨县',
          450224: '融安县',
          450225: '融水苗族自治县',
          450226: '三江侗族自治县',
          450227: '其它区',
          450300: '桂林市',
          450302: '秀峰区',
          450303: '叠彩区',
          450304: '象山区',
          450305: '七星区',
          450311: '雁山区',
          450321: '阳朔县',
          450322: '临桂区',
          450323: '灵川县',
          450324: '全州县',
          450325: '兴安县',
          450326: '永福县',
          450327: '灌阳县',
          450328: '龙胜各族自治县',
          450329: '资源县',
          450330: '平乐县',
          450331: '荔浦县',
          450332: '恭城瑶族自治县',
          450333: '其它区',
          450400: '梧州市',
          450403: '万秀区',
          450405: '长洲区',
          450406: '龙圩区',
          450421: '苍梧县',
          450422: '藤县',
          450423: '蒙山县',
          450481: '岑溪市',
          450482: '其它区',
          450500: '北海市',
          450502: '海城区',
          450503: '银海区',
          450512: '铁山港区',
          450521: '合浦县',
          450522: '其它区',
          450600: '防城港市',
          450602: '港口区',
          450603: '防城区',
          450621: '上思县',
          450681: '东兴市',
          450682: '其它区',
          450700: '钦州市',
          450702: '钦南区',
          450703: '钦北区',
          450721: '灵山县',
          450722: '浦北县',
          450723: '其它区',
          450800: '贵港市',
          450802: '港北区',
          450803: '港南区',
          450804: '覃塘区',
          450821: '平南县',
          450881: '桂平市',
          450882: '其它区',
          450900: '玉林市',
          450902: '玉州区',
          450903: '福绵区',
          450921: '容县',
          450922: '陆川县',
          450923: '博白县',
          450924: '兴业县',
          450981: '北流市',
          450982: '其它区',
          451e3: '百色市',
          451002: '右江区',
          451021: '田阳县',
          451022: '田东县',
          451023: '平果县',
          451024: '德保县',
          451025: '靖西县',
          451026: '那坡县',
          451027: '凌云县',
          451028: '乐业县',
          451029: '田林县',
          451030: '西林县',
          451031: '隆林各族自治县',
          451032: '其它区',
          451100: '贺州市',
          451102: '八步区',
          451119: '平桂管理区',
          451121: '昭平县',
          451122: '钟山县',
          451123: '富川瑶族自治县',
          451124: '其它区',
          451200: '河池市',
          451202: '金城江区',
          451221: '南丹县',
          451222: '天峨县',
          451223: '凤山县',
          451224: '东兰县',
          451225: '罗城仫佬族自治县',
          451226: '环江毛南族自治县',
          451227: '巴马瑶族自治县',
          451228: '都安瑶族自治县',
          451229: '大化瑶族自治县',
          451281: '宜州市',
          451282: '其它区',
          451300: '来宾市',
          451302: '兴宾区',
          451321: '忻城县',
          451322: '象州县',
          451323: '武宣县',
          451324: '金秀瑶族自治县',
          451381: '合山市',
          451382: '其它区',
          451400: '崇左市',
          451402: '江州区',
          451421: '扶绥县',
          451422: '宁明县',
          451423: '龙州县',
          451424: '大新县',
          451425: '天等县',
          451481: '凭祥市',
          451482: '其它区',
          46e4: '海南省',
          460100: '海口市',
          460105: '秀英区',
          460106: '龙华区',
          460107: '琼山区',
          460108: '美兰区',
          460109: '其它区',
          460200: '三亚市',
          460300: '三沙市',
          460321: '西沙群岛',
          460322: '南沙群岛',
          460323: '中沙群岛的岛礁及其海域',
          469001: '五指山市',
          469002: '琼海市',
          469003: '儋州市',
          469005: '文昌市',
          469006: '万宁市',
          469007: '东方市',
          469025: '定安县',
          469026: '屯昌县',
          469027: '澄迈县',
          469028: '临高县',
          469030: '白沙黎族自治县',
          469031: '昌江黎族自治县',
          469033: '乐东黎族自治县',
          469034: '陵水黎族自治县',
          469035: '保亭黎族苗族自治县',
          469036: '琼中黎族苗族自治县',
          471005: '其它区',
          5e5: '重庆',
          500100: '重庆市',
          500101: '万州区',
          500102: '涪陵区',
          500103: '渝中区',
          500104: '大渡口区',
          500105: '江北区',
          500106: '沙坪坝区',
          500107: '九龙坡区',
          500108: '南岸区',
          500109: '北碚区',
          500110: '万盛区',
          500111: '双桥区',
          500112: '渝北区',
          500113: '巴南区',
          500114: '黔江区',
          500115: '长寿区',
          500222: '綦江区',
          500223: '潼南县',
          500224: '铜梁县',
          500225: '大足区',
          500226: '荣昌县',
          500227: '璧山县',
          500228: '梁平县',
          500229: '城口县',
          500230: '丰都县',
          500231: '垫江县',
          500232: '武隆县',
          500233: '忠县',
          500234: '开县',
          500235: '云阳县',
          500236: '奉节县',
          500237: '巫山县',
          500238: '巫溪县',
          500240: '石柱土家族自治县',
          500241: '秀山土家族苗族自治县',
          500242: '酉阳土家族苗族自治县',
          500243: '彭水苗族土家族自治县',
          500381: '江津区',
          500382: '合川区',
          500383: '永川区',
          500384: '南川区',
          500385: '其它区',
          51e4: '四川省',
          510100: '成都市',
          510104: '锦江区',
          510105: '青羊区',
          510106: '金牛区',
          510107: '武侯区',
          510108: '成华区',
          510112: '龙泉驿区',
          510113: '青白江区',
          510114: '新都区',
          510115: '温江区',
          510121: '金堂县',
          510122: '双流县',
          510124: '郫县',
          510129: '大邑县',
          510131: '蒲江县',
          510132: '新津县',
          510181: '都江堰市',
          510182: '彭州市',
          510183: '邛崃市',
          510184: '崇州市',
          510185: '其它区',
          510300: '自贡市',
          510302: '自流井区',
          510303: '贡井区',
          510304: '大安区',
          510311: '沿滩区',
          510321: '荣县',
          510322: '富顺县',
          510323: '其它区',
          510400: '攀枝花市',
          510402: '东区',
          510403: '西区',
          510411: '仁和区',
          510421: '米易县',
          510422: '盐边县',
          510423: '其它区',
          510500: '泸州市',
          510502: '江阳区',
          510503: '纳溪区',
          510504: '龙马潭区',
          510521: '泸县',
          510522: '合江县',
          510524: '叙永县',
          510525: '古蔺县',
          510526: '其它区',
          510600: '德阳市',
          510603: '旌阳区',
          510623: '中江县',
          510626: '罗江县',
          510681: '广汉市',
          510682: '什邡市',
          510683: '绵竹市',
          510684: '其它区',
          510700: '绵阳市',
          510703: '涪城区',
          510704: '游仙区',
          510722: '三台县',
          510723: '盐亭县',
          510724: '安县',
          510725: '梓潼县',
          510726: '北川羌族自治县',
          510727: '平武县',
          510781: '江油市',
          510782: '其它区',
          510800: '广元市',
          510802: '利州区',
          510811: '昭化区',
          510812: '朝天区',
          510821: '旺苍县',
          510822: '青川县',
          510823: '剑阁县',
          510824: '苍溪县',
          510825: '其它区',
          510900: '遂宁市',
          510903: '船山区',
          510904: '安居区',
          510921: '蓬溪县',
          510922: '射洪县',
          510923: '大英县',
          510924: '其它区',
          511e3: '内江市',
          511002: '市中区',
          511011: '东兴区',
          511024: '威远县',
          511025: '资中县',
          511028: '隆昌县',
          511029: '其它区',
          511100: '乐山市',
          511102: '市中区',
          511111: '沙湾区',
          511112: '五通桥区',
          511113: '金口河区',
          511123: '犍为县',
          511124: '井研县',
          511126: '夹江县',
          511129: '沐川县',
          511132: '峨边彝族自治县',
          511133: '马边彝族自治县',
          511181: '峨眉山市',
          511182: '其它区',
          511300: '南充市',
          511302: '顺庆区',
          511303: '高坪区',
          511304: '嘉陵区',
          511321: '南部县',
          511322: '营山县',
          511323: '蓬安县',
          511324: '仪陇县',
          511325: '西充县',
          511381: '阆中市',
          511382: '其它区',
          511400: '眉山市',
          511402: '东坡区',
          511421: '仁寿县',
          511422: '彭山县',
          511423: '洪雅县',
          511424: '丹棱县',
          511425: '青神县',
          511426: '其它区',
          511500: '宜宾市',
          511502: '翠屏区',
          511521: '宜宾县',
          511522: '南溪区',
          511523: '江安县',
          511524: '长宁县',
          511525: '高县',
          511526: '珙县',
          511527: '筠连县',
          511528: '兴文县',
          511529: '屏山县',
          511530: '其它区',
          511600: '广安市',
          511602: '广安区',
          511603: '前锋区',
          511621: '岳池县',
          511622: '武胜县',
          511623: '邻水县',
          511681: '华蓥市',
          511683: '其它区',
          511700: '达州市',
          511702: '通川区',
          511721: '达川区',
          511722: '宣汉县',
          511723: '开江县',
          511724: '大竹县',
          511725: '渠县',
          511781: '万源市',
          511782: '其它区',
          511800: '雅安市',
          511802: '雨城区',
          511821: '名山区',
          511822: '荥经县',
          511823: '汉源县',
          511824: '石棉县',
          511825: '天全县',
          511826: '芦山县',
          511827: '宝兴县',
          511828: '其它区',
          511900: '巴中市',
          511902: '巴州区',
          511903: '恩阳区',
          511921: '通江县',
          511922: '南江县',
          511923: '平昌县',
          511924: '其它区',
          512e3: '资阳市',
          512002: '雁江区',
          512021: '安岳县',
          512022: '乐至县',
          512081: '简阳市',
          512082: '其它区',
          513200: '阿坝藏族羌族自治州',
          513221: '汶川县',
          513222: '理县',
          513223: '茂县',
          513224: '松潘县',
          513225: '九寨沟县',
          513226: '金川县',
          513227: '小金县',
          513228: '黑水县',
          513229: '马尔康县',
          513230: '壤塘县',
          513231: '阿坝县',
          513232: '若尔盖县',
          513233: '红原县',
          513234: '其它区',
          513300: '甘孜藏族自治州',
          513321: '康定县',
          513322: '泸定县',
          513323: '丹巴县',
          513324: '九龙县',
          513325: '雅江县',
          513326: '道孚县',
          513327: '炉霍县',
          513328: '甘孜县',
          513329: '新龙县',
          513330: '德格县',
          513331: '白玉县',
          513332: '石渠县',
          513333: '色达县',
          513334: '理塘县',
          513335: '巴塘县',
          513336: '乡城县',
          513337: '稻城县',
          513338: '得荣县',
          513339: '其它区',
          513400: '凉山彝族自治州',
          513401: '西昌市',
          513422: '木里藏族自治县',
          513423: '盐源县',
          513424: '德昌县',
          513425: '会理县',
          513426: '会东县',
          513427: '宁南县',
          513428: '普格县',
          513429: '布拖县',
          513430: '金阳县',
          513431: '昭觉县',
          513432: '喜德县',
          513433: '冕宁县',
          513434: '越西县',
          513435: '甘洛县',
          513436: '美姑县',
          513437: '雷波县',
          513438: '其它区',
          52e4: '贵州省',
          520100: '贵阳市',
          520102: '南明区',
          520103: '云岩区',
          520111: '花溪区',
          520112: '乌当区',
          520113: '白云区',
          520121: '开阳县',
          520122: '息烽县',
          520123: '修文县',
          520151: '观山湖区',
          520181: '清镇市',
          520182: '其它区',
          520200: '六盘水市',
          520201: '钟山区',
          520203: '六枝特区',
          520221: '水城县',
          520222: '盘县',
          520223: '其它区',
          520300: '遵义市',
          520302: '红花岗区',
          520303: '汇川区',
          520321: '遵义县',
          520322: '桐梓县',
          520323: '绥阳县',
          520324: '正安县',
          520325: '道真仡佬族苗族自治县',
          520326: '务川仡佬族苗族自治县',
          520327: '凤冈县',
          520328: '湄潭县',
          520329: '余庆县',
          520330: '习水县',
          520381: '赤水市',
          520382: '仁怀市',
          520383: '其它区',
          520400: '安顺市',
          520402: '西秀区',
          520421: '平坝县',
          520422: '普定县',
          520423: '镇宁布依族苗族自治县',
          520424: '关岭布依族苗族自治县',
          520425: '紫云苗族布依族自治县',
          520426: '其它区',
          522200: '铜仁市',
          522201: '碧江区',
          522222: '江口县',
          522223: '玉屏侗族自治县',
          522224: '石阡县',
          522225: '思南县',
          522226: '印江土家族苗族自治县',
          522227: '德江县',
          522228: '沿河土家族自治县',
          522229: '松桃苗族自治县',
          522230: '万山区',
          522231: '其它区',
          522300: '黔西南布依族苗族自治州',
          522301: '兴义市',
          522322: '兴仁县',
          522323: '普安县',
          522324: '晴隆县',
          522325: '贞丰县',
          522326: '望谟县',
          522327: '册亨县',
          522328: '安龙县',
          522329: '其它区',
          522400: '毕节市',
          522401: '七星关区',
          522422: '大方县',
          522423: '黔西县',
          522424: '金沙县',
          522425: '织金县',
          522426: '纳雍县',
          522427: '威宁彝族回族苗族自治县',
          522428: '赫章县',
          522429: '其它区',
          522600: '黔东南苗族侗族自治州',
          522601: '凯里市',
          522622: '黄平县',
          522623: '施秉县',
          522624: '三穗县',
          522625: '镇远县',
          522626: '岑巩县',
          522627: '天柱县',
          522628: '锦屏县',
          522629: '剑河县',
          522630: '台江县',
          522631: '黎平县',
          522632: '榕江县',
          522633: '从江县',
          522634: '雷山县',
          522635: '麻江县',
          522636: '丹寨县',
          522637: '其它区',
          522700: '黔南布依族苗族自治州',
          522701: '都匀市',
          522702: '福泉市',
          522722: '荔波县',
          522723: '贵定县',
          522725: '瓮安县',
          522726: '独山县',
          522727: '平塘县',
          522728: '罗甸县',
          522729: '长顺县',
          522730: '龙里县',
          522731: '惠水县',
          522732: '三都水族自治县',
          522733: '其它区',
          53e4: '云南省',
          530100: '昆明市',
          530102: '五华区',
          530103: '盘龙区',
          530111: '官渡区',
          530112: '西山区',
          530113: '东川区',
          530121: '呈贡区',
          530122: '晋宁县',
          530124: '富民县',
          530125: '宜良县',
          530126: '石林彝族自治县',
          530127: '嵩明县',
          530128: '禄劝彝族苗族自治县',
          530129: '寻甸回族彝族自治县',
          530181: '安宁市',
          530182: '其它区',
          530300: '曲靖市',
          530302: '麒麟区',
          530321: '马龙县',
          530322: '陆良县',
          530323: '师宗县',
          530324: '罗平县',
          530325: '富源县',
          530326: '会泽县',
          530328: '沾益县',
          530381: '宣威市',
          530382: '其它区',
          530400: '玉溪市',
          530402: '红塔区',
          530421: '江川县',
          530422: '澄江县',
          530423: '通海县',
          530424: '华宁县',
          530425: '易门县',
          530426: '峨山彝族自治县',
          530427: '新平彝族傣族自治县',
          530428: '元江哈尼族彝族傣族自治县',
          530429: '其它区',
          530500: '保山市',
          530502: '隆阳区',
          530521: '施甸县',
          530522: '腾冲县',
          530523: '龙陵县',
          530524: '昌宁县',
          530525: '其它区',
          530600: '昭通市',
          530602: '昭阳区',
          530621: '鲁甸县',
          530622: '巧家县',
          530623: '盐津县',
          530624: '大关县',
          530625: '永善县',
          530626: '绥江县',
          530627: '镇雄县',
          530628: '彝良县',
          530629: '威信县',
          530630: '水富县',
          530631: '其它区',
          530700: '丽江市',
          530702: '古城区',
          530721: '玉龙纳西族自治县',
          530722: '永胜县',
          530723: '华坪县',
          530724: '宁蒗彝族自治县',
          530725: '其它区',
          530800: '普洱市',
          530802: '思茅区',
          530821: '宁洱哈尼族彝族自治县',
          530822: '墨江哈尼族自治县',
          530823: '景东彝族自治县',
          530824: '景谷傣族彝族自治县',
          530825: '镇沅彝族哈尼族拉祜族自治县',
          530826: '江城哈尼族彝族自治县',
          530827: '孟连傣族拉祜族佤族自治县',
          530828: '澜沧拉祜族自治县',
          530829: '西盟佤族自治县',
          530830: '其它区',
          530900: '临沧市',
          530902: '临翔区',
          530921: '凤庆县',
          530922: '云县',
          530923: '永德县',
          530924: '镇康县',
          530925: '双江拉祜族佤族布朗族傣族自治县',
          530926: '耿马傣族佤族自治县',
          530927: '沧源佤族自治县',
          530928: '其它区',
          532300: '楚雄彝族自治州',
          532301: '楚雄市',
          532322: '双柏县',
          532323: '牟定县',
          532324: '南华县',
          532325: '姚安县',
          532326: '大姚县',
          532327: '永仁县',
          532328: '元谋县',
          532329: '武定县',
          532331: '禄丰县',
          532332: '其它区',
          532500: '红河哈尼族彝族自治州',
          532501: '个旧市',
          532502: '开远市',
          532522: '蒙自市',
          532523: '屏边苗族自治县',
          532524: '建水县',
          532525: '石屏县',
          532526: '弥勒市',
          532527: '泸西县',
          532528: '元阳县',
          532529: '红河县',
          532530: '金平苗族瑶族傣族自治县',
          532531: '绿春县',
          532532: '河口瑶族自治县',
          532533: '其它区',
          532600: '文山壮族苗族自治州',
          532621: '文山市',
          532622: '砚山县',
          532623: '西畴县',
          532624: '麻栗坡县',
          532625: '马关县',
          532626: '丘北县',
          532627: '广南县',
          532628: '富宁县',
          532629: '其它区',
          532800: '西双版纳傣族自治州',
          532801: '景洪市',
          532822: '勐海县',
          532823: '勐腊县',
          532824: '其它区',
          532900: '大理白族自治州',
          532901: '大理市',
          532922: '漾濞彝族自治县',
          532923: '祥云县',
          532924: '宾川县',
          532925: '弥渡县',
          532926: '南涧彝族自治县',
          532927: '巍山彝族回族自治县',
          532928: '永平县',
          532929: '云龙县',
          532930: '洱源县',
          532931: '剑川县',
          532932: '鹤庆县',
          532933: '其它区',
          533100: '德宏傣族景颇族自治州',
          533102: '瑞丽市',
          533103: '芒市',
          533122: '梁河县',
          533123: '盈江县',
          533124: '陇川县',
          533125: '其它区',
          533300: '怒江傈僳族自治州',
          533321: '泸水县',
          533323: '福贡县',
          533324: '贡山独龙族怒族自治县',
          533325: '兰坪白族普米族自治县',
          533326: '其它区',
          533400: '迪庆藏族自治州',
          533421: '香格里拉县',
          533422: '德钦县',
          533423: '维西傈僳族自治县',
          533424: '其它区',
          54e4: '西藏自治区',
          540100: '拉萨市',
          540102: '城关区',
          540121: '林周县',
          540122: '当雄县',
          540123: '尼木县',
          540124: '曲水县',
          540125: '堆龙德庆县',
          540126: '达孜县',
          540127: '墨竹工卡县',
          540128: '其它区',
          542100: '昌都地区',
          542121: '昌都县',
          542122: '江达县',
          542123: '贡觉县',
          542124: '类乌齐县',
          542125: '丁青县',
          542126: '察雅县',
          542127: '八宿县',
          542128: '左贡县',
          542129: '芒康县',
          542132: '洛隆县',
          542133: '边坝县',
          542134: '其它区',
          542200: '山南地区',
          542221: '乃东县',
          542222: '扎囊县',
          542223: '贡嘎县',
          542224: '桑日县',
          542225: '琼结县',
          542226: '曲松县',
          542227: '措美县',
          542228: '洛扎县',
          542229: '加查县',
          542231: '隆子县',
          542232: '错那县',
          542233: '浪卡子县',
          542234: '其它区',
          542300: '日喀则地区',
          542301: '日喀则市',
          542322: '南木林县',
          542323: '江孜县',
          542324: '定日县',
          542325: '萨迦县',
          542326: '拉孜县',
          542327: '昂仁县',
          542328: '谢通门县',
          542329: '白朗县',
          542330: '仁布县',
          542331: '康马县',
          542332: '定结县',
          542333: '仲巴县',
          542334: '亚东县',
          542335: '吉隆县',
          542336: '聂拉木县',
          542337: '萨嘎县',
          542338: '岗巴县',
          542339: '其它区',
          542400: '那曲地区',
          542421: '那曲县',
          542422: '嘉黎县',
          542423: '比如县',
          542424: '聂荣县',
          542425: '安多县',
          542426: '申扎县',
          542427: '索县',
          542428: '班戈县',
          542429: '巴青县',
          542430: '尼玛县',
          542431: '其它区',
          542432: '双湖县',
          542500: '阿里地区',
          542521: '普兰县',
          542522: '札达县',
          542523: '噶尔县',
          542524: '日土县',
          542525: '革吉县',
          542526: '改则县',
          542527: '措勤县',
          542528: '其它区',
          542600: '林芝地区',
          542621: '林芝县',
          542622: '工布江达县',
          542623: '米林县',
          542624: '墨脱县',
          542625: '波密县',
          542626: '察隅县',
          542627: '朗县',
          542628: '其它区',
          61e4: '陕西省',
          610100: '西安市',
          610102: '新城区',
          610103: '碑林区',
          610104: '莲湖区',
          610111: '灞桥区',
          610112: '未央区',
          610113: '雁塔区',
          610114: '阎良区',
          610115: '临潼区',
          610116: '长安区',
          610122: '蓝田县',
          610124: '周至县',
          610125: '户县',
          610126: '高陵县',
          610127: '其它区',
          610200: '铜川市',
          610202: '王益区',
          610203: '印台区',
          610204: '耀州区',
          610222: '宜君县',
          610223: '其它区',
          610300: '宝鸡市',
          610302: '渭滨区',
          610303: '金台区',
          610304: '陈仓区',
          610322: '凤翔县',
          610323: '岐山县',
          610324: '扶风县',
          610326: '眉县',
          610327: '陇县',
          610328: '千阳县',
          610329: '麟游县',
          610330: '凤县',
          610331: '太白县',
          610332: '其它区',
          610400: '咸阳市',
          610402: '秦都区',
          610403: '杨陵区',
          610404: '渭城区',
          610422: '三原县',
          610423: '泾阳县',
          610424: '乾县',
          610425: '礼泉县',
          610426: '永寿县',
          610427: '彬县',
          610428: '长武县',
          610429: '旬邑县',
          610430: '淳化县',
          610431: '武功县',
          610481: '兴平市',
          610482: '其它区',
          610500: '渭南市',
          610502: '临渭区',
          610521: '华县',
          610522: '潼关县',
          610523: '大荔县',
          610524: '合阳县',
          610525: '澄城县',
          610526: '蒲城县',
          610527: '白水县',
          610528: '富平县',
          610581: '韩城市',
          610582: '华阴市',
          610583: '其它区',
          610600: '延安市',
          610602: '宝塔区',
          610621: '延长县',
          610622: '延川县',
          610623: '子长县',
          610624: '安塞县',
          610625: '志丹县',
          610626: '吴起县',
          610627: '甘泉县',
          610628: '富县',
          610629: '洛川县',
          610630: '宜川县',
          610631: '黄龙县',
          610632: '黄陵县',
          610633: '其它区',
          610700: '汉中市',
          610702: '汉台区',
          610721: '南郑县',
          610722: '城固县',
          610723: '洋县',
          610724: '西乡县',
          610725: '勉县',
          610726: '宁强县',
          610727: '略阳县',
          610728: '镇巴县',
          610729: '留坝县',
          610730: '佛坪县',
          610731: '其它区',
          610800: '榆林市',
          610802: '榆阳区',
          610821: '神木县',
          610822: '府谷县',
          610823: '横山县',
          610824: '靖边县',
          610825: '定边县',
          610826: '绥德县',
          610827: '米脂县',
          610828: '佳县',
          610829: '吴堡县',
          610830: '清涧县',
          610831: '子洲县',
          610832: '其它区',
          610900: '安康市',
          610902: '汉滨区',
          610921: '汉阴县',
          610922: '石泉县',
          610923: '宁陕县',
          610924: '紫阳县',
          610925: '岚皋县',
          610926: '平利县',
          610927: '镇坪县',
          610928: '旬阳县',
          610929: '白河县',
          610930: '其它区',
          611e3: '商洛市',
          611002: '商州区',
          611021: '洛南县',
          611022: '丹凤县',
          611023: '商南县',
          611024: '山阳县',
          611025: '镇安县',
          611026: '柞水县',
          611027: '其它区',
          62e4: '甘肃省',
          620100: '兰州市',
          620102: '城关区',
          620103: '七里河区',
          620104: '西固区',
          620105: '安宁区',
          620111: '红古区',
          620121: '永登县',
          620122: '皋兰县',
          620123: '榆中县',
          620124: '其它区',
          620200: '嘉峪关市',
          620300: '金昌市',
          620302: '金川区',
          620321: '永昌县',
          620322: '其它区',
          620400: '白银市',
          620402: '白银区',
          620403: '平川区',
          620421: '靖远县',
          620422: '会宁县',
          620423: '景泰县',
          620424: '其它区',
          620500: '天水市',
          620502: '秦州区',
          620503: '麦积区',
          620521: '清水县',
          620522: '秦安县',
          620523: '甘谷县',
          620524: '武山县',
          620525: '张家川回族自治县',
          620526: '其它区',
          620600: '武威市',
          620602: '凉州区',
          620621: '民勤县',
          620622: '古浪县',
          620623: '天祝藏族自治县',
          620624: '其它区',
          620700: '张掖市',
          620702: '甘州区',
          620721: '肃南裕固族自治县',
          620722: '民乐县',
          620723: '临泽县',
          620724: '高台县',
          620725: '山丹县',
          620726: '其它区',
          620800: '平凉市',
          620802: '崆峒区',
          620821: '泾川县',
          620822: '灵台县',
          620823: '崇信县',
          620824: '华亭县',
          620825: '庄浪县',
          620826: '静宁县',
          620827: '其它区',
          620900: '酒泉市',
          620902: '肃州区',
          620921: '金塔县',
          620922: '瓜州县',
          620923: '肃北蒙古族自治县',
          620924: '阿克塞哈萨克族自治县',
          620981: '玉门市',
          620982: '敦煌市',
          620983: '其它区',
          621e3: '庆阳市',
          621002: '西峰区',
          621021: '庆城县',
          621022: '环县',
          621023: '华池县',
          621024: '合水县',
          621025: '正宁县',
          621026: '宁县',
          621027: '镇原县',
          621028: '其它区',
          621100: '定西市',
          621102: '安定区',
          621121: '通渭县',
          621122: '陇西县',
          621123: '渭源县',
          621124: '临洮县',
          621125: '漳县',
          621126: '岷县',
          621127: '其它区',
          621200: '陇南市',
          621202: '武都区',
          621221: '成县',
          621222: '文县',
          621223: '宕昌县',
          621224: '康县',
          621225: '西和县',
          621226: '礼县',
          621227: '徽县',
          621228: '两当县',
          621229: '其它区',
          622900: '临夏回族自治州',
          622901: '临夏市',
          622921: '临夏县',
          622922: '康乐县',
          622923: '永靖县',
          622924: '广河县',
          622925: '和政县',
          622926: '东乡族自治县',
          622927: '积石山保安族东乡族撒拉族自治县',
          622928: '其它区',
          623e3: '甘南藏族自治州',
          623001: '合作市',
          623021: '临潭县',
          623022: '卓尼县',
          623023: '舟曲县',
          623024: '迭部县',
          623025: '玛曲县',
          623026: '碌曲县',
          623027: '夏河县',
          623028: '其它区',
          63e4: '青海省',
          630100: '西宁市',
          630102: '城东区',
          630103: '城中区',
          630104: '城西区',
          630105: '城北区',
          630121: '大通回族土族自治县',
          630122: '湟中县',
          630123: '湟源县',
          630124: '其它区',
          632100: '海东市',
          632121: '平安县',
          632122: '民和回族土族自治县',
          632123: '乐都区',
          632126: '互助土族自治县',
          632127: '化隆回族自治县',
          632128: '循化撒拉族自治县',
          632129: '其它区',
          632200: '海北藏族自治州',
          632221: '门源回族自治县',
          632222: '祁连县',
          632223: '海晏县',
          632224: '刚察县',
          632225: '其它区',
          632300: '黄南藏族自治州',
          632321: '同仁县',
          632322: '尖扎县',
          632323: '泽库县',
          632324: '河南蒙古族自治县',
          632325: '其它区',
          632500: '海南藏族自治州',
          632521: '共和县',
          632522: '同德县',
          632523: '贵德县',
          632524: '兴海县',
          632525: '贵南县',
          632526: '其它区',
          632600: '果洛藏族自治州',
          632621: '玛沁县',
          632622: '班玛县',
          632623: '甘德县',
          632624: '达日县',
          632625: '久治县',
          632626: '玛多县',
          632627: '其它区',
          632700: '玉树藏族自治州',
          632721: '玉树市',
          632722: '杂多县',
          632723: '称多县',
          632724: '治多县',
          632725: '囊谦县',
          632726: '曲麻莱县',
          632727: '其它区',
          632800: '海西蒙古族藏族自治州',
          632801: '格尔木市',
          632802: '德令哈市',
          632821: '乌兰县',
          632822: '都兰县',
          632823: '天峻县',
          632824: '其它区',
          64e4: '宁夏回族自治区',
          640100: '银川市',
          640104: '兴庆区',
          640105: '西夏区',
          640106: '金凤区',
          640121: '永宁县',
          640122: '贺兰县',
          640181: '灵武市',
          640182: '其它区',
          640200: '石嘴山市',
          640202: '大武口区',
          640205: '惠农区',
          640221: '平罗县',
          640222: '其它区',
          640300: '吴忠市',
          640302: '利通区',
          640303: '红寺堡区',
          640323: '盐池县',
          640324: '同心县',
          640381: '青铜峡市',
          640382: '其它区',
          640400: '固原市',
          640402: '原州区',
          640422: '西吉县',
          640423: '隆德县',
          640424: '泾源县',
          640425: '彭阳县',
          640426: '其它区',
          640500: '中卫市',
          640502: '沙坡头区',
          640521: '中宁县',
          640522: '海原县',
          640523: '其它区',
          65e4: '新疆维吾尔自治区',
          650100: '乌鲁木齐市',
          650102: '天山区',
          650103: '沙依巴克区',
          650104: '新市区',
          650105: '水磨沟区',
          650106: '头屯河区',
          650107: '达坂城区',
          650109: '米东区',
          650121: '乌鲁木齐县',
          650122: '其它区',
          650200: '克拉玛依市',
          650202: '独山子区',
          650203: '克拉玛依区',
          650204: '白碱滩区',
          650205: '乌尔禾区',
          650206: '其它区',
          652100: '吐鲁番地区',
          652101: '吐鲁番市',
          652122: '鄯善县',
          652123: '托克逊县',
          652124: '其它区',
          652200: '哈密地区',
          652201: '哈密市',
          652222: '巴里坤哈萨克自治县',
          652223: '伊吾县',
          652224: '其它区',
          652300: '昌吉回族自治州',
          652301: '昌吉市',
          652302: '阜康市',
          652323: '呼图壁县',
          652324: '玛纳斯县',
          652325: '奇台县',
          652327: '吉木萨尔县',
          652328: '木垒哈萨克自治县',
          652329: '其它区',
          652700: '博尔塔拉蒙古自治州',
          652701: '博乐市',
          652702: '阿拉山口市',
          652722: '精河县',
          652723: '温泉县',
          652724: '其它区',
          652800: '巴音郭楞蒙古自治州',
          652801: '库尔勒市',
          652822: '轮台县',
          652823: '尉犁县',
          652824: '若羌县',
          652825: '且末县',
          652826: '焉耆回族自治县',
          652827: '和静县',
          652828: '和硕县',
          652829: '博湖县',
          652830: '其它区',
          652900: '阿克苏地区',
          652901: '阿克苏市',
          652922: '温宿县',
          652923: '库车县',
          652924: '沙雅县',
          652925: '新和县',
          652926: '拜城县',
          652927: '乌什县',
          652928: '阿瓦提县',
          652929: '柯坪县',
          652930: '其它区',
          653e3: '克孜勒苏柯尔克孜自治州',
          653001: '阿图什市',
          653022: '阿克陶县',
          653023: '阿合奇县',
          653024: '乌恰县',
          653025: '其它区',
          653100: '喀什地区',
          653101: '喀什市',
          653121: '疏附县',
          653122: '疏勒县',
          653123: '英吉沙县',
          653124: '泽普县',
          653125: '莎车县',
          653126: '叶城县',
          653127: '麦盖提县',
          653128: '岳普湖县',
          653129: '伽师县',
          653130: '巴楚县',
          653131: '塔什库尔干塔吉克自治县',
          653132: '其它区',
          653200: '和田地区',
          653201: '和田市',
          653221: '和田县',
          653222: '墨玉县',
          653223: '皮山县',
          653224: '洛浦县',
          653225: '策勒县',
          653226: '于田县',
          653227: '民丰县',
          653228: '其它区',
          654e3: '伊犁哈萨克自治州',
          654002: '伊宁市',
          654003: '奎屯市',
          654021: '伊宁县',
          654022: '察布查尔锡伯自治县',
          654023: '霍城县',
          654024: '巩留县',
          654025: '新源县',
          654026: '昭苏县',
          654027: '特克斯县',
          654028: '尼勒克县',
          654029: '其它区',
          654200: '塔城地区',
          654201: '塔城市',
          654202: '乌苏市',
          654221: '额敏县',
          654223: '沙湾县',
          654224: '托里县',
          654225: '裕民县',
          654226: '和布克赛尔蒙古自治县',
          654227: '其它区',
          654300: '阿勒泰地区',
          654301: '阿勒泰市',
          654321: '布尔津县',
          654322: '富蕴县',
          654323: '福海县',
          654324: '哈巴河县',
          654325: '青河县',
          654326: '吉木乃县',
          654327: '其它区',
          659001: '石河子市',
          659002: '阿拉尔市',
          659003: '图木舒克市',
          659004: '五家渠市',
          71e4: '台湾',
          710100: '台北市',
          710101: '中正区',
          710102: '大同区',
          710103: '中山区',
          710104: '松山区',
          710105: '大安区',
          710106: '万华区',
          710107: '信义区',
          710108: '士林区',
          710109: '北投区',
          710110: '内湖区',
          710111: '南港区',
          710112: '文山区',
          710113: '其它区',
          710200: '高雄市',
          710201: '新兴区',
          710202: '前金区',
          710203: '芩雅区',
          710204: '盐埕区',
          710205: '鼓山区',
          710206: '旗津区',
          710207: '前镇区',
          710208: '三民区',
          710209: '左营区',
          710210: '楠梓区',
          710211: '小港区',
          710212: '其它区',
          710241: '苓雅区',
          710242: '仁武区',
          710243: '大社区',
          710244: '冈山区',
          710245: '路竹区',
          710246: '阿莲区',
          710247: '田寮区',
          710248: '燕巢区',
          710249: '桥头区',
          710250: '梓官区',
          710251: '弥陀区',
          710252: '永安区',
          710253: '湖内区',
          710254: '凤山区',
          710255: '大寮区',
          710256: '林园区',
          710257: '鸟松区',
          710258: '大树区',
          710259: '旗山区',
          710260: '美浓区',
          710261: '六龟区',
          710262: '内门区',
          710263: '杉林区',
          710264: '甲仙区',
          710265: '桃源区',
          710266: '那玛夏区',
          710267: '茂林区',
          710268: '茄萣区',
          710300: '台南市',
          710301: '中西区',
          710302: '东区',
          710303: '南区',
          710304: '北区',
          710305: '安平区',
          710306: '安南区',
          710307: '其它区',
          710339: '永康区',
          710340: '归仁区',
          710341: '新化区',
          710342: '左镇区',
          710343: '玉井区',
          710344: '楠西区',
          710345: '南化区',
          710346: '仁德区',
          710347: '关庙区',
          710348: '龙崎区',
          710349: '官田区',
          710350: '麻豆区',
          710351: '佳里区',
          710352: '西港区',
          710353: '七股区',
          710354: '将军区',
          710355: '学甲区',
          710356: '北门区',
          710357: '新营区',
          710358: '后壁区',
          710359: '白河区',
          710360: '东山区',
          710361: '六甲区',
          710362: '下营区',
          710363: '柳营区',
          710364: '盐水区',
          710365: '善化区',
          710366: '大内区',
          710367: '山上区',
          710368: '新市区',
          710369: '安定区',
          710400: '台中市',
          710401: '中区',
          710402: '东区',
          710403: '南区',
          710404: '西区',
          710405: '北区',
          710406: '北屯区',
          710407: '西屯区',
          710408: '南屯区',
          710409: '其它区',
          710431: '太平区',
          710432: '大里区',
          710433: '雾峰区',
          710434: '乌日区',
          710435: '丰原区',
          710436: '后里区',
          710437: '石冈区',
          710438: '东势区',
          710439: '和平区',
          710440: '新社区',
          710441: '潭子区',
          710442: '大雅区',
          710443: '神冈区',
          710444: '大肚区',
          710445: '沙鹿区',
          710446: '龙井区',
          710447: '梧栖区',
          710448: '清水区',
          710449: '大甲区',
          710450: '外埔区',
          710451: '大安区',
          710500: '金门县',
          710507: '金沙镇',
          710508: '金湖镇',
          710509: '金宁乡',
          710510: '金城镇',
          710511: '烈屿乡',
          710512: '乌坵乡',
          710600: '南投县',
          710614: '南投市',
          710615: '中寮乡',
          710616: '草屯镇',
          710617: '国姓乡',
          710618: '埔里镇',
          710619: '仁爱乡',
          710620: '名间乡',
          710621: '集集镇',
          710622: '水里乡',
          710623: '鱼池乡',
          710624: '信义乡',
          710625: '竹山镇',
          710626: '鹿谷乡',
          710700: '基隆市',
          710701: '仁爱区',
          710702: '信义区',
          710703: '中正区',
          710704: '中山区',
          710705: '安乐区',
          710706: '暖暖区',
          710707: '七堵区',
          710708: '其它区',
          710800: '新竹市',
          710801: '东区',
          710802: '北区',
          710803: '香山区',
          710804: '其它区',
          710900: '嘉义市',
          710901: '东区',
          710902: '西区',
          710903: '其它区',
          711100: '新北市',
          711130: '万里区',
          711131: '金山区',
          711132: '板桥区',
          711133: '汐止区',
          711134: '深坑区',
          711135: '石碇区',
          711136: '瑞芳区',
          711137: '平溪区',
          711138: '双溪区',
          711139: '贡寮区',
          711140: '新店区',
          711141: '坪林区',
          711142: '乌来区',
          711143: '永和区',
          711144: '中和区',
          711145: '土城区',
          711146: '三峡区',
          711147: '树林区',
          711148: '莺歌区',
          711149: '三重区',
          711150: '新庄区',
          711151: '泰山区',
          711152: '林口区',
          711153: '芦洲区',
          711154: '五股区',
          711155: '八里区',
          711156: '淡水区',
          711157: '三芝区',
          711158: '石门区',
          711200: '宜兰县',
          711214: '宜兰市',
          711215: '头城镇',
          711216: '礁溪乡',
          711217: '壮围乡',
          711218: '员山乡',
          711219: '罗东镇',
          711220: '三星乡',
          711221: '大同乡',
          711222: '五结乡',
          711223: '冬山乡',
          711224: '苏澳镇',
          711225: '南澳乡',
          711226: '钓鱼台',
          711300: '新竹县',
          711314: '竹北市',
          711315: '湖口乡',
          711316: '新丰乡',
          711317: '新埔镇',
          711318: '关西镇',
          711319: '芎林乡',
          711320: '宝山乡',
          711321: '竹东镇',
          711322: '五峰乡',
          711323: '横山乡',
          711324: '尖石乡',
          711325: '北埔乡',
          711326: '峨眉乡',
          711400: '桃园县',
          711414: '中坜市',
          711415: '平镇市',
          711416: '龙潭乡',
          711417: '杨梅市',
          711418: '新屋乡',
          711419: '观音乡',
          711420: '桃园市',
          711421: '龟山乡',
          711422: '八德市',
          711423: '大溪镇',
          711424: '复兴乡',
          711425: '大园乡',
          711426: '芦竹乡',
          711500: '苗栗县',
          711519: '竹南镇',
          711520: '头份镇',
          711521: '三湾乡',
          711522: '南庄乡',
          711523: '狮潭乡',
          711524: '后龙镇',
          711525: '通霄镇',
          711526: '苑里镇',
          711527: '苗栗市',
          711528: '造桥乡',
          711529: '头屋乡',
          711530: '公馆乡',
          711531: '大湖乡',
          711532: '泰安乡',
          711533: '铜锣乡',
          711534: '三义乡',
          711535: '西湖乡',
          711536: '卓兰镇',
          711700: '彰化县',
          711727: '彰化市',
          711728: '芬园乡',
          711729: '花坛乡',
          711730: '秀水乡',
          711731: '鹿港镇',
          711732: '福兴乡',
          711733: '线西乡',
          711734: '和美镇',
          711735: '伸港乡',
          711736: '员林镇',
          711737: '社头乡',
          711738: '永靖乡',
          711739: '埔心乡',
          711740: '溪湖镇',
          711741: '大村乡',
          711742: '埔盐乡',
          711743: '田中镇',
          711744: '北斗镇',
          711745: '田尾乡',
          711746: '埤头乡',
          711747: '溪州乡',
          711748: '竹塘乡',
          711749: '二林镇',
          711750: '大城乡',
          711751: '芳苑乡',
          711752: '二水乡',
          711900: '嘉义县',
          711919: '番路乡',
          711920: '梅山乡',
          711921: '竹崎乡',
          711922: '阿里山乡',
          711923: '中埔乡',
          711924: '大埔乡',
          711925: '水上乡',
          711926: '鹿草乡',
          711927: '太保市',
          711928: '朴子市',
          711929: '东石乡',
          711930: '六脚乡',
          711931: '新港乡',
          711932: '民雄乡',
          711933: '大林镇',
          711934: '溪口乡',
          711935: '义竹乡',
          711936: '布袋镇',
          712100: '云林县',
          712121: '斗南镇',
          712122: '大埤乡',
          712123: '虎尾镇',
          712124: '土库镇',
          712125: '褒忠乡',
          712126: '东势乡',
          712127: '台西乡',
          712128: '仑背乡',
          712129: '麦寮乡',
          712130: '斗六市',
          712131: '林内乡',
          712132: '古坑乡',
          712133: '莿桐乡',
          712134: '西螺镇',
          712135: '二仑乡',
          712136: '北港镇',
          712137: '水林乡',
          712138: '口湖乡',
          712139: '四湖乡',
          712140: '元长乡',
          712400: '屏东县',
          712434: '屏东市',
          712435: '三地门乡',
          712436: '雾台乡',
          712437: '玛家乡',
          712438: '九如乡',
          712439: '里港乡',
          712440: '高树乡',
          712441: '盐埔乡',
          712442: '长治乡',
          712443: '麟洛乡',
          712444: '竹田乡',
          712445: '内埔乡',
          712446: '万丹乡',
          712447: '潮州镇',
          712448: '泰武乡',
          712449: '来义乡',
          712450: '万峦乡',
          712451: '崁顶乡',
          712452: '新埤乡',
          712453: '南州乡',
          712454: '林边乡',
          712455: '东港镇',
          712456: '琉球乡',
          712457: '佳冬乡',
          712458: '新园乡',
          712459: '枋寮乡',
          712460: '枋山乡',
          712461: '春日乡',
          712462: '狮子乡',
          712463: '车城乡',
          712464: '牡丹乡',
          712465: '恒春镇',
          712466: '满州乡',
          712500: '台东县',
          712517: '台东市',
          712518: '绿岛乡',
          712519: '兰屿乡',
          712520: '延平乡',
          712521: '卑南乡',
          712522: '鹿野乡',
          712523: '关山镇',
          712524: '海端乡',
          712525: '池上乡',
          712526: '东河乡',
          712527: '成功镇',
          712528: '长滨乡',
          712529: '金峰乡',
          712530: '大武乡',
          712531: '达仁乡',
          712532: '太麻里乡',
          712600: '花莲县',
          712615: '花莲市',
          712616: '新城乡',
          712617: '太鲁阁',
          712618: '秀林乡',
          712619: '吉安乡',
          712620: '寿丰乡',
          712621: '凤林镇',
          712622: '光复乡',
          712623: '丰滨乡',
          712624: '瑞穗乡',
          712625: '万荣乡',
          712626: '玉里镇',
          712627: '卓溪乡',
          712628: '富里乡',
          712700: '澎湖县',
          712707: '马公市',
          712708: '西屿乡',
          712709: '望安乡',
          712710: '七美乡',
          712711: '白沙乡',
          712712: '湖西乡',
          712800: '连江县',
          712805: '南竿乡',
          712806: '北竿乡',
          712807: '莒光乡',
          712808: '东引乡',
          81e4: '香港特别行政区',
          810100: '香港岛',
          810101: '中西区',
          810102: '湾仔',
          810103: '东区',
          810104: '南区',
          810200: '九龙',
          810201: '九龙城区',
          810202: '油尖旺区',
          810203: '深水埗区',
          810204: '黄大仙区',
          810205: '观塘区',
          810300: '新界',
          810301: '北区',
          810302: '大埔区',
          810303: '沙田区',
          810304: '西贡区',
          810305: '元朗区',
          810306: '屯门区',
          810307: '荃湾区',
          810308: '葵青区',
          810309: '离岛区',
          82e4: '澳门特别行政区',
          820100: '澳门半岛',
          820200: '离岛',
          99e4: '海外',
          990100: '海外',
        };
        function s(a) {
          for (var l = {}, f = 0, m; f < a.length; f++) (m = a[f]), !(!m || !m.id) && (l[m.id] = m);
          for (var v = [], I = 0; I < a.length; I++)
            if (((m = a[I]), !!m)) {
              if (m.pid == null && m.parentId == null) {
                v.push(m);
                continue;
              }
              var L = l[m.pid] || l[m.parentId];
              L && (L.children || (L.children = []), L.children.push(m));
            }
          return v;
        }
        var o = (function () {
          var a = [];
          for (var l in n) {
            var f =
              l.slice(2, 6) === '0000' ? void 0 : l.slice(4, 6) == '00' ? l.slice(0, 2) + '0000' : l.slice(0, 4) + '00';
            a.push({ id: l, pid: f, name: n[l] });
          }
          return s(a);
        })();
        r.exports = o;
      },
      function (r, e, n) {
        var s = n(18);
        r.exports = {
          d4: function () {
            return this.natural(1, 4);
          },
          d6: function () {
            return this.natural(1, 6);
          },
          d8: function () {
            return this.natural(1, 8);
          },
          d12: function () {
            return this.natural(1, 12);
          },
          d20: function () {
            return this.natural(1, 20);
          },
          d100: function () {
            return this.natural(1, 100);
          },
          guid: function () {
            var o = 'abcdefABCDEF1234567890',
              a =
                this.string(o, 8) +
                '-' +
                this.string(o, 4) +
                '-' +
                this.string(o, 4) +
                '-' +
                this.string(o, 4) +
                '-' +
                this.string(o, 12);
            return a;
          },
          uuid: function () {
            return this.guid();
          },
          id: function () {
            var o,
              a = 0,
              l = ['7', '9', '10', '5', '8', '4', '2', '1', '6', '3', '7', '9', '10', '5', '8', '4', '2'],
              f = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];
            o = this.pick(s).id + this.date('yyyyMMdd') + this.string('number', 3);
            for (var m = 0; m < o.length; m++) a += o[m] * l[m];
            return (o += f[a % 11]), o;
          },
          increment: (function () {
            var o = 0;
            return function (a) {
              return (o += +a || 1);
            };
          })(),
          inc: function (o) {
            return this.increment(o);
          },
        };
      },
      function (r, e, n) {
        var s = n(21),
          o = n(22);
        r.exports = { Parser: s, Handler: o };
      },
      function (r, e) {
        function n(hl) {
          (this.type = hl), (this.offset = n.offset()), (this.text = n.text());
        }
        function s(hl, fl) {
          n.call(this, 'alternate'), (this.left = hl), (this.right = fl);
        }
        function o(hl) {
          n.call(this, 'match'), (this.body = hl.filter(Boolean));
        }
        function a(hl, fl) {
          n.call(this, hl), (this.body = fl);
        }
        function l(hl) {
          a.call(this, 'capture-group'), (this.index = Wi[this.offset] || (Wi[this.offset] = tl++)), (this.body = hl);
        }
        function f(hl, fl) {
          n.call(this, 'quantified'), (this.body = hl), (this.quantifier = fl);
        }
        function m(hl, fl) {
          n.call(this, 'quantifier'), (this.min = hl), (this.max = fl), (this.greedy = !0);
        }
        function v(hl, fl) {
          n.call(this, 'charset'), (this.invert = hl), (this.body = fl);
        }
        function I(hl, fl) {
          n.call(this, 'range'), (this.start = hl), (this.end = fl);
        }
        function L(hl) {
          n.call(this, 'literal'), (this.body = hl), (this.escaped = this.body != this.text);
        }
        function V(hl) {
          n.call(this, 'unicode'), (this.code = hl.toUpperCase());
        }
        function se(hl) {
          n.call(this, 'hex'), (this.code = hl.toUpperCase());
        }
        function Ee(hl) {
          n.call(this, 'octal'), (this.code = hl.toUpperCase());
        }
        function ht(hl) {
          n.call(this, 'back-reference'), (this.code = hl.toUpperCase());
        }
        function ar(hl) {
          n.call(this, 'control-character'), (this.code = hl.toUpperCase());
        }
        var $i = (function () {
            function hl(Al, Fl) {
              function vl() {
                this.constructor = Al;
              }
              (vl.prototype = Fl.prototype), (Al.prototype = new vl());
            }
            function fl(Al, Fl, vl, kl, El) {
              function Jl(Kc, Il) {
                function Ll(Bl) {
                  function ql(Yl) {
                    return Yl.charCodeAt(0).toString(16).toUpperCase();
                  }
                  return Bl.replace(/\\/g, '\\\\')
                    .replace(/"/g, '\\"')
                    .replace(/\x08/g, '\\b')
                    .replace(/\t/g, '\\t')
                    .replace(/\n/g, '\\n')
                    .replace(/\f/g, '\\f')
                    .replace(/\r/g, '\\r')
                    .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (Yl) {
                      return '\\x0' + ql(Yl);
                    })
                    .replace(/[\x10-\x1F\x80-\xFF]/g, function (Yl) {
                      return '\\x' + ql(Yl);
                    })
                    .replace(/[\u0180-\u0FFF]/g, function (Yl) {
                      return '\\u0' + ql(Yl);
                    })
                    .replace(/[\u1080-\uFFFF]/g, function (Yl) {
                      return '\\u' + ql(Yl);
                    });
                }
                var Nl, Hl;
                switch (Kc.length) {
                  case 0:
                    Nl = 'end of input';
                    break;
                  case 1:
                    Nl = Kc[0];
                    break;
                  default:
                    Nl = Kc.slice(0, -1).join(', ') + ' or ' + Kc[Kc.length - 1];
                }
                return (Hl = Il ? '"' + Ll(Il) + '"' : 'end of input'), 'Expected ' + Nl + ' but ' + Hl + ' found.';
              }
              (this.expected = Al),
                (this.found = Fl),
                (this.offset = vl),
                (this.line = kl),
                (this.column = El),
                (this.name = 'SyntaxError'),
                (this.message = Jl(Al, Fl));
            }
            function dl(Al) {
              function Fl() {
                return Al.substring(oh, rl);
              }
              function vl() {
                return oh;
              }
              function kl(dn) {
                function Xi(_l, ah, Ch) {
                  var Uh, ad;
                  for (Uh = ah; Ch > Uh; Uh++)
                    (ad = Al.charAt(Uh)),
                      ad ===
                      `
`
                        ? (_l.seenCR || _l.line++, (_l.column = 1), (_l.seenCR = !1))
                        : ad === '\r' || ad === '\u2028' || ad === '\u2029'
                        ? (_l.line++, (_l.column = 1), (_l.seenCR = !0))
                        : (_l.column++, (_l.seenCR = !1));
                }
                return (
                  Vh !== dn &&
                    (Vh > dn && ((Vh = 0), (Ld = { line: 1, column: 1, seenCR: !1 })), Xi(Ld, Vh, dn), (Vh = dn)),
                  Ld
                );
              }
              function El(dn) {
                Zf > rl || (rl > Zf && ((Zf = rl), (e0 = [])), e0.push(dn));
              }
              function Jl(dn) {
                var Xi = 0;
                for (dn.sort(); Xi < dn.length; ) dn[Xi - 1] === dn[Xi] ? dn.splice(Xi, 1) : Xi++;
              }
              function Kc() {
                var dn, Xi, _l, ah, Ch;
                return (
                  (dn = rl),
                  (Xi = Il()),
                  Xi !== null
                    ? ((_l = rl),
                      Al.charCodeAt(rl) === 124 ? ((ah = t0), rl++) : ((ah = null), eh === 0 && El(Yd)),
                      ah !== null
                        ? ((Ch = Kc()), Ch !== null ? ((ah = [ah, Ch]), (_l = ah)) : ((rl = _l), (_l = uh)))
                        : ((rl = _l), (_l = uh)),
                      _l === null && (_l = dd),
                      _l !== null
                        ? ((oh = dn), (Xi = Xd(Xi, _l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function Il() {
                var dn, Xi, _l, ah, Ch;
                if (((dn = rl), (Xi = Nl()), Xi === null && (Xi = dd), Xi !== null))
                  if (
                    ((_l = rl), eh++, (ah = ql()), eh--, ah === null ? (_l = dd) : ((rl = _l), (_l = uh)), _l !== null)
                  ) {
                    for (ah = [], Ch = Bl(), Ch === null && (Ch = Ll()); Ch !== null; )
                      ah.push(Ch), (Ch = Bl()), Ch === null && (Ch = Ll());
                    ah !== null
                      ? ((Ch = Hl()),
                        Ch === null && (Ch = dd),
                        Ch !== null
                          ? ((oh = dn), (Xi = r0(Xi, ah, Ch)), Xi === null && (rl = dn), (dn = Xi))
                          : ((rl = dn), (dn = uh)))
                      : ((rl = dn), (dn = uh));
                  } else (rl = dn), (dn = uh);
                else (rl = dn), (dn = uh);
                return dn;
              }
              function Ll() {
                var dn;
                return (dn = zc()), dn === null && ((dn = Pl()), dn === null && (dn = Hc())), dn;
              }
              function Nl() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 94 ? ((Xi = jd), rl++) : ((Xi = null), eh === 0 && El(Ef)),
                  Xi !== null && ((oh = dn), (Xi = vd())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Hl() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 36 ? ((Xi = Qd), rl++) : ((Xi = null), eh === 0 && El(Sd)),
                  Xi !== null && ((oh = dn), (Xi = wd())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Bl() {
                var dn, Xi, _l;
                return (
                  (dn = rl),
                  (Xi = Ll()),
                  Xi !== null
                    ? ((_l = ql()),
                      _l !== null
                        ? ((oh = dn), (Xi = bf(Xi, _l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function ql() {
                var dn, Xi, _l;
                return (
                  eh++,
                  (dn = rl),
                  (Xi = Yl()),
                  Xi !== null
                    ? ((_l = wl()),
                      _l === null && (_l = dd),
                      _l !== null
                        ? ((oh = dn), (Xi = Vd(Xi, _l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  eh--,
                  dn === null && ((Xi = null), eh === 0 && El(Af)),
                  dn
                );
              }
              function Yl() {
                var dn;
                return (
                  (dn = ih()),
                  dn === null &&
                    ((dn = ph()),
                    dn === null &&
                      ((dn = gh()),
                      dn === null && ((dn = xh()), dn === null && ((dn = bh()), dn === null && (dn = Ah()))))),
                  dn
                );
              }
              function ih() {
                var dn, Xi, _l, ah, Ch, Uh;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 123 ? ((Xi = ld), rl++) : ((Xi = null), eh === 0 && El(fd)),
                  Xi !== null
                    ? ((_l = zl()),
                      _l !== null
                        ? (Al.charCodeAt(rl) === 44 ? ((ah = id), rl++) : ((ah = null), eh === 0 && El(Zd)),
                          ah !== null
                            ? ((Ch = zl()),
                              Ch !== null
                                ? (Al.charCodeAt(rl) === 125 ? ((Uh = vf), rl++) : ((Uh = null), eh === 0 && El(Sf)),
                                  Uh !== null
                                    ? ((oh = dn), (Xi = n0(_l, Ch)), Xi === null && (rl = dn), (dn = Xi))
                                    : ((rl = dn), (dn = uh)))
                                : ((rl = dn), (dn = uh)))
                            : ((rl = dn), (dn = uh)))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function ph() {
                var dn, Xi, _l, ah;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 123 ? ((Xi = ld), rl++) : ((Xi = null), eh === 0 && El(fd)),
                  Xi !== null
                    ? ((_l = zl()),
                      _l !== null
                        ? (Al.substr(rl, 2) === ef ? ((ah = ef), (rl += 2)) : ((ah = null), eh === 0 && El(Hd)),
                          ah !== null
                            ? ((oh = dn), (Xi = tf(_l)), Xi === null && (rl = dn), (dn = Xi))
                            : ((rl = dn), (dn = uh)))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function gh() {
                var dn, Xi, _l, ah;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 123 ? ((Xi = ld), rl++) : ((Xi = null), eh === 0 && El(fd)),
                  Xi !== null
                    ? ((_l = zl()),
                      _l !== null
                        ? (Al.charCodeAt(rl) === 125 ? ((ah = vf), rl++) : ((ah = null), eh === 0 && El(Sf)),
                          ah !== null
                            ? ((oh = dn), (Xi = _h(_l)), Xi === null && (rl = dn), (dn = Xi))
                            : ((rl = dn), (dn = uh)))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function xh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 43 ? ((Xi = Xh), rl++) : ((Xi = null), eh === 0 && El(ud)),
                  Xi !== null && ((oh = dn), (Xi = rf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function bh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 42 ? ((Xi = wf), rl++) : ((Xi = null), eh === 0 && El(i0)),
                  Xi !== null && ((oh = dn), (Xi = nf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Ah() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 63 ? ((Xi = sd), rl++) : ((Xi = null), eh === 0 && El(Fd)),
                  Xi !== null && ((oh = dn), (Xi = Jh())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function wl() {
                var dn;
                return Al.charCodeAt(rl) === 63 ? ((dn = sd), rl++) : ((dn = null), eh === 0 && El(Fd)), dn;
              }
              function zl() {
                var dn, Xi, _l;
                if (
                  ((dn = rl),
                  (Xi = []),
                  Qh.test(Al.charAt(rl)) ? ((_l = Al.charAt(rl)), rl++) : ((_l = null), eh === 0 && El(Ff)),
                  _l !== null)
                )
                  for (; _l !== null; )
                    Xi.push(_l),
                      Qh.test(Al.charAt(rl)) ? ((_l = Al.charAt(rl)), rl++) : ((_l = null), eh === 0 && El(Ff));
                else Xi = uh;
                return Xi !== null && ((oh = dn), (Xi = s0(Xi))), Xi === null && (rl = dn), (dn = Xi), dn;
              }
              function zc() {
                var dn, Xi, _l, ah;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 40 ? ((Xi = md), rl++) : ((Xi = null), eh === 0 && El(sf)),
                  Xi !== null
                    ? ((_l = gl()),
                      _l === null && ((_l = bl()), _l === null && ((_l = Dh()), _l === null && (_l = Ul()))),
                      _l !== null
                        ? (Al.charCodeAt(rl) === 41 ? ((ah = Tf), rl++) : ((ah = null), eh === 0 && El(o0)),
                          ah !== null
                            ? ((oh = dn), (Xi = kf(_l)), Xi === null && (rl = dn), (dn = Xi))
                            : ((rl = dn), (dn = uh)))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function Ul() {
                var dn, Xi;
                return (
                  (dn = rl),
                  (Xi = Kc()),
                  Xi !== null && ((oh = dn), (Xi = a0(Xi))),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Dh() {
                var dn, Xi, _l;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === of ? ((Xi = of), (rl += 2)) : ((Xi = null), eh === 0 && El(gd)),
                  Xi !== null
                    ? ((_l = Kc()),
                      _l !== null
                        ? ((oh = dn), (Xi = af(_l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function gl() {
                var dn, Xi, _l;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Td ? ((Xi = Td), (rl += 2)) : ((Xi = null), eh === 0 && El(Pf)),
                  Xi !== null
                    ? ((_l = Kc()),
                      _l !== null
                        ? ((oh = dn), (Xi = yd(_l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function bl() {
                var dn, Xi, _l;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === cd ? ((Xi = cd), (rl += 2)) : ((Xi = null), eh === 0 && El(kd)),
                  Xi !== null
                    ? ((_l = Kc()),
                      _l !== null
                        ? ((oh = dn), (Xi = l0(_l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function Pl() {
                var dn, Xi, _l, ah, Ch;
                if (
                  (eh++,
                  (dn = rl),
                  Al.charCodeAt(rl) === 91 ? ((Xi = Pd), rl++) : ((Xi = null), eh === 0 && El(Dd)),
                  Xi !== null)
                )
                  if (
                    (Al.charCodeAt(rl) === 94 ? ((_l = jd), rl++) : ((_l = null), eh === 0 && El(Ef)),
                    _l === null && (_l = dd),
                    _l !== null)
                  ) {
                    for (ah = [], Ch = Rl(), Ch === null && (Ch = Wl()); Ch !== null; )
                      ah.push(Ch), (Ch = Rl()), Ch === null && (Ch = Wl());
                    ah !== null
                      ? (Al.charCodeAt(rl) === 93 ? ((Ch = Bf), rl++) : ((Ch = null), eh === 0 && El(ed)),
                        Ch !== null
                          ? ((oh = dn), (Xi = Nf(_l, ah)), Xi === null && (rl = dn), (dn = Xi))
                          : ((rl = dn), (dn = uh)))
                      : ((rl = dn), (dn = uh));
                  } else (rl = dn), (dn = uh);
                else (rl = dn), (dn = uh);
                return eh--, dn === null && ((Xi = null), eh === 0 && El(Zh)), dn;
              }
              function Rl() {
                var dn, Xi, _l, ah;
                return (
                  eh++,
                  (dn = rl),
                  (Xi = Wl()),
                  Xi !== null
                    ? (Al.charCodeAt(rl) === 45 ? ((_l = Mf), rl++) : ((_l = null), eh === 0 && El(hh)),
                      _l !== null
                        ? ((ah = Wl()),
                          ah !== null
                            ? ((oh = dn), (Xi = lf(Xi, ah)), Xi === null && (rl = dn), (dn = Xi))
                            : ((rl = dn), (dn = uh)))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  eh--,
                  dn === null && ((Xi = null), eh === 0 && El(If)),
                  dn
                );
              }
              function Wl() {
                var dn;
                return eh++, (dn = th()), dn === null && (dn = Kl()), eh--, dn === null && eh === 0 && El(uf), dn;
              }
              function Kl() {
                var dn, Xi;
                return (
                  (dn = rl),
                  u0.test(Al.charAt(rl)) ? ((Xi = Al.charAt(rl)), rl++) : ((Xi = null), eh === 0 && El(Of)),
                  Xi !== null && ((oh = dn), (Xi = cf(Xi))),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function th() {
                var dn;
                return (
                  (dn = lh()),
                  dn === null &&
                    ((dn = Hh()),
                    dn === null &&
                      ((dn = yh()),
                      dn === null &&
                        ((dn = kh()),
                        dn === null &&
                          ((dn = Sh()),
                          dn === null &&
                            ((dn = Fh()),
                            dn === null &&
                              ((dn = Lh()),
                              dn === null &&
                                ((dn = Yh()),
                                dn === null &&
                                  ((dn = td()),
                                  dn === null &&
                                    ((dn = rd()),
                                    dn === null &&
                                      ((dn = nd()),
                                      dn === null &&
                                        ((dn = $h()),
                                        dn === null &&
                                          ((dn = Rh()),
                                          dn === null &&
                                            ((dn = Ad()),
                                            dn === null &&
                                              ((dn = $d()),
                                              dn === null &&
                                                ((dn = qd()),
                                                dn === null && ((dn = Kd()), dn === null && (dn = Jd()))))))))))))))))),
                  dn
                );
              }
              function Hc() {
                var dn;
                return (dn = Qc()), dn === null && ((dn = ch()), dn === null && (dn = Gl())), dn;
              }
              function Qc() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 46 ? ((Xi = c0), rl++) : ((Xi = null), eh === 0 && El(jh)),
                  Xi !== null && ((oh = dn), (Xi = od())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Gl() {
                var dn, Xi;
                return (
                  eh++,
                  (dn = rl),
                  h0.test(Al.charAt(rl)) ? ((Xi = Al.charAt(rl)), rl++) : ((Xi = null), eh === 0 && El(p0)),
                  Xi !== null && ((oh = dn), (Xi = cf(Xi))),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  eh--,
                  dn === null && ((Xi = null), eh === 0 && El(xd)),
                  dn
                );
              }
              function ch() {
                var dn;
                return (
                  (dn = dh()),
                  dn === null &&
                    ((dn = mh()),
                    dn === null &&
                      ((dn = Hh()),
                      dn === null &&
                        ((dn = yh()),
                        dn === null &&
                          ((dn = kh()),
                          dn === null &&
                            ((dn = Sh()),
                            dn === null &&
                              ((dn = Fh()),
                              dn === null &&
                                ((dn = Lh()),
                                dn === null &&
                                  ((dn = Yh()),
                                  dn === null &&
                                    ((dn = td()),
                                    dn === null &&
                                      ((dn = rd()),
                                      dn === null &&
                                        ((dn = nd()),
                                        dn === null &&
                                          ((dn = $h()),
                                          dn === null &&
                                            ((dn = Rh()),
                                            dn === null &&
                                              ((dn = Wh()),
                                              dn === null &&
                                                ((dn = Ad()),
                                                dn === null &&
                                                  ((dn = $d()),
                                                  dn === null &&
                                                    ((dn = qd()),
                                                    dn === null &&
                                                      ((dn = Kd()), dn === null && (dn = Jd()))))))))))))))))))),
                  dn
                );
              }
              function lh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Bd ? ((Xi = Bd), (rl += 2)) : ((Xi = null), eh === 0 && El(Lf)),
                  Xi !== null && ((oh = dn), (Xi = $f())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function dh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Bd ? ((Xi = Bd), (rl += 2)) : ((Xi = null), eh === 0 && El(Lf)),
                  Xi !== null && ((oh = dn), (Xi = d0())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function mh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Rf ? ((Xi = Rf), (rl += 2)) : ((Xi = null), eh === 0 && El(f0)),
                  Xi !== null && ((oh = dn), (Xi = _f())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function yh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === sh ? ((Xi = sh), (rl += 2)) : ((Xi = null), eh === 0 && El(m0)),
                  Xi !== null && ((oh = dn), (Xi = hf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function kh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === pf ? ((Xi = pf), (rl += 2)) : ((Xi = null), eh === 0 && El(jf)),
                  Xi !== null && ((oh = dn), (Xi = Vf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Sh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === df ? ((Xi = df), (rl += 2)) : ((Xi = null), eh === 0 && El(zd)),
                  Xi !== null && ((oh = dn), (Xi = Hf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Fh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === ff ? ((Xi = ff), (rl += 2)) : ((Xi = null), eh === 0 && El(zf)),
                  Xi !== null && ((oh = dn), (Xi = g0())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Lh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Wf ? ((Xi = Wf), (rl += 2)) : ((Xi = null), eh === 0 && El(Mh)),
                  Xi !== null && ((oh = dn), (Xi = hd())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Yh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === mf ? ((Xi = mf), (rl += 2)) : ((Xi = null), eh === 0 && El(Uf)),
                  Xi !== null && ((oh = dn), (Xi = qf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function td() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Kf ? ((Xi = Kf), (rl += 2)) : ((Xi = null), eh === 0 && El(Wd)),
                  Xi !== null && ((oh = dn), (Xi = y0())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function rd() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Ud ? ((Xi = Ud), (rl += 2)) : ((Xi = null), eh === 0 && El(D0)),
                  Xi !== null && ((oh = dn), (Xi = x0())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function nd() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Nd ? ((Xi = Nd), (rl += 2)) : ((Xi = null), eh === 0 && El(C0)),
                  Xi !== null && ((oh = dn), (Xi = Jf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function $h() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Id ? ((Xi = Id), (rl += 2)) : ((Xi = null), eh === 0 && El(E0)),
                  Xi !== null && ((oh = dn), (Xi = Gf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Rh() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === gf ? ((Xi = gf), (rl += 2)) : ((Xi = null), eh === 0 && El(Cd)),
                  Xi !== null && ((oh = dn), (Xi = Yf())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Hh() {
                var dn, Xi, _l;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === Xf ? ((Xi = Xf), (rl += 2)) : ((Xi = null), eh === 0 && El(b0)),
                  Xi !== null
                    ? (Al.length > rl ? ((_l = Al.charAt(rl)), rl++) : ((_l = null), eh === 0 && El(Md)),
                      _l !== null
                        ? ((oh = dn), (Xi = Od(_l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function Wh() {
                var dn, Xi, _l;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 92 ? ((Xi = yf), rl++) : ((Xi = null), eh === 0 && El(Qf)),
                  Xi !== null
                    ? (g.test(Al.charAt(rl)) ? ((_l = Al.charAt(rl)), rl++) : ((_l = null), eh === 0 && El(u)),
                      _l !== null
                        ? ((oh = dn), (Xi = N(_l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              function Ad() {
                var dn, Xi, _l, ah;
                if (
                  ((dn = rl),
                  Al.substr(rl, 2) === _ ? ((Xi = _), (rl += 2)) : ((Xi = null), eh === 0 && El(Be)),
                  Xi !== null)
                ) {
                  if (
                    ((_l = []),
                    Cn.test(Al.charAt(rl)) ? ((ah = Al.charAt(rl)), rl++) : ((ah = null), eh === 0 && El(Yi)),
                    ah !== null)
                  )
                    for (; ah !== null; )
                      _l.push(ah),
                        Cn.test(Al.charAt(rl)) ? ((ah = Al.charAt(rl)), rl++) : ((ah = null), eh === 0 && El(Yi));
                  else _l = uh;
                  _l !== null
                    ? ((oh = dn), (Xi = nl(_l)), Xi === null && (rl = dn), (dn = Xi))
                    : ((rl = dn), (dn = uh));
                } else (rl = dn), (dn = uh);
                return dn;
              }
              function $d() {
                var dn, Xi, _l, ah;
                if (
                  ((dn = rl),
                  Al.substr(rl, 2) === xl ? ((Xi = xl), (rl += 2)) : ((Xi = null), eh === 0 && El(Dl)),
                  Xi !== null)
                ) {
                  if (
                    ((_l = []),
                    jl.test(Al.charAt(rl)) ? ((ah = Al.charAt(rl)), rl++) : ((ah = null), eh === 0 && El(Zl)),
                    ah !== null)
                  )
                    for (; ah !== null; )
                      _l.push(ah),
                        jl.test(Al.charAt(rl)) ? ((ah = Al.charAt(rl)), rl++) : ((ah = null), eh === 0 && El(Zl));
                  else _l = uh;
                  _l !== null
                    ? ((oh = dn), (Xi = Zc(_l)), Xi === null && (rl = dn), (dn = Xi))
                    : ((rl = dn), (dn = uh));
                } else (rl = dn), (dn = uh);
                return dn;
              }
              function qd() {
                var dn, Xi, _l, ah;
                if (
                  ((dn = rl),
                  Al.substr(rl, 2) === rh ? ((Xi = rh), (rl += 2)) : ((Xi = null), eh === 0 && El(Ph)),
                  Xi !== null)
                ) {
                  if (
                    ((_l = []),
                    jl.test(Al.charAt(rl)) ? ((ah = Al.charAt(rl)), rl++) : ((ah = null), eh === 0 && El(Zl)),
                    ah !== null)
                  )
                    for (; ah !== null; )
                      _l.push(ah),
                        jl.test(Al.charAt(rl)) ? ((ah = Al.charAt(rl)), rl++) : ((ah = null), eh === 0 && El(Zl));
                  else _l = uh;
                  _l !== null
                    ? ((oh = dn), (Xi = Th(_l)), Xi === null && (rl = dn), (dn = Xi))
                    : ((rl = dn), (dn = uh));
                } else (rl = dn), (dn = uh);
                return dn;
              }
              function Kd() {
                var dn, Xi;
                return (
                  (dn = rl),
                  Al.substr(rl, 2) === _ ? ((Xi = _), (rl += 2)) : ((Xi = null), eh === 0 && El(Be)),
                  Xi !== null && ((oh = dn), (Xi = Oh())),
                  Xi === null && (rl = dn),
                  (dn = Xi),
                  dn
                );
              }
              function Jd() {
                var dn, Xi, _l;
                return (
                  (dn = rl),
                  Al.charCodeAt(rl) === 92 ? ((Xi = yf), rl++) : ((Xi = null), eh === 0 && El(Qf)),
                  Xi !== null
                    ? (Al.length > rl ? ((_l = Al.charAt(rl)), rl++) : ((_l = null), eh === 0 && El(Md)),
                      _l !== null
                        ? ((oh = dn), (Xi = cf(_l)), Xi === null && (rl = dn), (dn = Xi))
                        : ((rl = dn), (dn = uh)))
                    : ((rl = dn), (dn = uh)),
                  dn
                );
              }
              var Rd,
                Ih = arguments.length > 1 ? arguments[1] : {},
                Gd = { regexp: Kc },
                _d = Kc,
                uh = null,
                dd = '',
                t0 = '|',
                Yd = '"|"',
                Xd = function (dn, Xi) {
                  return Xi ? new s(dn, Xi[1]) : dn;
                },
                r0 = function (dn, Xi, _l) {
                  return new o([dn].concat(Xi).concat([_l]));
                },
                jd = '^',
                Ef = '"^"',
                vd = function () {
                  return new n('start');
                },
                Qd = '$',
                Sd = '"$"',
                wd = function () {
                  return new n('end');
                },
                bf = function (dn, Xi) {
                  return new f(dn, Xi);
                },
                Af = 'Quantifier',
                Vd = function (dn, Xi) {
                  return Xi && (dn.greedy = !1), dn;
                },
                ld = '{',
                fd = '"{"',
                id = ',',
                Zd = '","',
                vf = '}',
                Sf = '"}"',
                n0 = function (dn, Xi) {
                  return new m(dn, Xi);
                },
                ef = ',}',
                Hd = '",}"',
                tf = function (dn) {
                  return new m(dn, 1 / 0);
                },
                _h = function (dn) {
                  return new m(dn, dn);
                },
                Xh = '+',
                ud = '"+"',
                rf = function () {
                  return new m(1, 1 / 0);
                },
                wf = '*',
                i0 = '"*"',
                nf = function () {
                  return new m(0, 1 / 0);
                },
                sd = '?',
                Fd = '"?"',
                Jh = function () {
                  return new m(0, 1);
                },
                Qh = /^[0-9]/,
                Ff = '[0-9]',
                s0 = function (dn) {
                  return +dn.join('');
                },
                md = '(',
                sf = '"("',
                Tf = ')',
                o0 = '")"',
                kf = function (dn) {
                  return dn;
                },
                a0 = function (dn) {
                  return new l(dn);
                },
                of = '?:',
                gd = '"?:"',
                af = function (dn) {
                  return new a('non-capture-group', dn);
                },
                Td = '?=',
                Pf = '"?="',
                yd = function (dn) {
                  return new a('positive-lookahead', dn);
                },
                cd = '?!',
                kd = '"?!"',
                l0 = function (dn) {
                  return new a('negative-lookahead', dn);
                },
                Zh = 'CharacterSet',
                Pd = '[',
                Dd = '"["',
                Bf = ']',
                ed = '"]"',
                Nf = function (dn, Xi) {
                  return new v(!!dn, Xi);
                },
                If = 'CharacterRange',
                Mf = '-',
                hh = '"-"',
                lf = function (dn, Xi) {
                  return new I(dn, Xi);
                },
                uf = 'Character',
                u0 = /^[^\\\]]/,
                Of = '[^\\\\\\]]',
                cf = function (dn) {
                  return new L(dn);
                },
                c0 = '.',
                jh = '"."',
                od = function () {
                  return new n('any-character');
                },
                xd = 'Literal',
                h0 = /^[^|\\\/.[()?+*$\^]/,
                p0 = '[^|\\\\\\/.[()?+*$\\^]',
                Bd = '\\b',
                Lf = '"\\\\b"',
                $f = function () {
                  return new n('backspace');
                },
                d0 = function () {
                  return new n('word-boundary');
                },
                Rf = '\\B',
                f0 = '"\\\\B"',
                _f = function () {
                  return new n('non-word-boundary');
                },
                sh = '\\d',
                m0 = '"\\\\d"',
                hf = function () {
                  return new n('digit');
                },
                pf = '\\D',
                jf = '"\\\\D"',
                Vf = function () {
                  return new n('non-digit');
                },
                df = '\\f',
                zd = '"\\\\f"',
                Hf = function () {
                  return new n('form-feed');
                },
                ff = '\\n',
                zf = '"\\\\n"',
                g0 = function () {
                  return new n('line-feed');
                },
                Wf = '\\r',
                Mh = '"\\\\r"',
                hd = function () {
                  return new n('carriage-return');
                },
                mf = '\\s',
                Uf = '"\\\\s"',
                qf = function () {
                  return new n('white-space');
                },
                Kf = '\\S',
                Wd = '"\\\\S"',
                y0 = function () {
                  return new n('non-white-space');
                },
                Ud = '\\t',
                D0 = '"\\\\t"',
                x0 = function () {
                  return new n('tab');
                },
                Nd = '\\v',
                C0 = '"\\\\v"',
                Jf = function () {
                  return new n('vertical-tab');
                },
                Id = '\\w',
                E0 = '"\\\\w"',
                Gf = function () {
                  return new n('word');
                },
                gf = '\\W',
                Cd = '"\\\\W"',
                Yf = function () {
                  return new n('non-word');
                },
                Xf = '\\c',
                b0 = '"\\\\c"',
                Md = 'any character',
                Od = function (dn) {
                  return new ar(dn);
                },
                yf = '\\',
                Qf = '"\\\\"',
                g = /^[1-9]/,
                u = '[1-9]',
                N = function (dn) {
                  return new ht(dn);
                },
                _ = '\\0',
                Be = '"\\\\0"',
                Cn = /^[0-7]/,
                Yi = '[0-7]',
                nl = function (dn) {
                  return new Ee(dn.join(''));
                },
                xl = '\\x',
                Dl = '"\\\\x"',
                jl = /^[0-9a-fA-F]/,
                Zl = '[0-9a-fA-F]',
                Zc = function (dn) {
                  return new se(dn.join(''));
                },
                rh = '\\u',
                Ph = '"\\\\u"',
                Th = function (dn) {
                  return new V(dn.join(''));
                },
                Oh = function () {
                  return new n('null-character');
                },
                rl = 0,
                oh = 0,
                Vh = 0,
                Ld = { line: 1, column: 1, seenCR: !1 },
                Zf = 0,
                e0 = [],
                eh = 0;
              if ('startRule' in Ih) {
                if (!(Ih.startRule in Gd)) throw new Error(`Can't start parsing from rule "` + Ih.startRule + '".');
                _d = Gd[Ih.startRule];
              }
              if (((n.offset = vl), (n.text = Fl), (Rd = _d()), Rd !== null && rl === Al.length)) return Rd;
              throw (
                (Jl(e0),
                (oh = Math.max(rl, Zf)),
                new fl(e0, oh < Al.length ? Al.charAt(oh) : null, oh, kl(oh).line, kl(oh).column))
              );
            }
            return hl(fl, Error), { SyntaxError: fl, parse: dl };
          })(),
          tl = 1,
          Wi = {};
        r.exports = $i;
      },
      function (r, e, n) {
        var s = n(3),
          o = n(5),
          a = { extend: s.extend },
          l = se(97, 122),
          f = se(65, 90),
          m = se(48, 57),
          v = se(32, 47) + se(58, 64) + se(91, 96) + se(123, 126),
          I = se(32, 126),
          L = ` \f
\r	\v \u2028\u2029`,
          V = {
            '\\w': l + f + m + '_',
            '\\W': v.replace('_', ''),
            '\\s': L,
            '\\S': (function () {
              for (var Ee = I, ht = 0; ht < L.length; ht++) Ee = Ee.replace(L[ht], '');
              return Ee;
            })(),
            '\\d': m,
            '\\D': l + f + v,
          };
        function se(Ee, ht) {
          for (var ar = '', $i = Ee; $i <= ht; $i++) ar += String.fromCharCode($i);
          return ar;
        }
        (a.gen = function (Ee, ht, ar) {
          return (ar = ar || { guid: 1 }), a[Ee.type] ? a[Ee.type](Ee, ht, ar) : a.token(Ee, ht, ar);
        }),
          a.extend({
            'token': function (Ee, ht, ar) {
              switch (Ee.type) {
                case 'start':
                case 'end':
                  return '';
                case 'any-character':
                  return o.character();
                case 'backspace':
                  return '';
                case 'word-boundary':
                  return '';
                case 'non-word-boundary':
                  break;
                case 'digit':
                  return o.pick(m.split(''));
                case 'non-digit':
                  return o.pick((l + f + v).split(''));
                case 'form-feed':
                  break;
                case 'line-feed':
                  return Ee.body || Ee.text;
                case 'carriage-return':
                  break;
                case 'white-space':
                  return o.pick(L.split(''));
                case 'non-white-space':
                  return o.pick((l + f + m).split(''));
                case 'tab':
                  break;
                case 'vertical-tab':
                  break;
                case 'word':
                  return o.pick((l + f + m).split(''));
                case 'non-word':
                  return o.pick(v.replace('_', '').split(''));
              }
              return Ee.body || Ee.text;
            },
            'alternate': function (Ee, ht, ar) {
              return this.gen(o.boolean() ? Ee.left : Ee.right, ht, ar);
            },
            'match': function (Ee, ht, ar) {
              ht = '';
              for (var $i = 0; $i < Ee.body.length; $i++) ht += this.gen(Ee.body[$i], ht, ar);
              return ht;
            },
            'capture-group': function (Ee, ht, ar) {
              return (ht = this.gen(Ee.body, ht, ar)), (ar[ar.guid++] = ht), ht;
            },
            'non-capture-group': function (Ee, ht, ar) {
              return this.gen(Ee.body, ht, ar);
            },
            'positive-lookahead': function (Ee, ht, ar) {
              return this.gen(Ee.body, ht, ar);
            },
            'negative-lookahead': function (Ee, ht, ar) {
              return '';
            },
            'quantified': function (Ee, ht, ar) {
              ht = '';
              for (var $i = this.quantifier(Ee.quantifier), tl = 0; tl < $i; tl++) ht += this.gen(Ee.body, ht, ar);
              return ht;
            },
            'quantifier': function (Ee, ht, ar) {
              var $i = Math.max(Ee.min, 0),
                tl = isFinite(Ee.max) ? Ee.max : $i + o.integer(3, 7);
              return o.integer($i, tl);
            },
            'charset': function (Ee, ht, ar) {
              if (Ee.invert) return this['invert-charset'](Ee, ht, ar);
              var $i = o.pick(Ee.body);
              return this.gen($i, ht, ar);
            },
            'invert-charset': function (Ee, ht, ar) {
              for (var $i = I, tl = 0, Wi; tl < Ee.body.length; tl++)
                switch (((Wi = Ee.body[tl]), Wi.type)) {
                  case 'literal':
                    $i = $i.replace(Wi.body, '');
                    break;
                  case 'range':
                    for (
                      var hl = this.gen(Wi.start, ht, ar).charCodeAt(),
                        fl = this.gen(Wi.end, ht, ar).charCodeAt(),
                        dl = hl;
                      dl <= fl;
                      dl++
                    )
                      $i = $i.replace(String.fromCharCode(dl), '');
                  default:
                    var Al = V[Wi.text];
                    if (Al) for (var Fl = 0; Fl <= Al.length; Fl++) $i = $i.replace(Al[Fl], '');
                }
              return o.pick($i.split(''));
            },
            'range': function (Ee, ht, ar) {
              var $i = this.gen(Ee.start, ht, ar).charCodeAt(),
                tl = this.gen(Ee.end, ht, ar).charCodeAt();
              return String.fromCharCode(o.integer($i, tl));
            },
            'literal': function (Ee, ht, ar) {
              return Ee.escaped ? Ee.body : Ee.text;
            },
            'unicode': function (Ee, ht, ar) {
              return String.fromCharCode(parseInt(Ee.code, 16));
            },
            'hex': function (Ee, ht, ar) {
              return String.fromCharCode(parseInt(Ee.code, 16));
            },
            'octal': function (Ee, ht, ar) {
              return String.fromCharCode(parseInt(Ee.code, 8));
            },
            'back-reference': function (Ee, ht, ar) {
              return ar[Ee.code] || '';
            },
            'CONTROL_CHARACTER_MAP': (function () {
              for (
                var Ee = '@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _'.split(' '),
                  ht = `\0       \x07 \b 	 
 \v \f \r              \x1B    `.split(' '),
                  ar = {},
                  $i = 0;
                $i < Ee.length;
                $i++
              )
                ar[Ee[$i]] = ht[$i];
              return ar;
            })(),
            'control-character': function (Ee, ht, ar) {
              return this.CONTROL_CHARACTER_MAP[Ee.code];
            },
          }),
          (r.exports = a);
      },
      function (r, e, n) {
        r.exports = n(24);
      },
      function (r, e, n) {
        var s = n(2),
          o = n(3),
          a = n(4);
        function l(f, m, v) {
          v = v || [];
          var I = {
            name: typeof m == 'string' ? m.replace(s.RE_KEY, '$1') : m,
            template: f,
            type: o.type(f),
            rule: a.parse(m),
          };
          switch (((I.path = v.slice(0)), I.path.push(m === void 0 ? 'ROOT' : I.name), I.type)) {
            case 'array':
              (I.items = []),
                o.each(f, function (L, V) {
                  I.items.push(l(L, V, I.path));
                });
              break;
            case 'object':
              (I.properties = []),
                o.each(f, function (L, V) {
                  I.properties.push(l(L, V, I.path));
                });
              break;
          }
          return I;
        }
        r.exports = l;
      },
      function (r, e, n) {
        r.exports = n(26);
      },
      function (r, e, n) {
        var s = n(2),
          o = n(3),
          a = n(23);
        function l(v, I) {
          for (var L = a(v), V = f.diff(L, I), se = 0; se < V.length; se++);
          return V;
        }
        var f = {
            diff: function (I, L, V) {
              var se = [];
              return (
                this.name(I, L, V, se) &&
                  this.type(I, L, V, se) &&
                  (this.value(I, L, V, se), this.properties(I, L, V, se), this.items(I, L, V, se)),
                se
              );
            },
            name: function (v, I, L, V) {
              var se = V.length;
              return m.equal('name', v.path, L + '', v.name + '', V), V.length === se;
            },
            type: function (v, I, L, V) {
              var se = V.length;
              switch (v.type) {
                case 'string':
                  if (v.template.match(s.RE_PLACEHOLDER)) return !0;
                  break;
                case 'array':
                  if (
                    v.rule.parameters &&
                    ((v.rule.min !== void 0 && v.rule.max === void 0 && v.rule.count === 1) || v.rule.parameters[2])
                  )
                    return !0;
                  break;
                case 'function':
                  return !0;
              }
              return m.equal('type', v.path, o.type(I), v.type, V), V.length === se;
            },
            value: function (v, I, L, V) {
              var se = V.length,
                Ee = v.rule,
                ht = v.type;
              if (ht === 'object' || ht === 'array' || ht === 'function') return !0;
              if (!Ee.parameters) {
                switch (ht) {
                  case 'regexp':
                    return m.match('value', v.path, I, v.template, V), V.length === se;
                  case 'string':
                    if (v.template.match(s.RE_PLACEHOLDER)) return V.length === se;
                    break;
                }
                return m.equal('value', v.path, I, v.template, V), V.length === se;
              }
              var ar;
              switch (ht) {
                case 'number':
                  var $i = (I + '').split('.');
                  ($i[0] = +$i[0]),
                    Ee.min !== void 0 &&
                      Ee.max !== void 0 &&
                      (m.greaterThanOrEqualTo('value', v.path, $i[0], Math.min(Ee.min, Ee.max), V),
                      m.lessThanOrEqualTo('value', v.path, $i[0], Math.max(Ee.min, Ee.max), V)),
                    Ee.min !== void 0 &&
                      Ee.max === void 0 &&
                      m.equal('value', v.path, $i[0], Ee.min, V, '[value] ' + L),
                    Ee.decimal &&
                      (Ee.dmin !== void 0 &&
                        Ee.dmax !== void 0 &&
                        (m.greaterThanOrEqualTo('value', v.path, $i[1].length, Ee.dmin, V),
                        m.lessThanOrEqualTo('value', v.path, $i[1].length, Ee.dmax, V)),
                      Ee.dmin !== void 0 && Ee.dmax === void 0 && m.equal('value', v.path, $i[1].length, Ee.dmin, V));
                  break;
                case 'boolean':
                  break;
                case 'string':
                  (ar = I.match(new RegExp(v.template, 'g'))),
                    (ar = ar ? ar.length : 0),
                    Ee.min !== void 0 &&
                      Ee.max !== void 0 &&
                      (m.greaterThanOrEqualTo('repeat count', v.path, ar, Ee.min, V),
                      m.lessThanOrEqualTo('repeat count', v.path, ar, Ee.max, V)),
                    Ee.min !== void 0 && Ee.max === void 0 && m.equal('repeat count', v.path, ar, Ee.min, V);
                  break;
                case 'regexp':
                  (ar = I.match(new RegExp(v.template.source.replace(/^\^|\$$/g, ''), 'g'))),
                    (ar = ar ? ar.length : 0),
                    Ee.min !== void 0 &&
                      Ee.max !== void 0 &&
                      (m.greaterThanOrEqualTo('repeat count', v.path, ar, Ee.min, V),
                      m.lessThanOrEqualTo('repeat count', v.path, ar, Ee.max, V)),
                    Ee.min !== void 0 && Ee.max === void 0 && m.equal('repeat count', v.path, ar, Ee.min, V);
                  break;
              }
              return V.length === se;
            },
            properties: function (v, I, L, V) {
              var se = V.length,
                Ee = v.rule,
                ht = o.keys(I);
              if (v.properties) {
                if (
                  (v.rule.parameters
                    ? (Ee.min !== void 0 &&
                        Ee.max !== void 0 &&
                        (m.greaterThanOrEqualTo('properties length', v.path, ht.length, Math.min(Ee.min, Ee.max), V),
                        m.lessThanOrEqualTo('properties length', v.path, ht.length, Math.max(Ee.min, Ee.max), V)),
                      Ee.min !== void 0 &&
                        Ee.max === void 0 &&
                        Ee.count !== 1 &&
                        m.equal('properties length', v.path, ht.length, Ee.min, V))
                    : m.equal('properties length', v.path, ht.length, v.properties.length, V),
                  V.length !== se)
                )
                  return !1;
                for (var ar = 0; ar < ht.length; ar++)
                  V.push.apply(
                    V,
                    this.diff(
                      (function () {
                        var $i;
                        return (
                          o.each(v.properties, function (tl) {
                            tl.name === ht[ar] && ($i = tl);
                          }),
                          $i || v.properties[ar]
                        );
                      })(),
                      I[ht[ar]],
                      ht[ar],
                    ),
                  );
                return V.length === se;
              }
            },
            items: function (v, I, L, V) {
              var se = V.length;
              if (v.items) {
                var Ee = v.rule;
                if (!v.rule.parameters) m.equal('items length', v.path, I.length, v.items.length, V);
                else {
                  if (
                    (Ee.min !== void 0 &&
                      Ee.max !== void 0 &&
                      (m.greaterThanOrEqualTo(
                        'items',
                        v.path,
                        I.length,
                        Math.min(Ee.min, Ee.max) * v.items.length,
                        V,
                        '[{utype}] array is too short: {path} must have at least {expected} elements but instance has {actual} elements',
                      ),
                      m.lessThanOrEqualTo(
                        'items',
                        v.path,
                        I.length,
                        Math.max(Ee.min, Ee.max) * v.items.length,
                        V,
                        '[{utype}] array is too long: {path} must have at most {expected} elements but instance has {actual} elements',
                      )),
                    Ee.min !== void 0 && Ee.max === void 0)
                  ) {
                    if (Ee.count === 1) return V.length === se;
                    m.equal('items length', v.path, I.length, Ee.min * v.items.length, V);
                  }
                  if (Ee.parameters[2]) return V.length === se;
                }
                if (V.length !== se) return !1;
                for (var ht = 0; ht < I.length; ht++)
                  V.push.apply(V, this.diff(v.items[ht % v.items.length], I[ht], ht % v.items.length));
                return V.length === se;
              }
            },
          },
          m = {
            message: function (v) {
              return (v.message || "[{utype}] Expect {path}'{ltype} {action} {expected}, but is {actual}")
                .replace('{utype}', v.type.toUpperCase())
                .replace('{ltype}', v.type.toLowerCase())
                .replace('{path}', (o.isArray(v.path) && v.path.join('.')) || v.path)
                .replace('{action}', v.action)
                .replace('{expected}', v.expected)
                .replace('{actual}', v.actual);
            },
            equal: function (v, I, L, V, se, Ee) {
              if (L === V) return !0;
              switch (v) {
                case 'type':
                  if (V === 'regexp' && L === 'string') return !0;
                  break;
              }
              var ht = { path: I, type: v, actual: L, expected: V, action: 'is equal to', message: Ee };
              return (ht.message = m.message(ht)), se.push(ht), !1;
            },
            match: function (v, I, L, V, se, Ee) {
              if (V.test(L)) return !0;
              var ht = { path: I, type: v, actual: L, expected: V, action: 'matches', message: Ee };
              return (ht.message = m.message(ht)), se.push(ht), !1;
            },
            notEqual: function (v, I, L, V, se, Ee) {
              if (L !== V) return !0;
              var ht = { path: I, type: v, actual: L, expected: V, action: 'is not equal to', message: Ee };
              return (ht.message = m.message(ht)), se.push(ht), !1;
            },
            greaterThan: function (v, I, L, V, se, Ee) {
              if (L > V) return !0;
              var ht = { path: I, type: v, actual: L, expected: V, action: 'is greater than', message: Ee };
              return (ht.message = m.message(ht)), se.push(ht), !1;
            },
            lessThan: function (v, I, L, V, se, Ee) {
              if (L < V) return !0;
              var ht = { path: I, type: v, actual: L, expected: V, action: 'is less to', message: Ee };
              return (ht.message = m.message(ht)), se.push(ht), !1;
            },
            greaterThanOrEqualTo: function (v, I, L, V, se, Ee) {
              if (L >= V) return !0;
              var ht = { path: I, type: v, actual: L, expected: V, action: 'is greater than or equal to', message: Ee };
              return (ht.message = m.message(ht)), se.push(ht), !1;
            },
            lessThanOrEqualTo: function (v, I, L, V, se, Ee) {
              if (L <= V) return !0;
              var ht = { path: I, type: v, actual: L, expected: V, action: 'is less than or equal to', message: Ee };
              return (ht.message = m.message(ht)), se.push(ht), !1;
            },
          };
        (l.Diff = f), (l.Assert = m), (r.exports = l);
      },
      function (r, e, n) {
        r.exports = n(28);
      },
      function (r, e, n) {
        var s = n(3);
        (window._XMLHttpRequest = window.XMLHttpRequest), (window._ActiveXObject = window.ActiveXObject);
        try {
          new window.Event('custom');
        } catch {
          window.Event = function (Ee, ht, ar, $i) {
            var tl = document.createEvent('CustomEvent');
            return tl.initCustomEvent(Ee, ht, ar, $i), tl;
          };
        }
        var o = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 },
          a = 'readystatechange loadstart progress abort error load timeout loadend'.split(' '),
          l = 'timeout withCredentials'.split(' '),
          f = 'readyState responseURL status statusText responseType response responseText responseXML'.split(' '),
          m = {
            100: 'Continue',
            101: 'Switching Protocols',
            200: 'OK',
            201: 'Created',
            202: 'Accepted',
            203: 'Non-Authoritative Information',
            204: 'No Content',
            205: 'Reset Content',
            206: 'Partial Content',
            300: 'Multiple Choice',
            301: 'Moved Permanently',
            302: 'Found',
            303: 'See Other',
            304: 'Not Modified',
            305: 'Use Proxy',
            307: 'Temporary Redirect',
            400: 'Bad Request',
            401: 'Unauthorized',
            402: 'Payment Required',
            403: 'Forbidden',
            404: 'Not Found',
            405: 'Method Not Allowed',
            406: 'Not Acceptable',
            407: 'Proxy Authentication Required',
            408: 'Request Timeout',
            409: 'Conflict',
            410: 'Gone',
            411: 'Length Required',
            412: 'Precondition Failed',
            413: 'Request Entity Too Large',
            414: 'Request-URI Too Long',
            415: 'Unsupported Media Type',
            416: 'Requested Range Not Satisfiable',
            417: 'Expectation Failed',
            422: 'Unprocessable Entity',
            500: 'Internal Server Error',
            501: 'Not Implemented',
            502: 'Bad Gateway',
            503: 'Service Unavailable',
            504: 'Gateway Timeout',
            505: 'HTTP Version Not Supported',
          };
        function v() {
          this.custom = { events: {}, requestHeaders: {}, responseHeaders: {} };
        }
        (v._settings = { timeout: '10-100' }),
          (v.setup = function (se) {
            return s.extend(v._settings, se), v._settings;
          }),
          s.extend(v, o),
          s.extend(v.prototype, o),
          (v.prototype.mock = !0),
          (v.prototype.match = !1),
          s.extend(v.prototype, {
            open: function (se, Ee, ht, ar, $i) {
              var tl = this;
              s.extend(this.custom, {
                method: se,
                url: Ee,
                async: typeof ht == 'boolean' ? ht : !0,
                username: ar,
                password: $i,
                options: { url: Ee, type: se },
              }),
                (this.custom.timeout = (function (Fl) {
                  if (typeof Fl == 'number') return Fl;
                  if (typeof Fl == 'string' && !~Fl.indexOf('-')) return parseInt(Fl, 10);
                  if (typeof Fl == 'string' && ~Fl.indexOf('-')) {
                    var vl = Fl.split('-'),
                      kl = parseInt(vl[0], 10),
                      El = parseInt(vl[1], 10);
                    return Math.round(Math.random() * (El - kl)) + kl;
                  }
                })(v._settings.timeout));
              var Wi = L(this.custom.options);
              function hl(Fl) {
                for (var vl = 0; vl < f.length; vl++)
                  try {
                    tl[f[vl]] = fl[f[vl]];
                  } catch {}
                tl.dispatchEvent(new Event(Fl.type));
              }
              if (!Wi) {
                var fl = I();
                this.custom.xhr = fl;
                for (var dl = 0; dl < a.length; dl++) fl.addEventListener(a[dl], hl);
                ar ? fl.open(se, Ee, ht, ar, $i) : fl.open(se, Ee, ht);
                for (var Al = 0; Al < l.length; Al++)
                  try {
                    fl[l[Al]] = tl[l[Al]];
                  } catch {}
                return;
              }
              (this.match = !0),
                (this.custom.template = Wi),
                (this.readyState = v.OPENED),
                this.dispatchEvent(new Event('readystatechange'));
            },
            setRequestHeader: function (se, Ee) {
              if (!this.match) {
                this.custom.xhr.setRequestHeader(se, Ee);
                return;
              }
              var ht = this.custom.requestHeaders;
              ht[se] ? (ht[se] += ',' + Ee) : (ht[se] = Ee);
            },
            timeout: 0,
            withCredentials: !1,
            upload: {},
            send: function (Ee) {
              var ht = this;
              if (((this.custom.options.body = Ee), !this.match)) {
                this.custom.xhr.send(Ee);
                return;
              }
              this.setRequestHeader('X-Requested-With', 'MockXMLHttpRequest'),
                this.dispatchEvent(new Event('loadstart')),
                this.custom.async ? setTimeout(ar, this.custom.timeout) : ar();
              function ar() {
                (ht.readyState = v.HEADERS_RECEIVED),
                  ht.dispatchEvent(new Event('readystatechange')),
                  (ht.readyState = v.LOADING),
                  ht.dispatchEvent(new Event('readystatechange')),
                  (ht.status = 200),
                  (ht.statusText = m[200]),
                  (ht.response = ht.responseText = JSON.stringify(V(ht.custom.template, ht.custom.options), null, 4)),
                  (ht.readyState = v.DONE),
                  ht.dispatchEvent(new Event('readystatechange')),
                  ht.dispatchEvent(new Event('load')),
                  ht.dispatchEvent(new Event('loadend'));
              }
            },
            abort: function () {
              if (!this.match) {
                this.custom.xhr.abort();
                return;
              }
              (this.readyState = v.UNSENT),
                this.dispatchEvent(new Event('abort', !1, !1, this)),
                this.dispatchEvent(new Event('error', !1, !1, this));
            },
          }),
          s.extend(v.prototype, {
            responseURL: '',
            status: v.UNSENT,
            statusText: '',
            getResponseHeader: function (se) {
              return this.match ? this.custom.responseHeaders[se.toLowerCase()] : this.custom.xhr.getResponseHeader(se);
            },
            getAllResponseHeaders: function () {
              if (!this.match) return this.custom.xhr.getAllResponseHeaders();
              var se = this.custom.responseHeaders,
                Ee = '';
              for (var ht in se)
                se.hasOwnProperty(ht) &&
                  (Ee +=
                    ht +
                    ': ' +
                    se[ht] +
                    `\r
`);
              return Ee;
            },
            overrideMimeType: function () {},
            responseType: '',
            response: null,
            responseText: '',
            responseXML: null,
          }),
          s.extend(v.prototype, {
            addEventListener: function (Ee, ht) {
              var ar = this.custom.events;
              ar[Ee] || (ar[Ee] = []), ar[Ee].push(ht);
            },
            removeEventListener: function (Ee, ht) {
              for (var ar = this.custom.events[Ee] || [], $i = 0; $i < ar.length; $i++)
                ar[$i] === ht && ar.splice($i--, 1);
            },
            dispatchEvent: function (Ee) {
              for (var ht = this.custom.events[Ee.type] || [], ar = 0; ar < ht.length; ar++) ht[ar].call(this, Ee);
              var $i = 'on' + Ee.type;
              this[$i] && this[$i](Ee);
            },
          });
        function I() {
          var se = (function () {
            var ar = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
              $i = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
              tl = location.href,
              Wi = $i.exec(tl.toLowerCase()) || [];
            return ar.test(Wi[1]);
          })();
          return window.ActiveXObject ? (!se && Ee()) || ht() : Ee();
          function Ee() {
            try {
              return new window._XMLHttpRequest();
            } catch {}
          }
          function ht() {
            try {
              return new window._ActiveXObject('Microsoft.XMLHTTP');
            } catch {}
          }
        }
        function L(se) {
          for (var Ee in v.Mock._mocked) {
            var ht = v.Mock._mocked[Ee];
            if ((!ht.rurl || ar(ht.rurl, se.url)) && (!ht.rtype || ar(ht.rtype, se.type.toLowerCase()))) return ht;
          }
          function ar($i, tl) {
            if (s.type($i) === 'string') return $i === tl;
            if (s.type($i) === 'regexp') return $i.test(tl);
          }
        }
        function V(se, Ee) {
          return s.isFunction(se.template) ? se.template(Ee) : v.Mock.mock(se.template);
        }
        r.exports = v;
      },
    ]);
  });
})(mock);
var mockExports = mock.exports;
const Mock = getDefaultExportFromCjs(mockExports),
  mockVariants = Object.keys(Mock.Random).filter((r) => r !== 'extend' && !r.startsWith('_'));
function getCompletions(r) {
  const e = r.matchBefore(/['"]@\w*/);
  return !e || e.from == e.to
    ? null
    : {
        from: e.from + 1,
        options: mockVariants.map((n) => ({ label: `@${n}`, type: 'function', section: 'Mock.js Placeholder' })),
      };
}
const autoComplete = json5Language.data.of({ autocomplete: getCompletions }),
  theme = EditorView.theme({
    '&': { height: '100%', minHeight: '0', flex: '1' },
    '&.cm-focused': { outline: 'none' },
    '.cm-scroller': { fontFamily: 'SFMono-Regular, Consolas, Menlo, monospace', fontSize: '14px' },
    '.cm-gutters': { backgroundColor: 'white', borderRight: 'none' },
    '.cm-activeLine': { backgroundColor: 'hsl(var(--b2)/0.6)' },
    '.cm-activeLineGutter': { backgroundColor: 'hsl(var(--b2))' },
    '&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection':
      { backgroundColor: 'hsl(var(--pc)/0.9)' },
  }),
  defaultExtensions = [json5(), linter(json5ParseLinter()), theme, autoComplete],
  _hoisted_1$h = { class: 'flex flex-col' },
  _hoisted_2$a = { class: 'flex items-center justify-end' },
  _sfc_main$j = defineComponent({
    __name: 'Editor',
    props: { modelValue: {} },
    emits: ['update:modelValue', 'change'],
    setup(r, { expose: e, emit: n }) {
      const s = r;
      e({ format: L });
      const o = shallowRef(),
        a = computed({
          get() {
            return s.modelValue;
          },
          set(se) {
            n('update:modelValue', se), n('change', se);
          },
        }),
        l = useLocalStorage(LocalStorageKey.EditorLineWrap, !1),
        f = navigator.platform.toLowerCase().includes('mac'),
        m = keymap.of([
          { win: 'Shift-Alt-f', mac: 'Shift-Cmd-f', run: () => (L(), !0) },
          { key: 'Ctrl-s', run: () => (L(), !0) },
          { win: 'Shift-Alt-z', mac: 'Shift-Cmd-z', run: () => (V(), !0) },
        ]),
        v = computed(() => (l.value ? [...defaultExtensions, m, EditorView.lineWrapping] : [...defaultExtensions, m]));
      function I() {
        var Ee;
        const se = (Ee = o.value) == null ? void 0 : Ee.state.selection.ranges;
        return (se == null ? void 0 : se[0].anchor) ?? 0;
      }
      async function L() {
        const se = await standaloneExports.formatWithCursor(s.modelValue, {
          cursorOffset: I(),
          parser: 'json5',
          plugins: [Kn$1, FA],
          singleQuote: !0,
        });
        n('update:modelValue', se.formatted),
          n('change', se.formatted),
          nextTick(() => {
            var ht, ar;
            const Ee = Math.max(0, se.cursorOffset);
            (ht = o.value) == null || ht.dispatch({ selection: { anchor: Ee, head: Ee } }),
              (ar = o.value) == null || ar.focus();
          });
      }
      function V() {
        l.value = !l.value;
      }
      return (se, Ee) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$h, [
          createBaseVNode('div', _hoisted_2$a, [
            createVNode(
              unref(Tooltip),
              { content: `Line Wrap (${unref(f) ? '⇧ + ⌘ + Z' : 'Shift + Alt + Z'})`, position: 'left' },
              {
                default: withCtx(() => [
                  createVNode(
                    unref(_sfc_main$l),
                    { class: normalizeClass({ 'text-success': unref(l) }), size: 28, onClick: V },
                    { default: withCtx(() => [createVNode(unref(ParagraphBreak), { size: 16 })]), _: 1 },
                    8,
                    ['class'],
                  ),
                ]),
                _: 1,
              },
              8,
              ['content'],
            ),
            createVNode(
              unref(Tooltip),
              { class: 'ml-1', content: `Format (${unref(f) ? '⇧ + ⌘ + F' : 'Shift + Alt + F'})`, position: 'left' },
              {
                default: withCtx(() => [
                  createVNode(
                    unref(_sfc_main$l),
                    { size: 28, onClick: L },
                    { default: withCtx(() => [createVNode(unref(AlignTextLeft), { size: 16 })]), _: 1 },
                  ),
                ]),
                _: 1,
              },
              8,
              ['content'],
            ),
          ]),
          createVNode(
            unref(T),
            {
              'modelValue': a.value,
              'onUpdate:modelValue': Ee[0] || (Ee[0] = (ht) => (a.value = ht)),
              'placeholder': 'Please enter your mock json data',
              'extensions': v.value,
              'onReady': Ee[1] || (Ee[1] = (ht) => (o.value = ht.view)),
            },
            null,
            8,
            ['modelValue', 'extensions'],
          ),
        ])
      );
    },
  });
function useConfirm(r, e = 1500) {
  const n = ref(!1),
    { start: s, stop: o } = useTimeoutFn(() => {
      n.value = !1;
    }, e);
  function a() {
    n.value ? (o(), r()) : ((n.value = !0), s());
  }
  function l() {
    n.value = !1;
  }
  return { confirmed: n, trigger: a, cancel: l };
}
function identity(r) {
  return r;
}
function pipeFromArray(r) {
  return r.length === 0
    ? identity
    : r.length === 1
    ? r[0]
    : function (n) {
        return r.reduce((s, o) => o(s), n);
      };
}
function observable(r) {
  const e = {
    subscribe(n) {
      let s = null,
        o = !1,
        a = !1,
        l = !1;
      function f() {
        if (s === null) {
          l = !0;
          return;
        }
        a || ((a = !0), typeof s == 'function' ? s() : s && s.unsubscribe());
      }
      return (
        (s = r({
          next(m) {
            var v;
            o || (v = n.next) == null || v.call(n, m);
          },
          error(m) {
            var v;
            o || ((o = !0), (v = n.error) == null || v.call(n, m), f());
          },
          complete() {
            var m;
            o || ((o = !0), (m = n.complete) == null || m.call(n), f());
          },
        })),
        l && f(),
        { unsubscribe: f }
      );
    },
    pipe(...n) {
      return pipeFromArray(n)(e);
    },
  };
  return e;
}
function share(r) {
  return (e) => {
    let n = 0,
      s = null;
    const o = [];
    function a() {
      s ||
        (s = e.subscribe({
          next(f) {
            var m;
            for (const v of o) (m = v.next) == null || m.call(v, f);
          },
          error(f) {
            var m;
            for (const v of o) (m = v.error) == null || m.call(v, f);
          },
          complete() {
            var f;
            for (const m of o) (f = m.complete) == null || f.call(m);
          },
        }));
    }
    function l() {
      if (n === 0 && s) {
        const f = s;
        (s = null), f.unsubscribe();
      }
    }
    return {
      subscribe(f) {
        return (
          n++,
          o.push(f),
          a(),
          {
            unsubscribe() {
              n--, l();
              const m = o.findIndex((v) => v === f);
              m > -1 && o.splice(m, 1);
            },
          }
        );
      },
    };
  };
}
class ObservableAbortError extends Error {
  constructor(e) {
    super(e), (this.name = 'ObservableAbortError'), Object.setPrototypeOf(this, ObservableAbortError.prototype);
  }
}
function observableToPromise(r) {
  let e;
  return {
    promise: new Promise((s, o) => {
      let a = !1;
      function l() {
        a || ((a = !0), o(new ObservableAbortError('This operation was aborted.')), f.unsubscribe());
      }
      const f = r.subscribe({
        next(m) {
          (a = !0), s(m), l();
        },
        error(m) {
          (a = !0), o(m), l();
        },
        complete() {
          (a = !0), l();
        },
      });
      e = l;
    }),
    abort: e,
  };
}
function createChain(r) {
  return observable((e) => {
    function n(o = 0, a = r.op) {
      const l = r.links[o];
      if (!l) throw new Error('No more links to execute - did you forget to add an ending link?');
      return l({
        op: a,
        next(m) {
          return n(o + 1, m);
        },
      });
    }
    return n().subscribe(e);
  });
}
function isObject(r) {
  return !!r && !Array.isArray(r) && typeof r == 'object';
}
function transformResultInner(r, e) {
  if ('error' in r) {
    const s = e.transformer.deserialize(r.error);
    return { ok: !1, error: { ...r, error: s } };
  }
  return {
    ok: !0,
    result: {
      ...r.result,
      ...((!r.result.type || r.result.type === 'data') && {
        type: 'data',
        data: e.transformer.deserialize(r.result.data),
      }),
    },
  };
}
class TransformResultError extends Error {
  constructor() {
    super('Unable to transform response from server');
  }
}
function transformResult(r, e) {
  let n;
  try {
    n = transformResultInner(r, e);
  } catch {
    throw new TransformResultError();
  }
  if (!n.ok && (!isObject(n.error.error) || typeof n.error.error.code != 'number')) throw new TransformResultError();
  if (n.ok && !isObject(n.result)) throw new TransformResultError();
  return n;
}
function isTRPCClientError(r) {
  return r instanceof TRPCClientError || (r instanceof Error && r.name === 'TRPCClientError');
}
function isTRPCErrorResponse(r) {
  return isObject(r) && isObject(r.error) && typeof r.error.code == 'number' && typeof r.error.message == 'string';
}
class TRPCClientError extends Error {
  static from(e, n = {}) {
    const s = e;
    return isTRPCClientError(s)
      ? (n.meta && (s.meta = { ...s.meta, ...n.meta }), s)
      : isTRPCErrorResponse(s)
      ? new TRPCClientError(s.error.message, { ...n, result: s })
      : s instanceof Error
      ? new TRPCClientError(s.message, { ...n, cause: s })
      : new TRPCClientError('Unknown error', { ...n, cause: s });
  }
  constructor(e, n) {
    var o, a;
    const s = n == null ? void 0 : n.cause;
    super(e, { cause: s }),
      (this.meta = n == null ? void 0 : n.meta),
      (this.cause = s),
      (this.shape = (o = n == null ? void 0 : n.result) == null ? void 0 : o.error),
      (this.data = (a = n == null ? void 0 : n.result) == null ? void 0 : a.error.data),
      (this.name = 'TRPCClientError'),
      Object.setPrototypeOf(this, TRPCClientError.prototype);
  }
}
function invert(r) {
  const e = Object.create(null);
  for (const n in r) {
    const s = r[n];
    e[s] = n;
  }
  return e;
}
const TRPC_ERROR_CODES_BY_KEY = {
  PARSE_ERROR: -32700,
  BAD_REQUEST: -32600,
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099,
};
invert(TRPC_ERROR_CODES_BY_KEY);
invert(TRPC_ERROR_CODES_BY_KEY);
const noop = () => {};
function createInnerProxy(r, e) {
  return new Proxy(noop, {
    get(s, o) {
      if (!(typeof o != 'string' || o === 'then')) return createInnerProxy(r, [...e, o]);
    },
    apply(s, o, a) {
      const l = e[e.length - 1] === 'apply';
      return r({ args: l ? (a.length >= 2 ? a[1] : []) : a, path: l ? e.slice(0, -1) : e });
    },
  });
}
const createRecursiveProxy = (r) => createInnerProxy(r, []),
  createFlatProxy = (r) =>
    new Proxy(noop, {
      get(e, n) {
        if (!(typeof n != 'string' || n === 'then')) return r(n);
      },
    }),
  isFunction = (r) => typeof r == 'function';
function getFetch(r) {
  if (r) return r;
  if (typeof window < 'u' && isFunction(window.fetch)) return window.fetch;
  if (typeof globalThis < 'u' && isFunction(globalThis.fetch)) return globalThis.fetch;
  throw new Error('No fetch implementation found');
}
function getAbortController(r) {
  return (
    r ||
    (typeof window < 'u' && window.AbortController
      ? window.AbortController
      : typeof globalThis < 'u' && globalThis.AbortController
      ? globalThis.AbortController
      : null)
  );
}
function resolveHTTPLinkOptions(r) {
  return {
    url: r.url.toString().replace(/\/$/, ''),
    fetch: r.fetch,
    AbortController: getAbortController(r.AbortController),
  };
}
function arrayToDict(r) {
  const e = {};
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    e[n] = s;
  }
  return e;
}
const METHOD = { query: 'GET', mutation: 'POST' };
function getInput(r) {
  return 'input' in r
    ? r.runtime.transformer.serialize(r.input)
    : arrayToDict(r.inputs.map((e) => r.runtime.transformer.serialize(e)));
}
const getUrl = (r) => {
    let e = r.url + '/' + r.path;
    const n = [];
    if (('inputs' in r && n.push('batch=1'), r.type === 'query')) {
      const s = getInput(r);
      s !== void 0 && n.push(`input=${encodeURIComponent(JSON.stringify(s))}`);
    }
    return n.length && (e += '?' + n.join('&')), e;
  },
  getBody = (r) => {
    if (r.type === 'query') return;
    const e = getInput(r);
    return e !== void 0 ? JSON.stringify(e) : void 0;
  },
  jsonHttpRequester = (r) => httpRequest({ ...r, contentTypeHeader: 'application/json', getUrl, getBody });
async function fetchHTTPResponse(r, e) {
  const n = r.getUrl(r),
    s = r.getBody(r),
    { type: o } = r,
    a = await r.headers();
  /* istanbul ignore if -- @preserve */ if (o === 'subscription') throw new Error('Subscriptions should use wsLink');
  const l = {
    ...(r.contentTypeHeader ? { 'content-type': r.contentTypeHeader } : {}),
    ...(r.batchModeHeader ? { 'trpc-batch-mode': r.batchModeHeader } : {}),
    ...a,
  };
  return getFetch(r.fetch)(n, { method: METHOD[o], signal: e == null ? void 0 : e.signal, body: s, headers: l });
}
function httpRequest(r) {
  const e = r.AbortController ? new r.AbortController() : null,
    n = {};
  let s = !1;
  return {
    promise: new Promise((l, f) => {
      fetchHTTPResponse(r, e)
        .then((m) => ((n.response = m), (s = !0), m.json()))
        .then((m) => {
          (n.responseJSON = m), l({ json: m, meta: n });
        })
        .catch((m) => {
          (s = !0), f(TRPCClientError.from(m, { meta: n }));
        });
    }),
    cancel: () => {
      s || e == null || e.abort();
    },
  };
}
const throwFatalError = () => {
  throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');
};
function dataLoader(r) {
  let e = null,
    n = null;
  const s = () => {
    clearTimeout(n), (n = null), (e = null);
  };
  function o(f) {
    var I, L;
    const m = [[]];
    let v = 0;
    for (;;) {
      const V = f[v];
      if (!V) break;
      const se = m[m.length - 1];
      if (V.aborted) {
        (I = V.reject) == null || I.call(V, new Error('Aborted')), v++;
        continue;
      }
      if (r.validate(se.concat(V).map((ht) => ht.key))) {
        se.push(V), v++;
        continue;
      }
      if (se.length === 0) {
        (L = V.reject) == null || L.call(V, new Error('Input is too big for a single dispatch')), v++;
        continue;
      }
      m.push([]);
    }
    return m;
  }
  function a() {
    const f = o(e);
    s();
    for (const m of f) {
      if (!m.length) continue;
      const v = { items: m, cancel: throwFatalError };
      for (const se of m) se.batch = v;
      const I = (se, Ee) => {
          var ar;
          const ht = v.items[se];
          (ar = ht.resolve) == null || ar.call(ht, Ee), (ht.batch = null), (ht.reject = null), (ht.resolve = null);
        },
        { promise: L, cancel: V } = r.fetch(
          v.items.map((se) => se.key),
          I,
        );
      (v.cancel = V),
        L.then((se) => {
          var Ee;
          for (let ht = 0; ht < se.length; ht++) {
            const ar = se[ht];
            I(ht, ar);
          }
          for (const ht of v.items)
            (Ee = ht.reject) == null || Ee.call(ht, new Error('Missing result')), (ht.batch = null);
        }).catch((se) => {
          var Ee;
          for (const ht of v.items) (Ee = ht.reject) == null || Ee.call(ht, se), (ht.batch = null);
        });
    }
  }
  function l(f) {
    const m = { aborted: !1, key: f, batch: null, resolve: throwFatalError, reject: throwFatalError },
      v = new Promise((L, V) => {
        (m.reject = V), (m.resolve = L), e || (e = []), e.push(m);
      });
    return (
      n || (n = setTimeout(a)),
      {
        promise: v,
        cancel: () => {
          var L;
          (m.aborted = !0),
            (L = m.batch) != null && L.items.every((V) => V.aborted) && (m.batch.cancel(), (m.batch = null));
        },
      }
    );
  }
  return { load: l };
}
function createHTTPBatchLink(r) {
  return function (n) {
    const s = resolveHTTPLinkOptions(n),
      o = n.maxURLLength ?? 1 / 0;
    return (a) => {
      const l = (L) => {
          const V = (Ee) => {
              if (o === 1 / 0) return !0;
              const ht = Ee.map((tl) => tl.path).join(','),
                ar = Ee.map((tl) => tl.input);
              return getUrl({ ...s, runtime: a, type: L, path: ht, inputs: ar }).length <= o;
            },
            se = r({ ...s, runtime: a, type: L, opts: n });
          return { validate: V, fetch: se };
        },
        f = dataLoader(l('query')),
        m = dataLoader(l('mutation')),
        v = dataLoader(l('subscription')),
        I = { query: f, subscription: v, mutation: m };
      return ({ op: L }) =>
        observable((V) => {
          const se = I[L.type],
            { promise: Ee, cancel: ht } = se.load(L);
          let ar;
          return (
            Ee.then(($i) => {
              ar = $i;
              const tl = transformResult($i.json, a);
              if (!tl.ok) {
                V.error(TRPCClientError.from(tl.error, { meta: $i.meta }));
                return;
              }
              V.next({ context: $i.meta, result: tl.result }), V.complete();
            }).catch(($i) => {
              V.error(TRPCClientError.from($i, { meta: ar == null ? void 0 : ar.meta }));
            }),
            () => {
              ht();
            }
          );
        });
    };
  };
}
const batchRequester = (r) => (e) => {
    const n = e.map((l) => l.path).join(','),
      s = e.map((l) => l.input),
      { promise: o, cancel: a } = jsonHttpRequester({
        ...r,
        path: n,
        inputs: s,
        headers() {
          return r.opts.headers
            ? typeof r.opts.headers == 'function'
              ? r.opts.headers({ opList: e })
              : r.opts.headers
            : {};
        },
      });
    return {
      promise: o.then((l) =>
        (Array.isArray(l.json) ? l.json : e.map(() => l.json)).map((v) => ({ meta: l.meta, json: v })),
      ),
      cancel: a,
    };
  },
  httpBatchLink = createHTTPBatchLink(batchRequester);
class TRPCUntypedClient {
  $request({ type: e, input: n, path: s, context: o = {} }) {
    return createChain({
      links: this.links,
      op: { id: ++this.requestId, type: e, path: s, input: n, context: o },
    }).pipe(share());
  }
  requestAsPromise(e) {
    const n = this.$request(e),
      { promise: s, abort: o } = observableToPromise(n);
    return new Promise((l, f) => {
      var m;
      (m = e.signal) == null || m.addEventListener('abort', o),
        s
          .then((v) => {
            l(v.result.data);
          })
          .catch((v) => {
            f(TRPCClientError.from(v));
          });
    });
  }
  query(e, n, s) {
    return this.requestAsPromise({
      type: 'query',
      path: e,
      input: n,
      context: s == null ? void 0 : s.context,
      signal: s == null ? void 0 : s.signal,
    });
  }
  mutation(e, n, s) {
    return this.requestAsPromise({
      type: 'mutation',
      path: e,
      input: n,
      context: s == null ? void 0 : s.context,
      signal: s == null ? void 0 : s.signal,
    });
  }
  subscription(e, n, s) {
    return this.$request({
      type: 'subscription',
      path: e,
      input: n,
      context: s == null ? void 0 : s.context,
    }).subscribe({
      next(a) {
        var l, f, m;
        a.result.type === 'started'
          ? (l = s.onStarted) == null || l.call(s)
          : a.result.type === 'stopped'
          ? (f = s.onStopped) == null || f.call(s)
          : (m = s.onData) == null || m.call(s, a.result.data);
      },
      error(a) {
        var l;
        (l = s.onError) == null || l.call(s, a);
      },
      complete() {
        var a;
        (a = s.onComplete) == null || a.call(s);
      },
    });
  }
  constructor(e) {
    this.requestId = 0;
    const n = (() => {
      const s = e.transformer;
      return s
        ? 'input' in s
          ? e.transformer
          : { input: s, output: s }
        : {
            input: { serialize: (o) => o, deserialize: (o) => o },
            output: { serialize: (o) => o, deserialize: (o) => o },
          };
    })();
    (this.runtime = {
      transformer: { serialize: (s) => n.input.serialize(s), deserialize: (s) => n.output.deserialize(s) },
      combinedTransformer: n,
    }),
      (this.links = e.links.map((s) => s(this.runtime)));
  }
}
const clientCallTypeMap = { query: 'query', mutate: 'mutation', subscribe: 'subscription' },
  clientCallTypeToProcedureType = (r) => clientCallTypeMap[r];
function createTRPCClientProxy(r) {
  return createFlatProxy((e) =>
    r.hasOwnProperty(e)
      ? r[e]
      : e === '__untypedClient'
      ? r
      : createRecursiveProxy(({ path: n, args: s }) => {
          const o = [e, ...n],
            a = clientCallTypeToProcedureType(o.pop()),
            l = o.join('.');
          return r[a](l, ...s);
        }),
  );
}
function createTRPCProxyClient(r) {
  const e = new TRPCUntypedClient(r);
  return createTRPCClientProxy(e);
}
const prefix = '/whistle.mockya',
  trpc = createTRPCProxyClient({ links: [httpBatchLink({ url: `${prefix}/trpc` })] });
function handleError(r) {
  console.error(r), toast.error(r.message.trim());
}
function withRefs(r) {
  return () => {
    const e = r(),
      n = storeToRefs(e);
    return { ...e, ...n };
  };
}
const useCollectionsStore = withRefs(
    defineStore('collections', {
      state: () => ({ fetched: !1, collections: [] }),
      actions: {
        async fetchCollections() {
          try {
            (this.collections = await trpc.getAllCollections.query()), (this.fetched = !0);
          } catch (r) {
            handleError(r);
          }
        },
        checkIdDuplicated(r) {
          return this.collections.some((e) => e.id === r);
        },
        async upsertCollection(r) {
          try {
            await trpc.upsertCollection.mutate(r), await this.fetchCollections();
          } catch (e) {
            handleError(e);
          }
        },
        async deleteCollection(r) {
          try {
            await trpc.deleteCollection.mutate(r), await this.fetchCollections();
          } catch (e) {
            handleError(e);
          }
        },
      },
    }),
  ),
  useDetailStore = withRefs(
    defineStore('detail', () => {
      const r = ref(''),
        e = ref('');
      watch(r, n);
      async function n() {
        if (r.value)
          try {
            const { name: o } = await trpc.getCollection.query(r.value);
            e.value = o;
          } catch (o) {
            handleError(o);
          }
      }
      function s(o) {
        r.value = o;
      }
      return { collectionId: r, collectionName: e, setDetailCollectionId: s, fetchCollectionInfo: n };
    }),
  ),
  useRuleListStore = withRefs(
    defineStore('rule-list', () => {
      const { collectionId: r } = useDetailStore(),
        e = ref(0),
        n = ref([]);
      watch(r, s);
      async function s() {
        if (r.value)
          try {
            const f = await trpc.getRuleList.query(r.value);
            n.value = f;
          } catch (f) {
            handleError(f);
          }
      }
      async function o(f) {
        try {
          const m = await trpc.createRule.mutate({ collectionId: r.value, name: f });
          return await s(), m;
        } catch (m) {
          handleError(m);
        }
      }
      async function a(f) {
        try {
          await trpc.updateRule.mutate(f);
        } catch (m) {
          handleError(m);
        }
      }
      async function l(f) {
        try {
          await trpc.deleteRule.mutate(f), await s(), f === e.value && (e.value = 0);
        } catch (m) {
          handleError(m);
        }
      }
      return { selectedRuleId: e, rules: n, fetchRuleList: s, createRule: o, updateRule: a, deleteRule: l };
    }),
  ),
  useRuleConfigStore = withRefs(
    defineStore('rule-config', () => {
      const { selectedRuleId: r } = useRuleListStore(),
        e = ref(),
        n = computed(() => {
          var ht;
          return ((ht = e.value) == null ? void 0 : ht.mocks) ?? [];
        }),
        s = computed(() => {
          var ht;
          return ((ht = e.value) == null ? void 0 : ht.matchers) ?? [];
        });
      watch(r, o);
      async function o() {
        if (!r.value) {
          e.value = void 0;
          return;
        }
        try {
          const ht = await trpc.getRuleFull.query(r.value);
          e.value = ht;
        } catch (ht) {
          handleError(ht);
        }
      }
      async function a(ht) {
        try {
          await trpc.updateRule.mutate({ id: r.value, ...ht });
        } catch (ar) {
          handleError(ar);
        }
      }
      async function l(ht) {
        try {
          const ar = await trpc.createMock.mutate({ name: ht, ruleId: r.value });
          return await o(), ar;
        } catch (ar) {
          handleError(ar);
        }
      }
      async function f(ht) {
        try {
          await trpc.deleteMock.mutate(ht), await o();
        } catch (ar) {
          handleError(ar);
        }
      }
      async function m(ht) {
        try {
          await trpc.updateMock.mutate(ht);
        } catch (ar) {
          handleError(ar);
        }
      }
      async function v() {
        try {
          await trpc.createMatcher.mutate(r.value), await o();
        } catch (ht) {
          handleError(ht);
        }
      }
      async function I(ht) {
        try {
          await trpc.updateMatcher.mutate(ht);
        } catch (ar) {
          handleError(ar);
        }
      }
      async function L(ht) {
        try {
          await trpc.deleteMatcher.mutate(ht), await o();
        } catch (ar) {
          handleError(ar);
        }
      }
      async function V(ht) {
        try {
          await trpc.createMatcherConfig.mutate(ht), await o();
        } catch (ar) {
          handleError(ar);
        }
      }
      async function se(ht) {
        try {
          await trpc.updateMatcherConfig.mutate(ht);
        } catch (ar) {
          handleError(ar);
        }
      }
      async function Ee(ht) {
        try {
          await trpc.deleteMatcherConfig.mutate(ht), await o();
        } catch (ar) {
          handleError(ar);
        }
      }
      return {
        selectedRuleId: r,
        selectedRule: e,
        mockList: n,
        matcherList: s,
        updateRuleConfig: a,
        createMock: l,
        updateMock: m,
        deleteMock: f,
        createMatcher: v,
        updateMatcher: I,
        deleteMatcher: L,
        createMatcherConfig: V,
        updateMatcherConfig: se,
        deleteMatcherConfig: Ee,
      };
    }),
  );
var toggleSelection = function () {
    var r = document.getSelection();
    if (!r.rangeCount) return function () {};
    for (var e = document.activeElement, n = [], s = 0; s < r.rangeCount; s++) n.push(r.getRangeAt(s));
    switch (e.tagName.toUpperCase()) {
      case 'INPUT':
      case 'TEXTAREA':
        e.blur();
        break;
      default:
        e = null;
        break;
    }
    return (
      r.removeAllRanges(),
      function () {
        r.type === 'Caret' && r.removeAllRanges(),
          r.rangeCount ||
            n.forEach(function (o) {
              r.addRange(o);
            }),
          e && e.focus();
      }
    );
  },
  deselectCurrent = toggleSelection,
  clipboardToIE11Formatting = { 'text/plain': 'Text', 'text/html': 'Url', 'default': 'Text' },
  defaultMessage = 'Copy to clipboard: #{key}, Enter';
function format(r) {
  var e = (/mac os x/i.test(navigator.userAgent) ? '⌘' : 'Ctrl') + '+C';
  return r.replace(/#{\s*key\s*}/g, e);
}
function copy(r, e) {
  var n,
    s,
    o,
    a,
    l,
    f,
    m = !1;
  e || (e = {}), (n = e.debug || !1);
  try {
    (o = deselectCurrent()),
      (a = document.createRange()),
      (l = document.getSelection()),
      (f = document.createElement('span')),
      (f.textContent = r),
      (f.ariaHidden = 'true'),
      (f.style.all = 'unset'),
      (f.style.position = 'fixed'),
      (f.style.top = 0),
      (f.style.clip = 'rect(0, 0, 0, 0)'),
      (f.style.whiteSpace = 'pre'),
      (f.style.webkitUserSelect = 'text'),
      (f.style.MozUserSelect = 'text'),
      (f.style.msUserSelect = 'text'),
      (f.style.userSelect = 'text'),
      f.addEventListener('copy', function (I) {
        if ((I.stopPropagation(), e.format))
          if ((I.preventDefault(), typeof I.clipboardData > 'u')) {
            n && console.warn('unable to use e.clipboardData'),
              n && console.warn('trying IE specific stuff'),
              window.clipboardData.clearData();
            var L = clipboardToIE11Formatting[e.format] || clipboardToIE11Formatting.default;
            window.clipboardData.setData(L, r);
          } else I.clipboardData.clearData(), I.clipboardData.setData(e.format, r);
        e.onCopy && (I.preventDefault(), e.onCopy(I.clipboardData));
      }),
      document.body.appendChild(f),
      a.selectNodeContents(f),
      l.addRange(a);
    var v = document.execCommand('copy');
    if (!v) throw new Error('copy command was unsuccessful');
    m = !0;
  } catch (I) {
    n && console.error('unable to copy using execCommand: ', I), n && console.warn('trying IE specific stuff');
    try {
      window.clipboardData.setData(e.format || 'text', r), e.onCopy && e.onCopy(window.clipboardData), (m = !0);
    } catch (L) {
      n && console.error('unable to copy using clipboardData: ', L),
        n && console.error('falling back to prompt'),
        (s = format('message' in e ? e.message : defaultMessage)),
        window.prompt(s, r);
    }
  } finally {
    l && (typeof l.removeRange == 'function' ? l.removeRange(a) : l.removeAllRanges()),
      f && document.body.removeChild(f),
      o();
  }
  return m;
}
var copyToClipboard = copy;
const copy$1 = getDefaultExportFromCjs(copyToClipboard),
  _hoisted_1$g = { class: 'collection-card transition-hover' },
  _hoisted_2$9 = { class: 'flex justify-between' },
  _hoisted_3$7 = ['onClick'],
  _hoisted_4$7 = { class: 'id-icon-container transition-hover flex-center bg-base-300 h-full px-1 rounded-l' },
  _hoisted_5$3 = { class: 'mx-2 truncate max-w-50 text-sm' },
  _hoisted_6$1 = { class: 'operation-list flex-center gap-1 transition-hover opacity-0' },
  _hoisted_7$1 = { key: 0, class: 'flex-1 py-2 font-semibold text-lg truncate' },
  _hoisted_8$1 = { class: 'text-xs flex w-fit items-center text-neural' },
  _sfc_main$i = defineComponent({
    __name: 'CollectionCard',
    props: { collection: {} },
    setup(r) {
      const e = r,
        { deleteCollection: n, upsertCollection: s } = useCollectionsStore(),
        o = computed(() => dayjs(e.collection.updatedAt).fromNow()),
        {
          confirmed: a,
          trigger: l,
          cancel: f,
        } = useConfirm(() => {
          n(e.collection.id);
        }),
        m = ref(!1),
        v = ref(e.collection.name),
        I = ref(null);
      whenever(m, () => {
        (v.value = e.collection.name),
          nextTick(() => {
            var se, Ee;
            (se = I.value) == null || se.focus(), (Ee = I.value) == null || Ee.select();
          });
      });
      async function L() {
        const se = v.value.trim();
        se && se !== e.collection.name && (await s({ id: e.collection.id, name: se })), (m.value = !1);
      }
      function V() {
        copy$1(e.collection.id), toast.success(`ID "${e.collection.id}" Copied!`);
      }
      return (se, Ee) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$g, [
          createBaseVNode('div', _hoisted_2$9, [
            createVNode(
              unref(Tooltip),
              { class: 'id-tooltip w-fit', content: 'Copy ID', position: 'right' },
              {
                default: withCtx(() => [
                  createBaseVNode(
                    'div',
                    { class: 'id-marker transition-hover', onClick: withModifiers(V, ['stop']) },
                    [
                      createBaseVNode('div', _hoisted_4$7, [
                        createVNode(unref(Key), { class: 'id-icon transition-hover hover:text-base-100' }),
                      ]),
                      createBaseVNode('div', _hoisted_5$3, toDisplayString(se.collection.id), 1),
                    ],
                    8,
                    _hoisted_3$7,
                  ),
                ]),
                _: 1,
              },
            ),
            createBaseVNode('div', _hoisted_6$1, [
              createVNode(
                unref(_sfc_main$l),
                { onClick: Ee[0] || (Ee[0] = withModifiers((ht) => (m.value = !0), ['stop'])) },
                { default: withCtx(() => [createVNode(unref(Edit))]), _: 1 },
              ),
              createVNode(
                unref(_sfc_main$l),
                {
                  class: normalizeClass(['delete-btn', { '!bg-error text-base-100': unref(a) }]),
                  onClick: withModifiers(unref(l), ['stop']),
                  onMouseleave: unref(f),
                },
                { default: withCtx(() => [createVNode(unref(Delete))]), _: 1 },
                8,
                ['class', 'onClick', 'onMouseleave'],
              ),
            ]),
          ]),
          m.value
            ? (openBlock(),
              createElementBlock(
                'div',
                { key: 1, class: 'flex-1 py-2', onClick: Ee[2] || (Ee[2] = withModifiers(() => {}, ['stop'])) },
                [
                  createVNode(
                    unref(_sfc_main$s),
                    {
                      'ref_key': 'editInput',
                      'ref': I,
                      'modelValue': v.value,
                      'onUpdate:modelValue': Ee[1] || (Ee[1] = (ht) => (v.value = ht)),
                      'bordered': '',
                      'size': 'sm',
                      'onBlur': L,
                      'onKeydown': withKeys(L, ['enter']),
                    },
                    null,
                    8,
                    ['modelValue', 'onKeydown'],
                  ),
                ],
              ))
            : (openBlock(), createElementBlock('div', _hoisted_7$1, toDisplayString(se.collection.name), 1)),
          createBaseVNode('div', _hoisted_8$1, [
            createVNode(unref(Time), { class: 'mr-2' }),
            createTextVNode(' ' + toDisplayString(o.value), 1),
          ]),
        ])
      );
    },
  }),
  CollectionCard_vue_vue_type_style_index_0_scoped_5dc986e5_lang = '',
  CollectionCard = _export_sfc(_sfc_main$i, [['__scopeId', 'data-v-5dc986e5']]),
  _hoisted_1$f = { class: 'add-collection-card' },
  _sfc_main$h = defineComponent({
    __name: 'CreateCollectionCard',
    setup(r) {
      return (e, n) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$f, [
          createVNode(unref(Plus), { class: 'mr-2', size: 20 }),
          createTextVNode(' New Collection '),
        ])
      );
    },
  }),
  CreateCollectionCard_vue_vue_type_style_index_0_scoped_9de0f07b_lang = '',
  CreateCollectionCard = _export_sfc(_sfc_main$h, [['__scopeId', 'data-v-9de0f07b']]),
  _sfc_main$g = defineComponent({
    __name: 'CreateCollectionModal',
    props: { modelValue: { type: Boolean } },
    emits: ['update:modelValue'],
    setup(r, { emit: e }) {
      const n = r,
        s = computed({
          get() {
            return n.modelValue;
          },
          set(se) {
            e('update:modelValue', se);
          },
        }),
        o = reactive({ id: '', name: '' }),
        { checkIdDuplicated: a, upsertCollection: l } = useCollectionsStore(),
        f = ref(null),
        m = ref(null);
      whenever(s, () => {
        var se, Ee, ht;
        (o.id = ''),
          (o.name = ''),
          (se = f.value) == null || se.clearValidation(),
          (Ee = m.value) == null || Ee.clearValidation(),
          (ht = f.value) == null || ht.focus();
      });
      function v(se) {
        return (
          (se = se.trim()),
          se === ''
            ? 'ID cannot be empty'
            : /\s+/.test(se)
            ? 'ID cannot contain space'
            : a(se)
            ? 'ID already exists'
            : ''
        );
      }
      function I(se) {
        return (se = se.trim()), se === '' ? 'Name cannot be empty' : '';
      }
      async function L() {
        var ht, ar;
        const se = (ht = f.value) == null ? void 0 : ht.validate(),
          Ee = (ar = m.value) == null ? void 0 : ar.validate();
        se && Ee && (await l(o), V());
      }
      function V() {
        e('update:modelValue', !1);
      }
      return (se, Ee) => (
        openBlock(),
        createBlock(
          unref(_sfc_main$q),
          {
            'modelValue': s.value,
            'onUpdate:modelValue': Ee[3] || (Ee[3] = (ht) => (s.value = ht)),
            'title': 'Create Collection',
          },
          {
            default: withCtx(() => [
              createVNode(
                unref(_sfc_main$m),
                {
                  'ref_key': 'idInput',
                  'ref': f,
                  'modelValue': o.id,
                  'onUpdate:modelValue': Ee[0] || (Ee[0] = (ht) => (o.id = ht)),
                  'title': 'ID',
                  'tip': 'unique string without space',
                  'validate-fn': v,
                  'onKeydown':
                    Ee[1] ||
                    (Ee[1] = withKeys(
                      withModifiers(
                        (ht) => {
                          var ar;
                          return (ar = m.value) == null ? void 0 : ar.focus();
                        },
                        ['prevent'],
                      ),
                      ['enter'],
                    )),
                },
                null,
                8,
                ['modelValue'],
              ),
              createVNode(
                unref(_sfc_main$m),
                {
                  'ref_key': 'nameInput',
                  'ref': m,
                  'modelValue': o.name,
                  'onUpdate:modelValue': Ee[2] || (Ee[2] = (ht) => (o.name = ht)),
                  'title': 'Name',
                  'validate-fn': I,
                  'onKeydown': withKeys(withModifiers(L, ['prevent']), ['enter']),
                },
                null,
                8,
                ['modelValue', 'onKeydown'],
              ),
            ]),
            action: withCtx(() => [
              createVNode(
                unref(Button),
                { type: 'ghost', onClick: V },
                { default: withCtx(() => [createTextVNode('Cancel')]), _: 1 },
              ),
              createVNode(
                unref(Button),
                { type: 'primary', onClick: L },
                { default: withCtx(() => [createTextVNode('Create')]), _: 1 },
              ),
            ]),
            _: 1,
          },
          8,
          ['modelValue'],
        )
      );
    },
  }),
  _sfc_main$f = defineComponent({
    __name: 'CreateMockModal',
    props: { modelValue: { type: Boolean } },
    emits: ['update:modelValue', 'created'],
    setup(r, { emit: e }) {
      const n = r,
        { createMock: s } = useRuleConfigStore(),
        o = computed({
          get() {
            return n.modelValue;
          },
          set(I) {
            e('update:modelValue', I);
          },
        }),
        a = ref(''),
        l = ref();
      whenever(o, () => {
        var I, L;
        (a.value = ''), (I = l.value) == null || I.clearValidation(), (L = l.value) == null || L.focus();
      });
      function f() {
        e('update:modelValue', !1);
      }
      function m(I) {
        return (I = I.trim()), I === '' ? 'Name cannot be empty' : '';
      }
      async function v() {
        var I;
        if ((I = l.value) != null && I.validate()) {
          const L = await s(a.value);
          e('created', L == null ? void 0 : L.id), f();
        }
      }
      return (I, L) => (
        openBlock(),
        createBlock(
          unref(_sfc_main$q),
          {
            'modelValue': o.value,
            'onUpdate:modelValue': L[1] || (L[1] = (V) => (o.value = V)),
            'title': 'Create Mock Data',
          },
          {
            default: withCtx(() => [
              createVNode(
                unref(_sfc_main$m),
                {
                  'ref_key': 'nameInput',
                  'ref': l,
                  'modelValue': a.value,
                  'onUpdate:modelValue': L[0] || (L[0] = (V) => (a.value = V)),
                  'title': 'Name',
                  'validate-fn': m,
                  'onKeydown': withKeys(withModifiers(v, ['prevent']), ['enter']),
                },
                null,
                8,
                ['modelValue', 'onKeydown'],
              ),
            ]),
            action: withCtx(() => [
              createVNode(
                unref(Button),
                { type: 'ghost', onClick: f },
                { default: withCtx(() => [createTextVNode('Cancel')]), _: 1 },
              ),
              createVNode(
                unref(Button),
                { type: 'primary', onClick: v },
                { default: withCtx(() => [createTextVNode('Create')]), _: 1 },
              ),
            ]),
            _: 1,
          },
          8,
          ['modelValue'],
        )
      );
    },
  }),
  _hoisted_1$e = { key: 0, class: 'flex-1 min-w-0 truncate text-sm leading-6' },
  _sfc_main$e = defineComponent({
    __name: 'MockListItem',
    props: { mock: {}, selected: { type: Boolean }, dropdownOpen: { type: Boolean }, readOnly: { type: Boolean } },
    emits: ['edit-confirm', 'delete'],
    setup(r, { emit: e }) {
      const n = r,
        s = ref(!1),
        o = ref(!1),
        a = ref(),
        l = ref(n.mock.name),
        f = computed(() => n.mock.default),
        {
          confirmed: m,
          trigger: v,
          cancel: I,
        } = useConfirm(() => {
          e('delete');
        });
      whenever(s, () => {
        (l.value = n.mock.name),
          nextTick(() => {
            var se, Ee;
            (se = a.value) == null || se.focus(), (Ee = a.value) == null || Ee.select();
          });
      }),
        whenever(
          () => !n.dropdownOpen,
          () => {
            s.value = !1;
          },
        );
      function L() {
        const se = l.value.trim();
        se && e('edit-confirm', se), (s.value = !1);
      }
      function V() {
        s.value = !1;
      }
      return (se, Ee) => (
        openBlock(),
        createElementBlock(
          'div',
          {
            class: normalizeClass([
              'py-1 px-2 flex items-center leading-6 cursor-pointer rounded',
              { 'hover:bg-base-200/80': !se.selected, 'bg-primary-content/30': se.selected },
            ]),
            onMouseenter: Ee[3] || (Ee[3] = (ht) => (o.value = !0)),
            onMouseleave: Ee[4] || (Ee[4] = (ht) => (o.value = !1)),
          },
          [
            s.value
              ? (openBlock(),
                createBlock(
                  unref(_sfc_main$s),
                  {
                    'key': 1,
                    'ref_key': 'inputRef',
                    'ref': a,
                    'modelValue': l.value,
                    'onUpdate:modelValue': Ee[0] || (Ee[0] = (ht) => (l.value = ht)),
                    'class': 'flex-1 text-xs px-1 rounded',
                    'size': 'xs',
                    'bordered': '',
                    'onClick': Ee[1] || (Ee[1] = withModifiers(() => {}, ['stop'])),
                    'onKeydown': [withKeys(L, ['enter']), withKeys(V, ['esc'])],
                  },
                  null,
                  8,
                  ['modelValue', 'onKeydown'],
                ))
              : (openBlock(), createElementBlock('div', _hoisted_1$e, toDisplayString(se.mock.name), 1)),
            se.readOnly || !s.value
              ? (openBlock(),
                createElementBlock(
                  Fragment,
                  { key: 2 },
                  [
                    o.value && !f.value && !se.readOnly
                      ? (openBlock(),
                        createElementBlock(
                          Fragment,
                          { key: 0 },
                          [
                            createVNode(
                              unref(_sfc_main$l),
                              {
                                class: 'ml-2',
                                transparent: '',
                                onClick: Ee[2] || (Ee[2] = withModifiers((ht) => (s.value = !0), ['stop'])),
                              },
                              { default: withCtx(() => [createVNode(unref(Edit))]), _: 1 },
                            ),
                            createVNode(
                              unref(_sfc_main$l),
                              {
                                transparent: '',
                                danger: unref(m),
                                onClick: withModifiers(unref(v), ['stop']),
                                onMouseleave: unref(I),
                              },
                              { default: withCtx(() => [createVNode(unref(Delete))]), _: 1 },
                              8,
                              ['danger', 'onClick', 'onMouseleave'],
                            ),
                          ],
                          64,
                        ))
                      : createCommentVNode('', !0),
                  ],
                  64,
                ))
              : (openBlock(),
                createElementBlock(
                  Fragment,
                  { key: 3 },
                  [
                    createVNode(
                      unref(_sfc_main$l),
                      { class: 'ml-2', transparent: '', onClick: withModifiers(L, ['stop']) },
                      { default: withCtx(() => [createVNode(unref(Check))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                    createVNode(
                      unref(_sfc_main$l),
                      { transparent: '', onClick: withModifiers(V, ['stop']) },
                      { default: withCtx(() => [createVNode(unref(Close))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                  ],
                  64,
                )),
          ],
          34,
        )
      );
    },
  }),
  _hoisted_1$d = { class: 'relative' },
  _hoisted_2$8 = { class: 'min-w-0 truncate' },
  _hoisted_3$6 = {
    class:
      'flex flex-col gap-1 absolute p-2 shadow dropdown-content z-[1] bg-base-100 rounded w-full transform translate-y-2 overflow-auto max-h-60',
  },
  _hoisted_4$6 = { key: 1, class: 'flex-center py-2 text-sm' },
  _sfc_main$d = defineComponent({
    __name: 'MockDropdownList',
    props: { modelValue: {}, readOnly: { type: Boolean } },
    emits: ['update:modelValue', 'delete', 'update', 'change'],
    setup(r, { emit: e }) {
      const n = r,
        { mockList: s } = useRuleConfigStore(),
        o = computed(() => s.value.find((Ee) => Ee.id === n.modelValue)),
        a = ref(''),
        l = ref(!1),
        f = ref(),
        m = ref(),
        v = computed(() => {
          const Ee = a.value.trim().toLowerCase();
          return Ee ? s.value.filter((ht) => ht.name.toLowerCase().includes(Ee)) : s.value;
        });
      onClickOutside(f, () => {
        l.value = !1;
      }),
        watch(l, (Ee) => {
          var ht;
          (a.value = ''), Ee && ((ht = m.value) == null || ht.focus());
        });
      function I(Ee) {
        e('update:modelValue', Ee), e('change', Ee), (l.value = !1);
      }
      function L(Ee) {
        e('delete', Ee);
      }
      function V(Ee, ht) {
        e('update', Ee, ht);
      }
      function se() {
        var Ee;
        (l.value = !1), (Ee = m.value) == null || Ee.blur();
      }
      return (Ee, ht) => {
        var ar;
        return (
          openBlock(),
          createElementBlock(
            'div',
            { ref_key: 'containerRef', ref: f, class: 'relative w-full' },
            [
              createBaseVNode('div', _hoisted_1$d, [
                l.value
                  ? createCommentVNode('', !0)
                  : (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 0,
                        class: 'flex items-center pl-3 pr-8 inset-0 absolute cursor-pointer text-sm',
                        onClick: ht[0] || (ht[0] = ($i) => (l.value = !0)),
                      },
                      [
                        createBaseVNode(
                          'span',
                          _hoisted_2$8,
                          toDisplayString(((ar = o.value) == null ? void 0 : ar.name) ?? ''),
                          1,
                        ),
                      ],
                    )),
                createVNode(
                  unref(_sfc_main$s),
                  {
                    'ref_key': 'inputRef',
                    'ref': m,
                    'modelValue': a.value,
                    'onUpdate:modelValue': ht[1] || (ht[1] = ($i) => (a.value = $i)),
                    'class': 'pr-8',
                    'placeholder': l.value ? 'Search' : '',
                    'bordered': '',
                    'size': 'sm',
                    'onFocus': ht[2] || (ht[2] = ($i) => (l.value = !0)),
                    'onClick': ht[3] || (ht[3] = ($i) => (l.value = !0)),
                    'onKeydown': withKeys(se, ['esc']),
                  },
                  null,
                  8,
                  ['modelValue', 'placeholder', 'onKeydown'],
                ),
                createVNode(
                  unref(Down),
                  {
                    class: normalizeClass([
                      'absolute right-2 top-1/2 transform -translate-y-1/2 text-base-content/50 transition pointer-events-none',
                      { 'transform rotate-180': l.value },
                    ]),
                  },
                  null,
                  8,
                  ['class'],
                ),
              ]),
              withDirectives(
                createBaseVNode(
                  'div',
                  _hoisted_3$6,
                  [
                    v.value.length
                      ? (openBlock(!0),
                        createElementBlock(
                          Fragment,
                          { key: 0 },
                          renderList(
                            v.value,
                            ($i) => (
                              openBlock(),
                              createBlock(
                                _sfc_main$e,
                                {
                                  'key': $i.id,
                                  'mock': $i,
                                  'selected': $i.id === Ee.modelValue,
                                  'dropdown-open': l.value,
                                  'read-only': Ee.readOnly,
                                  'onClick': (tl) => I($i.id),
                                  'onDelete': (tl) => L($i.id),
                                  'onEditConfirm': (tl) => V($i.id, tl),
                                },
                                null,
                                8,
                                [
                                  'mock',
                                  'selected',
                                  'dropdown-open',
                                  'read-only',
                                  'onClick',
                                  'onDelete',
                                  'onEditConfirm',
                                ],
                              )
                            ),
                          ),
                          128,
                        ))
                      : (openBlock(), createElementBlock('div', _hoisted_4$6, 'No Data')),
                  ],
                  512,
                ),
                [[vShow, l.value]],
              ),
            ],
            512,
          )
        );
      };
    },
  }),
  _hoisted_1$c = { class: 'flex-1 truncate mr-1' },
  _sfc_main$c = defineComponent({
    __name: 'RuleItem',
    props: { rule: {}, initEdit: { type: Boolean, default: !1 }, selected: { type: Boolean, default: !1 } },
    emits: ['edit-confirm', 'edit-cancel', 'delete'],
    setup(r, { expose: e, emit: n }) {
      const s = r;
      e({ focusEdit: se });
      const o = ref(s.initEdit),
        a = ref(s.rule.name),
        l = ref(),
        f = ref(!1),
        {
          confirmed: m,
          trigger: v,
          cancel: I,
        } = useConfirm(() => {
          n('delete');
        });
      whenever(o, () => {
        (a.value = s.rule.name),
          nextTick(() => {
            se();
          });
      });
      function L() {
        n('edit-confirm', a.value), (o.value = !1);
      }
      function V() {
        n('edit-cancel'), (o.value = !1);
      }
      function se() {
        var ht, ar;
        (ht = l.value) == null || ht.focus(), (ar = l.value) == null || ar.select();
      }
      function Ee(ht) {
        o.value && (ht.stopPropagation(), se());
      }
      return (ht, ar) => (
        openBlock(),
        createElementBlock(
          'div',
          {
            class: normalizeClass([
              'flex items-center text-xs leading-6 cursor-pointer py-1 px-2 rounded',
              { 'hover:bg-base-200/80': !ht.selected, 'bg-primary-content/30': ht.selected },
            ]),
            onMouseenter: ar[3] || (ar[3] = ($i) => (f.value = !0)),
            onMouseleave: ar[4] || (ar[4] = ($i) => (f.value = !1)),
          },
          [
            createVNode(
              unref(FileCode),
              { class: normalizeClass({ 'mr-1': o.value, 'mr-2': !o.value }), size: 14, onClick: Ee },
              null,
              8,
              ['class'],
            ),
            o.value
              ? (openBlock(),
                createElementBlock(
                  Fragment,
                  { key: 1 },
                  [
                    createVNode(
                      unref(_sfc_main$s),
                      {
                        'ref_key': 'inputRef',
                        'ref': l,
                        'modelValue': a.value,
                        'onUpdate:modelValue': ar[1] || (ar[1] = ($i) => (a.value = $i)),
                        'class': 'flex-1 text-xs px-1 rounded',
                        'size': 'xs',
                        'bordered': '',
                        'onClick': ar[2] || (ar[2] = withModifiers(() => {}, ['stop'])),
                        'onKeydown': [withKeys(L, ['enter']), withKeys(V, ['esc'])],
                      },
                      null,
                      8,
                      ['modelValue', 'onKeydown'],
                    ),
                    createVNode(
                      unref(_sfc_main$l),
                      { class: 'ml-2', transparent: '', onClick: withModifiers(L, ['stop']) },
                      { default: withCtx(() => [createVNode(unref(Check))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                    createVNode(
                      unref(_sfc_main$l),
                      { transparent: '', onClick: withModifiers(V, ['stop']) },
                      { default: withCtx(() => [createVNode(unref(Close))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                  ],
                  64,
                ))
              : (openBlock(),
                createElementBlock(
                  Fragment,
                  { key: 0 },
                  [
                    createBaseVNode('div', _hoisted_1$c, toDisplayString(ht.rule.name), 1),
                    f.value
                      ? (openBlock(),
                        createElementBlock(
                          Fragment,
                          { key: 0 },
                          [
                            createVNode(
                              unref(_sfc_main$l),
                              {
                                transparent: '',
                                onClick: ar[0] || (ar[0] = withModifiers(($i) => (o.value = !0), ['stop'])),
                              },
                              { default: withCtx(() => [createVNode(unref(Edit))]), _: 1 },
                            ),
                            createVNode(
                              unref(_sfc_main$l),
                              {
                                transparent: '',
                                danger: unref(m),
                                onClick: withModifiers(unref(v), ['stop']),
                                onMouseleave: unref(I),
                              },
                              { default: withCtx(() => [createVNode(unref(Delete))]), _: 1 },
                              8,
                              ['danger', 'onClick', 'onMouseleave'],
                            ),
                          ],
                          64,
                        ))
                      : createCommentVNode('', !0),
                  ],
                  64,
                )),
            createVNode(
              unref(Dot),
              { class: normalizeClass(['ml-1', [ht.rule.enabled ? 'text-success' : 'text-base-300']]) },
              null,
              8,
              ['class'],
            ),
          ],
          34,
        )
      );
    },
  }),
  _hoisted_1$b = { class: 'py-2 h-screen w-10 bg-base-200 flex flex-col items-center justify-between' },
  _sfc_main$b = defineComponent({
    __name: 'SideBar',
    setup(r) {
      const e = useRouter(),
        o = [
          [
            {
              icon: Home,
              tip: 'Home',
              handler: () => {
                a('/');
              },
            },
            {
              icon: Search,
              tip: 'Search',
              handler: () => {
                toast.warning('Not Implemented 嘿嘿');
              },
            },
          ],
          [
            {
              icon: MonitorOne,
              tip: 'Traffic',
              handler: () => {
                a('/traffic');
              },
            },
            {
              icon: Analysis,
              tip: 'Statistics',
              handler: () => {
                a('/statistics');
              },
            },
            {
              icon: Setting,
              tip: 'Settings',
              handler: () => {
                a('/settings');
              },
            },
          ],
        ];
      function a(l) {
        e.push(l);
      }
      return (l, f) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$b, [
          (openBlock(),
          createElementBlock(
            Fragment,
            null,
            renderList(o, (m, v) =>
              createBaseVNode('div', { key: v, class: 'flex flex-col items-center gap-2' }, [
                (openBlock(!0),
                createElementBlock(
                  Fragment,
                  null,
                  renderList(
                    m,
                    (I) => (
                      openBlock(),
                      createBlock(
                        unref(Tooltip),
                        { key: I.tip, class: 'sidebar-btn-wrapper', content: I.tip, position: 'right' },
                        {
                          default: withCtx(() => [
                            createVNode(
                              unref(Button),
                              {
                                class: 'sidebar-btn rounded w-8 h-8 hover:shadow',
                                shape: 'square',
                                onClick: I.handler,
                              },
                              {
                                default: withCtx(() => [
                                  (openBlock(), createBlock(resolveDynamicComponent(I.icon), { size: 20 })),
                                ]),
                                _: 2,
                              },
                              1032,
                              ['onClick'],
                            ),
                          ]),
                          _: 2,
                        },
                        1032,
                        ['content'],
                      )
                    ),
                  ),
                  128,
                )),
              ]),
            ),
            64,
          )),
        ])
      );
    },
  }),
  SideBar_vue_vue_type_style_index_0_scoped_9bdc50d8_lang = '',
  SideBar = _export_sfc(_sfc_main$b, [['__scopeId', 'data-v-9bdc50d8']]),
  _withScopeId$4 = (r) => (pushScopeId('data-v-55066e46'), (r = r()), popScopeId(), r),
  _hoisted_1$a = { class: 'flex-1 grid grid-cols-[auto,1fr] gap-x-4 gap-y-2' },
  _hoisted_2$7 = _withScopeId$4(() => createBaseVNode('div', { class: 'info-label' }, 'When', -1)),
  _hoisted_3$5 = { class: 'grid grid-cols-[1fr,auto,1fr,auto] gap-y-2' },
  _hoisted_4$5 = _withScopeId$4(() => createBaseVNode('span', { class: 'leading-8 mx-2' }, '=', -1)),
  _hoisted_5$2 = { class: 'ml-2 h-full flex-center' },
  _hoisted_6 = { class: 'flex items-center w-full' },
  _hoisted_7 = _withScopeId$4(() => createBaseVNode('span', null, 'New Condition', -1)),
  _hoisted_8 = _withScopeId$4(() => createBaseVNode('div', { class: 'empty-placeholder' }, null, -1)),
  _hoisted_9 = _withScopeId$4(() => createBaseVNode('div', { class: 'info-label' }, 'When', -1)),
  _hoisted_10 = { class: 'info-label flex' },
  _hoisted_11 = _withScopeId$4(() => createBaseVNode('div', { class: 'empty-placeholder' }, null, -1)),
  _hoisted_12 = _withScopeId$4(() => createBaseVNode('div', { class: 'info-label' }, 'Use', -1)),
  _hoisted_13 = { class: 'flex items-center' },
  _hoisted_14 = { key: 1, class: 'empty-placeholder' },
  _sfc_main$a = defineComponent({
    __name: 'MatcherItem',
    props: { matcher: {} },
    emits: ['update', 'delete', 'create-config', 'delete-config', 'update-config'],
    setup(r, { emit: e }) {
      const n = r,
        s = computed(() => n.matcher.configs),
        o = computed(() => n.matcher.mock),
        a = computed(() => n.matcher.default),
        l = useEventBus(GlobalEvents.ChangeSelectMock),
        f = ref(!1),
        {
          confirmed: m,
          trigger: v,
          cancel: I,
        } = useConfirm(() => {
          e('delete');
        }),
        L = useDebounceFn((se) => {
          e('update-config', se);
        }, updateSaveDelay);
      function V(se) {
        l.emit({ id: se }), e('update', se);
      }
      return (se, Ee) => (
        openBlock(),
        createElementBlock(
          'div',
          {
            class: 'flex items-center',
            onMouseenter: Ee[2] || (Ee[2] = (ht) => (f.value = !0)),
            onMouseleave: Ee[3] || (Ee[3] = (ht) => (f.value = !1)),
          },
          [
            createBaseVNode('div', _hoisted_1$a, [
              a.value
                ? (openBlock(),
                  createElementBlock(
                    Fragment,
                    { key: 1 },
                    [
                      _hoisted_9,
                      createBaseVNode('div', _hoisted_10, [
                        createVNode(
                          unref(Tooltip),
                          {
                            class: 'flex-1 mr-2',
                            content: 'only works when URL Path is not empty',
                            position: 'bottom',
                          },
                          {
                            default: withCtx(() => [
                              createVNode(
                                unref(Button),
                                { class: 'flex-center w-full text-xs' },
                                { default: withCtx(() => [createTextVNode('Fallback')]), _: 1 },
                              ),
                            ]),
                            _: 1,
                          },
                        ),
                        _hoisted_11,
                      ]),
                    ],
                    64,
                  ))
                : (openBlock(),
                  createElementBlock(
                    Fragment,
                    { key: 0 },
                    [
                      _hoisted_2$7,
                      createBaseVNode('div', null, [
                        createBaseVNode('div', _hoisted_3$5, [
                          (openBlock(!0),
                          createElementBlock(
                            Fragment,
                            null,
                            renderList(
                              s.value,
                              (ht) => (
                                openBlock(),
                                createElementBlock(
                                  Fragment,
                                  { key: ht.id },
                                  [
                                    createVNode(
                                      unref(_sfc_main$s),
                                      {
                                        'modelValue': ht.key,
                                        'onUpdate:modelValue': (ar) => (ht.key = ar),
                                        'bordered': '',
                                        'size': 'sm',
                                        'onInput': (ar) => unref(L)({ id: ht.id, key: ar.trim() }),
                                      },
                                      null,
                                      8,
                                      ['modelValue', 'onUpdate:modelValue', 'onInput'],
                                    ),
                                    _hoisted_4$5,
                                    createVNode(
                                      unref(_sfc_main$s),
                                      {
                                        'modelValue': ht.value,
                                        'onUpdate:modelValue': (ar) => (ht.value = ar),
                                        'bordered': '',
                                        'size': 'sm',
                                        'onInput': (ar) => unref(L)({ id: ht.id, value: ar.trim() }),
                                      },
                                      null,
                                      8,
                                      ['modelValue', 'onUpdate:modelValue', 'onInput'],
                                    ),
                                    createBaseVNode('div', _hoisted_5$2, [
                                      createVNode(
                                        unref(_sfc_main$l),
                                        { transparent: '', onClick: (ar) => e('delete-config', ht.id) },
                                        { default: withCtx(() => [createVNode(unref(ReduceOne))]), _: 2 },
                                        1032,
                                        ['onClick'],
                                      ),
                                    ]),
                                  ],
                                  64,
                                )
                              ),
                            ),
                            128,
                          )),
                        ]),
                        createBaseVNode('div', _hoisted_6, [
                          createVNode(
                            unref(Button),
                            {
                              class: normalizeClass(['flex-1 mr-2 normal-case text-xs', { 'mt-2': s.value.length }]),
                              size: 'sm',
                              onClick: Ee[0] || (Ee[0] = (ht) => e('create-config')),
                            },
                            {
                              default: withCtx(() => [
                                createVNode(unref(Plus), { 'stroke-width': 5, 'size': 14 }),
                                _hoisted_7,
                              ]),
                              _: 1,
                            },
                            8,
                            ['class'],
                          ),
                          _hoisted_8,
                        ]),
                      ]),
                    ],
                    64,
                  )),
              _hoisted_12,
              createBaseVNode('div', _hoisted_13, [
                createVNode(
                  unref(_sfc_main$d),
                  {
                    'modelValue': o.value.id,
                    'onUpdate:modelValue': Ee[1] || (Ee[1] = (ht) => (o.value.id = ht)),
                    'class': 'mr-2',
                    'read-only': '',
                    'onChange': V,
                  },
                  null,
                  8,
                  ['modelValue'],
                ),
                a.value
                  ? (openBlock(), createElementBlock('div', _hoisted_14))
                  : (openBlock(),
                    createBlock(
                      unref(_sfc_main$l),
                      {
                        key: 0,
                        class: 'flex-none',
                        transparent: '',
                        danger: unref(m),
                        onClick: unref(v),
                        onMouseleave: unref(I),
                      },
                      { default: withCtx(() => [createVNode(unref(Delete))]), _: 1 },
                      8,
                      ['danger', 'onClick', 'onMouseleave'],
                    )),
              ]),
            ]),
          ],
          32,
        )
      );
    },
  }),
  MatcherItem_vue_vue_type_style_index_0_scoped_55066e46_lang = '',
  MatcherItem = _export_sfc(_sfc_main$a, [['__scopeId', 'data-v-55066e46']]),
  _hoisted_1$9 = { class: 'h-screen w-screen flex' },
  _hoisted_2$6 = { class: 'h-screen flex-1 relative min-w-0 py-2 pr-2 bg-base-200' },
  _sfc_main$9 = defineComponent({
    __name: 'App',
    setup(r) {
      return (e, n) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$9, [
          createVNode(unref(SideBar), { class: 'flex-none' }),
          createBaseVNode('div', _hoisted_2$6, [createVNode(unref(RouterView))]),
        ])
      );
    },
  }),
  antd = '',
  _withScopeId$3 = (r) => (pushScopeId('data-v-dffe5ed4'), (r = r()), popScopeId(), r),
  _hoisted_1$8 = _withScopeId$3(() => createBaseVNode('div', { class: 'px-4 py-2' }, 'Basic Config', -1)),
  _hoisted_2$5 = { class: 'h-full w-full p-4' },
  _hoisted_3$4 = { class: 'grid grid-cols-[auto,1fr] gap-x-2 gap-y-4' },
  _hoisted_4$4 = _withScopeId$3(() => createBaseVNode('label', { class: 'config-label' }, 'Enabled', -1)),
  _hoisted_5$1 = _withScopeId$3(() => createBaseVNode('label', { class: 'config-label' }, 'URL Path', -1)),
  _sfc_main$8 = defineComponent({
    __name: 'BasicConfig',
    setup(r) {
      const { rules: e } = useRuleListStore(),
        { selectedRule: n, updateRuleConfig: s } = useRuleConfigStore();
      async function o(l) {
        await s({ enabled: l }),
          (e.value.find((f) => {
            var m;
            return f.id === ((m = n.value) == null ? void 0 : m.id);
          }).enabled = l);
      }
      const a = useDebounceFn((l) => s({ path: l.trim() }), updateSaveDelay);
      return (l, f) => (
        openBlock(),
        createBlock(unref(_sfc_main$v), null, {
          header: withCtx(() => [_hoisted_1$8]),
          default: withCtx(() => [
            createBaseVNode('div', _hoisted_2$5, [
              createBaseVNode('div', _hoisted_3$4, [
                _hoisted_4$4,
                createVNode(
                  unref(_sfc_main$o),
                  {
                    'modelValue': unref(n).enabled,
                    'onUpdate:modelValue': f[0] || (f[0] = (m) => (unref(n).enabled = m)),
                    'type': 'success',
                    'onChange': o,
                  },
                  null,
                  8,
                  ['modelValue'],
                ),
                _hoisted_5$1,
                createVNode(
                  unref(_sfc_main$s),
                  {
                    'modelValue': unref(n).path,
                    'onUpdate:modelValue': f[1] || (f[1] = (m) => (unref(n).path = m)),
                    'class': 'max-w-100',
                    'size': 'sm',
                    'bordered': '',
                    'onInput': unref(a),
                  },
                  null,
                  8,
                  ['modelValue', 'onInput'],
                ),
              ]),
            ]),
          ]),
          _: 1,
        })
      );
    },
  }),
  BasicConfig_vue_vue_type_style_index_0_scoped_dffe5ed4_lang = '',
  BasicConfigPanel = _export_sfc(_sfc_main$8, [['__scopeId', 'data-v-dffe5ed4']]),
  _withScopeId$2 = (r) => (pushScopeId('data-v-8005d4df'), (r = r()), popScopeId(), r),
  _hoisted_1$7 = { class: 'px-4 py-2 pr-3 flex items-center justify-between' },
  _hoisted_2$4 = _withScopeId$2(() => createBaseVNode('span', null, 'Matcher Config', -1)),
  _hoisted_3$3 = { class: 'p-4 text-sm overflow-auto h-full' },
  _hoisted_4$3 = { key: 0, class: 'divider my-2' },
  _sfc_main$7 = defineComponent({
    __name: 'MatcherConfig',
    setup(r) {
      const {
          selectedRule: e,
          matcherList: n,
          createMatcher: s,
          updateMatcher: o,
          deleteMatcher: a,
          createMatcherConfig: l,
          updateMatcherConfig: f,
          deleteMatcherConfig: m,
        } = useRuleConfigStore(),
        v = computed(() => {
          var I;
          return (I = e.value) != null && I.path.trim().length ? n.value : n.value.filter((L) => !L.default);
        });
      return (I, L) => (
        openBlock(),
        createBlock(unref(_sfc_main$v), null, {
          header: withCtx(() => [
            createBaseVNode('div', _hoisted_1$7, [
              _hoisted_2$4,
              createVNode(
                unref(Tooltip),
                { class: 'flex text-xs', content: 'Add Matcher', position: 'left' },
                {
                  default: withCtx(() => [
                    createVNode(
                      unref(_sfc_main$l),
                      { onClick: unref(s) },
                      { default: withCtx(() => [createVNode(unref(FileAddition))]), _: 1 },
                      8,
                      ['onClick'],
                    ),
                  ]),
                  _: 1,
                },
              ),
            ]),
          ]),
          default: withCtx(() => [
            createBaseVNode('div', _hoisted_3$3, [
              (openBlock(!0),
              createElementBlock(
                Fragment,
                null,
                renderList(
                  v.value,
                  (V, se) => (
                    openBlock(),
                    createElementBlock(
                      Fragment,
                      { key: V.id },
                      [
                        se !== 0 ? (openBlock(), createElementBlock('div', _hoisted_4$3)) : createCommentVNode('', !0),
                        createVNode(
                          unref(MatcherItem),
                          {
                            matcher: V,
                            onUpdate: (Ee) => unref(o)({ id: V.id, mockId: Ee }),
                            onDelete: (Ee) => unref(a)(V.id),
                            onCreateConfig: (Ee) => unref(l)(V.id),
                            onUpdateConfig: unref(f),
                            onDeleteConfig: unref(m),
                          },
                          null,
                          8,
                          ['matcher', 'onUpdate', 'onDelete', 'onCreateConfig', 'onUpdateConfig', 'onDeleteConfig'],
                        ),
                      ],
                      64,
                    )
                  ),
                ),
                128,
              )),
            ]),
          ]),
          _: 1,
        })
      );
    },
  }),
  MatcherConfig_vue_vue_type_style_index_0_scoped_8005d4df_lang = '',
  MatcherConfigPanel = _export_sfc(_sfc_main$7, [['__scopeId', 'data-v-8005d4df']]),
  _hoisted_1$6 = { class: 'px-4 py-2 pr-3 flex items-center justify-between' },
  _hoisted_2$3 = createBaseVNode('span', null, 'Mock Config', -1),
  _hoisted_3$2 = { class: 'p-4 flex flex-col h-full' },
  _hoisted_4$2 = { class: 'mb-1 flex items-center' },
  _sfc_main$6 = defineComponent({
    __name: 'MockConfig',
    setup(r) {
      var ar;
      const { selectedRule: e, deleteMock: n, updateMock: s } = useRuleConfigStore(),
        o = computed(() => {
          var $i;
          return (($i = e.value) == null ? void 0 : $i.mocks) ?? [];
        }),
        a = ref(!1),
        l = computed(() => {
          var $i;
          return ($i = o.value.find((tl) => tl.default)) == null ? void 0 : $i.id;
        }),
        f = ref(l.value ?? 0),
        m = computed(() => o.value.find(($i) => $i.id === f.value)),
        v = ref(((ar = m.value) == null ? void 0 : ar.body) ?? '');
      useEventBus(GlobalEvents.ChangeSelectMock).on(($i) => {
        o.value.find((tl) => tl.id === $i.id) && (f.value = $i.id);
      }),
        watch(f, () => {
          var $i;
          v.value = (($i = m.value) == null ? void 0 : $i.body) ?? '';
        }),
        watch(l, () => {
          f.value = l.value ?? 0;
        });
      const L = useDebounceFn(($i) => {
        s($i);
      }, updateSaveDelay);
      function V() {
        const $i = f.value,
          tl = v.value;
        $i && L({ id: $i, body: tl });
      }
      async function se($i) {
        $i === f.value && (f.value = l.value ?? 0), await n($i);
      }
      async function Ee($i, tl) {
        (o.value.find((Wi) => Wi.id === $i).name = tl), await s({ id: $i, name: tl });
      }
      function ht($i) {
        !$i || !o.value.find((tl) => tl.id === $i) || (f.value = $i);
      }
      return ($i, tl) => (
        openBlock(),
        createBlock(unref(_sfc_main$v), null, {
          header: withCtx(() => [
            createBaseVNode('div', _hoisted_1$6, [
              _hoisted_2$3,
              createVNode(
                unref(Tooltip),
                { class: 'flex text-xs', content: 'Add Mock', position: 'left' },
                {
                  default: withCtx(() => [
                    createVNode(
                      unref(_sfc_main$l),
                      { onClick: tl[0] || (tl[0] = (Wi) => (a.value = !0)) },
                      { default: withCtx(() => [createVNode(unref(FileAddition))]), _: 1 },
                    ),
                  ]),
                  _: 1,
                },
              ),
            ]),
          ]),
          default: withCtx(() => [
            createBaseVNode('div', _hoisted_3$2, [
              createBaseVNode('div', _hoisted_4$2, [
                createVNode(
                  unref(_sfc_main$d),
                  {
                    'modelValue': f.value,
                    'onUpdate:modelValue': tl[1] || (tl[1] = (Wi) => (f.value = Wi)),
                    'onDelete': se,
                    'onUpdate': Ee,
                  },
                  null,
                  8,
                  ['modelValue'],
                ),
              ]),
              createVNode(
                unref(_sfc_main$j),
                {
                  'modelValue': v.value,
                  'onUpdate:modelValue': tl[2] || (tl[2] = (Wi) => (v.value = Wi)),
                  'class': 'editor flex-1 min-h-0',
                  'onChange': V,
                },
                null,
                8,
                ['modelValue'],
              ),
            ]),
            createVNode(
              unref(_sfc_main$f),
              {
                'modelValue': a.value,
                'onUpdate:modelValue': tl[3] || (tl[3] = (Wi) => (a.value = Wi)),
                'onCreated': ht,
              },
              null,
              8,
              ['modelValue'],
            ),
          ]),
          _: 1,
        })
      );
    },
  }),
  _withScopeId$1 = (r) => (pushScopeId('data-v-dce0df72'), (r = r()), popScopeId(), r),
  _hoisted_1$5 = { class: 'px-4 py-2 pr-3 flex items-center justify-between' },
  _hoisted_2$2 = _withScopeId$1(() => createBaseVNode('span', null, 'Rules', -1)),
  _hoisted_3$1 = { class: 'w-full h-full p-2 flex flex-col overflow-auto' },
  _hoisted_4$1 = { key: 0, class: 'rule-item create' },
  _sfc_main$5 = defineComponent({
    __name: 'RuleList',
    setup(r) {
      const e = { name: 'new rule' },
        { rules: n, createRule: s, updateRule: o, deleteRule: a, selectedRuleId: l } = useRuleListStore(),
        f = ref(!1),
        m = ref(null);
      function v() {
        f.value || (f.value = !0),
          nextTick(() => {
            var se;
            (se = m.value) == null || se.focusEdit();
          });
      }
      async function I(se) {
        const Ee = se.trim();
        if (Ee) {
          const ht = await s(Ee);
          n.value.find((ar) => ar.id === (ht == null ? void 0 : ht.id)) && (l.value = ht.id);
        }
        f.value = !1;
      }
      async function L(se) {
        await a(se);
      }
      async function V(se, Ee) {
        const ht = Ee.trim(),
          ar = n.value.find(($i) => $i.id === se);
        ht && ar && ht !== ar.name && ((ar.name = ht), await o({ id: se, name: ht }));
      }
      return (se, Ee) => (
        openBlock(),
        createBlock(unref(_sfc_main$v), null, {
          header: withCtx(() => [
            createBaseVNode('div', _hoisted_1$5, [
              _hoisted_2$2,
              createVNode(
                unref(Tooltip),
                { class: 'flex text-xs', content: 'Add Rule', position: 'left' },
                {
                  default: withCtx(() => [
                    createVNode(
                      unref(_sfc_main$l),
                      { onClick: v },
                      { default: withCtx(() => [createVNode(unref(FileAddition))]), _: 1 },
                    ),
                  ]),
                  _: 1,
                },
              ),
            ]),
          ]),
          default: withCtx(() => [
            createBaseVNode('div', _hoisted_3$1, [
              (openBlock(!0),
              createElementBlock(
                Fragment,
                null,
                renderList(
                  unref(n),
                  (ht) => (
                    openBlock(),
                    createElementBlock('div', { key: ht.name, class: 'rule-item' }, [
                      createVNode(
                        unref(_sfc_main$c),
                        {
                          class: 'rule-item',
                          rule: ht,
                          selected: unref(l) === ht.id,
                          onDelete: (ar) => L(ht.id),
                          onEditConfirm: (ar) => V(ht.id, ar),
                          onClick: (ar) => (l.value = ht.id),
                        },
                        null,
                        8,
                        ['rule', 'selected', 'onDelete', 'onEditConfirm', 'onClick'],
                      ),
                    ])
                  ),
                ),
                128,
              )),
              f.value
                ? (openBlock(),
                  createElementBlock('div', _hoisted_4$1, [
                    createVNode(
                      unref(_sfc_main$c),
                      {
                        'ref_key': 'createRuleRef',
                        'ref': m,
                        'class': 'rule-item',
                        'rule': e,
                        'init-edit': '',
                        'onEditConfirm': I,
                        'onEditCancel': Ee[0] || (Ee[0] = (ht) => (f.value = !1)),
                      },
                      null,
                      512,
                    ),
                  ]))
                : createCommentVNode('', !0),
            ]),
          ]),
          _: 1,
        })
      );
    },
  }),
  RuleList_vue_vue_type_style_index_0_scoped_dce0df72_lang = '',
  RuleListPanel = _export_sfc(_sfc_main$5, [['__scopeId', 'data-v-dce0df72']]),
  _hoisted_1$4 = { class: 'flex flex-col h-full gap-2' },
  _hoisted_2$1 = { class: 'flex-center flex-col text-xl' },
  _sfc_main$4 = defineComponent({
    __name: 'index',
    props: { id: {} },
    setup(r) {
      const e = r,
        { setDetailCollectionId: n } = useDetailStore(),
        { selectedRule: s } = useRuleConfigStore();
      return (
        n(e.id),
        (o, a) => (
          openBlock(),
          createBlock(
            unref(ResizeLayout),
            {
              'class': 'detail-layout',
              'init-start-size': '35%',
              'local-key': unref(LocalStorageKey).DetailResizeLayout,
              'start-min-size': 200,
              'start-max-size': 300,
            },
            {
              start: withCtx(() => [createVNode(RuleListPanel)]),
              end: withCtx(() => [
                unref(s)
                  ? (openBlock(),
                    createBlock(
                      unref(ResizeLayout),
                      {
                        'key': 0,
                        'class': 'flex-1 min-h-0',
                        'init-start-size': '40%',
                        'start-min-size': 300,
                        'start-max-size': 600,
                        'local-key': unref(LocalStorageKey).ConfigResizeLayout,
                      },
                      {
                        start: withCtx(() => [
                          createBaseVNode('div', _hoisted_1$4, [
                            createVNode(BasicConfigPanel, { class: '!h-fit' }),
                            createVNode(MatcherConfigPanel, { class: 'flex-1 min-h-0' }),
                          ]),
                        ]),
                        end: withCtx(() => [createVNode(_sfc_main$6)]),
                        _: 1,
                      },
                      8,
                      ['local-key'],
                    ))
                  : (openBlock(),
                    createBlock(
                      unref(_sfc_main$v),
                      { key: 1 },
                      {
                        default: withCtx(() => [
                          createVNode(unref(Hero), null, {
                            default: withCtx(() => [
                              createBaseVNode('div', _hoisted_2$1, [
                                createVNode(unref(HandLeft), { class: 'mb-4', size: 48 }),
                                createTextVNode(' Select One Rule First '),
                              ]),
                            ]),
                            _: 1,
                          }),
                        ]),
                        _: 1,
                      },
                    )),
              ]),
              _: 1,
            },
            8,
            ['local-key'],
          )
        )
      );
    },
  }),
  _withScopeId = (r) => (pushScopeId('data-v-21f82af6'), (r = r()), popScopeId(), r),
  _hoisted_1$3 = { class: 'h-full w-full' },
  _hoisted_2 = { key: 1, class: 'w-full h-full' },
  _hoisted_3 = { class: 'responsive-grid' },
  _hoisted_4 = _withScopeId(() =>
    createBaseVNode('div', { class: 'font-bold text-xl mt-8 mb-5' }, 'All Collections', -1),
  ),
  _hoisted_5 = { class: 'responsive-grid' },
  _sfc_main$3 = defineComponent({
    __name: 'index',
    setup(r) {
      const e = useRouter();
      function n(m) {
        e.push({ name: 'detail', params: { id: m } });
      }
      const { fetched: s, collections: o, fetchCollections: a } = useCollectionsStore(),
        l = ref(!s.value);
      a().then(() => {
        l.value = !1;
      });
      const f = ref(!1);
      return (m, v) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$3, [
          createVNode(
            unref(_sfc_main$v),
            { class: 'flex-center p-6' },
            {
              default: withCtx(() => [
                l.value
                  ? (openBlock(), createBlock(unref(_sfc_main$r), { key: 0, shape: 'dots', size: 'lg' }))
                  : (openBlock(),
                    createElementBlock('div', _hoisted_2, [
                      createBaseVNode('div', _hoisted_3, [
                        createVNode(unref(CreateCollectionCard), { onClick: v[0] || (v[0] = (I) => (f.value = !0)) }),
                      ]),
                      _hoisted_4,
                      createBaseVNode('div', _hoisted_5, [
                        (openBlock(!0),
                        createElementBlock(
                          Fragment,
                          null,
                          renderList(
                            unref(o),
                            (I) => (
                              openBlock(),
                              createBlock(
                                unref(CollectionCard),
                                { key: I.id, collection: I, onClick: (L) => n(I.id) },
                                {
                                  default: withCtx(() => {
                                    var L;
                                    return [
                                      createTextVNode(toDisplayString((L = unref(o)[0]) == null ? void 0 : L.name), 1),
                                    ];
                                  }),
                                  _: 2,
                                },
                                1032,
                                ['collection', 'onClick'],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                    ])),
              ]),
              _: 1,
            },
          ),
          createVNode(
            unref(_sfc_main$g),
            { 'modelValue': f.value, 'onUpdate:modelValue': v[1] || (v[1] = (I) => (f.value = I)) },
            null,
            8,
            ['modelValue'],
          ),
        ])
      );
    },
  }),
  index_vue_vue_type_style_index_0_scoped_21f82af6_lang = '',
  HomePage = _export_sfc(_sfc_main$3, [['__scopeId', 'data-v-21f82af6']]),
  _hoisted_1$2 = { class: 'h-full w-full' },
  _sfc_main$2 = defineComponent({
    __name: 'index',
    setup(r) {
      return (e, n) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$2, [
          createVNode(
            unref(_sfc_main$v),
            { class: 'flex-center' },
            {
              default: withCtx(() => [
                createVNode(unref(Button), null, { default: withCtx(() => [createTextVNode('Settings')]), _: 1 }),
              ]),
              _: 1,
            },
          ),
        ])
      );
    },
  }),
  _hoisted_1$1 = { class: 'h-full w-full' },
  _sfc_main$1 = defineComponent({
    __name: 'index',
    setup(r) {
      return (e, n) => (
        openBlock(),
        createElementBlock('div', _hoisted_1$1, [
          createVNode(
            unref(_sfc_main$v),
            { class: 'flex-center' },
            {
              default: withCtx(() => [
                createVNode(unref(Button), null, { default: withCtx(() => [createTextVNode('Statistics')]), _: 1 }),
              ]),
              _: 1,
            },
          ),
        ])
      );
    },
  }),
  _hoisted_1 = { class: 'h-full w-full' },
  _sfc_main = defineComponent({
    __name: 'index',
    setup(r) {
      return (e, n) => (
        openBlock(),
        createElementBlock('div', _hoisted_1, [
          createVNode(
            unref(_sfc_main$v),
            { class: 'flex-center' },
            {
              default: withCtx(() => [
                createVNode(unref(Button), null, { default: withCtx(() => [createTextVNode('Traffic')]), _: 1 }),
              ]),
              _: 1,
            },
          ),
        ])
      );
    },
  }),
  routes = [
    { path: '/', component: HomePage },
    { name: 'detail', path: '/collection/:id', component: _sfc_main$4, props: !0 },
    { name: 'settings', path: '/settings', component: _sfc_main$2 },
    { name: 'statistics', path: '/statistics', component: _sfc_main$1 },
    { name: 'traffic', path: '/traffic', component: _sfc_main },
  ],
  router = createRouter({ history: createWebHashHistory(), routes }),
  style = '';
dayjs.extend(relativeTime);
const app = createApp(_sfc_main$9),
  pinia = createPinia();
app.use(router);
app.use(pinia);
app.mount('#app');
